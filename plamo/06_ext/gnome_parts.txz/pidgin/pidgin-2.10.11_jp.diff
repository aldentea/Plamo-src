diff -uNr pidgin-2.10.11.orig/configure.ac pidgin-2.10.11/configure.ac
--- pidgin-2.10.11.orig/configure.ac	2014-11-24 01:41:25.000000000 +0900
+++ pidgin-2.10.11/configure.ac	2015-02-10 14:28:16.387351890 +0900
@@ -2037,7 +2037,7 @@
 					esac
 				fi
 			else
-				nsslibs="-lssl3 -lsmime3 -lnss3 -lsoftokn3"
+				nsslibs="-lssl3 -lsmime3 -lnss3 -lsoftokn3 -lsqlite3"
 			fi
 
 			AC_CACHE_CHECK([for Mozilla nss libraries], ac_cv_moz_nss_libs,
@@ -2051,7 +2051,7 @@
 					[ac_cv_moz_nss_libs="no"])
 
 				if test "x$ac_cv_moz_nss_libs" = "xno"; then
-					nsslibs="-lssl3 -lsmime3 -lnss3 -lsoftokn3"
+					nsslibs="-lssl3 -lsmime3 -lnss3 -lsoftokn3 -lsqlite3"
 					LDFLAGS="$LDFLAGS -L$with_nspr_libs -L$with_nss_libs"
 					LIBS="$LIBS $nsslibs"
 					AC_TRY_LINK_FUNC(NSS_Init,
diff -uNr pidgin-2.10.11.orig/configure.ac.orig pidgin-2.10.11/configure.ac.orig
--- pidgin-2.10.11.orig/configure.ac.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/configure.ac.orig	2014-11-24 01:41:25.000000000 +0900
@@ -0,0 +1,2660 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_PREREQ([2.50])
+
+# UPDATING VERSION NUMBERS FOR RELEASES
+#
+# purple_micro_version += 1
+#
+# If any functions have been added to libpurple, Pidgin, or Finch:
+#   purple_micro_version = 0
+#   purple_minor_version += 1
+#   purple_lt_current += 1
+#
+# If backwards compatibility has been broken in libpurple, Pidgin, or Finch:
+#   purple_micro_version = 0
+#   purple_minor_version = 0
+#   purple_major_version += 1;
+#   purple_lt_current += 1
+#
+# purple_version_suffix should be similar to one of the following:
+#   For beta releases:          [beta2]
+#   For code under development: [devel]
+#   For production releases:    []
+#
+#
+# If any code has changed in libgnt:
+#   gnt_micro_version += 1
+#
+# If any functions have been added to libgnt:
+#   gnt_micro_version = 0
+#   gnt_minor_version += 1
+#   gnt_lt_current += 1
+#
+# If backwards compatibility has been broken in libgnt:
+#   gnt_micro_version = 0
+#   gnt_minor_version = 0
+#   gnt_major_version += 1;
+#   gnt_lt_current += 1
+#
+# gnt_version_suffix should be similar to one of the following:
+#   For beta releases:          [beta2]
+#   For code under development: [devel]
+#   For production releases:    []
+#
+# Make sure to update finch/libgnt/configure.ac with libgnt version changes.
+#
+m4_define([purple_lt_current], [10])
+m4_define([purple_major_version], [2])
+m4_define([purple_minor_version], [10])
+m4_define([purple_micro_version], [11])
+m4_define([purple_version_suffix], [])
+m4_define([purple_version],
+          [purple_major_version.purple_minor_version.purple_micro_version])
+m4_define([purple_display_version], purple_version[]m4_ifdef([purple_version_suffix],[purple_version_suffix]))
+
+m4_define([gnt_lt_current], [8])
+m4_define([gnt_major_version], [2])
+m4_define([gnt_minor_version], [8])
+m4_define([gnt_micro_version], [10])
+m4_define([gnt_version_suffix], [])
+m4_define([gnt_version],
+          [gnt_major_version.gnt_minor_version.gnt_micro_version])
+m4_define([gnt_display_version], gnt_version[]m4_ifdef([gnt_version_suffix],[gnt_version_suffix]))
+
+
+AC_INIT([pidgin], [purple_display_version], [devel@pidgin.im])
+
+if test `pwd | wc -w` -ne 1; then
+	AC_MSG_ERROR([
+You are attempting to build in a path that contains spaces.  This
+will fail.  Relocate this source tree to a path that does not contain
+spaces and run configure again.
+])
+fi
+
+AC_CANONICAL_HOST
+AC_CONFIG_HEADERS([config.h])
+AM_INIT_AUTOMAKE([1.9 -Wno-portability dist-bzip2])
+dnl TODO: Always use AM_SILENT_RULES when we depend on automake >= 1.11
+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
+
+PURPLE_MAJOR_VERSION=purple_major_version
+PURPLE_MINOR_VERSION=purple_minor_version
+PURPLE_MICRO_VERSION=purple_micro_version
+PURPLE_VERSION=[purple_display_version]
+AC_SUBST(PURPLE_MAJOR_VERSION)
+AC_SUBST(PURPLE_MINOR_VERSION)
+AC_SUBST(PURPLE_MICRO_VERSION)
+AC_SUBST(PURPLE_VERSION)
+
+PURPLE_LT_VERSION_INFO="purple_lt_current:purple_micro_version:purple_minor_version"
+AC_SUBST(PURPLE_LT_VERSION_INFO)
+
+GNT_MAJOR_VERSION=gnt_major_version
+GNT_MINOR_VERSION=gnt_minor_version
+GNT_MICRO_VERSION=gnt_micro_version
+GNT_VERSION=[gnt_display_version]
+AC_SUBST(GNT_MAJOR_VERSION)
+AC_SUBST(GNT_MINOR_VERSION)
+AC_SUBST(GNT_MICRO_VERSION)
+AC_SUBST(GNT_VERSION)
+
+GNT_LT_VERSION_INFO="gnt_lt_current:gnt_micro_version:gnt_minor_version"
+AC_SUBST(GNT_LT_VERSION_INFO)
+
+AC_PATH_PROG(sedpath, sed)
+
+dnl Storing configure arguments
+AC_DEFINE_UNQUOTED(CONFIG_ARGS, "$ac_configure_args", [configure arguments])
+
+dnl Checks for programs.
+AC_PROG_CC
+AM_PROG_CC_C_O
+AC_DISABLE_STATIC
+AC_PROG_LIBTOOL
+LIBTOOL="$LIBTOOL --silent"
+AC_PROG_INSTALL
+PKG_PROG_PKG_CONFIG
+AC_FUNC_ALLOCA
+
+dnl Check for Sun compiler
+AC_CHECK_DECL([__SUNPRO_C], [SUNCC="yes"], [SUNCC="no"])
+
+dnl Checks for header files.
+AC_HEADER_STDC
+AC_HEADER_SYS_WAIT
+AC_CHECK_HEADERS(arpa/nameser_compat.h fcntl.h sys/time.h unistd.h locale.h signal.h stdint.h regex.h)
+
+dnl Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+AC_STRUCT_TM
+AC_CHECK_SIZEOF(time_t, ,[
+#include <stdio.h>
+#include <time.h>])
+
+AC_C_BIGENDIAN
+
+dnl Checks for library functions.
+AC_TYPE_SIGNAL
+AC_FUNC_STRFTIME
+AC_CHECK_FUNCS(strdup strstr atexit setlocale)
+dnl Checks for getopt in standard library
+AC_CHECK_FUNCS(getopt_long,,
+[
+	AC_LIBOBJ(getopt)
+	AC_LIBOBJ(getopt1)
+])
+
+dnl Check for inet_aton
+AC_CHECK_FUNC(inet_aton, , [AC_CHECK_LIB(resolv, inet_aton, ,
+				         [AC_MSG_ERROR([inet_aton not found])])])
+AC_CHECK_LIB(resolv, __res_query)
+AC_CHECK_LIB(nsl, gethostent)
+AC_CHECK_FUNC(socket, ,
+	[AC_CHECK_LIB(socket, socket, , [AC_MSG_ERROR([socket not found])])])
+dnl If all goes well, by this point the previous two checks will have
+dnl pulled in -lsocket and -lnsl if we need them.
+AC_CHECK_FUNC(getaddrinfo,
+	[AC_DEFINE([HAVE_GETADDRINFO], [1],
+		[Define to 1 if you have the getaddrinfo function.])],
+	[AC_CHECK_LIB(socket, getaddrinfo,
+		[AC_DEFINE([HAVE_GETADDRINFO]) LIBS="-lsocket -lsnl $LIBS"], , , -lnsl)])
+AC_CHECK_FUNCS(inet_ntop)
+AC_CHECK_FUNCS(getifaddrs)
+dnl Check for socklen_t (in Unix98)
+AC_MSG_CHECKING(for socklen_t)
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+	#include <sys/types.h>
+	#include <sys/socket.h>
+	socklen_t x;
+]], [[]])], [
+	AC_MSG_RESULT(yes)
+], [
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+		#include <sys/types.h>
+		#include <sys/socket.h>
+		int accept(int, struct sockaddr *, size_t *);
+	]], [[]])], [
+		AC_MSG_RESULT(size_t)
+		AC_DEFINE(socklen_t, size_t, [socklen_t size])
+	], [
+		AC_MSG_RESULT(int)
+		AC_DEFINE(socklen_t, int, [socklen_t size])
+	])
+])
+
+dnl Some systems do not have sa_len field for struct sockaddr.
+AC_CHECK_MEMBER([struct sockaddr.sa_len],
+	[AC_DEFINE([HAVE_STRUCT_SOCKADDR_SA_LEN],[1],
+	[Define if struct sockaddr has an sa_len member])],[:],
+	[#include <sys/socket.h>])
+
+dnl Check for v6-only sockets
+AC_CHECK_DECL([IPV6_V6ONLY],
+	[AC_DEFINE([HAVE_IPV6_V6ONLY],[1],
+	[Define if the IPV6_V6ONLY setsockopt option exists])],
+	[], [#include <netinet/in.h>])
+
+dnl to prevent the g_stat()/g_unlink() crash,
+dnl (09:50:07) Robot101: LSchiere2: it's easy. +LC_SYS_LARGEFILE somewhere in configure.ac
+AC_SYS_LARGEFILE
+
+dnl FreeBSD doesn't have libdl, dlopen is provided by libc
+AC_CHECK_FUNC(dlopen, LIBDL="", [AC_CHECK_LIB(dl, dlopen, LIBDL="-ldl")])
+
+dnl Haiku does not use libm for the math functions, they are part
+dnl of the C library
+AC_SEARCH_LIBS([ceil], [m], [], [
+  AC_MSG_ERROR([unable to find the floor() function])
+])
+
+AC_MSG_CHECKING(for fileno())
+AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <stdio.h>
+
+int main(int argc, char *argv[])
+{
+	int fd;
+
+	fd = fileno(stdout);
+
+	return !(fd > 0);
+}
+]])], [
+	AC_MSG_RESULT(yes)
+	AC_DEFINE([HAVE_FILENO], [1],
+	          [Define to 1 if your stdio has int fileno(FILE *).])
+], [
+	AC_MSG_RESULT(no)
+], [
+	# Fallback for Cross Compiling...
+	# This will enable the compatibility code.
+	AC_MSG_RESULT(no)
+])
+
+AC_MSG_CHECKING(for the %z format string in strftime())
+AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <time.h>
+#include <stdio.h>
+
+int main()
+{
+	char buf[6];
+	time_t t = time(NULL);
+
+	if (strftime(buf, sizeof(buf), "%z", localtime(&t)) != 5)
+		return 1;
+
+	fprintf(stderr, "strftime(\"%%z\") yields: \"%s\"\n", buf);
+
+	return !((buf[0] == '-' || buf[0] == '+') &&
+	         (buf[1] >= '0' && buf[1] <= '9') &&
+	         (buf[2] >= '0' && buf[2] <= '9') &&
+	         (buf[3] >= '0' && buf[3] <= '9') &&
+	         (buf[4] >= '0' && buf[4] <= '9')
+	        );
+}
+]])], [
+	AC_MSG_RESULT(yes)
+	AC_DEFINE([HAVE_STRFTIME_Z_FORMAT], [1],
+		[Define to 1 if you have a strftime() that supports the %z format string.])
+], [
+	AC_MSG_RESULT(no)
+], [
+	# Fallback for Cross Compiling...
+	# This will enable the compatibility code.
+	AC_MSG_RESULT(no)
+])
+
+# before gettexting, in case iconv matters
+case "$host_os" in
+darwin*)
+	AC_CHECK_LIB(resolv, res_query)
+
+	AC_CHECK_HEADER(CoreFoundation/CoreFoundation.h, [
+		AC_CHECK_HEADER(IOKit/IOKitLib.h, [
+			AC_DEFINE(HAVE_IOKIT, 1, [Define if we have IOKit])
+			LIBS="$LIBS -framework IOKit -framework CoreFoundation"
+		], [])
+	], [])
+
+	AC_MSG_CHECKING([for fink])
+	if test -d /sw; then
+		AC_MSG_RESULT([found, adding /sw to search paths])
+		CPPFLAGS="$CPPFLAGS -I/sw/include"
+		LDFLAGS="$LDFLAGS -L/sw/lib"
+	else
+		AC_MSG_RESULT([not found])
+	fi
+	;;
+*)
+	;;
+esac
+
+dnl #######################################################################
+dnl # Disable creation and installation of translation files
+dnl #######################################################################
+AC_ARG_ENABLE(nls, AC_HELP_STRING([--disable-nls], [disable installation of translation files]), enable_i18n="$enableval", enable_i18n=yes)
+
+if test x$enable_i18n = xyes; then
+	AC_PROG_INTLTOOL
+	GETTEXT_PACKAGE=pidgin
+	AC_SUBST(GETTEXT_PACKAGE)
+
+	ALL_LINGUAS="af am ar ast az be@latin bg bn bn_IN bs ca ca@valencia cs da de dz el en_AU en_CA en_GB eo es et eu fa fi fr ga gl gu he hi hr hu id it ja ka kk km kn ko ku ku_IQ lt lv mai mhr mk mn mr my_MM nb ne nl nn oc or pa pl pt_BR pt ps ro ru si sk sl sq sr sr@latin sv sw ta te th tr tt uk ur vi xh zh_CN zh_HK zh_TW"
+	AM_GLIB_GNU_GETTEXT
+
+	dnl If we don't have msgfmt, then po/ is going to fail -- ensure that
+	dnl AM_GLIB_GNU_GETTEXT found it.
+
+	if test x$MSGFMT = xno -o x$MSGFMT$GMSGFMT$INTLTOOL_MSGFMT = x
+	then
+		AC_MSG_ERROR([
+
+The msgfmt command is required to build libpurple.  If it is installed
+on your system, ensure that it is in your path.  If it is not, install
+GNU gettext to continue.
+
+If you have msgfmt installed, but for some reason this error message
+is still displayed, you have encountered what appears to be a bug in
+third-party configure macros.  Try setting the MSGFMT environment
+variable to the absolute path to your msgfmt binary and trying
+configure again, like this:
+
+MSGFMT=/path/to/msgfmt ./configure ...
+	])
+	fi
+fi #enable_i18n
+
+AM_CONDITIONAL(INSTALL_I18N, test "x$enable_i18n" = "xyes")
+
+dnl #######################################################################
+dnl # Check for GLib 2.16 (required)
+dnl #######################################################################
+PKG_CHECK_MODULES(GLIB, [glib-2.0 >= 2.16.0 gobject-2.0 gmodule-2.0 gthread-2.0], , [
+	AC_MSG_RESULT(no)
+	AC_MSG_ERROR([
+
+You must have GLib 2.16.0 or newer development headers installed to build.
+
+If you have these installed already you may need to install pkg-config so
+I can find them.
+])])
+AC_SUBST(GLIB_CFLAGS)
+AC_SUBST(GLIB_LIBS)
+
+GLIB_GENMARSHAL=`pkg-config --variable=glib_genmarshal glib-2.0`
+AC_SUBST(GLIB_GENMARSHAL)
+
+AC_ARG_WITH([extraversion],
+			AC_HELP_STRING([--with-extraversion=STRING],
+						   [extra version number to be displayed in Help->About and --help (for packagers)]),
+						   EXTRA_VERSION=$withval)
+
+if test x"$EXTRA_VERSION" != "x" ; then
+	AC_DEFINE_UNQUOTED(DISPLAY_VERSION, "$VERSION-$EXTRA_VERSION", [display version info])
+else
+	AC_DEFINE_UNQUOTED(DISPLAY_VERSION, "$VERSION", [display version info])
+fi
+
+AC_ARG_ENABLE(missing-dependencies, [AC_HELP_STRING([--disable-missing-dependencies],
+		[skip missing dependencies instead of aborting configure])],
+	force_deps="$enableval", force_deps="yes")
+
+AC_ARG_WITH(x, [],
+	with_x="$withval", with_x="yes")
+AC_ARG_ENABLE(gtkui, [AC_HELP_STRING([--disable-gtkui],
+		[compile without GTK+ user interface])],
+	enable_gtkui="$enableval", enable_gtkui="yes")
+AC_ARG_ENABLE(consoleui, [AC_HELP_STRING([--disable-consoleui],
+		[compile without console user interface])],
+	[enable_consoleui=$enableval force_finch=$enableval], [enable_consoleui=yes force_finch=no])
+
+dnl #######################################################################
+dnl # Check for GTK+ 2.10 and other things used by the GTK UI
+dnl #######################################################################
+AC_ARG_ENABLE(screensaver,
+	[AC_HELP_STRING([--disable-screensaver],
+		[compile without X screensaver extension (used to detect idleness)])],
+	enable_screensaver="$enableval", enable_screensaver="yes")
+AC_ARG_ENABLE(sm,
+	[AC_HELP_STRING([--disable-sm],
+		[compile without X session management support])],
+	enable_sm="$enableval", enable_sm="yes")
+AC_ARG_ENABLE(startup-notification,
+	[AC_HELP_STRING([--disable-startup-notification],
+		[compile without startup notification support])],
+	enable_startup_notification="$enableval", enable_startup_notification="yes")
+AC_ARG_ENABLE(gtkspell,
+	[AC_HELP_STRING([--disable-gtkspell],
+		[compile without GtkSpell automatic spell checking])],
+	enable_gtkspell="$enableval", enable_gtkspell="yes")
+AC_ARG_ENABLE(gevolution,
+	[AC_HELP_STRING([--enable-gevolution],
+		[compile with the Evolution plugin])],
+	enable_gevolution="$enableval", enable_gevolution="no")
+AC_ARG_ENABLE(cap,
+	[AC_HELP_STRING([--enable-cap],
+		[compile with Contact Availability Prediction plugin])],
+	enable_cap="$enableval", enable_cap="no")
+AC_ARG_ENABLE(gestures,
+	[AC_HELP_STRING([--disable-gestures],
+		[compile without the gestures plugin])],
+	enable_gestures="$enableval", enable_gestures="yes")
+
+AC_PATH_XTRA
+# We can't assume that $x_libraries will be set, because autoconf does not
+# set it in the case when the X libraries are in a standard place.
+# Ditto for $x_includes
+if test X"$x_libraries" = X"" || test X"$x_libraries" = XNONE; then
+    x_libpath_add=
+else
+    x_libpath_add="-L$x_libraries"
+fi
+if test X"$x_includes" = X"" || test X"$x_includes" = XNONE; then
+    x_incpath_add=
+else
+    x_incpath_add="-I$x_includes"
+fi
+
+if test "x$enable_gtkui" = "xyes" ; then
+	PKG_CHECK_MODULES(GTK, [gtk+-2.0 >= 2.10.0], , [
+		AC_MSG_RESULT(no)
+		AC_MSG_ERROR([
+
+You must have GTK+ 2.10.0 or newer development headers installed to compile
+Pidgin.  If you want to build only Finch then specify --disable-gtkui when
+running configure.
+])])
+
+	AC_SUBST(GTK_CFLAGS)
+	AC_SUBST(GTK_LIBS)
+
+	dnl We only really need Pango >= 1.4 for decent RTL support
+	PKG_CHECK_MODULES(PANGO, [pango >= 1.4.0],
+			AC_DEFINE(HAVE_PANGO14, 1, [Define if we have Pango 1.4 or newer.]),:)
+
+	dnl #######################################################################
+	dnl # Check if we should compile with X support
+	dnl #######################################################################
+	if test "x$with_x" = "xyes" ; then
+		PKG_CHECK_MODULES(X11, x11,
+			[AC_DEFINE(HAVE_X11, 1, [Define to 1 if you have X11])],
+			[AC_MSG_RESULT(no)
+				if test "x$x_incpath_add" != "x" -a "x$x_libpath_add" != "x"; then
+					X11_LIBS="$x_libpath_add"
+					X11_CFLAGS="$x_incpath_add"
+				else
+					with_x="no"
+					if test "x$force_deps" = "xyes" ; then
+						AC_MSG_ERROR([
+X11 development headers not found.
+Use --without-x if you do not need X11 support.
+])
+					fi
+				fi
+			])
+		AC_SUBST(X11_LIBS)
+		AC_SUBST(X11_CFLAGS)
+	else
+		enable_screensaver=no
+		enable_sm=no
+		enable_gestures=no
+	fi
+
+	dnl #######################################################################
+	dnl # Check for XScreenSaver
+	dnl #######################################################################
+	if test "x$enable_screensaver" = "xyes" ; then
+		if test "x$with_x" = "xyes" ; then
+			old_LIBS="$LIBS"
+			LIBS="$LIBS $GTK_LIBS $x_libpath_add"
+			XSS_LIBS=""
+			XSS_HEADERS=""
+			AC_CHECK_LIB(Xext, XScreenSaverRegister,[XSS_LIBS="$X_LIBS $X_PRE_LIBS -lX11 -lXext $X_EXTRA_LIBS"],[],[-lX11 -lXext -lm])
+			AC_CHECK_LIB(Xss, XScreenSaverRegister,[XSS_LIBS="$X_LIBS $X_PRE_LIBS -lX11 -lXext $X_LIBS $X_EXTRA_LIBS -lXss"],[],[-lX11 -lXext -lm])
+			if test "x$XSS_LIBS" != "x"; then
+				oldCPPFLAGS="$CPPFLAGS"
+				CPPFLAGS="$CPPFLAGS $x_incpath_add"
+				AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+					#include <X11/Xlib.h>
+					#include <X11/extensions/scrnsaver.h>
+					]], [[]])], [], [enable_screensaver=no])
+				CPPFLAGS="$oldCPPFLAGS"
+			else
+				enable_screensaver=no
+			fi
+			LIBS="$old_LIBS"
+
+			if test "x$enable_screensaver" = "xyes" ; then
+				AC_DEFINE(USE_SCREENSAVER, 1, [Define if we're using XScreenSaver.])
+				AC_SUBST(XSS_LIBS)
+			else
+				if test "x$force_deps" = "xyes" ; then
+					AC_MSG_ERROR([
+XScreenSaver extension development headers not found.
+Use --disable-screensaver if you do not need XScreenSaver extension support,
+this is required for detecting idle time by mouse and keyboard usage.
+])
+				fi
+			fi
+		else
+			AC_MSG_ERROR([X support is required to build with XScreenSaver extensions])
+		fi
+	fi
+
+	dnl #######################################################################
+	dnl # Check for X session management libs
+	dnl #######################################################################
+	if test "x$enable_sm" = "xyes"; then
+		if test "x$with_x" = "xyes" ; then
+			enable_sm=no
+			AC_CHECK_LIB(SM, SmcSaveYourselfDone, found_sm_lib=true, , [$x_libpath_add -lICE])
+			if test "x$found_sm_lib" = "xtrue"; then
+				oldCPPFLAGS="$CPPFLAGS"
+				CPPFLAGS="$CPPFLAGS $x_incpath_add"
+				AC_CHECK_HEADERS(X11/SM/SMlib.h, SM_LIBS="$x_libpath_add -lSM -lICE" enable_sm=yes)
+				CPPFLAGS="$oldCPPFLAGS"
+			fi
+
+			if test "x$enable_sm" = "xyes"; then
+				AC_DEFINE(USE_SM, 1, [Define if we're using X Session Management.])
+				AC_SUBST(SM_LIBS)
+			else
+				if test "x$force_deps" = "xyes" ; then
+					AC_MSG_ERROR([
+X session management development headers not found.
+Use --disable-sm if you do not need session management support.
+])
+				fi
+			fi
+		else
+			AC_MSG_ERROR([X support is required to build with X session management support])
+		fi
+	fi
+
+	dnl #######################################################################
+	dnl # Check for X11 to allow the gestures plugin
+	dnl #######################################################################
+	if test "x$enable_gestures" = "xyes"; then
+		if test "x$with_x" = "xno" ; then
+			enable_gestures=no
+		fi
+	fi
+
+	dnl #######################################################################
+	dnl # Check for GtkSpell
+	dnl #######################################################################
+	if test "x$enable_gtkspell" = "xyes" ; then
+		PKG_CHECK_MODULES(GTKSPELL, gtkspell-2.0 >= 2.0.2, , [
+			AC_MSG_RESULT(no)
+			enable_gtkspell="no"
+			if test "x$force_deps" = "xyes" ; then
+				AC_MSG_ERROR([
+GtkSpell development headers not found.
+Use --disable-gtkspell if you do not need it.
+])
+			fi])
+		if test "x$enable_gtkspell" = "xyes" ; then
+			AC_DEFINE(USE_GTKSPELL, 1, [Define if we're using GtkSpell])
+			AC_SUBST(GTKSPELL_CFLAGS)
+			AC_SUBST(GTKSPELL_LIBS)
+		fi
+	fi
+
+	dnl #######################################################################
+	dnl # Check for stuff needed by the Evolution integration plugin.
+	dnl #######################################################################
+	if test "x$enable_gevolution" = "xyes"; then
+		evo_deps="libebook-1.2 libedata-book-1.2 evolution-data-server-1.2 < 3.6"
+		PKG_CHECK_MODULES(EVOLUTION_ADDRESSBOOK, $evo_deps, , [
+			enable_gevolution="no"
+		])
+		if test "x$enable_gevolution" = "xno"; then
+			evo_deps="libebook-1.0 libedata-book-1.0"
+			PKG_CHECK_MODULES(EVOLUTION_ADDRESSBOOK, $evo_deps, [
+				enable_gevolution="yes"
+			], [
+				enable_gevolution="no"
+			])
+		fi
+		if test "x$enable_gevolution" = "xyes"; then
+			AC_DEFINE(HAVE_EVOLUTION_ADDRESSBOOK, 1, [Define if we're using evolution addressbook.])
+			AC_SUBST(EVOLUTION_ADDRESSBOOK_CFLAGS)
+			AC_SUBST(EVOLUTION_ADDRESSBOOK_LIBS)
+		else
+			if test "x$force_deps" = "xyes" ; then
+				AC_MSG_ERROR([
+Evolution development headers not found (libebook, libedata-book, evolution-data-server < 3.6).
+Use --disable-gevolution if you do not need it.
+])
+			fi
+		fi
+	fi
+
+	dnl #######################################################################
+	dnl # Check for libsqlite3 (for the Contact Availability Prediction plugin)
+	dnl #######################################################################
+	if test "x$enable_cap" = "xyes"; then
+		PKG_CHECK_MODULES(SQLITE3, sqlite3 >= 3.3,,[
+			AC_MSG_RESULT(no)
+			enable_cap="no"
+			if test "x$force_deps" = "xyes" ; then
+				AC_MSG_ERROR([
+sqlite3 development headers not found.
+Use --disable-cap if you do not need the Contact Availability Prediction plugin.
+])
+			fi])
+	fi
+        
+
+else # GTK
+	enable_cap=no
+	enable_gevolution=no
+	enable_gtkspell=no
+	enable_screensaver=no
+	enable_sm=no
+	enable_startup_notification=no
+fi	# GTK
+
+AM_CONDITIONAL(ENABLE_GTK, test "x$enable_gtkui" = "xyes")
+AM_CONDITIONAL(BUILD_GEVOLUTION, test "x$enable_gevolution" = "xyes")
+AM_CONDITIONAL(ENABLE_CAP, test "x$enable_cap" = "xyes")
+AM_CONDITIONAL(ENABLE_GESTURES, test "x$enable_gestures" = "xyes")
+
+
+dnl #######################################################################
+dnl # Check for ncurses and other things used by the console UI
+dnl #######################################################################
+GNT_LIBS=""
+GNT_CFLAGS=""
+AC_ARG_WITH(ncurses-headers, [AC_HELP_STRING([--with-ncurses-headers=DIR],
+		[compile finch against the ncurses includes in DIR])],
+		[ac_ncurses_includes="$withval"], [ac_ncurses_includes=""])
+if test "x$enable_consoleui" = "xyes"; then
+	AC_CHECK_LIB(ncursesw, initscr, [GNT_LIBS="-lncursesw"], [enable_consoleui=no])
+	AC_CHECK_LIB(panelw, update_panels, [GNT_LIBS="$GNT_LIBS -lpanelw"],
+	    [enable_consoleui=no], [$GNT_LIBS])
+
+	if test "x$enable_consoleui" = "xyes"; then
+		dnl # Some distros put the headers in ncursesw/, some don't
+		found_ncurses_h=no
+		for location in $ac_ncurses_includes $NCURSES_HEADERS /usr/include/ncursesw /usr/include
+		do
+			f="$location/ncurses.h"
+			orig_CFLAGS="$CFLAGS"
+			orig_CPPFLAGS="$CPPFLAGS"
+			CFLAGS="$CFLAGS -I$location"
+			CPPFLAGS="$CPPFLAGS -I$location"
+			AC_CHECK_HEADER($f,[
+				AC_MSG_CHECKING([if $f supports wide characters])
+				AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+					#define _XOPEN_SOURCE_EXTENDED
+					#include <$f>
+				]], [[
+					#ifndef get_wch
+					# error get_wch not found!
+					#endif
+				]])], [
+					dir=$location
+					if test x"$dir" != x"." ; then
+						GNT_CFLAGS="-I$dir/"
+					else
+						GNT_CFLAGS=""
+					fi
+
+					found_ncurses_h=yes
+					CFLAGS="$orig_CFLAGS"
+					CPPFLAGS="$orig_CPPFLAGS"
+					AC_MSG_RESULT([yes])
+					break
+				], [
+					CFLAGS="$orig_CFLAGS"
+					CPPFLAGS="$orig_CPPFLAGS"
+					AC_MSG_RESULT([no])
+				])
+			])
+		done
+
+		if test x"$found_ncurses_h" = x"no" ; then
+			GNT_LIBS=""
+			GNT_CFLAGS=""
+			enable_consoleui=no
+		fi
+	else
+		# ncursesw was not found. Look for plain old ncurses
+		enable_consoleui=yes
+		AC_CHECK_LIB(ncurses, initscr, [GNT_LIBS="-lncurses"], [enable_consoleui=no])
+		AC_CHECK_LIB(panel, update_panels, [GNT_LIBS="$GNT_LIBS -lpanel"],
+		    [enable_consoleui=no], [$GNT_LIBS])
+		AC_DEFINE(NO_WIDECHAR, 1, [Define to 1 if you don't have wide-character support.])
+		if test x"$ac_ncurses_includes" != "x"; then
+			GNT_CFLAGS="-I$ac_ncurses_includes"
+		else
+			if test x"$NCURSES_HEADERS" != "x"; then
+				GNT_CFLAGS="-I$NCURSES_HEADERS"
+			fi
+		fi
+	fi
+fi
+
+if test "x$force_finch" = "xyes" -a "x$enable_consoleui" != "xyes"; then
+	AC_MSG_ERROR([
+
+Finch will not be built. You need to install ncursesw (or ncurses) and its development headers.
+
+])
+fi
+
+AC_SUBST(GNT_LIBS)
+AC_SUBST(GNT_CFLAGS)
+AM_CONDITIONAL(ENABLE_GNT, test "x$enable_consoleui" = "xyes")
+
+#AC_CHECK_FUNC(wcwidth, [AC_DEFINE([HAVE_WCWIDTH], [1], [Define to 1 if you have wcwidth function.])])
+
+dnl #######################################################################
+dnl # Check for LibXML2 (required)
+dnl #######################################################################
+PKG_CHECK_MODULES(LIBXML, [libxml-2.0 >= 2.6.0], , [
+	AC_MSG_RESULT(no)
+	AC_MSG_ERROR([
+You must have libxml2 >= 2.6.0 development headers installed to build.
+])])
+PKG_CHECK_EXISTS([libxml-2.0 >= 2.6.18], , [
+	AC_MSG_WARN([
+Versions of libxml2 < 2.6.18 may contain bugs that could cause XMPP messages to be discarded.
+])])
+
+AC_SUBST(LIBXML_CFLAGS)
+AC_SUBST(LIBXML_LIBS)
+
+dnl #######################################################################
+dnl # GConf schemas
+dnl #######################################################################
+AC_PATH_PROG(GCONFTOOL, gconftool-2, no)
+AM_CONDITIONAL(USE_GCONFTOOL, test "x$GCONFTOOL" != "xno")
+AM_GCONF_SOURCE_2
+
+dnl #######################################################################
+dnl # Check for GStreamer
+dnl #######################################################################
+dnl
+dnl TODO: Depend on gstreamer >= 0.10.10, and remove the conditional use of
+dnl       gst_registry_fork_set_enabled.
+AC_ARG_ENABLE(gstreamer,
+	[AC_HELP_STRING([--disable-gstreamer], [compile without GStreamer audio support])],
+	enable_gst="$enableval", enable_gst="yes")
+if test "x$enable_gst" != "xno"; then
+	PKG_CHECK_MODULES(GSTREAMER, [gstreamer-0.10], [
+		AC_DEFINE(USE_GSTREAMER, 1, [Use GStreamer for playing sounds])
+		AC_SUBST(GSTREAMER_CFLAGS)
+		AC_SUBST(GSTREAMER_LIBS)
+		AC_CHECK_LIB(gstreamer-0.10, gst_registry_fork_set_enabled,
+			[ AC_DEFINE(GST_CAN_DISABLE_FORKING, [],
+			  [Define if gst_registry_fork_set_enabled exists])],
+			[], [$GSTREAMER_LIBS])
+	], [
+		AC_MSG_RESULT(no)
+		enable_gst="no"
+		if test "x$force_deps" = "xyes" ; then
+			AC_MSG_ERROR([
+GStreamer development headers not found.
+Use --disable-gstreamer if you do not need GStreamer (sound) support.
+])
+		fi])
+fi
+
+dnl #######################################################################
+dnl # Check for GStreamer Interfaces
+dnl #######################################################################
+if test "x$enable_gst" != "xno"; then
+	AC_ARG_ENABLE(gstreamer-interfaces,
+		[AC_HELP_STRING([--disable-gstreamer-interfaces], [compile without GStreamer interface support])],
+			enable_gstinterfaces="$enableval", enable_gstinterfaces="yes")
+	if test "x$enable_gstinterfaces" != "xno"; then
+		PKG_CHECK_MODULES(GSTINTERFACES, [gstreamer-interfaces-0.10], [
+			AC_DEFINE(USE_GSTINTERFACES, 1, [Use GStreamer interfaces for X overlay support])
+			AC_SUBST(GSTINTERFACES_CFLAGS)
+			AC_SUBST(GSTINTERFACES_LIBS)
+		], [
+			enable_gstinterfaces="no"
+		])
+	fi
+else
+	enable_gstinterfaces="no"
+fi
+
+dnl #######################################################################
+dnl # Check for Farstream
+dnl #######################################################################
+AC_ARG_ENABLE(farstream,
+	[AC_HELP_STRING([--disable-farstream], [compile without farstream support])],
+	enable_farstream="$enableval", enable_farstream="yes")
+if test "x$enable_farstream" != "xno"; then
+	PKG_CHECK_MODULES(FARSTREAM, [farstream-0.1], [
+		AC_SUBST(FARSTREAM_CFLAGS)
+		AC_SUBST(FARSTREAM_LIBS)
+ 	], [
+		# Try farsight.
+		PKG_CHECK_MODULES(FARSTREAM, [farsight2-0.10 >= 0.0.9], [
+		        AC_DEFINE(HAVE_FARSIGHT, 1, [Use Farsight instead of Farstream])
+			AC_SUBST(FARSTREAM_CFLAGS)
+			AC_SUBST(FARSTREAM_LIBS)
+		], [
+		        enable_farstream="no"
+		])
+ 	])
+ fi
+
+dnl #######################################################################
+dnl # Check for Voice and Video support
+dnl #######################################################################
+AC_ARG_ENABLE(vv,
+	[AC_HELP_STRING([--disable-vv], [compile without voice and video support])],
+	enable_vv="$enableval", enable_vv="yes")
+if test "x$enable_vv" != "xno"; then
+	if test "x$enable_gstreamer" != "xno" -a "x$enable_gstinterfaces" != "xno" -a "x$enable_farstream" != "xno"; then
+		AC_DEFINE(USE_VV, 1, [Use voice and video])
+	else
+		enable_vv="no"
+		if test "x$force_deps" = "xyes"; then
+			AC_MSG_ERROR([
+Dependencies for voice/video were not met.
+Install the necessary gstreamer and farstream packages first.
+Or use --disable-vv if you do not need voice/video support.
+			])
+		fi
+	fi
+fi
+AM_CONDITIONAL(USE_VV, test "x$enable_gstreamer" != "xno" -a "x$enable_gstinterfaces" != "xno" -a "x$enable_farstream" != "xno")
+
+dnl #######################################################################
+dnl # Check for Internationalized Domain Name support
+dnl #######################################################################
+
+AC_ARG_ENABLE(idn,
+	[AC_HELP_STRING([--disable-idn], [compile without IDN support])],
+	[enable_idn="$enableval" force_idn=$enableval], [enable_idn="yes" force_idn=no])
+if test "x$enable_idn" != "xno"; then
+	PKG_CHECK_MODULES(IDN, libidn >= 0.0.0, [
+		AC_DEFINE(USE_IDN, 1, [Use GNU Libidn for stringprep and IDN])
+		AC_SUBST(IDN_CFLAGS)
+		AC_SUBST(IDN_LIBS)
+	], [
+		AC_MSG_RESULT(no)
+		enable_idn="no"
+		if test "x$force_deps" = "xyes" ; then
+			AC_MSG_ERROR([
+GNU Libidn development headers not found.
+Use --disable-idn if you do not need it.
+])
+		fi
+	])
+fi
+
+dnl #######################################################################
+dnl # Check for Meanwhile headers (for Sametime)
+dnl #######################################################################
+AC_ARG_ENABLE(meanwhile,
+	[AC_HELP_STRING([--disable-meanwhile],
+		[compile without meanwhile (required for Sametime support)])],
+	enable_meanwhile="$enableval", enable_meanwhile="yes")
+if test "x$enable_meanwhile" = "xyes"; then
+	PKG_CHECK_MODULES(MEANWHILE, [meanwhile >= 1.0.0 meanwhile < 2.0.0], [
+		have_meanwhile="yes"
+	], [
+		have_meanwhile="no"
+		if test "x$force_deps" = "xyes" ; then
+			AC_MSG_ERROR([
+Meanwhile development headers not found.
+Use --disable-meanwhile if you do not need meanwhile (Sametime) support.
+])
+		fi])
+fi
+AC_SUBST(MEANWHILE_CFLAGS)
+AC_SUBST(MEANWHILE_LIBS)
+
+dnl #######################################################################
+dnl # Check for Native Avahi headers (for Bonjour)
+dnl #######################################################################
+AC_ARG_ENABLE(avahi,
+	[AC_HELP_STRING([--disable-avahi],
+		[compile without avahi (required for Bonjour support)])],
+	enable_avahi="$enableval", enable_avahi="yes")
+
+if test "x$enable_avahi" = "xyes"; then
+	AC_ARG_WITH(avahi-client-includes, [AC_HELP_STRING([--with-avahi-client-includes=DIR], [compile the Bonjour plugin against the Avahi Client includes in DIR])], [ac_avahi_client_includes="$withval"], [ac_avahi_client_includes="no"])
+	AC_ARG_WITH(avahi-client-libs, [AC_HELP_STRING([--with-avahi-client-libs=DIR], [compile the Bonjour plugin against the Avahi Client libs in DIR])], [ac_avahi_client_libs="$withval"], [ac_avahi_client_libs="no"])
+	AVAHI_CFLAGS=""
+	AVAHI_LIBS=""
+
+	dnl Attempt to autodetect Avahi
+	PKG_CHECK_MODULES(AVAHI, [avahi-client avahi-glib], [
+		avahiincludes="yes"
+		avahilibs="yes"
+	], [
+		avahiincludes="no"
+		avahilibs="no"
+	])
+
+	dnl Override AVAHI_CFLAGS if the user specified an include dir
+	if test "$ac_avahi_client_includes" != "no"; then
+		AVAHI_CFLAGS="-I$ac_avahi_client_includes"
+	fi
+	CPPFLAGS_save="$CPPFLAGS"
+	CPPFLAGS="$CPPFLAGS $AVAHI_CFLAGS"
+	AC_CHECK_HEADER(avahi-client/client.h, [avahiincludes=yes], [avahiincludes=no])
+	CPPFLAGS="$CPPFLAGS $AVAHI_CFLAGS $GLIB_CFLAGS"
+	AC_CHECK_HEADER(avahi-glib/glib-malloc.h, [avahiincludes=yes], [avahiincludes=no])
+	CPPFLAGS="$CPPFLAGS_save"
+
+	dnl Override AVAHI_LIBS if the user specified a libs dir
+	if test "$ac_avahi_client_libs" != "no"; then
+		AVAHI_LIBS="-L$ac_avahi_client_libs -lavahi-common -lavahi-client -lavahi-glib "
+	fi
+	AC_CHECK_LIB(avahi-client, avahi_client_new, [avahilibs=yes], [avahilibs=no], $AVAHI_LIBS)
+fi
+
+if test "x$enable_avahi" = "xyes" -a \( "x$avahiincludes" = "xno" -o "x$avahilibs" = "xno" \); then
+	enable_avahi="no"
+	if test "x$force_deps" = "xyes"; then
+		AC_MSG_ERROR([
+avahi development headers not found.
+Use --disable-avahi if you do not need avahi (Bonjour) support.
+])
+	fi
+fi
+AC_SUBST(AVAHI_CFLAGS)
+AC_SUBST(AVAHI_LIBS)
+
+
+dnl #######################################################################
+dnl # Check for SILC client includes and libraries
+dnl #######################################################################
+AC_ARG_WITH(silc-includes, [AC_HELP_STRING([--with-silc-includes=DIR], [compile the SILC plugin against includes in DIR])], [ac_silc_includes="$withval"], [ac_silc_includes="no"])
+AC_ARG_WITH(silc-libs, [AC_HELP_STRING([--with-silc-libs=DIR], [compile the SILC plugin against the SILC libs in DIR])], [ac_silc_libs="$withval"], [ac_silc_libs="no"])
+SILC_CFLAGS=""
+SILC_LIBS=""
+have_silc="no"
+if test -n "$with_silc_includes" || test -n "$with_silc_libs"; then
+	silc_manual_check="yes"
+else
+	silc_manual_check="no"
+fi
+if test "x$silc_manual_check" = "xno"; then
+	PKG_CHECK_MODULES(SILC, [silcclient >= 1.1], [
+		have_silc="yes"
+		silcincludes="yes"
+		silcclient="yes"
+	], [
+		have_silc="no"
+	])
+	if test "x$have_silc" = "xno"; then
+		PKG_CHECK_MODULES(SILC, silcclient, [
+			have_silc="yes"
+			silc10includes="yes"
+			silc10client="yes"
+		], [
+			have_silc="no"
+		])
+		dnl If silcclient.pc wasn't found, check for just silc.pc
+		if test "x$have_silc" = "xno"; then
+			PKG_CHECK_MODULES(SILC, silc, [
+				have_silc="yes"
+				silc10includes="yes"
+				silc10client="yes"
+			], [
+				have_silc="no"
+			])
+		fi
+	fi
+else
+	if test "$ac_silc_includes" != "no"; then
+		SILC_CFLAGS="-I$ac_silc_includes"
+	fi
+	CPPFLAGS_save="$CPPFLAGS"
+	CPPFLAGS="$CPPFLAGS $SILC_CFLAGS"
+	AC_CHECK_HEADER(silc.h, [silcincludes=yes])
+	CPPFLAGS="$CPPFLAGS_save"
+
+	if test "$ac_silc_libs" != "no"; then
+		SILC_LIBS="-L$ac_silc_libs"
+	fi
+	SILC_LIBS="$SILC_LIBS -lsilc -lsilcclient -lpthread $LIBDL"
+	AC_CHECK_LIB(silcclient, silc_client_init, [silcclient=yes], , $SILC_LIBS)
+
+	if test "x$silcincludes" = "xyes" -a "x$silcclient" = "xyes"; then
+		have_silc="yes"
+	else
+		CPPFLAGS_save="$CPPFLAGS"
+		CPPFLAGS="$CPPFLAGS $SILC_CFLAGS"
+		AC_CHECK_HEADER(silcincludes.h, [silc10includes=yes])
+		CPPFLAGS="$CPPFLAGS_save"
+
+		SILC_LIBS="$SILC_LIBS -lsilc -lsilcclient -lpthread $LIBDL"
+		AC_CHECK_LIB(silcclient, silc_client_init, [silc10client=yes], , $SILC_LIBS)
+		if test "x$silc10includes" = "xyes" -a "x$silc10client" = "xyes"; then
+			have_silc="yes"
+		fi
+	fi
+fi
+AC_SUBST(SILC_LIBS)
+AC_SUBST(SILC_CFLAGS)
+dnl SILC Toolkit >= 1.0.1 has a new MIME API
+if test "x$silcclient" = "xyes"; then
+	AC_DEFINE(HAVE_SILCMIME_H, 1, [Define if we have silcmime.h])
+elif test "x$silc10client" = "xyes"; then
+	CPPFLAGS_save="$CPPFLAGS"
+	CPPFLAGS="$CPPFLAGS $SILC_CFLAGS"
+		AC_MSG_CHECKING(for silcmime.h)
+		AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <silcincludes.h>
+#include <silcmime.h>
+		]], [[]])], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_SILCMIME_H, 1, [Define if we have silcmime.h])
+		], [
+		AC_MSG_RESULT(no)
+		])
+	CPPFLAGS="$CPPFLAGS_save"
+fi
+
+dnl #######################################################################
+dnl # Check for Gadu-Gadu protocol library (libgadu)
+dnl #######################################################################
+
+PKG_CHECK_MODULES(LIBGADU, [libgadu >= 1.12.0], [have_libgadu=yes], [have_libgadu=no])
+
+if test "x$have_libgadu" = "xyes"; then
+	AC_CHECK_LIB(gadu, gg_is_gpl_compliant, , [
+		LIBGADU_LIBS=""
+		LIBGADU_CFLAGS=""
+		have_libgadu=no
+		AC_MSG_WARN([
+libgadu is not compatible with the GPL when compiled with OpenSSL support.
+
+To compile against system libgadu, please recompile libgadu using:
+./configure --with-openssl=no
+Then rerun this ./configure
+
+Falling back to using our own copy of libgadu.
+		])
+	])
+fi
+
+AM_CONDITIONAL(HAVE_LIBGADU, test "x$have_libgadu" = "xyes")
+if test "x$have_libgadu" = "xyes"; then
+	AC_DEFINE(HAVE_LIBGADU, 1, [Linked with external libgadu])
+else
+	AC_CHECK_LIB(gnutls, gnutls_certificate_set_x509_system_trust, [gg_have_gnutls_csxst=yes], [gg_have_gnutls_csxst=no])
+
+	gg_gnutls_sts=""
+	if test "x$gg_have_gnutls_csxst" = "xno"; then
+		for i in /etc/ssl/ca-bundle.pem \
+			/etc/ssl/certs/ca-certificates.crt \
+			/etc/pki/tls/cert.pem \
+			/usr/local/share/certs/ca-root-nss.crt \
+			/etc/ssl/cert.pem
+		do
+			if test -e $i; then
+				gg_gnutls_sts="$i"
+				break
+			fi
+		done
+	fi
+
+	if test "x$gg_have_gnutls_csxst" = "xyes"; then
+		AC_DEFINE(HAVE_GNUTLS_CERTIFICATE_SET_X509_SYSTEM_TRUST, 1, [gnutls contains the gnutls_certificate_set_x509_system_trust function])
+	fi
+	if test "x$gg_gnutls_sts" != "x"; then
+		AC_DEFINE_UNQUOTED(GG_CONFIG_GNUTLS_SYSTEM_TRUST_STORE, ["$gg_gnutls_sts"], [use the given file as GnuTLS default trust store])
+	fi
+
+	PKG_CHECK_MODULES([GNUTLS_2_10], [gnutls >= 2.10.0], [
+		AC_DEFINE([HAVE_GNUTLS_2_10], [], [Defined if GnuTLS >= 2.10.0 is available.])
+	],:)
+fi
+
+AC_SUBST(LIBGADU_LIBS)
+AC_SUBST(LIBGADU_CFLAGS)
+
+
+AC_ARG_ENABLE(distrib,,,enable_distrib=no)
+AM_CONDITIONAL(DISTRIB, test "x$enable_distrib" = "xyes")
+DYNAMIC_PRPLS=all
+AC_ARG_WITH(static-prpls, [AC_HELP_STRING([--with-static-prpls], [Link to certain protocols statically])], [STATIC_PRPLS=`echo $withval | $sedpath 's/,/ /g'`], [STATIC_PRPLS=""])
+if test "x$STATIC_PRPLS" != "x" -a "x$DYNAMIC_PRPLS" = "xall"; then
+	DYNAMIC_PRPLS=""
+fi
+
+if test "x$STATIC_PRPLS" = "xall" ; then
+	STATIC_PRPLS="bonjour gg irc jabber msn myspace mxit novell oscar sametime silc simple yahoo zephyr"
+fi
+if test "x$have_meanwhile" != "xyes" ; then
+	STATIC_PRPLS=`echo $STATIC_PRPLS | $sedpath 's/sametime//'`
+fi
+if test "x$avahiincludes" != "xyes" -o "x$avahilibs" != "xyes"; then
+	STATIC_PRPLS=`echo $STATIC_PRPLS | $sedpath 's/bonjour//'`
+fi
+if test "x$silcincludes" != "xyes" -o "x$silcclient" != "xyes"; then
+	STATIC_PRPLS=`echo $STATIC_PRPLS | $sedpath 's/silc/silc10/'`
+fi
+if test "x$silc10includes" != "xyes" -o "x$silc10client" != "xyes"; then
+	STATIC_PRPLS=`echo $STATIC_PRPLS | $sedpath 's/silc10//'`
+fi
+AC_SUBST(STATIC_PRPLS)
+STATIC_LINK_LIBS=
+extern_init=
+load_proto=
+for i in $STATIC_PRPLS ; do
+	dnl Ugly special case for "libsilcpurple.la":
+	dnl ... and Ugly special case for multi-protocol oscar and yahoo
+	if test \( "x$i" = "xoscar" -o "x$i" = "xaim" -o "x$i" = "xicq" \) -a "x$static_oscar" != "xyes"; then
+		STATIC_LINK_LIBS="$STATIC_LINK_LIBS \$(top_builddir)/libpurple/protocols/oscar/liboscar.la"
+		extern_init="$extern_init extern gboolean purple_init_aim_plugin();"
+		extern_init="$extern_init extern gboolean purple_init_icq_plugin();"
+		load_proto="$load_proto purple_init_aim_plugin();"
+		load_proto="$load_proto purple_init_icq_plugin();"
+	elif test "x$i" = "xyahoo"; then
+		STATIC_LINK_LIBS="$STATIC_LINK_LIBS \$(top_builddir)/libpurple/protocols/yahoo/libymsg.la"
+		extern_init="$extern_init extern gboolean purple_init_yahoo_plugin();"
+		extern_init="$extern_init extern gboolean purple_init_yahoojp_plugin();"
+		load_proto="$load_proto purple_init_yahoo_plugin();"
+		load_proto="$load_proto purple_init_yahoojp_plugin();"
+	else
+		if test "x$i" = "xsilc"; then
+			STATIC_LINK_LIBS="$STATIC_LINK_LIBS \$(top_builddir)/libpurple/protocols/$i/lib${i}purple.la"
+		elif test "x$i" = "xsilc10"; then
+			STATIC_LINK_LIBS="$STATIC_LINK_LIBS \$(top_builddir)/libpurple/protocols/$i/libsilcpurple.la"
+		else
+			STATIC_LINK_LIBS="$STATIC_LINK_LIBS \$(top_builddir)/libpurple/protocols/$i/lib$i.la"
+		fi
+		extern_init="$extern_init extern gboolean purple_init_${i}_plugin();"
+		load_proto="$load_proto purple_init_${i}_plugin();"
+	fi
+	case $i in
+		bonjour)	static_bonjour=yes ;;
+		gg)			static_gg=yes ;;
+		irc)		static_irc=yes ;;
+		jabber)		static_jabber=yes ;;
+		msn)		static_msn=yes ;;
+		myspace)	static_myspace=yes ;;
+		mxit)		static_mxit=yes ;;
+		novell)		static_novell=yes ;;
+		oscar)		static_oscar=yes ;;
+		aim)		static_oscar=yes ;;
+		icq)		static_oscar=yes ;;
+		sametime)	static_sametime=yes ;;
+		silc)		static_silc=yes ;;
+		silc10)		static_silc=yes ;;
+		simple)		static_simple=yes ;;
+		yahoo)		static_yahoo=yes ;;
+		zephyr)		static_zephyr=yes ;;
+		*)			echo "Invalid static protocol $i!!" ; exit 1 ;;
+	esac
+done
+AM_CONDITIONAL(STATIC_BONJOUR, test "x$static_bonjour" = "xyes")
+AM_CONDITIONAL(STATIC_GG, test "x$static_gg" = "xyes")
+AM_CONDITIONAL(STATIC_IRC, test "x$static_irc" = "xyes")
+AM_CONDITIONAL(STATIC_JABBER, test "x$static_jabber" = "xyes")
+AM_CONDITIONAL(STATIC_MSN, test "x$static_msn" = "xyes")
+AM_CONDITIONAL(STATIC_MYSPACE, test "x$static_myspace" = "xyes")
+AM_CONDITIONAL(STATIC_MXIT, test "x$static_mxit" = "xyes")
+AM_CONDITIONAL(STATIC_NOVELL, test "x$static_novell" = "xyes")
+AM_CONDITIONAL(STATIC_OSCAR, test "x$static_oscar" = "xyes")
+AM_CONDITIONAL(STATIC_SAMETIME, test "x$static_sametime" = "xyes" -a "x$have_meanwhile" = "xyes")
+AM_CONDITIONAL(STATIC_SILC, test "x$static_silc" = "xyes" -a "x$have_silc" = "xyes")
+AM_CONDITIONAL(STATIC_SIMPLE, test "x$static_simple" = "xyes")
+AM_CONDITIONAL(STATIC_YAHOO, test "x$static_yahoo" = "xyes")
+AM_CONDITIONAL(STATIC_ZEPHYR, test "x$static_zephyr" = "xyes")
+AC_SUBST(STATIC_LINK_LIBS)
+AC_DEFINE_UNQUOTED(STATIC_PROTO_INIT, $extern_init static void static_proto_init(void) { $load_proto },
+	[Loads static protocol plugin module initialization functions.])
+
+AC_ARG_WITH(dynamic_prpls, [AC_HELP_STRING([--with-dynamic-prpls], [specify which protocols to build dynamically])], [DYNAMIC_PRPLS=`echo $withval | $sedpath 's/,/ /g'`])
+if test "x$DYNAMIC_PRPLS" = "xall" ; then
+	DYNAMIC_PRPLS="bonjour gg irc jabber msn myspace mxit novell oscar sametime silc simple yahoo zephyr"
+fi
+if test "x$have_meanwhile" != "xyes"; then
+	DYNAMIC_PRPLS=`echo $DYNAMIC_PRPLS | $sedpath 's/sametime//'`
+fi
+if test "x$avahiincludes" != "xyes" -o "x$avahilibs" != "xyes"; then
+	DYNAMIC_PRPLS=`echo $DYNAMIC_PRPLS | $sedpath 's/bonjour//'`
+fi
+if test "x$silcincludes" != "xyes" -o "x$silcclient" != "xyes"; then
+	DYNAMIC_PRPLS=`echo $DYNAMIC_PRPLS | $sedpath 's/silc/silc10/'`
+fi
+if test "x$silc10includes" != "xyes" -o "x$silc10client" != "xyes"; then
+	DYNAMIC_PRPLS=`echo $DYNAMIC_PRPLS | $sedpath 's/silc10//'`
+fi
+AC_SUBST(DYNAMIC_PRPLS)
+for i in $DYNAMIC_PRPLS ; do
+	case $i in
+		bonjour)	dynamic_bonjour=yes ;;
+		gg)			dynamic_gg=yes ;;
+		irc)		dynamic_irc=yes ;;
+		jabber)		dynamic_jabber=yes ;;
+		msn)		dynamic_msn=yes ;;
+		myspace)	dynamic_myspace=yes ;;
+		mxit)		dynamic_mxit=yes ;;
+		novell)		dynamic_novell=yes ;;
+		null)		dynamic_null=yes ;;
+		oscar)		dynamic_oscar=yes ;;
+		aim)		dynamic_oscar=yes ;;
+		icq)		dynamic_oscar=yes ;;
+		sametime)	dynamic_sametime=yes ;;
+		silc)		dynamic_silc=yes ;;
+		silc10)		dynamic_silc=yes ;;
+		simple)		dynamic_simple=yes ;;
+		yahoo)		dynamic_yahoo=yes ;;
+		zephyr)		dynamic_zephyr=yes ;;
+		*)			echo "Invalid dynamic protocol $i!!" ; exit 1 ;;
+	esac
+done
+
+AC_ARG_ENABLE(plugins, [AC_HELP_STRING([--disable-plugins], [compile without plugin support])], , enable_plugins=yes)
+AC_ARG_WITH(krb4, [AC_HELP_STRING([--with-krb4=PREFIX], [compile Zephyr plugin with Kerberos 4 support])], kerberos="$withval", kerberos="no")
+AC_ARG_WITH(zephyr, [AC_HELP_STRING([--with-zephyr=PREFIX], [compile Zephyr plugin against external libzephyr])], zephyr="$withval", zephyr="no")
+AM_CONDITIONAL(EXTERNAL_LIBZEPHYR, test "x$zephyr" != "xno")
+
+AC_CHECK_HEADERS(sys/utsname.h)
+AC_CHECK_FUNC(uname)
+
+AC_ARG_ENABLE(fortify, [AC_HELP_STRING([--disable-fortify], [compile without FORTIFY_SOURCE support])], , enable_fortify=yes)
+
+DEBUG_CFLAGS="$DEBUG_CFLAGS -DPURPLE_DISABLE_DEPRECATED -DPIDGIN_DISABLE_DEPRECATED -DFINCH_DISABLE_DEPRECATED -DGNT_DISABLE_DEPRECATED"
+if test "x$GCC" = "xyes"; then
+	dnl We enable -Wall later.
+	dnl If it's set after the warning CFLAGS in the compiler invocation, it counteracts the -Wno... flags.
+	dnl This leads to warnings we don't want.
+	CFLAGS=`echo $CFLAGS |$sedpath 's/-Wall//'`
+
+	dnl ENABLE WARNINGS SUPPORTED BY THE VERSION OF GCC IN USE
+	dnl
+	dnl Future Possibilities
+	dnl
+	dnl Consider adding -Wbad-function-cast.
+	dnl	This leads to spurious warnings using GPOINTER_TO_INT(), et al. directly on a function call.
+	dnl		We'd need an intermediate variable.
+	dnl
+	dnl Consider adding -Wfloat-equal.
+	dnl	This leads to warnings with Perl.
+	dnl		Perhaps we could write ugly configure magic and pass -Wno-float-equal down to that subdirectory.
+	dnl		On the other hand, it's probably actually broken, so maybe the Perl folks should fix that?
+	dnl
+	dnl Consider removing -Wno-sign-compare (from the -Wextra set) and fixing all those cases.
+	dnl	This is likely non-trivial.
+	dnl
+	for newflag in \
+			"-Waggregate-return" \
+			"-Wcast-align" \
+			"-Wdeclaration-after-statement" \
+			"-Wendif-labels" \
+			"-Werror-implicit-function-declaration" \
+			"-Wextra -Wno-unused-parameter" \
+			"-Wformat-security" \
+				"-Werror=format-security" \
+			"-Winit-self" \
+			"-Wmissing-declarations" \
+			"-Wmissing-noreturn" \
+			"-Wmissing-prototypes" \
+			"-Wpointer-arith" \
+			"-Wundef" \
+	; do
+		orig_CFLAGS="$CFLAGS"
+		CFLAGS="$CFLAGS $newflag"
+		AC_MSG_CHECKING(for $newflag option to gcc)
+		AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[]])], [
+			AC_MSG_RESULT(yes)
+			CFLAGS="$orig_CFLAGS"
+			DEBUG_CFLAGS="$DEBUG_CFLAGS $newflag"
+		], [
+			AC_MSG_RESULT(no)
+			CFLAGS="$orig_CFLAGS"
+		])
+	done
+
+	if test "x$enable_fortify" = "xyes"; then
+		AC_MSG_CHECKING(for FORTIFY_SOURCE support)
+		AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <features.h>]], [[
+			#if !(__GNUC_PREREQ (4, 1) \
+				|| (defined __GNUC_RH_RELEASE__ && __GNUC_PREREQ (4, 0)) \
+				|| (defined __GNUC_RH_RELEASE__ && __GNUC_PREREQ (3, 4) \
+					&& __GNUC_MINOR__ == 4 \
+					&& (__GNUC_PATCHLEVEL__ > 2 \
+						|| (__GNUC_PATCHLEVEL__ == 2 && __GNUC_RH_RELEASE__ >= 8))))
+			#error No FORTIFY_SOURCE support
+			#endif
+				return 0;
+		]])], [
+			AC_MSG_RESULT(yes)
+			DEBUG_CFLAGS="$DEBUG_CFLAGS -Wp,-D_FORTIFY_SOURCE=2"
+		], [
+			AC_MSG_RESULT(no)
+		])
+	fi
+
+	DEBUG_CFLAGS="-Wall $DEBUG_CFLAGS"
+	CFLAGS="-g $CFLAGS"
+fi
+
+if test "x$SUNCC" = "xyes"; then
+        CFLAGS="$CFLAGS -features=extensions" 
+fi
+AC_SUBST(CFLAGS)
+
+AC_PATH_PROG(pidginpath, pidgin)
+
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [
+	#if !defined(__clang__)
+	#error
+	#endif
+])], have_clang=yes, have_clang=no)
+
+if test "x$have_clang" = "xyes"; then
+	dnl we don't care about it for 2.x.y
+	DEBUG_CFLAGS=`echo $DEBUG_CFLAGS |$sedpath 's/-Wcast-align//'`
+fi
+
+dnl #######################################################################
+dnl # Check for D-Bus libraries
+dnl #######################################################################
+
+AC_ARG_ENABLE(dbus, [AC_HELP_STRING([--disable-dbus], [disable D-Bus support])], , enable_dbus=yes)
+AC_ARG_ENABLE(nm, [AC_HELP_STRING([--disable-nm], [disable NetworkManager support (requires D-Bus)])], enable_nm=$enableval, enable_nm=yes)
+
+if test "x$enable_dbus" = "xyes" ; then
+	AC_CHECK_PROG(enable_dbus, dbus-binding-tool, yes, no)
+fi
+
+if test "x$enable_dbus" = "xyes" ; then
+	PKG_CHECK_MODULES(DBUS, [dbus-1 >= 0.60 dbus-glib-1 >= 0.60], [
+		AC_SUBST(DBUS_CFLAGS)
+		AC_SUBST(DBUS_LIBS)
+		enable_dbus=yes
+	], [
+	enable_dbus=no
+	if test "x$force_deps" = "xyes" ; then
+		AC_MSG_ERROR([
+D-Bus development headers not found.
+Use --disable-dbus if you do not need D-Bus support.
+])
+	fi])
+fi
+
+dnl Check for NetworkManager.h; if we don't have it, oh well
+if test "x$enable_dbus" = "xyes" ; then
+	if test "x$enable_nm" = "xyes" ; then
+		PKG_CHECK_MODULES(NETWORKMANAGER, [NetworkManager >= 0.5.0], [
+			AC_SUBST(NETWORKMANAGER_CFLAGS)
+			AC_SUBST(NETWORKMANAGER_LIBS)
+			AC_DEFINE(HAVE_NETWORKMANAGER, 1, [Define if we have NetworkManager.])
+		], [
+			enable_nm=no
+			if test "x$force_deps" = "xyes" ; then
+				AC_MSG_ERROR([
+NetworkManager development headers not found.
+Use --disable-nm if you do not need NetworkManager support.
+])
+			fi])
+	fi
+else
+	enable_nm=no
+fi
+
+dnl #######################################################################
+dnl # Check for Unity and Messaging Menu
+dnl #######################################################################
+AC_ARG_ENABLE(unity, [AC_HELP_STRING([--enable-unity],
+	[compile with support for unity integration plugin])], enable_unity="$enableval", enable_unity="no")
+if test "$enable_unity" = yes; then
+	PKG_CHECK_MODULES(UNITY, [unity >= 6.8 messaging-menu >= 12.10], , [
+		AC_MSG_RESULT(no)
+		AC_MSG_ERROR([
+You must have libunity9 >= 6.8 and libmessaging-menu >= 12.10 to build the unity integration plugin.
+	])])
+	USES_MM_CHAT_SECTION="X-MessagingMenu-UsesChatSection=true"
+	AC_SUBST(UNITY_CFLAGS)
+	AC_SUBST(UNITY_LIBS)
+	AC_SUBST(USES_MM_CHAT_SECTION)
+else
+	enable_unity=no
+fi
+AM_CONDITIONAL(ENABLE_UNITY, [test "x$enable_unity" = "xyes"])
+
+dnl #######################################################################
+dnl # Check for Python
+dnl #######################################################################
+
+dnl Python scripts are used to auto-generate about 3000 lines of C
+dnl and XML code that wraps (part of) the existing API so that
+dnl it is now accessible through D-Bus.
+
+dnl Python is only required if --enable-dbus is used, and only for
+dnl the build process to generate the code, not for running pidgin.
+dnl This autogenerated code is system-independent, so in principle we
+dnl can generate all of it before shipping.  But I thought adding
+dnl auto-generated stuff to the repository is inelegant.
+dnl Alternatively, these python scripts could be rewritten
+dnl in C (brrrr ...).
+
+AC_ARG_WITH([python],
+			AC_HELP_STRING([--with-python=PATH],
+						   [which python interpreter to use for dbus code generation]),
+			PYTHON=$withval)
+
+if test "x$enable_dbus" = "xyes" || test "x$enable_consoleui" = "xyes" ; then
+	if test -z "$PYTHON" -o "x$PYTHON" = "xyes"; then
+		AC_PATH_PROG([PYTHON], [python], [no])
+	fi
+
+	if test x"$PYTHON" = x"no" ; then
+		AC_MSG_WARN([python interpreter not found in your path])
+		enable_dbus=no
+	fi
+
+	if $PYTHON -c "import sys; sys.exit(sys.version[[:3]] >= '2.4')" ; then
+		AC_MSG_WARN([python version >= 2.4 required])
+		enable_dbus=no
+	fi
+fi
+
+dnl ###########################################################################
+dnl # Find the D-Bus services dir.
+dnl #
+dnl # This is a 3 step process that
+dnl #
+dnl # 1. checks if --with-dbus-services was set, if so use that.
+dnl # 2. checks if --prefix was given, if so use that.
+dnl # 3. fallbacks to installing into what should be the correct system
+dnl #    directories.
+dnl #
+dnl # This is still prone to error if one of the legacy directories exist
+dnl # although a newer dbus is installed.  But I have tried to order the
+dnl # directory searching to keep this situation at a minimum.
+dnl ###########################################################################
+AC_ARG_WITH(dbus-services, [AC_HELP_STRING([--with-dbus-services=<dir>], [where the D-Bus services directory is located.])])
+
+DBUS_SERVICES_DIR=""
+
+if test x"$enable_dbus" = "xyes" ; then
+	AC_MSG_CHECKING([location of the D-Bus services directory])
+	if ! test -z "$with_dbus_services" ; then
+		if ! test -d "$with_dbus_services" ; then
+			AC_MSG_ERROR([$with_dbus_services does not exist, if this is the correct location please make sure that it exists.])
+		fi
+
+		DBUS_SERVICES_DIR="$with_dbus_services"
+	else
+		if test x"$prefix" = x"NONE" ; then
+			dnl # no prefix given, so we look for the correct dbus system paths.
+			dnl # if a prefix is given, we use it.
+
+			serviceprefixes="$prefix/share $prefix/lib /usr/share /usr/local/share"
+			DBUS_SERVICES_DIR=""
+
+			for d in $serviceprefixes ; do
+				dir="$d/dbus-1/services"
+				if test -d $dir ; then
+					DBUS_SERVICES_DIR="$dir"
+					break
+				fi
+			done
+
+			if test -z $DBUS_SERVICES_DIR ; then
+				AC_MSG_ERROR([D-Bus services directory was not found!  Please use --with-dbus-services and specify its location.])
+			fi
+		else
+			DBUS_SERVICES_DIR="$datadir/dbus-1/services"
+		fi
+	fi
+	AC_MSG_RESULT([$DBUS_SERVICES_DIR])
+	AC_DEFINE(HAVE_DBUS, 1, [Define if we are using D-Bus.])
+fi
+AC_SUBST(DBUS_SERVICES_DIR)
+
+if test "x$enable_dbus" = "xyes" ; then
+	echo "Building with D-Bus support"
+else
+	echo "Building without D-Bus support"
+fi
+
+AM_CONDITIONAL(ENABLE_DBUS, test "x$enable_dbus" = "xyes")
+
+dnl Check for Python headers (currently useful only for libgnt)
+dnl (Thanks to XChat)
+if test "x$enable_consoleui" = "xyes" -a ! -z "$PYTHON" -a x"$PYTHON" != x"no" ; then
+	AC_MSG_CHECKING(for Python compile flags)
+	if test -f ${PYTHON}-config; then
+		PY_CFLAGS=`${PYTHON}-config --includes`
+		PY_LIBS=`${PYTHON}-config --libs`
+		AC_DEFINE(USE_PYTHON, [1], [Define if python headers are available.])
+		AC_MSG_RESULT(ok)
+	else
+		AC_MSG_RESULT([Cannot find ${PYTHON}-config])
+		PY_CFLAGS=""
+		PY_LIBS=""
+	fi
+fi
+AC_SUBST(PY_CFLAGS)
+AC_SUBST(PY_LIBS)
+
+dnl #######################################################################
+dnl # Check for Mono support
+dnl #######################################################################
+AC_ARG_ENABLE(mono, [AC_HELP_STRING([--enable-mono], [compile with Mono runtime support (experimental)])], , enable_mono=no)
+if test x"$enable_mono" = x"yes" ; then
+	PKG_CHECK_MODULES(MONO, mono, [
+		AC_SUBST(MONO_CFLAGS)
+		AC_SUBST(MONO_LIBS)
+		enable_mono=yes
+	], [
+		AC_MSG_RESULT(no)
+		AC_MSG_ERROR([
+Mono development headers not found.
+Use --disable-mono if you do not need Mono support.
+])
+	])
+	if test x"$enable_mono" = x"yes"; then
+		oldLIBS="$LIBS"
+		LIBS="$LIBS $MONO_LIBS"
+		AC_MSG_CHECKING(for libmono)
+		AC_CHECK_FUNCS(mono_jit_init, [], enable_mono=no)
+		LIBS="$oldLIBS"
+
+		oldCPPFLAGS="$CPPFLAGS"
+		CPPFLAGS="$CPPFLAGS $MONO_CFLAGS"
+		AC_CHECK_HEADERS(mono/jit/jit.h, [], enable_mono=no)
+		AC_CHECK_HEADERS(mono/metadata/object.h, [], enable_mono=no)
+		CPPFLAGS="$oldCPPFLAGS"
+
+		AC_DEFINE(ENABLE_MONO, 1, [Define if mono enabled.])
+	fi
+else
+	MONO_CFLAGS=
+	MONO_LIBS=
+	enable_mono=no
+fi
+
+AC_SUBST(MONO_CFLAGS)
+AC_SUBST(MONO_LIBS)
+AM_CONDITIONAL(USE_MONO, test x"$enable_mono" = x"yes")
+
+dnl #######################################################################
+dnl # Check for Perl support
+dnl #######################################################################
+AC_ARG_ENABLE(perl, [AC_HELP_STRING([--disable-perl], [compile without perl scripting])], , enable_perl=yes)
+
+if test "$enable_plugins" = no ; then
+	enable_perl=no
+fi
+looked_for_perl="no"
+if test "$enable_perl" = yes ; then
+	looked_for_perl="yes"
+	AC_PATH_PROG(perlpath, perl)
+	AC_MSG_CHECKING(for Perl compile flags)
+	PERL_CFLAGS=`$perlpath -MExtUtils::Embed -e ccopts 2>/dev/null`
+	if test "_$PERL_CFLAGS" = _ ; then
+		AC_MSG_RESULT([not found, building without perl.])
+		enable_perl=no
+	else
+		PERL_LIBS=`$perlpath -MExtUtils::Embed -e ldopts 2>/dev/null |$sedpath 's/-lgdbm //'`
+		PERL_LIBS=`echo $PERL_LIBS |$sedpath 's/-ldb //'`
+		PERL_LIBS=`echo $PERL_LIBS |$sedpath 's/-lndbm //'`
+		if test "$system" = "Linux"; then
+			PERL_LIBS=`echo $PERL_LIBS |$sedpath 's/-lnsl //'`
+			PERL_LIBS=`echo $PERL_LIBS |$sedpath 's/-lposix //'`
+		fi
+		PERL_LIBS=`echo $PERL_LIBS |$sedpath 's/-lc //'`
+		AC_MSG_RESULT(ok)
+
+		oldLIBS="$LIBS"
+		LIBS="$LIBS $PERL_LIBS"
+		AC_MSG_CHECKING(for libperl)
+		AC_CHECK_FUNCS(perl_run, [], enable_perl=no)
+		LIBS="$oldLIBS"
+
+		oldCPPFLAGS="$CPPFLAGS"
+		CPPFLAGS="$CPPFLAGS $PERL_CFLAGS"
+		AC_CHECK_HEADERS(EXTERN.h)
+		AC_CHECK_HEADERS(perl.h, [], enable_perl=no,
+		[#if HAVE_EXTERN_H
+		 # include <EXTERN.h>
+		 #endif])
+		CPPFLAGS="$oldCPPFLAGS"
+	fi
+fi
+
+if test "$enable_perl" = yes ; then
+	AC_PROG_PERL_MODULES(ExtUtils::MakeMaker, , have_makemaker=no)
+
+	if test "x$have_makemaker" = "xno"; then
+		enable_perl=no
+		PERL_CFLAGS=
+		PERL_LIBS=
+		AM_CONDITIONAL(USE_PERL, false)
+		AC_MSG_WARN(Compiling perl requires ExtUtils::MakeMaker)
+	else
+		AC_DEFINE(HAVE_PERL, [1], [Compile with support for perl])
+		AC_SUBST(PERL_CFLAGS)
+		AC_SUBST(PERL_LIBS)
+		AM_CONDITIONAL(USE_PERL, true)
+
+		dnl This is almost definitely wrong, but in case there's
+		dnl something I'm missing, I'll leave it in.
+		AC_CHECK_FUNCS(Perl_eval_pv)
+
+		AC_MSG_CHECKING(for old perl)
+		PERL_OLD=`$perlpath -e 'if($]<5.006){printf"yes\n";}else{printf"no\n";}'`
+
+		if test "x$PERL_OLD" = "xyes"; then
+			AC_DEFINE(OLD_PERL, 1, [Define if old perl is installed.])
+			AC_MSG_RESULT(yes)
+		else
+			AC_MSG_RESULT(no)
+		fi
+
+		AC_MSG_CHECKING(for DynaLoader.a)
+		DYNALOADER_A=`echo $PERL_LDFLAGS | $perlpath -pe 's/^(.* )*([[^ ]]*DynaLoader\.a).*/\2/'`
+
+		dnl Don't check libperl.a if dynaloader.a wasn't found.
+		if test -n "$DYNALOADER_A"; then
+			AC_MSG_RESULT(yes)
+
+			dnl Find either libperl.a or libperl.so
+			AC_MSG_CHECKING(for libperl.a or libperl.so)
+			LIBPERL_A=`echo "$PERL_LDFLAGS -L/usr/lib"|$perlpath -e 'foreach (split(/ /, <STDIN>)) { if (/^-L(.*)/) { my $dir=$1; if (\`ls $dir/libperl.so* 2>/dev/null\`) { print "-lperl"; last; }; if (-e "$dir/libperl.a") { print "$dir/libperl.a"; last } } };'`
+			if test -z "$LIBPERL_A"; then
+				AC_MSG_RESULT(no)
+				DYNALOADER_A=
+			else
+				AC_MSG_RESULT(yes)
+
+				if test "$LIBPERL_A" = "-lperl"; then
+					LIBPERL_A=
+				fi
+			fi
+
+			PERL_LIBS=`echo $PERL_LIBS | $perlpath -pe 's/^(.* )*[[^ ]]*DynaLoader\.a/\1libperl_dynaloader.la/'`
+
+			if test -n "$LIBPERL_A"; then
+				PERL_LIBS=`echo $PERL_LDFLAGS | $sedpath -e 's/-lperl /libperl_orig.la /' -e 's/-lperl$/libperl_orig.la$/'`
+			fi
+
+			AC_SUBST(DYNALOADER_A)
+			AC_SUBST(LIBPERL_A)
+		else
+			AC_MSG_RESULT(no)
+		fi
+	fi
+else
+	PERL_CFLAGS=
+	PERL_LIBS=
+	AM_CONDITIONAL(USE_PERL, false)
+fi
+
+if test "x$looked_for_perl" = "xyes" -a "x$enable_perl" = "xno" -a "x$force_deps" = "xyes"; then
+	AC_MSG_ERROR([
+Perl development headers not found.
+Use --disable-perl if you do not need Perl scripting support.
+])
+fi
+
+dnl #######################################################################
+dnl # SSL support
+dnl #
+dnl # Thanks go to Evolution for the checks.
+dnl #######################################################################
+
+AC_ARG_WITH(system-ssl-certs, [AC_HELP_STRING([--with-system-ssl-certs=<dir>], [directory containing system-wide SSL CA certificates])], [ssl_certificates_dir=$withval])
+
+SSL_CERTIFICATES_DIR=""
+if ! test -z "$ssl_certificates_dir" ; then
+	if test "x$ssl_certificates_dir" = "xyes" ; then
+		AC_MSG_ERROR([--with-system-ssl-certs requires that a location is specified, eg. --with-system-ssl-certs=/etc/pki/tls/certs])
+	fi
+	if ! test -d "$ssl_certificates_dir" ; then
+		AC_MSG_ERROR([$ssl_certificates_dir does not exist, if this is the correct location please make sure that it exists.])
+	fi
+	SSL_CERTIFICATES_DIR="$ssl_certificates_dir"
+fi
+AC_SUBST(SSL_CERTIFICATES_DIR)
+AM_CONDITIONAL(INSTALL_SSL_CERTIFICATES, test "x$SSL_CERTIFICATES_DIR" = "x")
+
+dnl These two are inverses of each other <-- stolen from evolution!
+
+AC_ARG_ENABLE(gnutls,
+	[  --enable-gnutls=[yes,no]  attempt to use GnuTLS for SSL support [default=yes]],
+	[enable_gnutls="$enableval"],
+	[enable_gnutls="yes"])
+
+AC_ARG_ENABLE(nss,
+	[  --enable-nss=[yes,no,static]    attempt to use Mozilla libnss for SSL support [default=yes]],
+	[enable_nss="$enableval"],
+	[enable_nss="yes"])
+
+msg_ssl="None. MSN, Yahoo!, Novell Groupwise and Google Talk will not work without GnuTLS or NSS. OpenSSL is NOT usable!"
+looked_for_gnutls="no"
+dnl #
+dnl # Check for GnuTLS if it's specified.
+dnl #
+if test "x$enable_gnutls" != "xno"; then
+	enable_gnutls="no"
+	prefix=`eval echo $prefix`
+	looked_for_gnutls="yes"
+
+	AC_ARG_WITH(gnutls-includes,
+		[  --with-gnutls-includes=PREFIX   location of GnuTLS includes.],
+		[ with_gnutls_includes="$withval" ],
+		[ with_gnutls_includes="$prefix/include" ])
+
+	have_gnutls_includes="no"
+
+	if test "x$with_gnutls_includes" != "xno"; then
+		CPPFLAGS_save="$CPPFLAGS"
+
+		AC_MSG_CHECKING(for GnuTLS includes)
+		AC_MSG_RESULT("")
+
+		CPPFLAGS="$CPPFLAGS -I$with_gnutls_includes"
+		AC_CHECK_HEADERS(gnutls/gnutls.h, [ gnutls_includes="yes" ])
+		CPPFLAGS="$CPPFLAGS_save"
+
+		if test "x$gnutls_includes" != "xno" -a \
+		        "x$gnutls_includes" != "x"; then
+			have_gnutls_includes="yes"
+
+			if test "x$with_gnutls_includes" != "xNONE/include"; then
+				GNUTLS_CFLAGS="-I$with_gnutls_includes"
+			fi
+		else
+			GNUTLS_CFLAGS=""
+		fi
+	else
+		AC_MSG_CHECKING(for GnuTLS includes)
+		AC_MSG_RESULT(no)
+	fi
+
+	AC_ARG_WITH(gnutls-libs,
+		[AC_HELP_STRING([--with-gnutls-libs=PREFIX], [location of GnuTLS libraries.])],
+		[ with_gnutls_libs="$withval" ])
+
+	if test "x$with_gnutls_libs"     != "xno" -a \
+	        "x$have_gnutls_includes" != "xno"; then
+
+		LIBS_save="$LIBS"
+
+		case $with_gnutls_libs in
+			""|-L*) ;;
+			*) with_gnutls_libs="-L$with_gnutls_libs" ;;
+		esac
+
+		AC_CACHE_CHECK([for GnuTLS libraries], ac_cv_gnutls_libs,
+		[
+			LIBS="$LIBS $with_gnutls_libs -lgnutls"
+			AC_TRY_LINK_FUNC(gnutls_init, ac_cv_gnutls_libs="yes", ac_cv_gnutls_libs="no")
+			LIBS="$LIBS_save"
+		])
+
+		if test "x$ac_cv_gnutls_libs" != "xno"; then
+			AC_DEFINE(HAVE_GNUTLS, 1, [Define if you have GnuTLS])
+			AC_DEFINE(HAVE_SSL)
+			msg_gnutls="GnuTLS"
+			GNUTLS_LIBS="$with_gnutls_libs -lgnutls"
+
+			enable_gnutls="yes"
+		else
+			GNUTLS_CFLAGS=""
+			GNUTLS_LIBS=""
+		fi
+	else
+		AC_MSG_CHECKING(for GnuTLS libraries)
+		AC_MSG_RESULT(no)
+	fi
+else
+	GNUTLS_CFLAGS=""
+	GNUTLS_LIBS=""
+fi
+
+AC_SUBST(GNUTLS_CFLAGS)
+AC_SUBST(GNUTLS_LIBS)
+
+if test "x$enable_gnutls" = "xyes"; then
+	AC_MSG_CHECKING(for gnutls_priority_set_direct and gnutls_priority_set)
+	LIBS_save="$LIBS"
+	LIBS="$LIBS $GNUTLS_LIBS"
+	CPPFLAGS_save="$CPPFLAGS"
+	CPPFLAGS="$CPPFLAGS $GNUTLS_CFLAGS"
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <gnutls/gnutls.h>]],
+                                        [[gnutls_session s; gnutls_priority_set_direct(s, NULL, NULL); gnutls_priority_set(s, NULL);]])],
+	               [AC_DEFINE([HAVE_GNUTLS_PRIORITY_FUNCS], 1,
+                                  [Define if your gnutls has gnutls_priority_set_direct and friends])
+	                AC_MSG_RESULT(yes)],
+	               [AC_MSG_RESULT(no)])
+	CPPFLAGS="$CPPFLAGS_save"
+        LIBS="$LIBS_save"
+fi
+
+if test "x$enable_gnutls" = "xyes"; then
+	AC_MSG_CHECKING(for GNUTLS_CERT_INSECURE_ALGORITHM)
+	LIBS_save="$LIBS"
+	LIBS="$LIBS $GNUTLS_LIBS"
+	CPPFLAGS_save="$CPPFLAGS"
+	CPPFLAGS="$CPPFLAGS $GNUTLS_CFLAGS"
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <gnutls/gnutls.h>]],
+                                        [[unsigned int verify = GNUTLS_CERT_INSECURE_ALGORITHM;]])],
+	               [AC_DEFINE([HAVE_GNUTLS_CERT_INSECURE_ALGORITHM], 1,
+                                  [Define if your gnutls has the GNUTLS_CERT_INSECURE_ALGORITHM flag])
+	                AC_MSG_RESULT(yes)],
+	               [AC_MSG_RESULT(no)])
+	CPPFLAGS="$CPPFLAGS_save"
+        LIBS="$LIBS_save"
+fi
+
+
+AM_CONDITIONAL(USE_GNUTLS, test "x$enable_gnutls" = "xyes")
+
+
+dnl #
+dnl # Check for NSS if it's specified, or if GnuTLS checks failed.
+dnl #
+looked_for_nss="no"
+if test "x$enable_nss" != "xno"; then
+	looked_for_nss="yes"
+
+	AC_ARG_WITH(nspr-includes,
+		[AC_HELP_STRING([--with-nspr-includes=PREFIX], [specify location of Mozilla nspr4 includes.])],
+		[with_nspr_includes="$withval"])
+
+	AC_ARG_WITH(nspr-libs,
+		[AC_HELP_STRING([--with-nspr-libs=PREFIX], [specify location of Mozilla nspr4 libs.])],
+		[with_nspr_libs="$withval"])
+
+	AC_ARG_WITH(nss-includes,
+		[AC_HELP_STRING([--with-nss-includes=PREFIX], [specify location of Mozilla nss3 includes.])],
+		[with_nss_includes="$withval"])
+
+	AC_ARG_WITH(nss-libs,
+		[AC_HELP_STRING([--with-nss-libs=PREFIX], [specify location of Mozilla nss3 libs.])],
+		[with_nss_libs="$withval"])
+
+
+	if test -n "$with_nspr_includes" || test -n "$with_nspr_libs" || \
+	   test -n "$with_nss_includes"  || test -n "$with_nss_libs"  ||
+	   test "x$enable_nss" = "xstatic"; then
+
+		nss_manual_check="yes"
+	else
+		nss_manual_check="no"
+	fi
+
+	enable_nss="no"
+
+	if test "x$nss_manual_check" = "xno"; then
+		if `$PKG_CONFIG --exists mozilla-nss`; then
+			PKG_CHECK_MODULES(NSS, mozilla-nss, [
+				have_nss="yes"
+			], [
+				AC_MSG_RESULT(no)
+				have_nss="no"
+			])
+			mozilla_nspr="mozilla-nspr"
+			mozilla_nss="mozilla-nss"
+		elif `$PKG_CONFIG --exists nss`; then
+			PKG_CHECK_MODULES(NSS, nss, [
+				have_nss="yes"
+			], [
+				AC_MSG_RESULT(no)
+				have_nss="no"
+			])
+			mozilla_nspr="nspr"
+			mozilla_nss="nss"
+		elif `$PKG_CONFIG --exists microb-engine-nss`; then
+			PKG_CHECK_MODULES(NSS, microb-engine-nss, [
+				have_nss="yes"
+			], [
+				AC_MSG_RESULT(no)
+				have_nss="no"
+			])
+			mozilla_nspr="mozilla-nspr"
+			mozilla_nss="microb-engine-nss"
+		fi
+
+		if test "x$have_nss" = "xyes"; then
+
+			AC_DEFINE(HAVE_NSS, 1, [Define if you have Mozilla NSS])
+			AC_DEFINE(HAVE_SSL, 1, [Define if you have SSL])
+
+			msg_nss="Mozilla NSS"
+			enable_nss="yes"
+		else
+			nss_manual_check="yes"
+		fi
+	fi
+
+	if test "x$nss_manual_check" = "xyes"; then
+		mozilla_nss=""
+		have_nspr_includes="no"
+
+		if test "x$with_nspr_includes" != "xno"; then
+			CPPFLAGS_save=$CPPFLAGS
+
+			AC_MSG_CHECKING(for Mozilla nspr4 includes in $with_nspr_includes)
+			AC_MSG_RESULT("")
+
+			CPPFLAGS="$CPPFLAGS -I$with_nspr_includes"
+			AC_CHECK_HEADERS(nspr.h prio.h, [ moz_nspr_includes="yes" ])
+			CPPFLAGS=$CPPFLAGS_save
+
+			if test "x$moz_nspr_includes" != "xno" -a \
+			        "x$moz_nspr_includes" != "x"; then
+
+				have_nspr_includes="yes"
+				NSPR_CFLAGS="-I$with_nspr_includes"
+			fi
+		else
+			AC_MSG_CHECKING(for Mozilla nspr4 includes)
+			AC_MSG_RESULT(no)
+
+			enable_nss="no"
+		fi
+
+		have_nspr_libs="no"
+
+		if test "x$with_nspr_libs"     != "xno" -a \
+		        "x$have_nspr_includes" != "xno"; then
+
+			CFLAGS_save=$CFLAGS
+			LDFLAGS_save=$LDFLAGS
+
+			if test "$enable_nss" = "static"; then
+				if test -z "$with_nspr_libs"; then
+					AC_MSG_ERROR(
+						[Static linkage requested, but path to nspr libraries not set.]
+						[Please specify the path to libnspr4.a]
+						[Example: --with-nspr-libs=/usr/lib])
+
+					enable_nss="no"
+				else
+					nsprlibs="$LIBDL $with_nspr_libs/libplc4.a $with_nspr_libs/libplds4.a $with_nspr_libs/libnspr4.a $PTHREAD_LIB"
+				fi
+			else
+				nsprlibs="$LIBDL -lplc4 -lplds4 -lnspr4 $PTHREAD_LIB"
+			fi
+
+			AC_CACHE_CHECK([for Mozilla nspr libraries], ac_cv_moz_nspr_libs,
+			[
+				LIBS_save=$LIBS
+				CFLAGS="$CFLAGS $NSPR_CFLAGS"
+
+				LIBS="$nsprlibs"
+
+				if test "x$with_nspr_libs" != "x"; then
+					LDFLAGS="$LDFLAGS -L$with_nspr_libs"
+				else
+					LDFLAGS="$LDFLAGS"
+				fi
+
+				AC_TRY_LINK_FUNC(PR_Init,
+					[ac_cv_moz_nspr_libs="yes"],
+					[ac_cv_moz_nspr_libs="no"])
+
+				CFLAGS=$CFLAGS_save
+				LDFLAGS=$LDFLAGS_save
+				LIBS=$LIBS_save
+			])
+
+			if test "x$ac_cv_moz_nspr_libs" != "xno"; then
+				have_nspr_libs="yes"
+				NSPR_LIBS="-L$with_nspr_libs $nsprlibs"
+			else
+				NSPR_CFLAGS=""
+				enable_nss="no"
+			fi
+		else
+			AC_MSG_CHECKING(for Mozilla nspr4 libraries)
+			AC_MSG_RESULT(no)
+		fi
+
+		have_nss_includes="no"
+
+		if test "x$with_nss_includes" != "xno" -a \
+				"x$have_nspr_libs"    != "xno"; then
+
+			CPPFLAGS_save=$CPPFLAGS
+
+			AC_MSG_CHECKING(for Mozilla nss3 includes in $with_nss_includes)
+			AC_MSG_RESULT("")
+
+			if test "x$with_nspr_includes" != "x"; then
+				CPPFLAGS="$CPPFLAGS -I$with_nspr_includes -I$with_nss_includes"
+			else
+				CPPFLAGS="$CPPFLAGS -I$with_nss_includes"
+			fi
+
+			AC_CHECK_HEADERS(nss.h ssl.h smime.h,
+				[moz_nss_includes="yes"],
+				[moz_nss_includes="no"])
+
+			CPPFLAGS=$CPPFLAGS_save
+
+			if test "x$moz_nss_includes" = "xyes"; then
+				have_nss_includes="yes"
+				NSS_CFLAGS="-I$with_nss_includes"
+			else
+				NSPR_CFLAGS=""
+				NSPR_LIBS=""
+				enable_nss="no"
+			fi
+		else
+			AC_MSG_CHECKING(for Mozilla nss3 includes)
+			AC_MSG_RESULT(no)
+			enable_nss="no"
+		fi
+
+		if test "x$with_nss_libs"     != "xno" -a \
+				"x$have_nss_includes" != "xno"; then
+
+			LDFLAGS_save=$LDFLAGS
+
+			if test "$enable_nss" = "static"; then
+				if test -z "$with_nss_libs"; then
+					AC_MSG_ERROR(
+						[Static linkage requested, but path to nss libraries not set.]
+						[Please specify the path to libnss3.a]
+						[Example: --with-nspr-libs=/usr/lib/mozilla])
+					enable_nss="no"
+				else
+					nsslibs="-ldb1 $with_nss_libs/libnssckfw.a $with_nss_libs/libasn1.a $with_nss_libs/libcrmf.a $with_nss_libs/libswfci.a $with_nss_libs/libjar.a $with_nss_libs/libpkcs12.a $with_nss_libs/libpkcs7.a $with_nss_libs/libpki1.a $with_nss_libs/libsmime.a $with_nss_libs/libssl.a $with_nss_libs/libnss.a $with_nss_libs/libpk11wrap.a $with_nss_libs/libsoftokn.a $with_nss_libs/libfreebl.a $with_nss_libs/libnsspki.a $with_nss_libs/libnssdev.a $with_nss_libs/libcryptohi.a $with_nss_libs/libcerthi.a $with_nss_libs/libcertdb.a $with_nss_libs/libsecutil.a $with_nss_libs/libnssb.a"
+
+					case "$host" in
+						*solaris*)
+							nsslibs="$nsslibs $with_nss_libs/libfreeb1.a"
+							;;
+					esac
+				fi
+			else
+				nsslibs="-lssl3 -lsmime3 -lnss3 -lsoftokn3"
+			fi
+
+			AC_CACHE_CHECK([for Mozilla nss libraries], ac_cv_moz_nss_libs,
+			[
+				LIBS_save=$LIBS
+				LDFLAGS="$LDFLAGS -L$with_nspr_libs -L$with_nss_libs"
+				LIBS="$nsslibs $nsprlibs"
+
+				AC_TRY_LINK_FUNC(NSS_Init,
+					[ac_cv_moz_nss_libs="yes"],
+					[ac_cv_moz_nss_libs="no"])
+
+				if test "x$ac_cv_moz_nss_libs" = "xno"; then
+					nsslibs="-lssl3 -lsmime3 -lnss3 -lsoftokn3"
+					LDFLAGS="$LDFLAGS -L$with_nspr_libs -L$with_nss_libs"
+					LIBS="$LIBS $nsslibs"
+					AC_TRY_LINK_FUNC(NSS_Init,
+						[ac_cv_moz_nss_libs="yes"],
+						[ac_cv_moz_nss_libs="no"])
+				fi
+
+				LDFLAGS=$LDFLAGS_save
+				LIBS=$LIBS_save
+			])
+
+			if test "x$ac_cv_moz_nss_libs" != "xno"; then
+				AC_DEFINE(HAVE_NSS)
+				AC_DEFINE(HAVE_SSL)
+
+				NSS_LIBS="-L$with_nss_libs $nsslibs"
+
+				if test "$enable_nss" = "static"; then
+					msg_nss="Mozilla NSS (static)"
+				else
+					msg_nss="Mozilla NSS"
+				fi
+
+				enable_nss="yes"
+			else
+				NSS_CFLAGS=""
+				NSPR_CFLAGS=""
+				NSPR_LIBS=""
+				enable_nss="no"
+			fi
+		else
+			AC_MSG_CHECKING(for Mozilla nss libraries)
+			AC_MSG_RESULT(no)
+		fi
+
+		NSS_CFLAGS="$NSPR_CFLAGS $NSS_CFLAGS"
+		NSS_LIBS="$NSPR_LIBS $NSS_LIBS"
+	fi
+
+	AC_SUBST(NSS_CFLAGS)
+	AC_SUBST(NSS_LIBS)
+fi
+
+AM_CONDITIONAL(USE_NSS, test "x$enable_nss" = "xyes")
+
+if test "x$msg_nss" != "x" -a "x$msg_gnutls" != "x"; then
+	msg_ssl="$msg_nss and $msg_gnutls"
+elif test "x$msg_nss" != "x"; then
+	msg_ssl=$msg_nss
+elif test "x$msg_gnutls" != "x"; then
+	msg_ssl=$msg_gnutls
+elif test "x$looked_for_gnutls" = "xyes" -a "x$looked_for_nss" = "xyes" -a "x$force_deps" = "xyes" ; then
+	AC_MSG_ERROR([
+Neither GnuTLS or NSS SSL development headers found.
+Use --disable-nss --disable-gnutls if you do not need SSL support.
+MSN, Yahoo!, Novell Groupwise and Google Talk will not work without GnuTLS or NSS. OpenSSL is NOT usable!
+])
+elif test "x$looked_for_gnutls" = "xyes" -a "x$force_deps" = "xyes" ; then
+	AC_MSG_ERROR([
+GnuTLS SSL development headers not found.
+Use --disable-gnutls if you do not need SSL support.
+MSN, Yahoo!, Novell Groupwise and Google Talk will not work without SSL support.
+])
+elif test "x$looked_for_nss" = "xyes" -a "x$force_deps" = "xyes" ; then
+	AC_MSG_ERROR([
+NSS SSL development headers not found.
+Use --disable-nss if you do not need SSL support.
+MSN, Yahoo!, Novell Groupwise and Google Talk will not work without SSL support.
+])
+fi
+
+dnl #######################################################################
+dnl # Check for Tcl
+dnl #######################################################################
+AC_ARG_ENABLE(tcl, [AC_HELP_STRING([--disable-tcl],
+	[compile without Tcl scripting])], enable_tcl="$enableval", enable_tcl="yes")
+AC_ARG_WITH(tclconfig, [AC_HELP_STRING([--with-tclconfig=DIR],
+	[directory containing tclConfig.sh])])
+
+if test "$enable_plugins" = no; then
+	enable_tcl=no
+fi
+
+if test "$enable_tcl" = yes; then
+	AC_MSG_CHECKING([for tclConfig.sh])
+	TCLCONFIG=no
+	TCLCONFIGDIRS="/usr/lib \
+			/usr/lib64 \
+			/usr/lib/tcl8.5 \
+			/usr/lib/tcl8.4 \
+			/usr/lib/tcl8.3 \
+			/usr/lib/tcl8.2 \
+			/usr/lib64/tcl8.5 \
+			/usr/lib64/tcl8.4 \
+			/System/Library/Tcl/8.3 \
+			/usr/local/lib"
+	for dir in $with_tclconfig $TCLCONFIGDIRS; do
+		if test -f $dir/tclConfig.sh; then
+			TCLCONFIG=$dir/tclConfig.sh
+			AC_MSG_RESULT([yes ($TCLCONFIG)])
+			break
+		fi
+	done
+	if test "$TCLCONFIG" = "no"; then
+		AC_MSG_RESULT([no])
+		enable_tcl=no
+		if test "x$force_deps" = "xyes" ; then
+			AC_MSG_ERROR([
+Tcl development headers not found.
+Use --disable-tcl if you do not need Tcl scripting support.
+])
+		fi
+	else
+		. $TCLCONFIG
+		AC_MSG_CHECKING([Tcl version compatability])
+		if test "$TCL_MAJOR_VERSION" -ne 8 -o "$TCL_MINOR_VERSION" -lt 3; then
+			AC_MSG_RESULT([bad, $TCL_VERSION found but 8.3 or later required])
+			enable_tcl=no
+		else
+			AC_MSG_RESULT([ok, $TCL_VERSION])
+			eval "TCL_LIB_SPEC=\"$TCL_LIB_SPEC\""
+			AC_MSG_CHECKING([for Tcl linkability])
+			oldCPPFLAGS=$CPPFLAGS
+			CPPFLAGS="$CPPFLAGS $TCL_INCLUDE_SPEC -I$TCL_PREFIX/include"
+			oldLIBS=$LIBS
+			LIBS="$LIBS $TCL_LIB_SPEC"
+			AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <tcl.h>]],
+				[[Tcl_Interp *interp=NULL; Tcl_Init(interp)]])],
+				[AC_MSG_RESULT([yes]);enable_tcl=yes],
+				[AC_MSG_RESULT([no]);enable_tcl=no])
+			CPPFLAGS="$oldCPPFLAGS"
+			LIBS="$oldLIBS"
+		fi
+	fi
+fi
+
+if test "$enable_tcl" = yes; then
+	AM_CONDITIONAL(USE_TCL, true)
+	TCL_LIBS=$TCL_LIB_SPEC
+	AC_DEFINE(HAVE_TCL, [1], [Compile with support for the Tcl toolkit])
+	AC_SUBST(TCL_LIBS)
+	TCL_CFLAGS="$TCL_INCLUDE_SPEC -I$TCL_PREFIX/include"
+	if test "x$GCC" = "xyes"; then
+		TCL_CFLAGS="$TCL_CFLAGS -fno-strict-aliasing"
+	fi
+	AC_SUBST(TCL_CFLAGS)
+else
+	AM_CONDITIONAL(USE_TCL, false)
+fi
+
+dnl #######################################################################
+dnl # Check for Tk
+dnl #######################################################################
+AC_ARG_ENABLE(tk, [AC_HELP_STRING([--disable-tk],
+	[compile without Tcl support for Tk])], enable_tk="$enableval", enable_tk="yes")
+AC_ARG_WITH(tkconfig, [AC_HELP_STRING([--with-tkconfig=DIR],
+	[directory containing tkConfig.sh])])
+
+if test "$enable_tcl" = yes -a "$enable_tk" = yes; then
+	AC_MSG_CHECKING([for tkConfig.sh])
+	TKCONFIG=no
+	TKCONFIGDIRS="/usr/lib \
+			/usr/lib64 \
+			/usr/lib/tk8.5 \
+			/usr/lib/tk8.4 \
+			/usr/lib/tk8.3 \
+			/usr/lib/tk8.2 \
+			/usr/local/lib"
+	for dir in $with_tkconfig $TKCONFIGDIRS; do
+		if test -f $dir/tkConfig.sh; then
+			TKCONFIG=$dir/tkConfig.sh
+			AC_MSG_RESULT([yes ($TKCONFIG)])
+			break
+		fi
+	done
+	if test "$TKCONFIG" = "no"; then
+		AC_MSG_RESULT([no])
+		enable_tk=no
+		if test "x$force_deps" = "xyes" ; then
+			AC_MSG_ERROR([
+Tk development headers not found.
+Use --disable-tk if you do not need Tk scripting support.
+])
+		fi
+	else
+		. $TKCONFIG
+		eval "TK_LIB_SPEC=\"$TK_LIB_SPEC\""
+		AC_MSG_CHECKING([for Tk linkability])
+		oldCPPFLAGS=$CPPFLAGS
+		CPPFLAGS="$CPPFLAGS $TCL_CFLAGS"
+		oldLIBS=$LIBS
+		LIBS="$LIBS $TCL_LIB_SPEC $TK_LIB_SPEC"
+		AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <tk.h>]],
+				[[Tcl_Interp *interp=NULL; Tcl_Init(interp); Tk_Init(interp);]])],
+				[AC_MSG_RESULT([yes]);enable_tk=yes],
+				[AC_MSG_RESULT([no]);enable_tk=no])
+		CPPFLAGS="$oldCPPFLAGS"
+		LIBS="$oldLIBS"
+	fi
+else
+	enable_tk=no
+fi
+
+if test "$enable_tk" = yes; then
+	AM_CONDITIONAL(USE_TK, true)
+	AC_DEFINE(HAVE_TK, [1], [Compile with support for the Tk toolkit])
+	TK_LIBS=$TK_LIB_SPEC
+	AC_SUBST(TK_LIBS)
+else
+	AM_CONDITIONAL(USE_TK, false)
+fi
+
+if test "$ac_cv_cygwin" = yes ; then
+	LDADD="$LDADD -static"
+	AC_DEFINE(DEBUG, 1, [Define if debugging is enabled.])
+fi
+
+AC_SUBST(DEBUG_CFLAGS)
+AC_SUBST(LDADD)
+AC_SUBST(LIBS)
+
+if test "x$enable_plugins" = "xyes" ; then
+	AC_DEFINE(PURPLE_PLUGINS, 1, [Define if plugins are enabled.])
+	AM_CONDITIONAL(PLUGINS, true)
+	PLUGINS_DEFINE="#define PURPLE_PLUGINS 1"
+else
+	AM_CONDITIONAL(PLUGINS, false)
+	PLUGINS_DEFINE="#undef PURPLE_PLUGINS"
+fi
+AC_SUBST(PLUGINS_DEFINE)
+
+dnl #######################################################################
+dnl # Check for Cyrus-SASL (for xmpp/irc)
+dnl #######################################################################
+dnl AC_CHECK_SIZEOF(short)
+AC_CHECK_FUNCS(snprintf connect)
+AC_SUBST(SASL_LIBS)
+AC_ARG_ENABLE(cyrus-sasl, AC_HELP_STRING([--enable-cyrus-sasl], [enable Cyrus SASL support for xmpp/irc]), enable_cyrus_sasl=$enableval, enable_cyrus_sasl=no)
+if test "x$enable_cyrus_sasl" = "xyes" ; then
+	AC_CHECK_LIB(sasl2, sasl_client_init, [
+			AM_CONDITIONAL(USE_CYRUS_SASL, true)
+			AC_DEFINE(HAVE_CYRUS_SASL, [1], [Define to 1 if Cyrus SASL is present])
+			SASL_LIBS=-"lsasl2"
+		], [
+			AM_CONDITIONAL(USE_CYRUS_SASL, false)
+			AC_MSG_ERROR([Cyrus SASL library not found])
+		])
+else
+	AM_CONDITIONAL(USE_CYRUS_SASL, false)
+fi
+
+dnl #######################################################################
+dnl # Check for Kerberos (for Zephyr)
+dnl #######################################################################
+AC_DEFINE(ZEPHYR_INT32, long, [Size of an int32.])
+AC_SUBST(KRB4_CFLAGS)
+AC_SUBST(KRB4_LDFLAGS)
+AC_SUBST(KRB4_LIBS)
+if test "$kerberos" != "no" ; then
+	if test "$kerberos" != "yes" ; then
+		KRB4_CFLAGS="-I${kerberos}/include"
+		if test -d "$kerberos/include/kerberosIV" ; then
+			KRB4_CFLAGS="$KRB4_CFLAGS -I${kerberos}/include/kerberosIV"
+		fi
+		KRB4_LDFLAGS="-L${kerberos}/lib"
+	elif test -d /usr/local/include/kerberosIV ; then
+		KRB4_CFLAGS="-I/usr/local/include/kerberosIV"
+	elif test -d /usr/include/kerberosIV ; then
+		KRB4_CFLAGS="-I/usr/include/kerberosIV"
+	fi
+	AC_DEFINE(ZEPHYR_USES_KERBEROS, 1, [Define if kerberos should be used in Zephyr.])
+
+	orig_LDFLAGS="$LDFLAGS"
+	LDFLAGS="$LDFLAGS $KRB4_LDFLAGS"
+	AC_CHECK_LIB(krb4, krb_rd_req,
+			[KRB4_LIBS="-lkrb4 -ldes425 -lkrb5 -lk5crypto -lcom_err"],
+			[AC_CHECK_LIB(krb, krb_rd_req,
+				[KRB4_LIBS="-lkrb -ldes"],
+				[AC_MSG_ERROR([Kerberos 4 libraries not found])],
+				-ldes)],
+			-ldes425 -lkrb5 -lk5crypto -lcom_err)
+	orig_LIBS="$LIBS"
+	LIBS="$LIBS $KRB4_LIBS"
+	AC_CHECK_FUNCS(krb_set_key krb_rd_req krb_get_lrealm)
+	AC_CHECK_FUNCS(krb_get_err_text krb_log)
+	LIBS="$orig_LIBS"
+	LDFLAGS="$orig_LDFLAGS"
+fi
+
+dnl #######################################################################
+dnl # Check for external libzephyr
+dnl #######################################################################
+AC_SUBST(ZEPHYR_CFLAGS)
+AC_SUBST(ZEPHYR_LDFLAGS)
+AC_SUBST(ZEPHYR_LIBS)
+if test "$zephyr" != "no" ; then
+	if test "$zephyr" != "yes" ; then
+		ZEPHYR_CFLAGS="-I${zephyr}/include"
+		ZEPHYR_LDFLAGS="-L${zephyr}/lib"
+	elif test -d /usr/athena/include/zephyr ; then
+		ZEPHYR_CFLAGS="-I/usr/athena/include"
+	elif test -d /usr/include/zephyr ; then
+		ZEPHYR_CFLAGS="-I/usr/include"
+	elif test -d /usr/local/include/zephyr ; then
+		ZEPHYR_CFLAGS="-I/usr/local/include"
+	fi
+	AC_DEFINE(LIBZEPHYR_EXT, 1 , [Define if external libzephyr should be used.])
+	AM_CONDITIONAL(EXTERNAL_LIBZEPHYR, test "x$zephyr" != "xno")
+	orig_LDFLAGS="$LDFLAGS"
+	LDFLAGS="$LDFLAGS $ZEPHYR_LDFLAGS"
+	AC_CHECK_LIB(zephyr, ZInitialize,
+		[ZEPHYR_LIBS="-lzephyr"],
+		[AC_MSG_ERROR([Zephyr libraries not found])],
+		-lzephyr)
+	orig_LIBS="$LIBS"
+	LIBS="$orig_LIBS"
+	LDFLAGS="$orig_LDFLAGS"
+fi
+
+AC_MSG_CHECKING(for me pot o' gold)
+AC_MSG_RESULT(no)
+AC_CHECK_FUNCS(gethostid lrand48 timegm)
+AC_CHECK_FUNCS(memcpy memmove random strchr strerror vprintf)
+AC_CHECK_HEADERS(malloc.h paths.h sgtty.h stdarg.h sys/cdefs.h)
+AC_CHECK_HEADERS(sys/file.h sys/filio.h sys/ioctl.h sys/msgbuf.h)
+AC_CHECK_HEADERS(sys/select.h sys/uio.h sys/utsname.h sys/wait.h)
+AC_CHECK_HEADERS(termios.h)
+
+# sys/sysctl.h on OpenBSD 4.2 requires sys/param.h
+# sys/sysctl.h on FreeBSD requires sys/types.h
+AC_CHECK_HEADERS(sys/param.h)
+AC_CHECK_HEADERS(sys/sysctl.h, [], [],
+	[[
+		#include <sys/types.h>
+		#ifdef HAVE_PARAM_H
+		# include <sys/param.h>
+		#endif
+	]])
+
+AC_CHECK_HEADERS(sys/socket.h)
+AC_VAR_TIMEZONE_EXTERNALS
+
+AC_CACHE_CHECK(for tm_gmtoff in struct tm, ac_cv_struct_tm_gmtoff,
+        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+                #include <time.h>
+        ]], [[
+                struct tm tm;
+                tm.tm_gmtoff = 1;
+        ]])], [ac_cv_struct_tm_gmtoff=yes], [ac_cv_struct_tm_gmtoff=no]))
+if test $ac_cv_struct_tm_gmtoff = yes; then
+        AC_DEFINE(HAVE_TM_GMTOFF, 1, [Define if you have a tm_gmtoff member in struct tm])
+fi
+
+AC_CACHE_CHECK([whether va_lists can be copied by value], ac_cv_va_val_copy,[
+	AC_RUN_IFELSE([AC_LANG_SOURCE([[#include <stdarg.h>
+#include <stdlib.h>
+	void f (int i, ...) {
+	va_list args1, args2;
+	va_start (args1, i);
+	args2 = args1;
+	if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+	  exit (1);
+	va_end (args1); va_end (args2);
+	}
+	int main() {
+	  f (0, 42);
+	  return 0;
+	}]])],
+	[ac_cv_va_val_copy=yes],
+	[ac_cv_va_val_copy=no],
+	[ac_cv_va_val_copy=yes])
+])
+
+if test "x$ac_cv_va_val_copy" = "xno"; then
+	AC_DEFINE(VA_COPY_AS_ARRAY, 1, ['va_lists' cannot be copied as values])
+fi
+
+dnl #######################################################################
+dnl # Check for check
+dnl #######################################################################
+PKG_CHECK_MODULES(CHECK, [check >= 0.9.4], , [AC_MSG_RESULT([no, testing is disabled])])
+AM_CONDITIONAL(HAVE_CHECK, [test "x$CHECK_LIBS" != "x"])
+AC_SUBST(CHECK_CFLAGS)
+AC_SUBST(CHECK_LIBS)
+
+dnl #######################################################################
+dnl # Disable pixmap installation
+dnl #######################################################################
+AC_ARG_ENABLE(pixmaps-install, AC_HELP_STRING([--disable-pixmaps-install], [disable installation of pixmap files - Pidgin still needs them!]), enable_pixmaps="$enableval", enable_pixmaps=yes)
+
+AM_CONDITIONAL(INSTALL_PIXMAPS, test "x$enable_pixmaps" = "xyes")
+
+dnl #######################################################################
+dnl # Tweak status tray icon installation directory
+dnl #######################################################################
+AC_ARG_ENABLE(trayicon-compat, AC_HELP_STRING([--enable-trayicon-compat], [install tray icons in location compatible with older releases of hicolor-icon-theme]), enable_traycompat="$enableval", enable_traycompat=no)
+
+AM_CONDITIONAL(ENABLE_TRAYCOMPAT, test "x$enable_traycompat" = "xyes")
+
+dnl #######################################################################
+dnl # Check for Doxygen and dot (part of GraphViz)
+dnl #######################################################################
+AC_ARG_ENABLE(doxygen,
+	[AC_HELP_STRING([--disable-doxygen],
+		[disable documentation with doxygen])],
+	enable_doxygen="$enableval", enable_doxygen="yes")
+AC_ARG_ENABLE(dot,
+	[AC_HELP_STRING([--disable-dot],
+		[disable graphs in doxygen via 'dot'])],
+	enable_dot="$enableval", enable_dot="yes")
+AC_ARG_ENABLE(devhelp,
+	[AC_HELP_STRING([--disable-devhelp],
+		[disable building index for devhelp documentation browser])],
+	enable_devhelp="$enableval", enable_devhelp="yes")
+
+if test "x$enable_doxygen" = xyes; then
+	AC_CHECK_PROG(DOXYGEN, doxygen, true, false)
+	if test $DOXYGEN = false; then
+		AC_MSG_WARN([*** Doxygen not found, docs will not be available])
+		enable_doxygen="no"
+	else
+		AC_DEFINE_UNQUOTED(HAVE_DOXYGEN, 1, [whether or not we have doxygen])
+
+		if test "x$enable_dot" = "xyes"; then
+			AC_CHECK_PROG(DOT, dot, true, false)
+
+			if test $DOT = false; then
+				enable_dot="no";
+				AC_MSG_WARN([*** GraphViz dot not found, docs will not have graphs])
+			else
+				AC_DEFINE_UNQUOTED(HAVE_DOT, 1, [whether or not we have dot])
+			fi
+		fi
+
+		if test "x$enable_devhelp" = "xyes"; then
+			AC_CHECK_PROG(XSLTPROC, xsltproc, true, false)
+
+			if test $XSLTPROC = false; then
+				enable_devhelp="no";
+				AC_MSG_WARN([*** xsltproc not found; devhelp index will not be created])
+			else
+				AC_DEFINE_UNQUOTED(HAVE_XSLTPROC, 1, [whether or not we have xsltproc for devhelp index])
+			fi
+		fi
+	fi
+else
+	enable_dot="no"
+	enable_devhelp="no"
+fi
+
+AC_SUBST(enable_doxygen)
+AC_SUBST(enable_dot)
+AC_SUBST(enable_devhelp)
+AM_CONDITIONAL(HAVE_DOXYGEN, test "x$enable_doxygen" = "xyes")
+AM_CONDITIONAL(HAVE_XSLTPROC, test "x$enable_devhelp" = "xyes")
+
+AC_ARG_ENABLE(debug, [AC_HELP_STRING([--enable-debug],
+	[compile with debugging support])], , enable_debug=no)
+
+if test "x$enable_debug" = "xyes" ; then
+	AC_DEFINE(DEBUG, 1, [Define if debugging is enabled.])
+fi
+
+AM_CONDITIONAL(PURPLE_AVAILABLE, true)
+
+AC_CONFIG_FILES([Makefile
+		   Doxyfile
+		   doc/Makefile
+		   doc/pidgin.1
+		   doc/finch.1
+		   m4macros/Makefile
+		   pidgin.apspec
+		   pidgin/Makefile
+		   pidgin/data/pidgin.desktop.in
+		   pidgin/data/pidgin.pc
+		   pidgin/data/pidgin-uninstalled.pc
+		   pidgin/data/pidgin-2.pc
+		   pidgin/data/pidgin-2-uninstalled.pc
+		   pidgin/pixmaps/Makefile
+		   pidgin/pixmaps/emotes/default/24/Makefile
+		   pidgin/pixmaps/emotes/none/Makefile
+		   pidgin/pixmaps/emotes/small/16/Makefile
+		   pidgin/plugins/Makefile
+		   pidgin/plugins/cap/Makefile
+		   pidgin/plugins/disco/Makefile
+		   pidgin/plugins/gestures/Makefile
+		   pidgin/plugins/gevolution/Makefile
+		   pidgin/plugins/musicmessaging/Makefile
+		   pidgin/plugins/perl/Makefile
+		   pidgin/plugins/perl/common/Makefile.PL
+		   pidgin/plugins/ticker/Makefile
+		   libpurple/data/gconf/Makefile
+		   libpurple/data/purple.pc
+		   libpurple/data/purple-uninstalled.pc
+		   libpurple/data/purple-2.pc
+		   libpurple/data/purple-2-uninstalled.pc
+		   libpurple/ciphers/Makefile
+		   libpurple/example/Makefile
+		   libpurple/plugins/Makefile
+		   libpurple/plugins/mono/Makefile
+		   libpurple/plugins/mono/api/Makefile
+		   libpurple/plugins/mono/loader/Makefile
+		   libpurple/plugins/perl/Makefile
+		   libpurple/plugins/perl/common/Makefile.PL
+		   libpurple/plugins/ssl/Makefile
+		   libpurple/plugins/tcl/Makefile
+		   libpurple/Makefile
+		   libpurple/protocols/Makefile
+		   libpurple/protocols/bonjour/Makefile
+		   libpurple/protocols/gg/Makefile
+		   libpurple/protocols/irc/Makefile
+		   libpurple/protocols/jabber/Makefile
+		   libpurple/protocols/msn/Makefile
+		   libpurple/protocols/myspace/Makefile
+		   libpurple/protocols/mxit/Makefile
+		   libpurple/protocols/novell/Makefile
+		   libpurple/protocols/null/Makefile
+		   libpurple/protocols/oscar/Makefile
+		   libpurple/protocols/sametime/Makefile
+		   libpurple/protocols/silc/Makefile
+		   libpurple/protocols/silc10/Makefile
+		   libpurple/protocols/simple/Makefile
+		   libpurple/protocols/yahoo/Makefile
+		   libpurple/protocols/zephyr/Makefile
+		   libpurple/tests/Makefile
+		   libpurple/purple.h
+		   libpurple/version.h
+		   share/sounds/Makefile
+		   share/ca-certs/Makefile
+		   finch/finch.pc
+		   finch/Makefile
+		   finch/libgnt/Makefile
+		   finch/libgnt/gnt.pc
+		   finch/libgnt/wms/Makefile
+		   finch/plugins/Makefile
+		   po/Makefile.in
+		   pidgin.spec
+		  ])
+AC_OUTPUT
+
+echo
+echo $PACKAGE $VERSION
+
+echo
+echo Build GTK+ 2.x UI............. : $enable_gtkui
+echo Build console UI.............. : $enable_consoleui
+echo Build for X11................. : $with_x
+echo
+echo Enable Gestures............... : $enable_gestures
+echo Protocols to build dynamically : $DYNAMIC_PRPLS
+echo Protocols to link statically.. : $STATIC_PRPLS
+echo
+echo Build with GStreamer support.. : $enable_gst
+echo Build with D-Bus support...... : $enable_dbus
+echo Build with voice and video.... : $enable_vv
+if test "x$enable_dbus" = "xyes" ; then
+	eval eval echo D-Bus services directory...... : $DBUS_SERVICES_DIR
+fi
+echo Build with GNU Libidn......... : $enable_idn
+echo Build with NetworkManager..... : $enable_nm
+echo SSL Library/Libraries......... : $msg_ssl
+if test "x$SSL_CERTIFICATES_DIR" != "x" ; then
+	eval eval echo SSL CA certificates directory. : $SSL_CERTIFICATES_DIR
+fi
+echo Build with Cyrus SASL support. : $enable_cyrus_sasl
+echo Use kerberos 4 with zephyr.... : $kerberos
+echo Use external libzephyr........ : $zephyr
+echo Use external libgadu.......... : $have_libgadu
+echo Install pixmaps............... : $enable_pixmaps
+echo Old tray icon compatibility... : $enable_traycompat
+echo Install translations.......... : $enable_i18n
+echo Has you....................... : yes
+echo
+echo Use XScreenSaver Extension.... : $enable_screensaver
+echo Use X Session Management...... : $enable_sm
+echo Use startup notification...... : $enable_startup_notification
+echo Build with GtkSpell support... : $enable_gtkspell
+echo Build Unity integration plugin.: $enable_unity
+echo
+echo Build with plugin support..... : $enable_plugins
+echo Build with Mono support....... : $enable_mono
+echo Build with Perl support....... : $enable_perl
+echo Build with Tcl support........ : $enable_tcl
+echo Build with Tk support......... : $enable_tk
+echo
+echo Print debugging messages...... : $enable_debug
+echo
+eval eval echo Pidgin will be installed in $bindir.
+if test "x$pidginpath" != "x" ; then
+	echo Warning: You have an old copy of Pidgin at $pidginpath.
+fi
+if test "x$enable_pixmaps" = "xno" ; then
+	echo
+	echo Warning: You have disabled the installation of pixmap data, but Pidgin
+	echo still requires installed pixmaps.  Be sure you know what you are doing.
+fi
+if test "x$enable_i18n" = "xno" ; then
+	echo
+	echo Warning: You have disabled the building and installation of translation
+	echo data.  This will prevent building pidgin.desktop and the GConf schemas.
+	echo Be sure you know what you are doing.
+fi
+echo
+echo configure complete, now type \'make\'
+echo
+
diff -uNr pidgin-2.10.11.orig/libpurple/conversation.c pidgin-2.10.11/libpurple/conversation.c
--- pidgin-2.10.11.orig/libpurple/conversation.c	2014-11-24 01:41:25.000000000 +0900
+++ pidgin-2.10.11/libpurple/conversation.c	2015-02-10 14:28:16.387351890 +0900
@@ -735,6 +735,8 @@
 	PurpleBuddy *b;
 	PurpleChat *chat;
 	const char *text = NULL, *name;
+	gchar *utf8;
+	gsize dummy;
 
 	g_return_if_fail(conv != NULL);
 
@@ -753,7 +755,9 @@
 	if(text == NULL)
 		text = name;
 
-	purple_conversation_set_title(conv, text);
+	utf8 = sanitize_utf(text, strlen(text), &dummy);
+	purple_conversation_set_title(conv, utf8);
+	g_free(utf8);
 }
 
 void
@@ -1234,6 +1238,7 @@
 			  PurpleMessageFlags flags, time_t mtime)
 {
 	PurpleConversation *c;
+	char *tmpmessage = NULL;
 
 	g_return_if_fail(im != NULL);
 	g_return_if_fail(message != NULL);
@@ -1244,11 +1249,20 @@
 		purple_conv_im_set_typing_state(im, PURPLE_NOT_TYPING);
 	}
 
+	// yaz
+	if (purple_prefs_get_bool("/purple/conversations/msnstyle")) {
+		tmpmessage = g_strdup_printf("<br>%s", message);
+	} else {
+		tmpmessage = g_strdup_printf("%s", message);
+	}
+
 	/* Pass this on to either the ops structure or the default write func. */
 	if (c->ui_ops != NULL && c->ui_ops->write_im != NULL)
-		c->ui_ops->write_im(c, who, message, flags, mtime);
+		c->ui_ops->write_im(c, who, tmpmessage, flags, mtime);
 	else
-		purple_conversation_write(c, who, message, flags, mtime);
+		purple_conversation_write(c, who, tmpmessage, flags, mtime);
+
+	g_free(tmpmessage);
 }
 
 gboolean purple_conv_present_error(const char *who, PurpleAccount *account, const char *what)
diff -uNr pidgin-2.10.11.orig/libpurple/notify.c pidgin-2.10.11/libpurple/notify.c
--- pidgin-2.10.11.orig/libpurple/notify.c	2014-11-24 01:41:25.000000000 +0900
+++ pidgin-2.10.11/libpurple/notify.c	2015-02-10 14:28:16.387351890 +0900
@@ -417,6 +417,9 @@
 		purple_signal_emit(purple_notify_get_handle(), "displaying-userinfo",
 						 purple_connection_get_account(gc), who, user_info);
 
+		g_return_val_if_fail(g_utf8_validate(who, -1, NULL), NULL); //yaz
+		g_return_val_if_fail(g_utf8_validate(user_info, -1, NULL), NULL); //yaz
+
 		ui_handle = ops->notify_userinfo(gc, who, user_info);
 
 		if (ui_handle != NULL) {
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/gg/lib/pubdir50.c pidgin-2.10.11/libpurple/protocols/gg/lib/pubdir50.c
--- pidgin-2.10.11.orig/libpurple/protocols/gg/lib/pubdir50.c	2014-11-24 01:41:25.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/gg/lib/pubdir50.c	2015-02-10 14:28:16.387351890 +0900
@@ -31,6 +31,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
+#include <glib.h>
 
 #include "libgadu.h"
 #include "internal.h"
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/gg/lib/pubdir50.c.orig pidgin-2.10.11/libpurple/protocols/gg/lib/pubdir50.c.orig
--- pidgin-2.10.11.orig/libpurple/protocols/gg/lib/pubdir50.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/gg/lib/pubdir50.c.orig	2014-11-24 01:41:25.000000000 +0900
@@ -0,0 +1,555 @@
+/*
+ *  (C) Copyright 2003 Wojtek Kaniewski <wojtekka@irc.pl>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License Version
+ *  2.1 as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
+ *  USA.
+ */
+
+/**
+ * \file pubdir50.c
+ *
+ * \brief Obsługa katalogu publicznego od wersji Gadu-Gadu 5.x
+ *
+ * \todo Zoptymalizować konwersję CP1250<->UTF8. Obecnie robiona jest
+ * testowa konwersja, żeby poznać długość tekstu wynikowego.
+ */
+
+#include "network.h"
+#include "strman.h"
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include "libgadu.h"
+#include "internal.h"
+#include "encoding.h"
+
+/**
+ * Tworzy nowe zapytanie katalogu publicznego.
+ *
+ * \param type Rodzaj zapytania
+ *
+ * \return Zmienna \c gg_pubdir50_t lub \c NULL w przypadku błędu.
+ *
+ * \ingroup pubdir50
+ */
+gg_pubdir50_t gg_pubdir50_new(int type)
+{
+	gg_pubdir50_t res = malloc(sizeof(struct gg_pubdir50_s));
+
+	gg_debug(GG_DEBUG_FUNCTION, "** gg_pubdir50_new(%d);\n", type);
+
+	if (!res) {
+		gg_debug(GG_DEBUG_MISC, "// gg_pubdir50_new() out of memory\n");
+		return NULL;
+	}
+
+	memset(res, 0, sizeof(struct gg_pubdir50_s));
+
+	res->type = type;
+
+	return res;
+}
+
+/**
+ * \internal Dodaje lub zastępuje pole zapytania lub odpowiedzi katalogu
+ * publicznego.
+ *
+ * \param req Zapytanie lub odpowiedź
+ * \param num Numer wyniku odpowiedzi (0 dla zapytania)
+ * \param field Nazwa pola
+ * \param value Wartość pola
+ *
+ * \return 0 jeśli się powiodło, -1 w przypadku błędu
+ */
+static int gg_pubdir50_add_n(gg_pubdir50_t req, int num, const char *field, const char *value)
+{
+	struct gg_pubdir50_entry *tmp = NULL, *entry;
+	char *dupfield, *dupvalue;
+	int i;
+
+	gg_debug(GG_DEBUG_FUNCTION, "** gg_pubdir50_add_n(%p, %d, \"%s\", \"%s\");\n", req, num, field, value);
+
+	if (!(dupvalue = strdup(value))) {
+		gg_debug(GG_DEBUG_MISC, "// gg_pubdir50_add_n() out of memory\n");
+		return -1;
+	}
+
+	for (i = 0; i < req->entries_count; i++) {
+		if (req->entries[i].num != num || strcmp(req->entries[i].field, field))
+			continue;
+
+		free(req->entries[i].value);
+		req->entries[i].value = dupvalue;
+
+		return 0;
+	}
+
+	if (!(dupfield = strdup(field))) {
+		gg_debug(GG_DEBUG_MISC, "// gg_pubdir50_add_n() out of memory\n");
+		free(dupvalue);
+		return -1;
+	}
+
+	if (!(tmp = realloc(req->entries, sizeof(struct gg_pubdir50_entry) * (req->entries_count + 1)))) {
+		gg_debug(GG_DEBUG_MISC, "// gg_pubdir50_add_n() out of memory\n");
+		free(dupfield);
+		free(dupvalue);
+		return -1;
+	}
+
+	req->entries = tmp;
+
+	entry = &req->entries[req->entries_count];
+	entry->num = num;
+	entry->field = dupfield;
+	entry->value = dupvalue;
+
+	req->entries_count++;
+
+	return 0;
+}
+
+/**
+ * Dodaje pole zapytania.
+ *
+ * \param req Zapytanie
+ * \param field Nazwa pola
+ * \param value Wartość pola
+ *
+ * \return 0 jeśli się powiodło, -1 w przypadku błędu
+ *
+ * \ingroup pubdir50
+ */
+int gg_pubdir50_add(gg_pubdir50_t req, const char *field, const char *value)
+{
+	return gg_pubdir50_add_n(req, 0, field, value);
+}
+
+/**
+ * Ustawia numer sekwencyjny zapytania.
+ *
+ * \param req Zapytanie
+ * \param seq Numer sekwencyjny
+ *
+ * \return 0 jeśli się powiodło, -1 w przypadku błędu
+ *
+ * \ingroup pubdir50
+ */
+int gg_pubdir50_seq_set(gg_pubdir50_t req, uint32_t seq)
+{
+	gg_debug(GG_DEBUG_FUNCTION, "** gg_pubdir50_seq_set(%p, %d);\n", req, seq);
+
+	if (!req) {
+		gg_debug(GG_DEBUG_MISC, "// gg_pubdir50_seq_set() invalid arguments\n");
+		errno = EFAULT;
+		return -1;
+	}
+
+	req->seq = seq;
+
+	return 0;
+}
+
+/**
+ * Zwalnia zasoby po zapytaniu lub odpowiedzi katalogu publicznego.
+ *
+ * \param s Zapytanie lub odpowiedź
+ *
+ * \ingroup pubdir50
+ */
+void gg_pubdir50_free(gg_pubdir50_t s)
+{
+	int i;
+
+	if (!s)
+		return;
+
+	for (i = 0; i < s->entries_count; i++) {
+		free(s->entries[i].field);
+		free(s->entries[i].value);
+	}
+
+	free(s->entries);
+	free(s);
+}
+
+/**
+ * Wysyła zapytanie katalogu publicznego do serwera.
+ *
+ * \param sess Struktura sesji
+ * \param req Zapytanie
+ *
+ * \return Numer sekwencyjny zapytania lub 0 w przypadku błędu
+ *
+ * \ingroup pubdir50
+ */
+uint32_t gg_pubdir50(struct gg_session *sess, gg_pubdir50_t req)
+{
+	int i, size = 5;
+	uint32_t res;
+	char *buf, *p;
+	struct gg_pubdir50_request *r;
+
+	gg_debug_session(sess, GG_DEBUG_FUNCTION, "** gg_pubdir50(%p, %p);\n", sess, req);
+
+	if (!sess || !req) {
+		gg_debug_session(sess, GG_DEBUG_MISC, "// gg_pubdir50() invalid arguments\n");
+		errno = EFAULT;
+		return 0;
+	}
+
+	if (sess->state != GG_STATE_CONNECTED) {
+		gg_debug_session(sess, GG_DEBUG_MISC, "// gg_pubdir50() not connected\n");
+		errno = ENOTCONN;
+		return 0;
+	}
+
+	for (i = 0; i < req->entries_count; i++) {
+		/* wyszukiwanie bierze tylko pierwszy wpis */
+		if (req->entries[i].num)
+			continue;
+
+		if (sess->encoding == GG_ENCODING_CP1250) {
+			size += strlen(req->entries[i].field) + 1;
+			size += strlen(req->entries[i].value) + 1;
+		} else {
+			char *tmp;
+
+			/* XXX \todo zoptymalizować */
+			tmp = gg_encoding_convert(req->entries[i].field, sess->encoding, GG_ENCODING_CP1250, -1, -1);
+
+			if (tmp == NULL)
+				return -1;
+
+			size += strlen(tmp) + 1;
+
+			free(tmp);
+
+			/* XXX \todo zoptymalizować */
+			tmp = gg_encoding_convert(req->entries[i].value, sess->encoding, GG_ENCODING_CP1250, -1, -1);
+
+			if (tmp == NULL)
+				return -1;
+
+			size += strlen(tmp) + 1;
+
+			free(tmp);
+		}
+	}
+
+	if (!(buf = malloc(size))) {
+		gg_debug_session(sess, GG_DEBUG_MISC, "// gg_pubdir50() out of memory (%d bytes)\n", size);
+		return 0;
+	}
+
+	if (!req->seq)
+		req->seq = time(NULL);
+
+	res = req->seq;
+
+	r = (struct gg_pubdir50_request*) buf;
+	r->type = req->type;
+	r->seq = gg_fix32(req->seq);
+
+	for (i = 0, p = buf + 5; i < req->entries_count; i++) {
+		if (req->entries[i].num)
+			continue;
+
+		if (sess->encoding == GG_ENCODING_CP1250) {
+			strcpy(p, req->entries[i].field);
+			p += strlen(p) + 1;
+
+			strcpy(p, req->entries[i].value);
+			p += strlen(p) + 1;
+		} else {
+			char *tmp;
+
+			/* XXX \todo zoptymalizować */
+			tmp = gg_encoding_convert(req->entries[i].field, sess->encoding, GG_ENCODING_CP1250, -1, -1);
+
+			if (tmp == NULL) {
+				free(buf);
+				return -1;
+			}
+
+			strcpy(p, tmp);
+			p += strlen(tmp) + 1;
+			free(tmp);
+
+			/* XXX \todo zoptymalizować */
+			tmp = gg_encoding_convert(req->entries[i].value, sess->encoding, GG_ENCODING_CP1250, -1, -1);
+
+
+			if (tmp == NULL) {
+				free(buf);
+				return -1;
+			}
+
+			strcpy(p, tmp);
+			p += strlen(tmp) + 1;
+			free(tmp);
+		}
+	}
+
+	if (gg_send_packet(sess, GG_PUBDIR50_REQUEST, buf, size, NULL, 0) == -1)
+		res = 0;
+
+	free(buf);
+
+	return res;
+}
+
+/*
+ * \internal Analizuje przychodzący pakiet odpowiedzi i zapisuje wynik
+ * w strukturze \c gg_event.
+ *
+ * \param sess Struktura sesji
+ * \param e Struktura zdarzenia
+ * \param packet Pakiet odpowiedzi
+ * \param length Długość pakietu odpowiedzi
+ *
+ * \return 0 jeśli się powiodło, -1 w przypadku błędu
+ */
+int gg_pubdir50_handle_reply_sess(struct gg_session *sess, struct gg_event *e, const char *packet, int length)
+{
+	const char *end = packet + length, *p;
+	const struct gg_pubdir50_reply *r = (const struct gg_pubdir50_reply*) packet;
+	gg_pubdir50_t res;
+	int num = 0;
+
+	gg_debug(GG_DEBUG_FUNCTION, "** gg_pubdir50_handle_reply_sess(%p, %p, %p, %d);\n", sess, e, packet, length);
+
+	if (!sess || !e || !packet) {
+		gg_debug(GG_DEBUG_MISC, "// gg_pubdir50_handle_reply() invalid arguments\n");
+		errno = EFAULT;
+		return -1;
+	}
+
+	if (length < 5) {
+		gg_debug(GG_DEBUG_MISC, "// gg_pubdir50_handle_reply() packet too short\n");
+		errno = EINVAL;
+		return -1;
+	}
+
+	if (!(res = gg_pubdir50_new(r->type))) {
+		gg_debug(GG_DEBUG_MISC, "// gg_pubdir50_handle_reply() unable to allocate reply\n");
+		return -1;
+	}
+
+	e->event.pubdir50 = res;
+
+	res->seq = gg_fix32(r->seq);
+
+	switch (res->type) {
+		case GG_PUBDIR50_READ:
+			e->type = GG_EVENT_PUBDIR50_READ;
+			break;
+
+		case GG_PUBDIR50_WRITE:
+			e->type = GG_EVENT_PUBDIR50_WRITE;
+			break;
+
+		default:
+			e->type = GG_EVENT_PUBDIR50_SEARCH_REPLY;
+			break;
+	}
+
+	/* brak wyników? */
+	if (length == 5)
+		return 0;
+
+	/* pomiń początek odpowiedzi */
+	p = packet + 5;
+
+	while (p < end) {
+		const char *field, *value;
+
+		field = p;
+
+		/* sprawdź, czy nie mamy podziału na kolejne pole */
+		if (!*field) {
+			num++;
+			field++;
+		}
+
+		value = NULL;
+
+		for (p = field; p < end; p++) {
+			/* jeśli mamy koniec tekstu... */
+			if (!*p) {
+				/* ...i jeszcze nie mieliśmy wartości pola to
+				 * wiemy, że po tym zerze jest wartość... */
+				if (!value)
+					value = p + 1;
+				else
+					/* ...w przeciwym wypadku koniec
+					 * wartości i możemy wychodzić
+					 * grzecznie z pętli */
+					break;
+			}
+		}
+
+		/* sprawdźmy, czy pole nie wychodzi poza pakiet, żeby nie
+		 * mieć segfaultów, jeśli serwer przestanie zakańczać pakietów
+		 * przez \0 */
+
+		if (p == end) {
+			gg_debug(GG_DEBUG_MISC, "// gg_pubdir50_handle_reply() premature end of packet\n");
+			goto failure;
+		}
+
+		p++;
+
+		/* jeśli dostaliśmy namier na następne wyniki, to znaczy że
+		 * mamy koniec wyników i nie jest to kolejna osoba. */
+		if (!strcasecmp(field, "nextstart")) {
+			res->next = atoi(value);
+			num--;
+		} else {
+			if (sess->encoding == GG_ENCODING_CP1250) {
+				if (gg_pubdir50_add_n(res, num, field, value) == -1)
+					goto failure;
+			} else {
+				char *tmp;
+
+				tmp = gg_encoding_convert(value, GG_ENCODING_CP1250, sess->encoding, -1, -1);
+
+				if (tmp == NULL)
+					goto failure;
+
+				if (gg_pubdir50_add_n(res, num, field, tmp) == -1) {
+					free(tmp);
+					goto failure;
+				}
+
+				free(tmp);
+			}
+		}
+	}
+
+	res->count = num + 1;
+
+	return 0;
+
+failure:
+	gg_pubdir50_free(res);
+	return -1;
+}
+
+/**
+ * Pobiera pole z odpowiedzi katalogu publicznego.
+ *
+ * \param res Odpowiedź
+ * \param num Numer wyniku odpowiedzi
+ * \param field Nazwa pola (wielkość liter nie ma znaczenia)
+ *
+ * \return Wartość pola lub \c NULL jeśli nie znaleziono
+ *
+ * \ingroup pubdir50
+ */
+const char *gg_pubdir50_get(gg_pubdir50_t res, int num, const char *field)
+{
+	char *value = NULL;
+	int i;
+
+	gg_debug(GG_DEBUG_FUNCTION, "** gg_pubdir50_get(%p, %d, \"%s\");\n", res, num, field);
+
+	if (!res || num < 0 || !field) {
+		gg_debug(GG_DEBUG_MISC, "// gg_pubdir50_get() invalid arguments\n");
+		errno = EINVAL;
+		return NULL;
+	}
+
+	for (i = 0; i < res->entries_count; i++) {
+		if (res->entries[i].num == num && !strcasecmp(res->entries[i].field, field)) {
+			value = res->entries[i].value;
+			break;
+		}
+	}
+
+	return value;
+}
+
+/**
+ * Zwraca liczbę wyników odpowiedzi.
+ *
+ * \param res Odpowiedź
+ *
+ * \return Liczba wyników lub -1 w przypadku błędu
+ *
+ * \ingroup pubdir50
+ */
+int gg_pubdir50_count(gg_pubdir50_t res)
+{
+	return (!res) ? -1 : res->count;
+}
+
+/**
+ * Zwraca rodzaj zapytania lub odpowiedzi.
+ *
+ * \param res Zapytanie lub odpowiedź
+ *
+ * \return Rodzaj lub -1 w przypadku błędu
+ *
+ * \ingroup pubdir50
+ */
+int gg_pubdir50_type(gg_pubdir50_t res)
+{
+	return (!res) ? -1 : res->type;
+}
+
+/**
+ * Zwraca numer, od którego należy rozpocząc kolejne wyszukiwanie.
+ *
+ * Dłuższe odpowiedzi katalogu publicznego są wysyłane przez serwer
+ * w mniejszych paczkach. Po otrzymaniu odpowiedzi, jeśli numer kolejnego
+ * wyszukiwania jest większy od zera, dalsze wyniki można otrzymać przez
+ * wywołanie kolejnego zapytania z określonym numerem początkowym.
+ *
+ * \param res Odpowiedź
+ *
+ * \return Numer lub -1 w przypadku błędu
+ *
+ * \ingroup pubdir50
+ */
+uin_t gg_pubdir50_next(gg_pubdir50_t res)
+{
+	return (!res) ? (unsigned) -1 : res->next;
+}
+
+/**
+ * Zwraca numer sekwencyjny zapytania lub odpowiedzi.
+ *
+ * \param res Zapytanie lub odpowiedź
+ *
+ * \return Numer sekwencyjny lub -1 w przypadku błędu
+ *
+ * \ingroup pubdir50
+ */
+uint32_t gg_pubdir50_seq(gg_pubdir50_t res)
+{
+	return (!res) ? (unsigned) -1 : res->seq;
+}
+
+/*
+ * Local variables:
+ * c-indentation-style: k&r
+ * c-basic-offset: 8
+ * indent-tabs-mode: notnil
+ * End:
+ *
+ * vim: shiftwidth=8:
+ */
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/irc/irc.c pidgin-2.10.11/libpurple/protocols/irc/irc.c
--- pidgin-2.10.11.orig/libpurple/protocols/irc/irc.c	2014-11-24 01:41:25.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/irc/irc.c	2015-02-10 14:28:16.390685387 +0900
@@ -1053,6 +1053,12 @@
 	option = purple_account_option_bool_new(_("Auto-detect incoming UTF-8"), "autodetect_utf8", IRC_DEFAULT_AUTODETECT);
 	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
 
+	option = purple_account_option_bool_new(_("Use SO/SI to send hankaku kana"), "irc_use_sosi", FALSE);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+	option = purple_account_option_bool_new(_("Use 8bit to send hankaku kana"), "irc_use_8bit", FALSE);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
 	option = purple_account_option_string_new(_("Ident name"), "username", "");
 	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
 
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/irc/irc.c.orig pidgin-2.10.11/libpurple/protocols/irc/irc.c.orig
--- pidgin-2.10.11.orig/libpurple/protocols/irc/irc.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/irc/irc.c.orig	2014-11-24 01:41:25.000000000 +0900
@@ -0,0 +1,1088 @@
+/**
+ * @file irc.c
+ *
+ * purple
+ *
+ * Copyright (C) 2003, Robbert Haarman <purple@inglorion.net>
+ * Copyright (C) 2003, 2012 Ethan Blanton <elb@pidgin.im>
+ * Copyright (C) 2000-2003, Rob Flynn <rob@tgflinux.com>
+ * Copyright (C) 1998-1999, Mark Spencer <markster@marko.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#include "internal.h"
+
+#include "accountopt.h"
+#include "blist.h"
+#include "conversation.h"
+#include "debug.h"
+#include "notify.h"
+#include "prpl.h"
+#include "plugin.h"
+#include "util.h"
+#include "version.h"
+
+#include "irc.h"
+
+#define PING_TIMEOUT 60
+
+static void irc_ison_buddy_init(char *name, struct irc_buddy *ib, GList **list);
+
+static const char *irc_blist_icon(PurpleAccount *a, PurpleBuddy *b);
+static GList *irc_status_types(PurpleAccount *account);
+static GList *irc_actions(PurplePlugin *plugin, gpointer context);
+/* static GList *irc_chat_info(PurpleConnection *gc); */
+static void irc_login(PurpleAccount *account);
+static void irc_login_cb_ssl(gpointer data, PurpleSslConnection *gsc, PurpleInputCondition cond);
+static void irc_login_cb(gpointer data, gint source, const gchar *error_message);
+static void irc_ssl_connect_failure(PurpleSslConnection *gsc, PurpleSslErrorType error, gpointer data);
+static void irc_close(PurpleConnection *gc);
+static int irc_im_send(PurpleConnection *gc, const char *who, const char *what, PurpleMessageFlags flags);
+static int irc_chat_send(PurpleConnection *gc, int id, const char *what, PurpleMessageFlags flags);
+static void irc_chat_join (PurpleConnection *gc, GHashTable *data);
+static void irc_input_cb(gpointer data, gint source, PurpleInputCondition cond);
+static void irc_input_cb_ssl(gpointer data, PurpleSslConnection *gsc, PurpleInputCondition cond);
+
+static guint irc_nick_hash(const char *nick);
+static gboolean irc_nick_equal(const char *nick1, const char *nick2);
+static void irc_buddy_free(struct irc_buddy *ib);
+
+PurplePlugin *_irc_plugin = NULL;
+
+static void irc_view_motd(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	struct irc_conn *irc;
+	char *title, *body;
+
+	if (gc == NULL || gc->proto_data == NULL) {
+		purple_debug(PURPLE_DEBUG_ERROR, "irc", "got MOTD request for NULL gc\n");
+		return;
+	}
+	irc = gc->proto_data;
+	if (irc->motd == NULL) {
+		purple_notify_error(gc, _("Error displaying MOTD"), _("No MOTD available"),
+				  _("There is no MOTD associated with this connection."));
+		return;
+	}
+	title = g_strdup_printf(_("MOTD for %s"), irc->server);
+	body = g_strdup_printf("<span style=\"font-family: monospace;\">%s</span>", irc->motd->str);
+	purple_notify_formatted(gc, title, title, NULL, body, NULL, NULL);
+	g_free(title);
+	g_free(body);
+}
+
+static int do_send(struct irc_conn *irc, const char *buf, gsize len)
+{
+	int ret;
+
+	if (irc->gsc) {
+		ret = purple_ssl_write(irc->gsc, buf, len);
+	} else {
+		ret = write(irc->fd, buf, len);
+	}
+
+	return ret;
+}
+
+static int irc_send_raw(PurpleConnection *gc, const char *buf, int len)
+{
+	struct irc_conn *irc = (struct irc_conn*)gc->proto_data;
+	if (len == -1) {
+		len = strlen(buf);
+	}
+	irc_send_len(irc, buf, len);
+	return len;
+}
+
+static void
+irc_send_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	struct irc_conn *irc = data;
+	int ret, writelen;
+
+	writelen = purple_circ_buffer_get_max_read(irc->outbuf);
+
+	if (writelen == 0) {
+		purple_input_remove(irc->writeh);
+		irc->writeh = 0;
+		return;
+	}
+
+	ret = do_send(irc, irc->outbuf->outptr, writelen);
+
+	if (ret < 0 && errno == EAGAIN)
+		return;
+	else if (ret <= 0) {
+		PurpleConnection *gc = purple_account_get_connection(irc->account);
+		gchar *tmp = g_strdup_printf(_("Lost connection with server: %s"),
+			g_strerror(errno));
+		purple_connection_error_reason (gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	}
+
+	purple_circ_buffer_mark_read(irc->outbuf, ret);
+
+#if 0
+	/* We *could* try to write more if we wrote it all */
+	if (ret == write_len) {
+		irc_send_cb(data, source, cond);
+	}
+#endif
+}
+
+int irc_send(struct irc_conn *irc, const char *buf)
+{
+    return irc_send_len(irc, buf, strlen(buf));
+}
+
+int irc_send_len(struct irc_conn *irc, const char *buf, int buflen)
+{
+	int ret;
+ 	char *tosend= g_strdup(buf);
+
+	purple_signal_emit(_irc_plugin, "irc-sending-text", purple_account_get_connection(irc->account), &tosend);
+	
+	if (tosend == NULL)
+		return 0;
+
+	/* If we're not buffering writes, try to send immediately */
+	if (!irc->writeh)
+		ret = do_send(irc, tosend, buflen);
+	else {
+		ret = -1;
+		errno = EAGAIN;
+	}
+
+	/* purple_debug(PURPLE_DEBUG_MISC, "irc", "sent%s: %s",
+		irc->gsc ? " (ssl)" : "", tosend); */
+	if (ret <= 0 && errno != EAGAIN) {
+		PurpleConnection *gc = purple_account_get_connection(irc->account);
+		gchar *tmp = g_strdup_printf(_("Lost connection with server: %s"),
+			g_strerror(errno));
+		purple_connection_error_reason (gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+	} else if (ret < buflen) {
+		if (ret < 0)
+			ret = 0;
+		if (!irc->writeh)
+			irc->writeh = purple_input_add(
+				irc->gsc ? irc->gsc->fd : irc->fd,
+				PURPLE_INPUT_WRITE, irc_send_cb, irc);
+		purple_circ_buffer_append(irc->outbuf, tosend + ret,
+			buflen - ret);
+	}
+	g_free(tosend);
+	return ret;
+}
+
+/* XXX I don't like messing directly with these buddies */
+gboolean irc_blist_timeout(struct irc_conn *irc)
+{
+	if (irc->ison_outstanding) {
+		return TRUE;
+	}
+
+	g_hash_table_foreach(irc->buddies, (GHFunc)irc_ison_buddy_init,
+	                     (gpointer *)&irc->buddies_outstanding);
+
+	irc_buddy_query(irc);
+
+	return TRUE;
+}
+
+void irc_buddy_query(struct irc_conn *irc)
+{
+	GList *lp;
+	GString *string;
+	struct irc_buddy *ib;
+	char *buf;
+
+	string = g_string_sized_new(512);
+
+	while ((lp = g_list_first(irc->buddies_outstanding))) {
+		ib = (struct irc_buddy *)lp->data;
+		if (string->len + strlen(ib->name) + 1 > 450)
+			break;
+		g_string_append_printf(string, "%s ", ib->name);
+		ib->new_online_status = FALSE;
+		irc->buddies_outstanding = g_list_remove_link(irc->buddies_outstanding, lp);
+	}
+
+	if (string->len) {
+		buf = irc_format(irc, "vn", "ISON", string->str);
+		irc_send(irc, buf);
+		g_free(buf);
+		irc->ison_outstanding = TRUE;
+	} else
+		irc->ison_outstanding = FALSE;
+
+	g_string_free(string, TRUE);
+}
+
+static void irc_ison_buddy_init(char *name, struct irc_buddy *ib, GList **list)
+{
+	*list = g_list_append(*list, ib);
+}
+
+
+static void irc_ison_one(struct irc_conn *irc, struct irc_buddy *ib)
+{
+	char *buf;
+
+	if (irc->buddies_outstanding != NULL) {
+		irc->buddies_outstanding = g_list_append(irc->buddies_outstanding, ib);
+		return;
+	}
+
+	ib->new_online_status = FALSE;
+	buf = irc_format(irc, "vn", "ISON", ib->name);
+	irc_send(irc, buf);
+	g_free(buf);
+}
+
+
+static const char *irc_blist_icon(PurpleAccount *a, PurpleBuddy *b)
+{
+	return "irc";
+}
+
+static GList *irc_status_types(PurpleAccount *account)
+{
+	PurpleStatusType *type;
+	GList *types = NULL;
+
+	type = purple_status_type_new(PURPLE_STATUS_AVAILABLE, NULL, NULL, TRUE);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new_with_attrs(
+		PURPLE_STATUS_AWAY, NULL, NULL, TRUE, TRUE, FALSE,
+		"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+		NULL);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new(PURPLE_STATUS_OFFLINE, NULL, NULL, TRUE);
+	types = g_list_append(types, type);
+
+	return types;
+}
+
+static GList *irc_actions(PurplePlugin *plugin, gpointer context)
+{
+	GList *list = NULL;
+	PurplePluginAction *act = NULL;
+
+	act = purple_plugin_action_new(_("View MOTD"), irc_view_motd);
+	list = g_list_append(list, act);
+
+	return list;
+}
+
+static GList *irc_chat_join_info(PurpleConnection *gc)
+{
+	GList *m = NULL;
+	struct proto_chat_entry *pce;
+
+	pce = g_new0(struct proto_chat_entry, 1);
+	pce->label = _("_Channel:");
+	pce->identifier = "channel";
+	pce->required = TRUE;
+	m = g_list_append(m, pce);
+
+	pce = g_new0(struct proto_chat_entry, 1);
+	pce->label = _("_Password:");
+	pce->identifier = "password";
+	pce->secret = TRUE;
+	m = g_list_append(m, pce);
+
+	return m;
+}
+
+static GHashTable *irc_chat_info_defaults(PurpleConnection *gc, const char *chat_name)
+{
+	GHashTable *defaults;
+
+	defaults = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_free);
+
+	if (chat_name != NULL)
+		g_hash_table_insert(defaults, "channel", g_strdup(chat_name));
+
+	return defaults;
+}
+
+static void irc_login(PurpleAccount *account)
+{
+	PurpleConnection *gc;
+	struct irc_conn *irc;
+	char **userparts;
+	const char *username = purple_account_get_username(account);
+
+	gc = purple_account_get_connection(account);
+	gc->flags |= PURPLE_CONNECTION_NO_NEWLINES;
+
+	if (strpbrk(username, " \t\v\r\n") != NULL) {
+		purple_connection_error_reason (gc,
+			PURPLE_CONNECTION_ERROR_INVALID_SETTINGS,
+			_("IRC nick and server may not contain whitespace"));
+		return;
+	}
+
+	gc->proto_data = irc = g_new0(struct irc_conn, 1);
+	irc->fd = -1;
+	irc->account = account;
+	irc->outbuf = purple_circ_buffer_new(512);
+
+	userparts = g_strsplit(username, "@", 2);
+	purple_connection_set_display_name(gc, userparts[0]);
+	irc->server = g_strdup(userparts[1]);
+	g_strfreev(userparts);
+
+	irc->buddies = g_hash_table_new_full((GHashFunc)irc_nick_hash, (GEqualFunc)irc_nick_equal,
+					     NULL, (GDestroyNotify)irc_buddy_free);
+	irc->cmds = g_hash_table_new(g_str_hash, g_str_equal);
+	irc_cmd_table_build(irc);
+	irc->msgs = g_hash_table_new(g_str_hash, g_str_equal);
+	irc_msg_table_build(irc);
+
+	purple_connection_update_progress(gc, _("Connecting"), 1, 2);
+
+	if (purple_account_get_bool(account, "ssl", FALSE)) {
+		if (purple_ssl_is_supported()) {
+			irc->gsc = purple_ssl_connect(account, irc->server,
+					purple_account_get_int(account, "port", IRC_DEFAULT_SSL_PORT),
+					irc_login_cb_ssl, irc_ssl_connect_failure, gc);
+		} else {
+			purple_connection_error_reason (gc,
+				PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,
+				_("SSL support unavailable"));
+			return;
+		}
+	}
+
+	if (!irc->gsc) {
+
+		if (purple_proxy_connect(gc, account, irc->server,
+				 purple_account_get_int(account, "port", IRC_DEFAULT_PORT),
+				 irc_login_cb, gc) == NULL)
+		{
+			purple_connection_error_reason (gc,
+				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+				_("Unable to connect"));
+			return;
+		}
+	}
+}
+
+static gboolean do_login(PurpleConnection *gc) {
+	char *buf, *tmp = NULL;
+	char *server;
+	const char *nickname, *identname, *realname;
+	struct irc_conn *irc = gc->proto_data;
+	const char *pass = purple_connection_get_password(gc);
+#ifdef HAVE_CYRUS_SASL
+	const gboolean use_sasl = purple_account_get_bool(irc->account, "sasl", FALSE);
+#endif
+
+	if (pass && *pass) {
+#ifdef HAVE_CYRUS_SASL
+		if (use_sasl)
+			buf = irc_format(irc, "vv:", "CAP", "REQ", "sasl");
+		else /* intended to fall through */
+#endif
+			buf = irc_format(irc, "v:", "PASS", pass);
+		if (irc_send(irc, buf) < 0) {
+			g_free(buf);
+			return FALSE;
+		}
+		g_free(buf);
+	}
+
+	realname = purple_account_get_string(irc->account, "realname", "");
+	identname = purple_account_get_string(irc->account, "username", "");
+
+	if (identname == NULL || *identname == '\0') {
+		identname = g_get_user_name();
+	}
+
+	if (identname != NULL && strchr(identname, ' ') != NULL) {
+		tmp = g_strdup(identname);
+		while ((buf = strchr(tmp, ' ')) != NULL) {
+			*buf = '_';
+		}
+	}
+
+	if (*irc->server == ':') {
+		/* Same as hostname, above. */
+		server = g_strdup_printf("0%s", irc->server);
+	} else {
+		server = g_strdup(irc->server);
+	}
+
+	buf = irc_format(irc, "vvvv:", "USER", tmp ? tmp : identname, "*", server,
+	                 strlen(realname) ? realname : IRC_DEFAULT_ALIAS);
+	g_free(tmp);
+	g_free(server);
+	if (irc_send(irc, buf) < 0) {
+		g_free(buf);
+		return FALSE;
+	}
+	g_free(buf);
+	nickname = purple_connection_get_display_name(gc);
+	buf = irc_format(irc, "vn", "NICK", nickname);
+	irc->reqnick = g_strdup(nickname);
+	irc->nickused = FALSE;
+	if (irc_send(irc, buf) < 0) {
+		g_free(buf);
+		return FALSE;
+	}
+	g_free(buf);
+
+	irc->recv_time = time(NULL);
+
+	return TRUE;
+}
+
+static void irc_login_cb_ssl(gpointer data, PurpleSslConnection *gsc,
+	PurpleInputCondition cond)
+{
+	PurpleConnection *gc = data;
+
+	if (do_login(gc)) {
+		purple_ssl_input_add(gsc, irc_input_cb_ssl, gc);
+	}
+}
+
+static void irc_login_cb(gpointer data, gint source, const gchar *error_message)
+{
+	PurpleConnection *gc = data;
+	struct irc_conn *irc = gc->proto_data;
+
+	if (source < 0) {
+		gchar *tmp = g_strdup_printf(_("Unable to connect: %s"),
+			error_message);
+		purple_connection_error_reason (gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	}
+
+	irc->fd = source;
+
+	if (do_login(gc)) {
+		gc->inpa = purple_input_add(irc->fd, PURPLE_INPUT_READ, irc_input_cb, gc);
+	}
+}
+
+static void
+irc_ssl_connect_failure(PurpleSslConnection *gsc, PurpleSslErrorType error,
+		gpointer data)
+{
+	PurpleConnection *gc = data;
+	struct irc_conn *irc = gc->proto_data;
+
+	irc->gsc = NULL;
+
+	purple_connection_ssl_error (gc, error);
+}
+
+static void irc_close(PurpleConnection *gc)
+{
+	struct irc_conn *irc = gc->proto_data;
+
+	if (irc == NULL)
+		return;
+
+	if (irc->gsc || (irc->fd >= 0))
+		irc_cmd_quit(irc, "quit", NULL, NULL);
+
+	if (gc->inpa)
+		purple_input_remove(gc->inpa);
+
+	g_free(irc->inbuf);
+	if (irc->gsc) {
+		purple_ssl_close(irc->gsc);
+	} else if (irc->fd >= 0) {
+		close(irc->fd);
+	}
+	if (irc->timer)
+		purple_timeout_remove(irc->timer);
+	g_hash_table_destroy(irc->cmds);
+	g_hash_table_destroy(irc->msgs);
+	g_hash_table_destroy(irc->buddies);
+	if (irc->motd)
+		g_string_free(irc->motd, TRUE);
+	g_free(irc->server);
+
+	if (irc->writeh)
+		purple_input_remove(irc->writeh);
+
+	purple_circ_buffer_destroy(irc->outbuf);
+
+	g_free(irc->mode_chars);
+	g_free(irc->reqnick);
+
+#ifdef HAVE_CYRUS_SASL
+	if (irc->sasl_conn) {
+		sasl_dispose(&irc->sasl_conn);
+		irc->sasl_conn = NULL;
+	}
+	g_free(irc->sasl_cb);
+	if(irc->sasl_mechs)
+		g_string_free(irc->sasl_mechs, TRUE);
+#endif
+
+
+	g_free(irc);
+}
+
+static int irc_im_send(PurpleConnection *gc, const char *who, const char *what, PurpleMessageFlags flags)
+{
+	struct irc_conn *irc = gc->proto_data;
+	char *plain;
+	const char *args[2];
+
+	args[0] = irc_nick_skip_mode(irc, who);
+
+	purple_markup_html_to_xhtml(what, NULL, &plain);
+	args[1] = plain;
+
+	irc_cmd_privmsg(irc, "msg", NULL, args);
+	g_free(plain);
+	return 1;
+}
+
+static void irc_get_info(PurpleConnection *gc, const char *who)
+{
+	struct irc_conn *irc = gc->proto_data;
+	const char *args[2];
+	args[0] = who;
+	args[1] = NULL;
+	irc_cmd_whois(irc, "whois", NULL, args);
+}
+
+static void irc_set_status(PurpleAccount *account, PurpleStatus *status)
+{
+	PurpleConnection *gc = purple_account_get_connection(account);
+	struct irc_conn *irc;
+	const char *args[1];
+	const char *status_id = purple_status_get_id(status);
+
+	g_return_if_fail(gc != NULL);
+	irc = gc->proto_data;
+
+	if (!purple_status_is_active(status))
+		return;
+
+	args[0] = NULL;
+
+	if (!strcmp(status_id, "away")) {
+		args[0] = purple_status_get_attr_string(status, "message");
+		if ((args[0] == NULL) || (*args[0] == '\0'))
+			args[0] = _("Away");
+		irc_cmd_away(irc, "away", NULL, args);
+	} else if (!strcmp(status_id, "available")) {
+		irc_cmd_away(irc, "back", NULL, args);
+	}
+}
+
+static void irc_add_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group)
+{
+	struct irc_conn *irc = (struct irc_conn *)gc->proto_data;
+	struct irc_buddy *ib;
+	const char *bname = purple_buddy_get_name(buddy);
+
+	ib = g_hash_table_lookup(irc->buddies, bname);
+	if (ib != NULL) {
+		ib->ref++;
+		purple_prpl_got_user_status(irc->account, bname,
+				ib->online ? "available" : "offline", NULL);
+	} else {
+		ib = g_new0(struct irc_buddy, 1);
+		ib->name = g_strdup(bname);
+		ib->ref = 1;
+		g_hash_table_replace(irc->buddies, ib->name, ib);
+	}
+
+	/* if the timer isn't set, this is during signon, so we don't want to flood
+	 * ourself off with ISON's, so we don't, but after that we want to know when
+	 * someone's online asap */
+	if (irc->timer)
+		irc_ison_one(irc, ib);
+}
+
+static void irc_remove_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group)
+{
+	struct irc_conn *irc = (struct irc_conn *)gc->proto_data;
+	struct irc_buddy *ib;
+
+	ib = g_hash_table_lookup(irc->buddies, purple_buddy_get_name(buddy));
+	if (ib && --ib->ref == 0) {
+		g_hash_table_remove(irc->buddies, purple_buddy_get_name(buddy));
+	}
+}
+
+static void read_input(struct irc_conn *irc, int len)
+{
+	char *cur, *end;
+
+	irc->account->gc->last_received = time(NULL);
+	irc->inbufused += len;
+	irc->inbuf[irc->inbufused] = '\0';
+
+	cur = irc->inbuf;
+
+	/* This is a hack to work around the fact that marv gets messages
+	 * with null bytes in them while using some weird irc server at work
+	 */
+	while ((cur < (irc->inbuf + irc->inbufused)) && !*cur)
+		cur++;
+
+	while (cur < irc->inbuf + irc->inbufused &&
+	       ((end = strstr(cur, "\r\n")) || (end = strstr(cur, "\n")))) {
+		int step = (*end == '\r' ? 2 : 1);
+		*end = '\0';
+		irc_parse_msg(irc, cur);
+		cur = end + step;
+	}
+	if (cur != irc->inbuf + irc->inbufused) { /* leftover */
+		irc->inbufused -= (cur - irc->inbuf);
+		memmove(irc->inbuf, cur, irc->inbufused);
+	} else {
+		irc->inbufused = 0;
+	}
+}
+
+static void irc_input_cb_ssl(gpointer data, PurpleSslConnection *gsc,
+		PurpleInputCondition cond)
+{
+
+	PurpleConnection *gc = data;
+	struct irc_conn *irc = gc->proto_data;
+	int len;
+
+	if(!g_list_find(purple_connections_get_all(), gc)) {
+		purple_ssl_close(gsc);
+		return;
+	}
+
+	if (irc->inbuflen < irc->inbufused + IRC_INITIAL_BUFSIZE) {
+		irc->inbuflen += IRC_INITIAL_BUFSIZE;
+		irc->inbuf = g_realloc(irc->inbuf, irc->inbuflen);
+	}
+
+	len = purple_ssl_read(gsc, irc->inbuf + irc->inbufused, IRC_INITIAL_BUFSIZE - 1);
+
+	if (len < 0 && errno == EAGAIN) {
+		/* Try again later */
+		return;
+	} else if (len < 0) {
+		gchar *tmp = g_strdup_printf(_("Lost connection with server: %s"),
+				g_strerror(errno));
+		purple_connection_error_reason (gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	} else if (len == 0) {
+		purple_connection_error_reason (gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+			_("Server closed the connection"));
+		return;
+	}
+
+	read_input(irc, len);
+}
+
+static void irc_input_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	PurpleConnection *gc = data;
+	struct irc_conn *irc = gc->proto_data;
+	int len;
+
+	if (irc->inbuflen < irc->inbufused + IRC_INITIAL_BUFSIZE) {
+		irc->inbuflen += IRC_INITIAL_BUFSIZE;
+		irc->inbuf = g_realloc(irc->inbuf, irc->inbuflen);
+	}
+
+	len = read(irc->fd, irc->inbuf + irc->inbufused, IRC_INITIAL_BUFSIZE - 1);
+	if (len < 0 && errno == EAGAIN) {
+		return;
+	} else if (len < 0) {
+		gchar *tmp = g_strdup_printf(_("Lost connection with server: %s"),
+				g_strerror(errno));
+		purple_connection_error_reason (gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	} else if (len == 0) {
+		purple_connection_error_reason (gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+			_("Server closed the connection"));
+		return;
+	}
+
+	read_input(irc, len);
+}
+
+static void irc_chat_join (PurpleConnection *gc, GHashTable *data)
+{
+	struct irc_conn *irc = gc->proto_data;
+	const char *args[2];
+
+	args[0] = g_hash_table_lookup(data, "channel");
+	args[1] = g_hash_table_lookup(data, "password");
+	irc_cmd_join(irc, "join", NULL, args);
+}
+
+static char *irc_get_chat_name(GHashTable *data) {
+	return g_strdup(g_hash_table_lookup(data, "channel"));
+}
+
+static void irc_chat_invite(PurpleConnection *gc, int id, const char *message, const char *name)
+{
+	struct irc_conn *irc = gc->proto_data;
+	PurpleConversation *convo = purple_find_chat(gc, id);
+	const char *args[2];
+
+	if (!convo) {
+		purple_debug(PURPLE_DEBUG_ERROR, "irc", "Got chat invite request for bogus chat\n");
+		return;
+	}
+	args[0] = name;
+	args[1] = purple_conversation_get_name(convo);
+	irc_cmd_invite(irc, "invite", purple_conversation_get_name(convo), args);
+}
+
+
+static void irc_chat_leave (PurpleConnection *gc, int id)
+{
+	struct irc_conn *irc = gc->proto_data;
+	PurpleConversation *convo = purple_find_chat(gc, id);
+	const char *args[2];
+
+	if (!convo)
+		return;
+
+	args[0] = purple_conversation_get_name(convo);
+	args[1] = NULL;
+	irc_cmd_part(irc, "part", purple_conversation_get_name(convo), args);
+	serv_got_chat_left(gc, id);
+}
+
+static int irc_chat_send(PurpleConnection *gc, int id, const char *what, PurpleMessageFlags flags)
+{
+	struct irc_conn *irc = gc->proto_data;
+	PurpleConversation *convo = purple_find_chat(gc, id);
+	const char *args[2];
+	char *tmp;
+
+	if (!convo) {
+		purple_debug(PURPLE_DEBUG_ERROR, "irc", "chat send on nonexistent chat\n");
+		return -EINVAL;
+	}
+#if 0
+	if (*what == '/') {
+		return irc_parse_cmd(irc, convo->name, what + 1);
+	}
+#endif
+	purple_markup_html_to_xhtml(what, NULL, &tmp);
+	args[0] = convo->name;
+	args[1] = tmp;
+
+	irc_cmd_privmsg(irc, "msg", NULL, args);
+
+	serv_got_chat_in(gc, id, purple_connection_get_display_name(gc), flags, what, time(NULL));
+	g_free(tmp);
+	return 0;
+}
+
+static guint irc_nick_hash(const char *nick)
+{
+	char *lc;
+	guint bucket;
+
+	lc = g_utf8_strdown(nick, -1);
+	bucket = g_str_hash(lc);
+	g_free(lc);
+
+	return bucket;
+}
+
+static gboolean irc_nick_equal(const char *nick1, const char *nick2)
+{
+	return (purple_utf8_strcasecmp(nick1, nick2) == 0);
+}
+
+static void irc_buddy_free(struct irc_buddy *ib)
+{
+	g_free(ib->name);
+	g_free(ib);
+}
+
+static void irc_chat_set_topic(PurpleConnection *gc, int id, const char *topic)
+{
+	char *buf;
+	const char *name = NULL;
+	struct irc_conn *irc;
+
+	irc = gc->proto_data;
+	name = purple_conversation_get_name(purple_find_chat(gc, id));
+
+	if (name == NULL)
+		return;
+
+	buf = irc_format(irc, "vt:", "TOPIC", name, topic);
+	irc_send(irc, buf);
+	g_free(buf);
+}
+
+static PurpleRoomlist *irc_roomlist_get_list(PurpleConnection *gc)
+{
+	struct irc_conn *irc;
+	GList *fields = NULL;
+	PurpleRoomlistField *f;
+	char *buf;
+
+	irc = gc->proto_data;
+
+	if (irc->roomlist)
+		purple_roomlist_unref(irc->roomlist);
+
+	irc->roomlist = purple_roomlist_new(purple_connection_get_account(gc));
+
+	f = purple_roomlist_field_new(PURPLE_ROOMLIST_FIELD_STRING, "", "channel", TRUE);
+	fields = g_list_append(fields, f);
+
+	f = purple_roomlist_field_new(PURPLE_ROOMLIST_FIELD_INT, _("Users"), "users", FALSE);
+	fields = g_list_append(fields, f);
+
+	f = purple_roomlist_field_new(PURPLE_ROOMLIST_FIELD_STRING, _("Topic"), "topic", FALSE);
+	fields = g_list_append(fields, f);
+
+	purple_roomlist_set_fields(irc->roomlist, fields);
+
+	buf = irc_format(irc, "v", "LIST");
+	irc_send(irc, buf);
+	g_free(buf);
+
+	return irc->roomlist;
+}
+
+static void irc_roomlist_cancel(PurpleRoomlist *list)
+{
+	PurpleConnection *gc = purple_account_get_connection(list->account);
+	struct irc_conn *irc;
+
+	if (gc == NULL)
+		return;
+
+	irc = gc->proto_data;
+
+	purple_roomlist_set_in_progress(list, FALSE);
+
+	if (irc->roomlist == list) {
+		irc->roomlist = NULL;
+		purple_roomlist_unref(list);
+	}
+}
+
+static void irc_keepalive(PurpleConnection *gc)
+{
+	struct irc_conn *irc = gc->proto_data;
+	if ((time(NULL) - irc->recv_time) > PING_TIMEOUT)
+		irc_cmd_ping(irc, NULL, NULL, NULL);
+}
+
+static PurplePluginProtocolInfo prpl_info =
+{
+	OPT_PROTO_CHAT_TOPIC | OPT_PROTO_PASSWORD_OPTIONAL |
+	OPT_PROTO_SLASH_COMMANDS_NATIVE,
+	NULL,					/* user_splits */
+	NULL,					/* protocol_options */
+	NO_BUDDY_ICONS,		/* icon_spec */
+	irc_blist_icon,		/* list_icon */
+	NULL,			/* list_emblems */
+	NULL,					/* status_text */
+	NULL,					/* tooltip_text */
+	irc_status_types,	/* away_states */
+	NULL,					/* blist_node_menu */
+	irc_chat_join_info,	/* chat_info */
+	irc_chat_info_defaults,	/* chat_info_defaults */
+	irc_login,		/* login */
+	irc_close,		/* close */
+	irc_im_send,		/* send_im */
+	NULL,					/* set_info */
+	NULL,					/* send_typing */
+	irc_get_info,		/* get_info */
+	irc_set_status,		/* set_status */
+	NULL,					/* set_idle */
+	NULL,					/* change_passwd */
+	irc_add_buddy,		/* add_buddy */
+	NULL,					/* add_buddies */
+	irc_remove_buddy,	/* remove_buddy */
+	NULL,					/* remove_buddies */
+	NULL,					/* add_permit */
+	NULL,					/* add_deny */
+	NULL,					/* rem_permit */
+	NULL,					/* rem_deny */
+	NULL,					/* set_permit_deny */
+	irc_chat_join,		/* join_chat */
+	NULL,					/* reject_chat */
+	irc_get_chat_name,	/* get_chat_name */
+	irc_chat_invite,	/* chat_invite */
+	irc_chat_leave,		/* chat_leave */
+	NULL,					/* chat_whisper */
+	irc_chat_send,		/* chat_send */
+	irc_keepalive,		/* keepalive */
+	NULL,					/* register_user */
+	NULL,					/* get_cb_info */
+	NULL,					/* get_cb_away */
+	NULL,					/* alias_buddy */
+	NULL,					/* group_buddy */
+	NULL,					/* rename_group */
+	NULL,					/* buddy_free */
+	NULL,					/* convo_closed */
+	purple_normalize_nocase,	/* normalize */
+	NULL,					/* set_buddy_icon */
+	NULL,					/* remove_group */
+	NULL,					/* get_cb_real_name */
+	irc_chat_set_topic,	/* set_chat_topic */
+	NULL,					/* find_blist_chat */
+	irc_roomlist_get_list,	/* roomlist_get_list */
+	irc_roomlist_cancel,	/* roomlist_cancel */
+	NULL,					/* roomlist_expand_category */
+	NULL,					/* can_receive_file */
+	irc_dccsend_send_file,	/* send_file */
+	irc_dccsend_new_xfer,	/* new_xfer */
+	NULL,					/* offline_message */
+	NULL,					/* whiteboard_prpl_ops */
+	irc_send_raw,			/* send_raw */
+	NULL,					/* roomlist_room_serialize */
+	NULL,                   /* unregister_user */
+	NULL,                   /* send_attention */
+	NULL,                   /* get_attention_types */
+	sizeof(PurplePluginProtocolInfo),    /* struct_size */
+	NULL,                    /* get_account_text_table */
+	NULL,                    /* initiate_media */
+	NULL,					 /* get_media_caps */
+	NULL,					 /* get_moods */
+	NULL,					 /* set_public_alias */
+	NULL,					 /* get_public_alias */
+	NULL,					 /* add_buddy_with_invite */
+	NULL					 /* add_buddies_with_invite */
+};
+
+static gboolean load_plugin (PurplePlugin *plugin) {
+
+	purple_signal_register(plugin, "irc-sending-text",
+			     purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+			     purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			     purple_value_new_outgoing(PURPLE_TYPE_STRING));
+	purple_signal_register(plugin, "irc-receiving-text",
+			     purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+			     purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			     purple_value_new_outgoing(PURPLE_TYPE_STRING));
+	return TRUE;
+}
+
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	PURPLE_MAJOR_VERSION,
+	PURPLE_MINOR_VERSION,
+	PURPLE_PLUGIN_PROTOCOL,                             /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                            /**< priority       */
+
+	"prpl-irc",                                       /**< id             */
+	"IRC",                                            /**< name           */
+	DISPLAY_VERSION,                                  /**< version        */
+	N_("IRC Protocol Plugin"),                        /**  summary        */
+	N_("The IRC Protocol Plugin that Sucks Less"),    /**  description    */
+	NULL,                                             /**< author         */
+	PURPLE_WEBSITE,                                     /**< homepage       */
+
+	load_plugin,                                      /**< load           */
+	NULL,                                             /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	&prpl_info,                                       /**< extra_info     */
+	NULL,                                             /**< prefs_info     */
+	irc_actions,
+
+	/* padding */
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void _init_plugin(PurplePlugin *plugin)
+{
+	PurpleAccountUserSplit *split;
+	PurpleAccountOption *option;
+
+	split = purple_account_user_split_new(_("Server"), IRC_DEFAULT_SERVER, '@');
+	prpl_info.user_splits = g_list_append(prpl_info.user_splits, split);
+
+	option = purple_account_option_int_new(_("Port"), "port", IRC_DEFAULT_PORT);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+	option = purple_account_option_string_new(_("Encodings"), "encoding", IRC_DEFAULT_CHARSET);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+	option = purple_account_option_bool_new(_("Auto-detect incoming UTF-8"), "autodetect_utf8", IRC_DEFAULT_AUTODETECT);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+	option = purple_account_option_string_new(_("Ident name"), "username", "");
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+	option = purple_account_option_string_new(_("Real name"), "realname", "");
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+	/*
+	option = purple_account_option_string_new(_("Quit message"), "quitmsg", IRC_DEFAULT_QUIT);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+	*/
+
+	option = purple_account_option_bool_new(_("Use SSL"), "ssl", FALSE);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+#ifdef HAVE_CYRUS_SASL
+	option = purple_account_option_bool_new(_("Authenticate with SASL"), "sasl", FALSE);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+	option = purple_account_option_bool_new(
+						_("Allow plaintext SASL auth over unencrypted connection"),
+						"auth_plain_in_clear", FALSE);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+#endif
+
+	_irc_plugin = plugin;
+
+	purple_prefs_remove("/plugins/prpl/irc/quitmsg");
+	purple_prefs_remove("/plugins/prpl/irc");
+
+	irc_register_commands();
+}
+
+PURPLE_INIT_PLUGIN(irc, _init_plugin, info);
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/irc/parse.c pidgin-2.10.11/libpurple/protocols/irc/parse.c
--- pidgin-2.10.11.orig/libpurple/protocols/irc/parse.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/irc/parse.c	2015-02-10 14:28:16.390685387 +0900
@@ -35,7 +35,7 @@
 #include <ctype.h>
 
 static char *irc_send_convert(struct irc_conn *irc, const char *string);
-static char *irc_recv_convert(struct irc_conn *irc, const char *string);
+static char *irc_recv_convert(struct irc_conn *irc, char *string);
 
 static void irc_parse_error_cb(struct irc_conn *irc, char *input);
 
@@ -178,6 +178,20 @@
 	{ NULL, NULL, NULL, NULL }
 };
 
+/* yaz */
+#define ASCII	0
+#define KANJI	1
+#define KANA	2
+#define ROMAN	3
+char seq_ascii[] = {0x1B,0x28,0x42,0x00}; /* ESC ( B */
+char seq_kanji[] = {0x1B,0x24,0x42,0x00}; /* ESC $ B */
+char seq_kana[]  = {0x1B,0x28,0x49,0x00}; /* ESC ( I */
+char seq_roman[] = {0x1B,0x28,0x4A,0x00}; /* ESC ( J */
+char *seq[4] = {seq_ascii, seq_kanji, seq_kana, seq_roman};
+char *jisstate[5] = {"ASCII", "KANJI", "KANA", "ROMAN"};
+char SO[] = {0x0E,0x00};
+char SI[] = {0x0F,0x00};
+
 static PurpleCmdRet irc_parse_purple_cmd(PurpleConversation *conv, const gchar *cmd,
                                         gchar **args, gchar **error, void *data)
 {
@@ -245,34 +259,111 @@
 	GError *err = NULL;
 	gchar **encodings;
 	const gchar *enclist;
+	char *escpos = NULL;
+	char *temp = NULL;
+	gboolean iskana = FALSE;
+	char *pos = NULL;
+	gboolean irc_use_sosi, irc_use_8bit;
+	char *strtmp;
+	gsize strtmp_len;
 
 	enclist = purple_account_get_string(irc->account, "encoding", IRC_DEFAULT_CHARSET);
 	encodings = g_strsplit(enclist, ",", 2);
 
+	irc_use_sosi = purple_account_get_bool(irc->account, "irc_use_sosi", FALSE);
+	irc_use_8bit = purple_account_get_bool(irc->account, "irc_use_8bit", FALSE);
+
 	if (encodings[0] == NULL || !g_ascii_strcasecmp("UTF-8", encodings[0])) {
 		g_strfreev(encodings);
 		return NULL;
 	}
 
-	utf8 = g_convert(string, strlen(string), encodings[0], "UTF-8", NULL, NULL, &err);
+	strtmp  = botch_utf(string, strlen(string), &strtmp_len);
+	utf8 = g_convert(strtmp, strlen(strtmp), encodings[0], "UTF-8", NULL, NULL, &err);
+
 	if (err) {
 		purple_debug(PURPLE_DEBUG_ERROR, "irc", "Send conversion error: %s\n", err->message);
 		purple_debug(PURPLE_DEBUG_ERROR, "irc", "Sending as UTF-8 instead of %s\n", encodings[0]);
-		utf8 = g_strdup(string);
+		utf8 = g_strdup(strtmp);
 		g_error_free(err);
 	}
-	g_strfreev(encodings);
 
+	/* yaz */
+	if (!strncasecmp("iso-2022-jp", encodings[0], strlen("iso-2022-jp"))) {
+		escpos = strrchr(utf8, 0x1B);
+		if(escpos && (!strncmp(seq_kanji, escpos, 3) || !strncmp(seq_kana, escpos, 3))){
+			char *oldutf8 = utf8;
+			utf8 = g_realloc(utf8, strlen(utf8)+1+3);
+			if(utf8)
+				strncat(utf8, seq_ascii, 3);
+			else
+				utf8 = oldutf8;
+		}
+
+		if(irc_use_sosi || irc_use_8bit){
+			/* SO/SI */
+			//find kana escape and replace with roman+SO
+			temp = g_malloc0(strlen(utf8) * 7); //XXX should be reasonable size
+			pos = utf8;
+			while(pos < utf8+strlen(utf8)){
+				escpos = strchr(pos, 0x1B);
+				if(escpos){
+					if(!strncmp(seq_kana, escpos, 3)){ /* kana found */
+						iskana = TRUE;
+						strncat(temp, pos, escpos-pos);
+						strcat(temp, seq_roman);
+						if(irc_use_sosi)
+							strcat(temp, SO);
+						pos = escpos+3;
+					} else {
+						if(iskana){
+							char *ptr;
+							ptr = temp + strlen(temp);
+							while(pos<escpos){
+								if(irc_use_8bit)
+									*ptr = *pos + 128; // convert to 8bit
+								else
+									*ptr = *pos;
+								ptr++; pos++;
+							}
+							if(irc_use_sosi)
+								strcat(temp, SI);
+							strncat(temp, escpos, 3);
+							pos = escpos+3;
+							iskana = FALSE;
+						} else {
+							strncat(temp, pos, escpos-pos+3); //include esc
+							pos = escpos+3;
+						}
+					}
+				} else { /* escpos == NULL */
+					strcat(temp, pos);
+					break;
+				}
+			}
+			g_free(utf8);
+			utf8 = temp;
+		}
+	}
+
+	g_strfreev(encodings);
+	g_free(strtmp);
 	return utf8;
 }
 
-static char *irc_recv_convert(struct irc_conn *irc, const char *string)
+static char *irc_recv_convert(struct irc_conn *irc, char *string)
 {
 	char *utf8 = NULL;
 	const gchar *charset, *enclist;
 	gchar **encodings;
 	gboolean autodetect;
 	int i;
+	GError *err;
+	gboolean retry;
+	gsize in_len, out_len;
+	int conv_len;
+	char *strtmp;
+	gsize strtmp_len;
 
 	autodetect = purple_account_get_bool(irc->account, "autodetect_utf8", IRC_DEFAULT_AUTODETECT);
 
@@ -296,13 +387,123 @@
 		if (!g_ascii_strcasecmp("UTF-8", charset)) {
 			if (g_utf8_validate(string, -1, NULL))
 				utf8 = g_strdup(string);
+		} else if (!strncasecmp("iso-2022-jp-2", charset, strlen("iso-2022-jp-2"))){
+			/* pre-process quirky jis */
+			unsigned char *jisstr;
+			unsigned char *ptr, *ptr2;
+			int state = ASCII;
+			int is8bit = FALSE;
+
+			jisstr = (unsigned char *)calloc(1, strlen(string)*7); /* enough? */
+			ptr = (unsigned char *)string; ptr2 = jisstr;
+
+			while(*ptr){
+				if(*ptr == 0x1B){
+					/* escape sequence. */
+					if(*(ptr+1) == 0x28 && *(ptr+2) == 0x42){
+						state = ASCII;
+
+					} else if(*(ptr+1) == 0x24 && *(ptr+2) == 0x42){
+						state = KANJI;
+
+					} else if(*(ptr+1) == 0x28 && *(ptr+2) == 0x49){
+						state = KANA;
+
+					} else if(*(ptr+1) == 0x28 && *(ptr+2) == 0x4a){
+						state = ROMAN;
+
+					}
+					purple_debug(PURPLE_DEBUG_INFO, "irc", "state %s\n", jisstate[state]);
+				}
+				if(*ptr >= 0xA1 && *ptr <= 0xDF){
+					/* raw 8bit */
+					if(!is8bit){
+						strcat((char *)jisstr, seq[KANA]);
+						ptr2 += 3;
+						is8bit = TRUE;
+						purple_debug(PURPLE_DEBUG_INFO, "irc", "8bit = TRUE\n");
+					}
+					*ptr2 = *ptr - 0x80;
+					ptr++ ; ptr2++;
+				} else {
+					/* 7bit */
+					if(*ptr == 0x0E){
+						/* SO */
+						strcat((char *)jisstr, seq[KANA]);
+						ptr++; ptr2 += 3;
+						purple_debug(PURPLE_DEBUG_INFO, "irc", "SO\n");
+						continue;
+					} else if(*ptr == 0x0F){
+						/* SI */
+						strcat((char *)jisstr, seq[state]);
+						purple_debug(PURPLE_DEBUG_INFO, "irc", "SI to %s\n", jisstate[state]);
+						ptr++; ptr2 += 3;
+						purple_debug(PURPLE_DEBUG_INFO, "irc", "SI\n");
+						continue;
+					}
+					if(is8bit){ /* the edge of 8bit -> 7bit */
+						purple_debug(PURPLE_DEBUG_INFO, "irc", "8bit to %s\n", jisstate[state]);
+						strcat((char *)jisstr, seq[state]);
+						ptr2 += 3;
+						is8bit=FALSE;
+						purple_debug(PURPLE_DEBUG_INFO, "irc", "8bit = FALSE\n");
+					}
+					/* copy str */
+					*ptr2 = *ptr;
+					ptr++; ptr2++;
+				}
+			}
+
+			/* convert & error recovery */
+			do {
+				err = NULL;
+				retry = FALSE;
+
+				conv_len = strlen((char *)jisstr);
+				utf8 = g_convert_with_fallback((char *)jisstr, conv_len, "UTF-8", charset,
+							       "?", &in_len, &out_len, &err);
+				if(err != NULL){
+					if(err->code == G_CONVERT_ERROR_ILLEGAL_SEQUENCE){
+						memmove(jisstr + in_len, jisstr + in_len + 1,
+							conv_len - in_len -1);
+						conv_len--;
+						*(jisstr + conv_len) = '\0';
+						retry = TRUE;
+					}
+					g_error_free(err);
+				}
+			} while(retry);
+
+			if(jisstr)
+				free(jisstr);
+
 		} else {
-			utf8 = g_convert(string, -1, "UTF-8", charset, NULL, NULL, NULL);
+			do {
+				err = NULL;
+				retry = FALSE;
+
+				conv_len = strlen(string);
+				utf8 = g_convert_with_fallback(string, conv_len, "UTF-8", charset,
+							       "?", &in_len, &out_len, &err);
+				if(err != NULL){
+					if(err->code == G_CONVERT_ERROR_ILLEGAL_SEQUENCE){
+						memmove(string + in_len, string + in_len + 1,
+							 conv_len - in_len -1);
+						conv_len--;
+						*(string + conv_len) = '\0';
+						retry = TRUE;
+					}
+					g_error_free(err);
+				}
+			} while(retry);
 		}
 
-		if (utf8) {
-			g_strfreev(encodings);
-			return utf8;
+
+		if(utf8){
+			strtmp = sanitize_utf(utf8, strlen(utf8), &strtmp_len);
+ 			g_strfreev(encodings);
+			g_free(utf8);
+			return strtmp;
 		}
 	}
 	g_strfreev(encodings);
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/jabber/jabber.c pidgin-2.10.11/libpurple/protocols/jabber/jabber.c
--- pidgin-2.10.11.orig/libpurple/protocols/jabber/jabber.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/jabber/jabber.c	2015-02-10 14:28:16.390685387 +0900
@@ -588,8 +588,9 @@
                            gpointer unused)
 {
 	JabberStream *js;
-	char *txt;
+	char *txt, *utf;
 	int len;
+	gsize utflen;
 
 	if (NULL == packet)
 		return;
@@ -607,8 +608,9 @@
 				g_str_equal((*packet)->name, "presence"))
 			xmlnode_set_namespace(*packet, NS_XMPP_CLIENT);
 	txt = xmlnode_to_str(*packet, &len);
-	jabber_send_raw(js, txt, len);
-	g_free(txt);
+	utf = botch_utf(txt, len, &utflen); //yaz
+	jabber_send_raw(js, utf, utflen);
+	g_free(txt); g_free(utf);
 }
 
 void jabber_send(JabberStream *js, xmlnode *packet)
@@ -2329,6 +2331,7 @@
 				const char *title = purple_status_get_attr_string(tune, PURPLE_TUNE_TITLE);
 				const char *artist = purple_status_get_attr_string(tune, PURPLE_TUNE_ARTIST);
 				const char *album = purple_status_get_attr_string(tune, PURPLE_TUNE_ALBUM);
+
 				char *playing = purple_util_format_song_info(title, artist, album, NULL);
 				if (playing) {
 					purple_notify_user_info_add_pair(user_info, _("Now Listening"), playing);
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/jabber/jabber.c.orig pidgin-2.10.11/libpurple/protocols/jabber/jabber.c.orig
--- pidgin-2.10.11.orig/libpurple/protocols/jabber/jabber.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/jabber/jabber.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,4065 @@
+/*
+ * purple - Jabber Protocol Plugin
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+#include "internal.h"
+
+#include "account.h"
+#include "accountopt.h"
+#include "blist.h"
+#include "core.h"
+#include "cmds.h"
+#include "connection.h"
+#include "conversation.h"
+#include "debug.h"
+#include "dnssrv.h"
+#include "imgstore.h"
+#include "message.h"
+#include "notify.h"
+#include "pluginpref.h"
+#include "privacy.h"
+#include "proxy.h"
+#include "prpl.h"
+#include "request.h"
+#include "server.h"
+#include "status.h"
+#include "util.h"
+#include "version.h"
+#include "xmlnode.h"
+
+#include "auth.h"
+#include "buddy.h"
+#include "caps.h"
+#include "chat.h"
+#include "data.h"
+#include "disco.h"
+#include "google/google.h"
+#include "google/google_roster.h"
+#include "google/google_session.h"
+#include "ibb.h"
+#include "iq.h"
+#include "jutil.h"
+#include "message.h"
+#include "parser.h"
+#include "presence.h"
+#include "jabber.h"
+#include "roster.h"
+#include "ping.h"
+#include "si.h"
+#include "usermood.h"
+#include "xdata.h"
+#include "pep.h"
+#include "adhoccommands.h"
+
+#include "jingle/jingle.h"
+#include "jingle/rtp.h"
+
+#define PING_TIMEOUT 60
+/* Send a whitespace keepalive to the server if we haven't sent
+ * anything in the last 120 seconds
+ */
+#define DEFAULT_INACTIVITY_TIME 120
+
+GList *jabber_features = NULL;
+GList *jabber_identities = NULL;
+
+static GHashTable *jabber_cmds = NULL; /* PurplePlugin * => GSList of ids */
+
+static gint plugin_ref = 0;
+
+static void jabber_unregister_account_cb(JabberStream *js);
+static void try_srv_connect(JabberStream *js);
+
+static void jabber_stream_init(JabberStream *js)
+{
+	char *open_stream;
+
+	if (js->stream_id) {
+		g_free(js->stream_id);
+		js->stream_id = NULL;
+	}
+
+	open_stream = g_strdup_printf("<stream:stream to='%s' "
+				          "xmlns='" NS_XMPP_CLIENT "' "
+						  "xmlns:stream='" NS_XMPP_STREAMS "' "
+						  "version='1.0'>",
+						  js->user->domain);
+	/* setup the parser fresh for each stream */
+	jabber_parser_setup(js);
+	jabber_send_raw(js, open_stream, -1);
+	js->reinit = FALSE;
+	g_free(open_stream);
+}
+
+static void
+jabber_session_initialized_cb(JabberStream *js, const char *from,
+                              JabberIqType type, const char *id,
+                              xmlnode *packet, gpointer data)
+{
+	if (type == JABBER_IQ_RESULT) {
+		jabber_disco_items_server(js);
+		if(js->unregistration)
+			jabber_unregister_account_cb(js);
+	} else {
+		purple_connection_error_reason(js->gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+			("Error initializing session"));
+	}
+}
+
+static void jabber_session_init(JabberStream *js)
+{
+	JabberIq *iq = jabber_iq_new(js, JABBER_IQ_SET);
+	xmlnode *session;
+
+	jabber_iq_set_callback(iq, jabber_session_initialized_cb, NULL);
+
+	session = xmlnode_new_child(iq->node, "session");
+	xmlnode_set_namespace(session, NS_XMPP_SESSION);
+
+	jabber_iq_send(iq);
+}
+
+static void jabber_bind_result_cb(JabberStream *js, const char *from,
+                                  JabberIqType type, const char *id,
+                                  xmlnode *packet, gpointer data)
+{
+	xmlnode *bind;
+
+	if (type == JABBER_IQ_RESULT &&
+			(bind = xmlnode_get_child_with_namespace(packet, "bind", NS_XMPP_BIND))) {
+		xmlnode *jid;
+		char *full_jid;
+		if((jid = xmlnode_get_child(bind, "jid")) && (full_jid = xmlnode_get_data(jid))) {
+			jabber_id_free(js->user);
+
+			js->user = jabber_id_new(full_jid);
+			if (js->user == NULL) {
+				purple_connection_error_reason(js->gc,
+					PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+					_("Invalid response from server"));
+				g_free(full_jid);
+				return;
+			}
+
+			js->user_jb = jabber_buddy_find(js, full_jid, TRUE);
+			js->user_jb->subscription |= JABBER_SUB_BOTH;
+
+			purple_connection_set_display_name(js->gc, full_jid);
+
+			g_free(full_jid);
+		}
+	} else {
+		PurpleConnectionError reason = PURPLE_CONNECTION_ERROR_NETWORK_ERROR;
+		char *msg = jabber_parse_error(js, packet, &reason);
+		purple_connection_error_reason(js->gc, reason, msg);
+		g_free(msg);
+
+		return;
+	}
+
+	jabber_session_init(js);
+}
+
+static char *jabber_prep_resource(char *input) {
+	char hostname[256], /* current hostname */
+		 *dot = NULL;
+
+	/* Empty resource == don't send any */
+	if (input == NULL || *input == '\0')
+		return NULL;
+
+	if (strstr(input, "__HOSTNAME__") == NULL)
+		return g_strdup(input);
+
+	/* Replace __HOSTNAME__ with hostname */
+	if (gethostname(hostname, sizeof(hostname) - 1)) {
+		purple_debug_warning("jabber", "gethostname: %s\n", g_strerror(errno));
+		/* according to glibc doc, the only time an error is returned
+		   is if the hostname is longer than the buffer, in which case
+		   glibc 2.2+ would still fill the buffer with partial
+		   hostname, so maybe we want to detect that and use it
+		   instead
+		*/
+		g_strlcpy(hostname, "localhost", sizeof(hostname));
+	}
+	hostname[sizeof(hostname) - 1] = '\0';
+
+	/* We want only the short hostname, not the FQDN - this will prevent the
+	 * resource string from being unreasonably long on systems which stuff the
+	 * whole FQDN in the hostname */
+	if((dot = strchr(hostname, '.')))
+		*dot = '\0';
+
+	return purple_strreplace(input, "__HOSTNAME__", hostname);
+}
+
+static gboolean
+jabber_process_starttls(JabberStream *js, xmlnode *packet)
+{
+	PurpleAccount *account;
+	xmlnode *starttls;
+
+	account = purple_connection_get_account(js->gc);
+
+#if 0
+	/*
+	 * This code DOES NOT EXIST, will never be enabled by default, and
+	 * will never ever be supported (by me).
+	 * It's literally *only* for developer testing.
+	 */
+	{
+		const gchar *connection_security = purple_account_get_string(account, "connection_security", JABBER_DEFAULT_REQUIRE_TLS);
+		if (!g_str_equal(connection_security, "none") &&
+				purple_ssl_is_supported()) {
+			jabber_send_raw(js,
+					"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>", -1);
+			return TRUE;
+		}
+	}
+#else
+	if(purple_ssl_is_supported()) {
+		jabber_send_raw(js,
+				"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>", -1);
+		return TRUE;
+	} else {
+		purple_debug_warning("jabber", "No libpurple TLS/SSL support found.");
+	}
+#endif
+
+	starttls = xmlnode_get_child(packet, "starttls");
+	if(xmlnode_get_child(starttls, "required")) {
+		purple_connection_error_reason(js->gc,
+				PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,
+				_("Server requires TLS/SSL, but no TLS/SSL support was found."));
+		return TRUE;
+	}
+
+	if (g_str_equal("require_tls", purple_account_get_string(account, "connection_security", JABBER_DEFAULT_REQUIRE_TLS))) {
+		purple_connection_error_reason(js->gc,
+				PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,
+				_("You require encryption, but no TLS/SSL support was found."));
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+void jabber_stream_features_parse(JabberStream *js, xmlnode *packet)
+{
+	PurpleAccount *account = purple_connection_get_account(js->gc);
+	const char *connection_security =
+		purple_account_get_string(account, "connection_security", JABBER_DEFAULT_REQUIRE_TLS);
+
+	if (xmlnode_get_child(packet, "starttls")) {
+		if (jabber_process_starttls(js, packet)) {
+			jabber_stream_set_state(js, JABBER_STREAM_INITIALIZING_ENCRYPTION);
+			return;
+		}
+	} else if (g_str_equal(connection_security, "require_tls") && !jabber_stream_is_ssl(js)) {
+		purple_connection_error_reason(js->gc,
+			 PURPLE_CONNECTION_ERROR_ENCRYPTION_ERROR,
+			_("You require encryption, but it is not available on this server."));
+		return;
+	}
+
+	if(js->registration) {
+		jabber_register_start(js);
+	} else if(xmlnode_get_child(packet, "mechanisms")) {
+		jabber_stream_set_state(js, JABBER_STREAM_AUTHENTICATING);
+		jabber_auth_start(js, packet);
+	} else if(xmlnode_get_child(packet, "bind")) {
+		xmlnode *bind, *resource;
+		char *requested_resource;
+		JabberIq *iq = jabber_iq_new(js, JABBER_IQ_SET);
+		bind = xmlnode_new_child(iq->node, "bind");
+		xmlnode_set_namespace(bind, NS_XMPP_BIND);
+		requested_resource = jabber_prep_resource(js->user->resource);
+
+		if (requested_resource != NULL) {
+			resource = xmlnode_new_child(bind, "resource");
+			xmlnode_insert_data(resource, requested_resource, -1);
+			g_free(requested_resource);
+		}
+
+		jabber_iq_set_callback(iq, jabber_bind_result_cb, NULL);
+
+		jabber_iq_send(iq);
+	} else if (xmlnode_get_child_with_namespace(packet, "ver", NS_ROSTER_VERSIONING)) {
+		js->server_caps |= JABBER_CAP_ROSTER_VERSIONING;
+	} else /* if(xmlnode_get_child_with_namespace(packet, "auth")) */ {
+		/* If we get an empty stream:features packet, or we explicitly get
+		 * an auth feature with namespace http://jabber.org/features/iq-auth
+		 * we should revert back to iq:auth authentication, even though we're
+		 * connecting to an XMPP server.  */
+		jabber_stream_set_state(js, JABBER_STREAM_AUTHENTICATING);
+		jabber_auth_start_old(js);
+	}
+}
+
+static void jabber_stream_handle_error(JabberStream *js, xmlnode *packet)
+{
+	PurpleConnectionError reason = PURPLE_CONNECTION_ERROR_NETWORK_ERROR;
+	char *msg = jabber_parse_error(js, packet, &reason);
+
+	purple_connection_error_reason(js->gc, reason, msg);
+
+	g_free(msg);
+}
+
+static void tls_init(JabberStream *js);
+
+void jabber_process_packet(JabberStream *js, xmlnode **packet)
+{
+	const char *name;
+	const char *xmlns;
+
+	purple_signal_emit(purple_connection_get_prpl(js->gc), "jabber-receiving-xmlnode", js->gc, packet);
+
+	/* if the signal leaves us with a null packet, we're done */
+	if(NULL == *packet)
+		return;
+
+	name = (*packet)->name;
+	xmlns = xmlnode_get_namespace(*packet);
+
+	if(!strcmp((*packet)->name, "iq")) {
+		jabber_iq_parse(js, *packet);
+	} else if(!strcmp((*packet)->name, "presence")) {
+		jabber_presence_parse(js, *packet);
+	} else if(!strcmp((*packet)->name, "message")) {
+		jabber_message_parse(js, *packet);
+	} else if (purple_strequal(xmlns, NS_XMPP_STREAMS)) {
+		if (g_str_equal(name, "features"))
+			jabber_stream_features_parse(js, *packet);
+		else if (g_str_equal(name, "error"))
+			jabber_stream_handle_error(js, *packet);
+	} else if (purple_strequal(xmlns, NS_XMPP_SASL)) {
+		if (js->state != JABBER_STREAM_AUTHENTICATING)
+			purple_debug_warning("jabber", "Ignoring spurious SASL stanza %s\n", name);
+		else {
+			if (g_str_equal(name, "challenge"))
+				jabber_auth_handle_challenge(js, *packet);
+			else if (g_str_equal(name, "success"))
+				jabber_auth_handle_success(js, *packet);
+			else if (g_str_equal(name, "failure"))
+				jabber_auth_handle_failure(js, *packet);
+		}
+	} else if (purple_strequal(xmlns, NS_XMPP_TLS)) {
+		if (js->state != JABBER_STREAM_INITIALIZING_ENCRYPTION || js->gsc)
+			purple_debug_warning("jabber", "Ignoring spurious %s\n", name);
+		else {
+			if (g_str_equal(name, "proceed"))
+				tls_init(js);
+			/* TODO: Handle <failure/>, I guess? */
+		}
+	} else {
+		purple_debug_warning("jabber", "Unknown packet: %s\n", (*packet)->name);
+	}
+}
+
+static int jabber_do_send(JabberStream *js, const char *data, int len)
+{
+	int ret;
+
+	if (js->gsc)
+		ret = purple_ssl_write(js->gsc, data, len);
+	else
+		ret = write(js->fd, data, len);
+
+	return ret;
+}
+
+static void jabber_send_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	JabberStream *js = data;
+	int ret, writelen;
+	writelen = purple_circ_buffer_get_max_read(js->write_buffer);
+
+	if (writelen == 0) {
+		purple_input_remove(js->writeh);
+		js->writeh = 0;
+		return;
+	}
+
+	ret = jabber_do_send(js, js->write_buffer->outptr, writelen);
+
+	if (ret < 0 && errno == EAGAIN)
+		return;
+	else if (ret <= 0) {
+		gchar *tmp = g_strdup_printf(_("Lost connection with server: %s"),
+				g_strerror(errno));
+		purple_connection_error_reason(js->gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	}
+
+	purple_circ_buffer_mark_read(js->write_buffer, ret);
+}
+
+static gboolean do_jabber_send_raw(JabberStream *js, const char *data, int len)
+{
+	int ret;
+	gboolean success = TRUE;
+
+	g_return_val_if_fail(len > 0, FALSE);
+
+	if (js->state == JABBER_STREAM_CONNECTED)
+		jabber_stream_restart_inactivity_timer(js);
+
+	if (js->writeh == 0)
+		ret = jabber_do_send(js, data, len);
+	else {
+		ret = -1;
+		errno = EAGAIN;
+	}
+
+	if (ret < 0 && errno != EAGAIN) {
+		PurpleAccount *account = purple_connection_get_account(js->gc);
+		/*
+		 * The server may have closed the socket (on a stream error), so if
+		 * we're disconnecting, don't generate (possibly another) error that
+		 * (for some UIs) would mask the first.
+		 */
+		if (!account->disconnecting) {
+			gchar *tmp = g_strdup_printf(_("Lost connection with server: %s"),
+					g_strerror(errno));
+			purple_connection_error_reason(js->gc,
+				PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+			g_free(tmp);
+		}
+
+		success = FALSE;
+	} else if (ret < len) {
+		if (ret < 0)
+			ret = 0;
+		if (js->writeh == 0)
+			js->writeh = purple_input_add(
+				js->gsc ? js->gsc->fd : js->fd,
+				PURPLE_INPUT_WRITE, jabber_send_cb, js);
+		purple_circ_buffer_append(js->write_buffer,
+			data + ret, len - ret);
+	}
+
+	return success;
+}
+
+void jabber_send_raw(JabberStream *js, const char *data, int len)
+{
+	PurpleConnection *gc;
+	PurpleAccount *account;
+
+	gc = js->gc;
+	account = purple_connection_get_account(gc);
+
+	g_return_if_fail(data != NULL);
+
+	/* because printing a tab to debug every minute gets old */
+	if (data && strcmp(data, "\t") != 0) {
+		const char *username;
+		char *text = NULL, *last_part = NULL, *tag_start = NULL;
+
+		/* Because debug logs with plaintext passwords make me sad */
+		if (!purple_debug_is_unsafe() && js->state != JABBER_STREAM_CONNECTED &&
+				/* Either <auth> or <query><password>... */
+				(((tag_start = strstr(data, "<auth ")) &&
+					strstr(data, "xmlns='" NS_XMPP_SASL "'")) ||
+				((tag_start = strstr(data, "<query ")) &&
+					strstr(data, "xmlns='jabber:iq:auth'>") &&
+					(tag_start = strstr(tag_start, "<password>"))))) {
+			char *data_start, *tag_end = strchr(tag_start, '>');
+			text = g_strdup(data);
+
+			/* Better to print out some wacky debugging than crash
+			 * due to a plugin sending bad xml */
+			if (tag_end == NULL)
+				tag_end = tag_start;
+
+			data_start = text + (tag_end - data) + 1;
+
+			last_part = strchr(data_start, '<');
+			*data_start = '\0';
+		}
+
+		username = purple_connection_get_display_name(gc);
+		if (!username)
+			username = purple_account_get_username(account);
+
+		purple_debug_misc("jabber", "Sending%s (%s): %s%s%s\n",
+				jabber_stream_is_ssl(js) ? " (ssl)" : "", username,
+				text ? text : data,
+				last_part ? "password removed" : "",
+				last_part ? last_part : "");
+
+		g_free(text);
+	}
+
+	purple_signal_emit(purple_connection_get_prpl(gc), "jabber-sending-text", gc, &data);
+	if (data == NULL)
+		return;
+
+	if (len == -1)
+		len = strlen(data);
+
+	/* If we've got a security layer, we need to encode the data,
+	 * splitting it on the maximum buffer length negotiated */
+#ifdef HAVE_CYRUS_SASL
+	if (js->sasl_maxbuf>0) {
+		int pos = 0;
+
+		if (!js->gsc && js->fd<0)
+			g_return_if_reached();
+
+		while (pos < len) {
+			int towrite;
+			const char *out;
+			unsigned olen;
+			int rc;
+
+			towrite = MIN((len - pos), js->sasl_maxbuf);
+
+			rc = sasl_encode(js->sasl, &data[pos], towrite,
+			                 &out, &olen);
+			if (rc != SASL_OK) {
+				gchar *error =
+					g_strdup_printf(_("SASL error: %s"),
+						sasl_errdetail(js->sasl));
+				purple_debug_error("jabber",
+					"sasl_encode error %d: %s\n", rc,
+					sasl_errdetail(js->sasl));
+				purple_connection_error_reason(gc,
+					PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+					error);
+				g_free(error);
+				return;
+			}
+			pos += towrite;
+
+			/* do_jabber_send_raw returns FALSE when it throws a
+			 * connection error.
+			 */
+			if (!do_jabber_send_raw(js, out, olen))
+				break;
+		}
+		return;
+	}
+#endif
+
+	if (js->bosh)
+		jabber_bosh_connection_send_raw(js->bosh, data);
+	else
+		do_jabber_send_raw(js, data, len);
+}
+
+int jabber_prpl_send_raw(PurpleConnection *gc, const char *buf, int len)
+{
+	JabberStream *js = purple_connection_get_protocol_data(gc);
+
+	g_return_val_if_fail(js != NULL, -1);
+	/* TODO: It's probably worthwhile to restrict this to when the account
+	 * state is CONNECTED, but I can /almost/ envision reasons for wanting
+	 * to do things during the connection process.
+	 */
+
+	jabber_send_raw(js, buf, len);
+	return (len < 0 ? (int)strlen(buf) : len);
+}
+
+void jabber_send_signal_cb(PurpleConnection *pc, xmlnode **packet,
+                           gpointer unused)
+{
+	JabberStream *js;
+	char *txt;
+	int len;
+
+	if (NULL == packet)
+		return;
+
+	g_return_if_fail(PURPLE_CONNECTION_IS_VALID(pc));
+
+	js = purple_connection_get_protocol_data(pc);
+
+	if (NULL == js)
+		return;
+
+	if (js->bosh)
+		if (g_str_equal((*packet)->name, "message") ||
+				g_str_equal((*packet)->name, "iq") ||
+				g_str_equal((*packet)->name, "presence"))
+			xmlnode_set_namespace(*packet, NS_XMPP_CLIENT);
+	txt = xmlnode_to_str(*packet, &len);
+	jabber_send_raw(js, txt, len);
+	g_free(txt);
+}
+
+void jabber_send(JabberStream *js, xmlnode *packet)
+{
+	purple_signal_emit(purple_connection_get_prpl(js->gc), "jabber-sending-xmlnode", js->gc, &packet);
+}
+
+static gboolean jabber_keepalive_timeout(PurpleConnection *gc)
+{
+	JabberStream *js = gc->proto_data;
+	purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+					_("Ping timed out"));
+	js->keepalive_timeout = 0;
+	return FALSE;
+}
+
+void jabber_keepalive(PurpleConnection *gc)
+{
+	JabberStream *js = purple_connection_get_protocol_data(gc);
+	time_t now = time(NULL);
+
+	if (js->keepalive_timeout == 0 && (now - js->last_ping) >= PING_TIMEOUT) {
+		js->last_ping = now;
+
+		jabber_keepalive_ping(js);
+		js->keepalive_timeout = purple_timeout_add_seconds(120,
+				(GSourceFunc)(jabber_keepalive_timeout), gc);
+	}
+}
+
+static void
+jabber_recv_cb_ssl(gpointer data, PurpleSslConnection *gsc,
+		PurpleInputCondition cond)
+{
+	PurpleConnection *gc = data;
+	JabberStream *js = gc->proto_data;
+	int len;
+	static char buf[4096];
+
+	/* TODO: It should be possible to make this check unnecessary */
+	if(!PURPLE_CONNECTION_IS_VALID(gc)) {
+		purple_ssl_close(gsc);
+		g_return_if_reached();
+	}
+
+	while((len = purple_ssl_read(gsc, buf, sizeof(buf) - 1)) > 0) {
+		gc->last_received = time(NULL);
+		buf[len] = '\0';
+		purple_debug_info("jabber", "Recv (ssl)(%d): %s\n", len, buf);
+		jabber_parser_process(js, buf, len);
+		if(js->reinit)
+			jabber_stream_init(js);
+	}
+
+	if(len < 0 && errno == EAGAIN)
+		return;
+	else {
+		gchar *tmp;
+		if (len == 0)
+			tmp = g_strdup(_("Server closed the connection"));
+		else
+			tmp = g_strdup_printf(_("Lost connection with server: %s"),
+					g_strerror(errno));
+		purple_connection_error_reason(js->gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+	}
+}
+
+static void
+jabber_recv_cb(gpointer data, gint source, PurpleInputCondition condition)
+{
+	PurpleConnection *gc = data;
+	JabberStream *js = purple_connection_get_protocol_data(gc);
+	int len;
+	static char buf[4096];
+
+	g_return_if_fail(PURPLE_CONNECTION_IS_VALID(gc));
+
+	if((len = read(js->fd, buf, sizeof(buf) - 1)) > 0) {
+		gc->last_received = time(NULL);
+#ifdef HAVE_CYRUS_SASL
+		if (js->sasl_maxbuf > 0) {
+			const char *out;
+			unsigned int olen;
+			int rc;
+
+			rc = sasl_decode(js->sasl, buf, len, &out, &olen);
+			if (rc != SASL_OK) {
+				gchar *error =
+					g_strdup_printf(_("SASL error: %s"),
+						sasl_errdetail(js->sasl));
+				purple_debug_error("jabber",
+					"sasl_decode_error %d: %s\n", rc,
+					sasl_errdetail(js->sasl));
+				purple_connection_error_reason(gc,
+					PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+					error);
+			} else if (olen > 0) {
+				purple_debug_info("jabber", "RecvSASL (%u): %s\n", olen, out);
+				jabber_parser_process(js, out, olen);
+				if (js->reinit)
+					jabber_stream_init(js);
+			}
+			return;
+		}
+#endif
+		buf[len] = '\0';
+		purple_debug_info("jabber", "Recv (%d): %s\n", len, buf);
+		jabber_parser_process(js, buf, len);
+		if(js->reinit)
+			jabber_stream_init(js);
+	} else if(len < 0 && errno == EAGAIN) {
+		return;
+	} else {
+		gchar *tmp;
+		if (len == 0)
+			tmp = g_strdup(_("Server closed the connection"));
+		else
+			tmp = g_strdup_printf(_("Lost connection with server: %s"),
+					g_strerror(errno));
+		purple_connection_error_reason(js->gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+	}
+}
+
+static void
+jabber_login_callback_ssl(gpointer data, PurpleSslConnection *gsc,
+		PurpleInputCondition cond)
+{
+	PurpleConnection *gc = data;
+	JabberStream *js;
+
+	/* TODO: It should be possible to make this check unnecessary */
+	if(!PURPLE_CONNECTION_IS_VALID(gc)) {
+		purple_ssl_close(gsc);
+		g_return_if_reached();
+	}
+
+	js = gc->proto_data;
+
+	if(js->state == JABBER_STREAM_CONNECTING)
+		jabber_send_raw(js, "<?xml version='1.0' ?>", -1);
+	jabber_stream_set_state(js, JABBER_STREAM_INITIALIZING);
+	purple_ssl_input_add(gsc, jabber_recv_cb_ssl, gc);
+
+	/* Tell the app that we're doing encryption */
+	jabber_stream_set_state(js, JABBER_STREAM_INITIALIZING_ENCRYPTION);
+}
+
+static void
+txt_resolved_cb(GList *responses, gpointer data)
+{
+	JabberStream *js = data;
+	gboolean found = FALSE;
+
+	js->srv_query_data = NULL;
+
+	while (responses) {
+		PurpleTxtResponse *resp = responses->data;
+		gchar **token;
+		token = g_strsplit(purple_txt_response_get_content(resp), "=", 2);
+		if (!strcmp(token[0], "_xmpp-client-xbosh")) {
+			purple_debug_info("jabber","Found alternative connection method using %s at %s.\n", token[0], token[1]);
+			js->bosh = jabber_bosh_connection_init(js, token[1]);
+			g_strfreev(token);
+			break;
+		}
+		g_strfreev(token);
+		purple_txt_response_destroy(resp);
+		responses = g_list_delete_link(responses, responses);
+	}
+
+	if (js->bosh) {
+		found = TRUE;
+		jabber_bosh_connection_connect(js->bosh);
+	}
+
+	if (!found) {
+		purple_debug_warning("jabber", "Unable to find alternative XMPP connection "
+				  "methods after failing to connect directly.\n");
+		purple_connection_error_reason(js->gc,
+				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+				_("Unable to connect"));
+		return;
+	}
+
+	if (responses) {
+		g_list_foreach(responses, (GFunc)purple_txt_response_destroy, NULL);
+		g_list_free(responses);
+	}
+}
+
+static void
+jabber_login_callback(gpointer data, gint source, const gchar *error)
+{
+	PurpleConnection *gc = data;
+	JabberStream *js = purple_connection_get_protocol_data(gc);
+
+	if (source < 0) {
+		if (js->srv_rec != NULL) {
+			purple_debug_error("jabber", "Unable to connect to server: %s.  Trying next SRV record or connecting directly.\n", error);
+			try_srv_connect(js);
+		} else {
+			purple_debug_info("jabber","Couldn't connect directly to %s.  Trying to find alternative connection methods, like BOSH.\n", js->user->domain);
+			js->srv_query_data = purple_txt_resolve_account(
+					purple_connection_get_account(gc), "_xmppconnect",
+					js->user->domain, txt_resolved_cb, js);
+		}
+		return;
+	}
+
+	g_free(js->srv_rec);
+	js->srv_rec = NULL;
+
+	js->fd = source;
+
+	if(js->state == JABBER_STREAM_CONNECTING)
+		jabber_send_raw(js, "<?xml version='1.0' ?>", -1);
+
+	jabber_stream_set_state(js, JABBER_STREAM_INITIALIZING);
+	gc->inpa = purple_input_add(js->fd, PURPLE_INPUT_READ, jabber_recv_cb, gc);
+}
+
+static void
+jabber_ssl_connect_failure(PurpleSslConnection *gsc, PurpleSslErrorType error,
+		gpointer data)
+{
+	PurpleConnection *gc = data;
+	JabberStream *js;
+
+	/* If the connection is already disconnected, we don't need to do anything else */
+	g_return_if_fail(PURPLE_CONNECTION_IS_VALID(gc));
+
+	js = gc->proto_data;
+	js->gsc = NULL;
+
+	purple_connection_ssl_error (gc, error);
+}
+
+static void tls_init(JabberStream *js)
+{
+	purple_input_remove(js->gc->inpa);
+	js->gc->inpa = 0;
+	js->gsc = purple_ssl_connect_with_host_fd(js->gc->account, js->fd,
+			jabber_login_callback_ssl, jabber_ssl_connect_failure, js->certificate_CN, js->gc);
+	/* The fd is no longer our concern */
+	js->fd = -1;
+}
+
+static gboolean jabber_login_connect(JabberStream *js, const char *domain, const char *host, int port,
+				 gboolean fatal_failure)
+{
+	/* host should be used in preference to domain to
+	 * allow SASL authentication to work with FQDN of the server,
+	 * but we use domain as fallback for when users enter IP address
+	 * in connect server */
+	g_free(js->serverFQDN);
+	if (purple_ip_address_is_valid(host))
+		js->serverFQDN = g_strdup(domain);
+	else
+		js->serverFQDN = g_strdup(host);
+
+	if (purple_proxy_connect(js->gc, purple_connection_get_account(js->gc),
+			host, port, jabber_login_callback, js->gc) == NULL) {
+		if (fatal_failure) {
+			purple_connection_error_reason(js->gc,
+				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+				_("Unable to connect"));
+		}
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static void try_srv_connect(JabberStream *js)
+{
+	while (js->srv_rec != NULL && js->srv_rec_idx < js->max_srv_rec_idx) {
+		PurpleSrvResponse *tmp_resp = js->srv_rec + (js->srv_rec_idx++);
+		if (jabber_login_connect(js, tmp_resp->hostname, tmp_resp->hostname, tmp_resp->port, FALSE))
+			return;
+	}
+
+	g_free(js->srv_rec);
+	js->srv_rec = NULL;
+
+	/* Fall back to the defaults (I'm not sure if we should actually do this) */
+	jabber_login_connect(js, js->user->domain, js->user->domain,
+			purple_account_get_int(purple_connection_get_account(js->gc), "port", 5222),
+			TRUE);
+}
+
+static void srv_resolved_cb(PurpleSrvResponse *resp, int results, gpointer data)
+{
+	JabberStream *js = data;
+	js->srv_query_data = NULL;
+
+	if(results) {
+		js->srv_rec = resp;
+		js->srv_rec_idx = 0;
+		js->max_srv_rec_idx = results;
+		try_srv_connect(js);
+	} else {
+		jabber_login_connect(js, js->user->domain, js->user->domain,
+				purple_account_get_int(purple_connection_get_account(js->gc), "port", 5222),
+				TRUE);
+	}
+}
+
+static JabberStream *
+jabber_stream_new(PurpleAccount *account)
+{
+	PurpleConnection *gc = purple_account_get_connection(account);
+	JabberStream *js;
+	PurplePresence *presence;
+	gchar *user;
+	gchar *slash;
+
+	js = gc->proto_data = g_new0(JabberStream, 1);
+	js->gc = gc;
+	js->fd = -1;
+
+	if (g_strcmp0("prpl-facebook-xmpp",
+		purple_account_get_protocol_id(account)) == 0)
+	{
+		js->server_caps |= JABBER_CAP_FACEBOOK;
+	}
+
+	user = g_strdup(purple_account_get_username(account));
+	/* jabber_id_new doesn't accept "user@domain/" as valid */
+	slash = strchr(user, '/');
+	if (slash && *(slash + 1) == '\0')
+		*slash = '\0';
+	js->user = jabber_id_new(user);
+
+	if (!js->user) {
+		purple_connection_error_reason(gc,
+			PURPLE_CONNECTION_ERROR_INVALID_SETTINGS,
+			_("Invalid XMPP ID"));
+		g_free(user);
+		/* Destroying the connection will free the JabberStream */
+		return NULL;
+	}
+
+	if (!js->user->node || *(js->user->node) == '\0') {
+		purple_connection_error_reason(gc,
+			PURPLE_CONNECTION_ERROR_INVALID_SETTINGS,
+			_("Invalid XMPP ID. Username portion must be set."));
+		g_free(user);
+		/* Destroying the connection will free the JabberStream */
+		return NULL;
+	}
+
+	if (!js->user->domain || *(js->user->domain) == '\0') {
+		purple_connection_error_reason(gc,
+			PURPLE_CONNECTION_ERROR_INVALID_SETTINGS,
+			_("Invalid XMPP ID. Domain must be set."));
+		g_free(user);
+		/* Destroying the connection will free the JabberStream */
+		return NULL;
+	}
+
+	js->buddies = g_hash_table_new_full(g_str_hash, g_str_equal,
+			g_free, (GDestroyNotify)jabber_buddy_free);
+
+	/* This is overridden during binding, but we need it here
+	 * in case the server only does legacy non-sasl auth!.
+	 */
+	purple_connection_set_display_name(gc, user);
+
+	js->user_jb = jabber_buddy_find(js, user, TRUE);
+	g_free(user);
+	if (!js->user_jb) {
+		/* This basically *can't* fail, but for good measure... */
+		purple_connection_error_reason(gc,
+			PURPLE_CONNECTION_ERROR_INVALID_SETTINGS,
+			_("Invalid XMPP ID"));
+		/* Destroying the connection will free the JabberStream */
+		g_return_val_if_reached(NULL);
+	}
+
+	js->user_jb->subscription |= JABBER_SUB_BOTH;
+
+	js->iq_callbacks = g_hash_table_new_full(g_str_hash, g_str_equal,
+			g_free, (GDestroyNotify)jabber_iq_callbackdata_free);
+	js->chats = g_hash_table_new_full(g_str_hash, g_str_equal,
+			g_free, (GDestroyNotify)jabber_chat_free);
+	js->next_id = g_random_int();
+	js->write_buffer = purple_circ_buffer_new(512);
+	js->old_length = 0;
+	js->keepalive_timeout = 0;
+	js->max_inactivity = DEFAULT_INACTIVITY_TIME;
+	/* Set the default protocol version to 1.0. Overridden in parser.c. */
+	js->protocol_version.major = 1;
+	js->protocol_version.minor = 0;
+	js->sessions = NULL;
+	js->stun_ip = NULL;
+	js->stun_port = 0;
+	js->stun_query = NULL;
+	js->google_relay_token = NULL;
+	js->google_relay_host = NULL;
+	js->google_relay_requests = NULL;
+
+	/* if we are idle, set idle-ness on the stream (this could happen if we get
+		disconnected and the reconnects while being idle. I don't think it makes
+		sense to do this when registering a new account... */
+	presence = purple_account_get_presence(account);
+	if (purple_presence_is_idle(presence))
+		js->idle = purple_presence_get_idle_time(presence);
+
+	return js;
+}
+
+static void
+jabber_stream_connect(JabberStream *js)
+{
+	PurpleConnection *gc = js->gc;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	const char *connect_server = purple_account_get_string(account,
+			"connect_server", "");
+	const char *bosh_url = purple_account_get_string(account,
+			"bosh_url", "");
+
+	jabber_stream_set_state(js, JABBER_STREAM_CONNECTING);
+
+	/* If both BOSH and a Connect Server are specified, we prefer BOSH. I'm not
+	 * attached to that choice, though.
+	 */
+	if (*bosh_url) {
+		js->bosh = jabber_bosh_connection_init(js, bosh_url);
+		if (js->bosh)
+			jabber_bosh_connection_connect(js->bosh);
+		else {
+			purple_connection_error_reason(gc,
+				PURPLE_CONNECTION_ERROR_INVALID_SETTINGS,
+				_("Malformed BOSH URL"));
+		}
+
+		return;
+	}
+
+	js->certificate_CN = g_strdup(connect_server[0] ? connect_server : js->user->domain);
+
+	/* if they've got old-ssl mode going, we probably want to ignore SRV lookups */
+	if (g_str_equal("old_ssl", purple_account_get_string(account, "connection_security", JABBER_DEFAULT_REQUIRE_TLS))) {
+		if(purple_ssl_is_supported()) {
+			js->gsc = purple_ssl_connect(account, js->certificate_CN,
+					purple_account_get_int(account, "port", 5223),
+					jabber_login_callback_ssl, jabber_ssl_connect_failure, gc);
+			if (!js->gsc) {
+				purple_connection_error_reason(gc,
+					PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,
+					_("Unable to establish SSL connection"));
+			}
+		} else {
+			purple_connection_error_reason(gc,
+				PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,
+				_("SSL support unavailable"));
+		}
+
+		return;
+	}
+
+	/* no old-ssl, so if they've specified a connect server, we'll use that, otherwise we'll
+	 * invoke the magic of SRV lookups, to figure out host and port */
+	if(connect_server[0]) {
+		jabber_login_connect(js, js->user->domain, connect_server,
+				purple_account_get_int(account, "port", 5222), TRUE);
+	} else {
+		js->srv_query_data = purple_srv_resolve_account(account, "xmpp-client",
+				"tcp", js->user->domain, srv_resolved_cb, js);
+	}
+}
+
+void
+jabber_login(PurpleAccount *account)
+{
+	PurpleConnection *gc = purple_account_get_connection(account);
+	JabberStream *js;
+	PurpleStoredImage *image;
+
+	gc->flags |= PURPLE_CONNECTION_HTML |
+		PURPLE_CONNECTION_ALLOW_CUSTOM_SMILEY;
+	js = jabber_stream_new(account);
+	if (js == NULL)
+		return;
+
+	/* TODO: Remove this at some point.  Added 2010-02-14 (v2.6.6) */
+	if (g_str_equal("proxy.jabber.org", purple_account_get_string(account, "ft_proxies", "")))
+		purple_account_set_string(account, "ft_proxies", JABBER_DEFAULT_FT_PROXIES);
+
+	/*
+	 * Calculate the avatar hash for our current image so we know (when we
+	 * fetch our vCard and PEP avatar) if we should send our avatar to the
+	 * server.
+	 */
+	image = purple_buddy_icons_find_account_icon(account);
+	if (image != NULL) {
+		js->initial_avatar_hash =
+			jabber_calculate_data_hash(purple_imgstore_get_data(image),
+					purple_imgstore_get_size(image), "sha1");
+		purple_imgstore_unref(image);
+	}
+
+	jabber_stream_connect(js);
+}
+
+
+static gboolean
+conn_close_cb(gpointer data)
+{
+	JabberStream *js = data;
+	PurpleAccount *account = purple_connection_get_account(js->gc);
+
+	jabber_parser_free(js);
+
+	purple_account_disconnect(account);
+
+	return FALSE;
+}
+
+static void
+jabber_connection_schedule_close(JabberStream *js)
+{
+	purple_timeout_add(0, conn_close_cb, js);
+}
+
+static void
+jabber_registration_result_cb(JabberStream *js, const char *from,
+                              JabberIqType type, const char *id,
+                              xmlnode *packet, gpointer data)
+{
+	PurpleAccount *account = purple_connection_get_account(js->gc);
+	char *buf;
+	char *to = data;
+
+	if (type == JABBER_IQ_RESULT) {
+		if(js->registration) {
+			buf = g_strdup_printf(_("Registration of %s@%s successful"),
+					js->user->node, js->user->domain);
+			if(account->registration_cb)
+				(account->registration_cb)(account, TRUE, account->registration_cb_user_data);
+		} else {
+			g_return_if_fail(to != NULL);
+			buf = g_strdup_printf(_("Registration to %s successful"),
+				to);
+		}
+		purple_notify_info(NULL, _("Registration Successful"),
+				_("Registration Successful"), buf);
+		g_free(buf);
+	} else {
+		char *msg = jabber_parse_error(js, packet, NULL);
+
+		if(!msg)
+			msg = g_strdup(_("Unknown Error"));
+
+		purple_notify_error(NULL, _("Registration Failed"),
+				_("Registration Failed"), msg);
+		g_free(msg);
+		if(account->registration_cb)
+			(account->registration_cb)(account, FALSE, account->registration_cb_user_data);
+	}
+	g_free(to);
+	if(js->registration)
+		jabber_connection_schedule_close(js);
+}
+
+static void
+jabber_unregistration_result_cb(JabberStream *js, const char *from,
+                                JabberIqType type, const char *id,
+                                xmlnode *packet, gpointer data)
+{
+	char *buf;
+	char *to = data;
+
+	/* This function is never called for unregistering our XMPP account from
+	 * the server, so there should always be a 'to' address. */
+	g_return_if_fail(to != NULL);
+
+	if (type == JABBER_IQ_RESULT) {
+		buf = g_strdup_printf(_("Registration from %s successfully removed"),
+							  to);
+		purple_notify_info(NULL, _("Unregistration Successful"),
+						   _("Unregistration Successful"), buf);
+		g_free(buf);
+	} else {
+		char *msg = jabber_parse_error(js, packet, NULL);
+
+		if(!msg)
+			msg = g_strdup(_("Unknown Error"));
+
+		purple_notify_error(NULL, _("Unregistration Failed"),
+							_("Unregistration Failed"), msg);
+		g_free(msg);
+	}
+	g_free(to);
+}
+
+typedef struct _JabberRegisterCBData {
+	JabberStream *js;
+	char *who;
+} JabberRegisterCBData;
+
+static void
+jabber_register_cb(JabberRegisterCBData *cbdata, PurpleRequestFields *fields)
+{
+	GList *groups, *flds;
+	xmlnode *query, *y;
+	JabberIq *iq;
+	char *username;
+
+	iq = jabber_iq_new_query(cbdata->js, JABBER_IQ_SET, "jabber:iq:register");
+	query = xmlnode_get_child(iq->node, "query");
+	if (cbdata->who)
+		xmlnode_set_attrib(iq->node, "to", cbdata->who);
+
+	for(groups = purple_request_fields_get_groups(fields); groups;
+			groups = groups->next) {
+		for(flds = purple_request_field_group_get_fields(groups->data);
+				flds; flds = flds->next) {
+			PurpleRequestField *field = flds->data;
+			const char *id = purple_request_field_get_id(field);
+			if(!strcmp(id,"unregister")) {
+				gboolean value = purple_request_field_bool_get_value(field);
+				if(value) {
+					/* unregister from service. this doesn't include any of the fields, so remove them from the stanza by recreating it
+					   (there's no "remove child" function for xmlnode) */
+					jabber_iq_free(iq);
+					iq = jabber_iq_new_query(cbdata->js, JABBER_IQ_SET, "jabber:iq:register");
+					query = xmlnode_get_child(iq->node, "query");
+					if (cbdata->who)
+						xmlnode_set_attrib(iq->node,"to",cbdata->who);
+					xmlnode_new_child(query, "remove");
+
+					jabber_iq_set_callback(iq, jabber_unregistration_result_cb, cbdata->who);
+
+					jabber_iq_send(iq);
+					g_free(cbdata);
+					return;
+				}
+			} else {
+				const char *ids[] = {"username", "password", "name", "email", "nick", "first",
+					"last", "address", "city", "state", "zip", "phone", "url", "date",
+					NULL};
+				const char *value = purple_request_field_string_get_value(field);
+				int i;
+				for (i = 0; ids[i]; i++) {
+					if (!strcmp(id, ids[i]))
+						break;
+				}
+
+				if (!ids[i])
+					continue;
+				y = xmlnode_new_child(query, ids[i]);
+				xmlnode_insert_data(y, value, -1);
+				if(cbdata->js->registration && !strcmp(id, "username")) {
+					g_free(cbdata->js->user->node);
+					cbdata->js->user->node = g_strdup(value);
+				}
+				if(cbdata->js->registration && !strcmp(id, "password"))
+					purple_account_set_password(cbdata->js->gc->account, value);
+			}
+		}
+	}
+
+	if(cbdata->js->registration) {
+		username = g_strdup_printf("%s@%s%s%s", cbdata->js->user->node, cbdata->js->user->domain,
+			cbdata->js->user->resource ? "/" : "",
+			cbdata->js->user->resource ? cbdata->js->user->resource : "");
+		purple_account_set_username(cbdata->js->gc->account, username);
+		g_free(username);
+	}
+
+	jabber_iq_set_callback(iq, jabber_registration_result_cb, cbdata->who);
+
+	jabber_iq_send(iq);
+	g_free(cbdata);
+}
+
+static void
+jabber_register_cancel_cb(JabberRegisterCBData *cbdata, PurpleRequestFields *fields)
+{
+	PurpleAccount *account = purple_connection_get_account(cbdata->js->gc);
+	if(account && cbdata->js->registration) {
+		if(account->registration_cb)
+			(account->registration_cb)(account, FALSE, account->registration_cb_user_data);
+		jabber_connection_schedule_close(cbdata->js);
+	}
+	g_free(cbdata->who);
+	g_free(cbdata);
+}
+
+static void jabber_register_x_data_cb(JabberStream *js, xmlnode *result, gpointer data)
+{
+	xmlnode *query;
+	JabberIq *iq;
+	char *to = data;
+
+	iq = jabber_iq_new_query(js, JABBER_IQ_SET, "jabber:iq:register");
+	query = xmlnode_get_child(iq->node, "query");
+	if (to)
+		xmlnode_set_attrib(iq->node,"to",to);
+
+	xmlnode_insert_child(query, result);
+
+	jabber_iq_set_callback(iq, jabber_registration_result_cb, to);
+	jabber_iq_send(iq);
+}
+
+static const struct {
+	const char *name;
+	const char *label;
+} registration_fields[] = {
+	{ "email",   N_("Email") },
+	{ "nick",    N_("Nickname") },
+	{ "first",   N_("First name") },
+	{ "last",    N_("Last name") },
+	{ "address", N_("Address") },
+	{ "city",    N_("City") },
+	{ "state",   N_("State") },
+	{ "zip",     N_("Postal code") },
+	{ "phone",   N_("Phone") },
+	{ "url",     N_("URL") },
+	{ "date",    N_("Date") },
+	{ NULL, NULL }
+};
+
+void jabber_register_parse(JabberStream *js, const char *from, JabberIqType type,
+                           const char *id, xmlnode *query)
+{
+	PurpleAccount *account = purple_connection_get_account(js->gc);
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *group;
+	PurpleRequestField *field;
+	xmlnode *x, *y, *node;
+	char *instructions;
+	JabberRegisterCBData *cbdata;
+	gboolean registered = FALSE;
+	int i;
+
+	if (type != JABBER_IQ_RESULT)
+		return;
+
+	if(js->registration) {
+		/* get rid of the login thingy */
+		purple_connection_set_state(js->gc, PURPLE_CONNECTED);
+	}
+
+	if(xmlnode_get_child(query, "registered")) {
+		registered = TRUE;
+
+		if(js->registration) {
+			purple_notify_error(NULL, _("Already Registered"),
+								_("Already Registered"), NULL);
+			if(account->registration_cb)
+				(account->registration_cb)(account, FALSE, account->registration_cb_user_data);
+			jabber_connection_schedule_close(js);
+			return;
+		}
+	}
+
+	if((x = xmlnode_get_child_with_namespace(query, "x", "jabber:x:data"))) {
+		jabber_x_data_request(js, x, jabber_register_x_data_cb, g_strdup(from));
+		return;
+
+	} else if((x = xmlnode_get_child_with_namespace(query, "x", NS_OOB_X_DATA))) {
+		xmlnode *url;
+
+		if((url = xmlnode_get_child(x, "url"))) {
+			char *href;
+			if((href = xmlnode_get_data(url))) {
+				purple_notify_uri(NULL, href);
+				g_free(href);
+
+				if(js->registration) {
+					js->gc->wants_to_die = TRUE;
+					if(account->registration_cb) /* succeeded, but we have no login info */
+						(account->registration_cb)(account, TRUE, account->registration_cb_user_data);
+					jabber_connection_schedule_close(js);
+				}
+				return;
+			}
+		}
+	}
+
+	/* as a last resort, use the old jabber:iq:register syntax */
+
+	fields = purple_request_fields_new();
+	group = purple_request_field_group_new(NULL);
+	purple_request_fields_add_group(fields, group);
+
+	if((node = xmlnode_get_child(query, "username"))) {
+		char *data = xmlnode_get_data(node);
+		if(js->registration)
+			field = purple_request_field_string_new("username", _("Username"), data ? data : js->user->node, FALSE);
+		else
+			field = purple_request_field_string_new("username", _("Username"), data, FALSE);
+
+		purple_request_field_group_add_field(group, field);
+		g_free(data);
+	}
+	if((node = xmlnode_get_child(query, "password"))) {
+		if(js->registration)
+			field = purple_request_field_string_new("password", _("Password"),
+										purple_connection_get_password(js->gc), FALSE);
+		else {
+			char *data = xmlnode_get_data(node);
+			field = purple_request_field_string_new("password", _("Password"), data, FALSE);
+			g_free(data);
+		}
+
+		purple_request_field_string_set_masked(field, TRUE);
+		purple_request_field_group_add_field(group, field);
+	}
+
+	if((node = xmlnode_get_child(query, "name"))) {
+		if(js->registration)
+			field = purple_request_field_string_new("name", _("Name"),
+													purple_account_get_alias(js->gc->account), FALSE);
+		else {
+			char *data = xmlnode_get_data(node);
+			field = purple_request_field_string_new("name", _("Name"), data, FALSE);
+			g_free(data);
+		}
+		purple_request_field_group_add_field(group, field);
+	}
+
+	for (i = 0; registration_fields[i].name != NULL; ++i) {
+		if ((node = xmlnode_get_child(query, registration_fields[i].name))) {
+			char *data = xmlnode_get_data(node);
+			field = purple_request_field_string_new(registration_fields[i].name,
+			                                        _(registration_fields[i].label),
+			                                        data, FALSE);
+			purple_request_field_group_add_field(group, field);
+			g_free(data);
+		}
+	}
+
+	if(registered) {
+		field = purple_request_field_bool_new("unregister", _("Unregister"), FALSE);
+		purple_request_field_group_add_field(group, field);
+	}
+
+	if((y = xmlnode_get_child(query, "instructions")))
+		instructions = xmlnode_get_data(y);
+	else if(registered)
+		instructions = g_strdup(_("Please fill out the information below "
+					"to change your account registration."));
+	else
+		instructions = g_strdup(_("Please fill out the information below "
+					"to register your new account."));
+
+	cbdata = g_new0(JabberRegisterCBData, 1);
+	cbdata->js = js;
+	cbdata->who = g_strdup(from);
+
+	if(js->registration)
+		purple_request_fields(js->gc, _("Register New XMPP Account"),
+				_("Register New XMPP Account"), instructions, fields,
+				_("Register"), G_CALLBACK(jabber_register_cb),
+				_("Cancel"), G_CALLBACK(jabber_register_cancel_cb),
+				purple_connection_get_account(js->gc), NULL, NULL,
+				cbdata);
+	else {
+		char *title;
+		g_return_if_fail(from != NULL);
+		title = registered ? g_strdup_printf(_("Change Account Registration at %s"), from)
+								:g_strdup_printf(_("Register New Account at %s"), from);
+		purple_request_fields(js->gc, title,
+			  title, instructions, fields,
+			  (registered ? _("Change Registration") : _("Register")), G_CALLBACK(jabber_register_cb),
+			  _("Cancel"), G_CALLBACK(jabber_register_cancel_cb),
+			  purple_connection_get_account(js->gc), NULL, NULL,
+			  cbdata);
+		g_free(title);
+	}
+
+	g_free(instructions);
+}
+
+void jabber_register_start(JabberStream *js)
+{
+	JabberIq *iq;
+
+	iq = jabber_iq_new_query(js, JABBER_IQ_GET, "jabber:iq:register");
+	jabber_iq_send(iq);
+}
+
+void jabber_register_gateway(JabberStream *js, const char *gateway) {
+	JabberIq *iq;
+
+	iq = jabber_iq_new_query(js, JABBER_IQ_GET, "jabber:iq:register");
+	xmlnode_set_attrib(iq->node, "to", gateway);
+	jabber_iq_send(iq);
+}
+
+void jabber_register_account(PurpleAccount *account)
+{
+	JabberStream *js;
+
+	js = jabber_stream_new(account);
+	if (js == NULL)
+		return;
+
+	js->registration = TRUE;
+	jabber_stream_connect(js);
+}
+
+static void
+jabber_unregister_account_iq_cb(JabberStream *js, const char *from,
+                                JabberIqType type, const char *id,
+                                xmlnode *packet, gpointer data)
+{
+	PurpleAccount *account = purple_connection_get_account(js->gc);
+
+	if (type == JABBER_IQ_ERROR) {
+		char *msg = jabber_parse_error(js, packet, NULL);
+
+		purple_notify_error(js->gc, _("Error unregistering account"),
+							_("Error unregistering account"), msg);
+		g_free(msg);
+		if(js->unregistration_cb)
+			js->unregistration_cb(account, FALSE, js->unregistration_user_data);
+	} else {
+		purple_notify_info(js->gc, _("Account successfully unregistered"),
+						   _("Account successfully unregistered"), NULL);
+		if(js->unregistration_cb)
+			js->unregistration_cb(account, TRUE, js->unregistration_user_data);
+	}
+}
+
+static void jabber_unregister_account_cb(JabberStream *js) {
+	JabberIq *iq;
+	xmlnode *query;
+
+	g_return_if_fail(js->unregistration);
+
+	iq = jabber_iq_new_query(js, JABBER_IQ_SET, "jabber:iq:register");
+
+	query = xmlnode_get_child_with_namespace(iq->node, "query", "jabber:iq:register");
+
+	xmlnode_new_child(query, "remove");
+	xmlnode_set_attrib(iq->node, "to", js->user->domain);
+
+	jabber_iq_set_callback(iq, jabber_unregister_account_iq_cb, NULL);
+	jabber_iq_send(iq);
+}
+
+void jabber_unregister_account(PurpleAccount *account, PurpleAccountUnregistrationCb cb, void *user_data) {
+	PurpleConnection *gc = purple_account_get_connection(account);
+	JabberStream *js;
+
+	if(gc->state != PURPLE_CONNECTED) {
+		if(gc->state != PURPLE_CONNECTING)
+			jabber_login(account);
+		js = gc->proto_data;
+		js->unregistration = TRUE;
+		js->unregistration_cb = cb;
+		js->unregistration_user_data = user_data;
+		return;
+	}
+
+	js = gc->proto_data;
+
+	if (js->unregistration) {
+		purple_debug_error("jabber", "Unregistration in process; ignoring duplicate request.\n");
+		return;
+	}
+
+	js->unregistration = TRUE;
+	js->unregistration_cb = cb;
+	js->unregistration_user_data = user_data;
+
+	jabber_unregister_account_cb(js);
+}
+
+/* TODO: As Will pointed out in IRC, after being notified by the core to
+ * shutdown, we should async. wait for the server to send us the stream
+ * termination before destorying everything. That seems like it would require
+ * changing the semantics of prpl->close(), so it's a good idea for 3.0.0.
+ */
+void jabber_close(PurpleConnection *gc)
+{
+	JabberStream *js = purple_connection_get_protocol_data(gc);
+
+	/* Close all of the open Jingle sessions on this stream */
+	jingle_terminate_sessions(js);
+
+	if (js->bosh)
+		jabber_bosh_connection_close(js->bosh);
+	else if ((js->gsc && js->gsc->fd > 0) || js->fd > 0)
+		jabber_send_raw(js, "</stream:stream>", -1);
+
+	if (js->srv_query_data)
+		purple_srv_cancel(js->srv_query_data);
+
+	if(js->gsc) {
+		purple_ssl_close(js->gsc);
+	} else if (js->fd > 0) {
+		if(js->gc->inpa)
+			purple_input_remove(js->gc->inpa);
+		close(js->fd);
+	}
+
+	if (js->bosh)
+		jabber_bosh_connection_destroy(js->bosh);
+
+	jabber_buddy_remove_all_pending_buddy_info_requests(js);
+
+	jabber_parser_free(js);
+
+	if(js->iq_callbacks)
+		g_hash_table_destroy(js->iq_callbacks);
+	if(js->buddies)
+		g_hash_table_destroy(js->buddies);
+	if(js->chats)
+		g_hash_table_destroy(js->chats);
+
+	while(js->chat_servers) {
+		g_free(js->chat_servers->data);
+		js->chat_servers = g_list_delete_link(js->chat_servers, js->chat_servers);
+	}
+
+	while(js->user_directories) {
+		g_free(js->user_directories->data);
+		js->user_directories = g_list_delete_link(js->user_directories, js->user_directories);
+	}
+
+	while(js->bs_proxies) {
+		JabberBytestreamsStreamhost *sh = js->bs_proxies->data;
+		g_free(sh->jid);
+		g_free(sh->host);
+		g_free(sh->zeroconf);
+		g_free(sh);
+		js->bs_proxies = g_list_delete_link(js->bs_proxies, js->bs_proxies);
+	}
+
+	while(js->url_datas) {
+		purple_util_fetch_url_cancel(js->url_datas->data);
+		js->url_datas = g_slist_delete_link(js->url_datas, js->url_datas);
+	}
+
+	g_free(js->stream_id);
+	if(js->user)
+		jabber_id_free(js->user);
+	g_free(js->initial_avatar_hash);
+	g_free(js->avatar_hash);
+	g_free(js->caps_hash);
+
+	if (js->write_buffer)
+		purple_circ_buffer_destroy(js->write_buffer);
+	if(js->writeh)
+		purple_input_remove(js->writeh);
+	if (js->auth_mech && js->auth_mech->dispose)
+		js->auth_mech->dispose(js);
+#ifdef HAVE_CYRUS_SASL
+	if(js->sasl)
+		sasl_dispose(&js->sasl);
+	if(js->sasl_mechs)
+		g_string_free(js->sasl_mechs, TRUE);
+	g_free(js->sasl_cb);
+	/* Note: _not_ g_free.  See auth_cyrus.c:jabber_sasl_cb_secret */
+	free(js->sasl_secret);
+#endif
+	g_free(js->serverFQDN);
+	while(js->commands) {
+		JabberAdHocCommands *cmd = js->commands->data;
+		g_free(cmd->jid);
+		g_free(cmd->node);
+		g_free(cmd->name);
+		g_free(cmd);
+		js->commands = g_list_delete_link(js->commands, js->commands);
+	}
+	g_free(js->server_name);
+	g_free(js->certificate_CN);
+	g_free(js->gmail_last_time);
+	g_free(js->gmail_last_tid);
+	g_free(js->old_msg);
+	g_free(js->old_avatarhash);
+	g_free(js->old_artist);
+	g_free(js->old_title);
+	g_free(js->old_source);
+	g_free(js->old_uri);
+	g_free(js->old_track);
+
+	if (js->vcard_timer != 0)
+		purple_timeout_remove(js->vcard_timer);
+
+	if (js->keepalive_timeout != 0)
+		purple_timeout_remove(js->keepalive_timeout);
+	if (js->inactivity_timer != 0)
+		purple_timeout_remove(js->inactivity_timer);
+
+	g_free(js->srv_rec);
+	js->srv_rec = NULL;
+
+	g_free(js->stun_ip);
+	js->stun_ip = NULL;
+
+	/* cancel DNS query for STUN, if one is ongoing */
+	if (js->stun_query) {
+		purple_dnsquery_destroy(js->stun_query);
+		js->stun_query = NULL;
+	}
+
+	/* remove Google relay-related stuff */
+	g_free(js->google_relay_token);
+	g_free(js->google_relay_host);
+	if (js->google_relay_requests) {
+		while (js->google_relay_requests) {
+			PurpleUtilFetchUrlData *url_data =
+				(PurpleUtilFetchUrlData *) js->google_relay_requests->data;
+			purple_util_fetch_url_cancel(url_data);
+			g_free(url_data);
+			js->google_relay_requests =
+				g_list_delete_link(js->google_relay_requests,
+					js->google_relay_requests);
+		}
+	}
+
+	g_free(js);
+
+	gc->proto_data = NULL;
+}
+
+void jabber_stream_set_state(JabberStream *js, JabberStreamState state)
+{
+#define JABBER_CONNECT_STEPS ((js->gsc || js->state == JABBER_STREAM_INITIALIZING_ENCRYPTION) ? 9 : 5)
+
+	js->state = state;
+	switch(state) {
+		case JABBER_STREAM_OFFLINE:
+			break;
+		case JABBER_STREAM_CONNECTING:
+			purple_connection_update_progress(js->gc, _("Connecting"), 1,
+					JABBER_CONNECT_STEPS);
+			break;
+		case JABBER_STREAM_INITIALIZING:
+			purple_connection_update_progress(js->gc, _("Initializing Stream"),
+					js->gsc ? 5 : 2, JABBER_CONNECT_STEPS);
+			jabber_stream_init(js);
+			break;
+		case JABBER_STREAM_INITIALIZING_ENCRYPTION:
+			purple_connection_update_progress(js->gc, _("Initializing SSL/TLS"),
+											  6, JABBER_CONNECT_STEPS);
+			break;
+		case JABBER_STREAM_AUTHENTICATING:
+			purple_connection_update_progress(js->gc, _("Authenticating"),
+					js->gsc ? 7 : 3, JABBER_CONNECT_STEPS);
+			break;
+		case JABBER_STREAM_POST_AUTH:
+			purple_connection_update_progress(js->gc, _("Re-initializing Stream"),
+					(js->gsc ? 8 : 4), JABBER_CONNECT_STEPS);
+
+			break;
+		case JABBER_STREAM_CONNECTED:
+			/* Send initial presence */
+			jabber_presence_send(js, TRUE);
+			/* Start up the inactivity timer */
+			jabber_stream_restart_inactivity_timer(js);
+
+			purple_connection_set_state(js->gc, PURPLE_CONNECTED);
+			break;
+	}
+
+#undef JABBER_CONNECT_STEPS
+}
+
+char *jabber_get_next_id(JabberStream *js)
+{
+	return g_strdup_printf("purple%x", js->next_id++);
+}
+
+
+void jabber_idle_set(PurpleConnection *gc, int idle)
+{
+	JabberStream *js = gc->proto_data;
+
+	js->idle = idle ? time(NULL) - idle : idle;
+
+	/* send out an updated prescence */
+	purple_debug_info("jabber", "sending updated presence for idle\n");
+	jabber_presence_send(js, FALSE);
+}
+
+void jabber_blocklist_parse_push(JabberStream *js, const char *from,
+                                 JabberIqType type, const char *id,
+                                 xmlnode *child)
+{
+	JabberIq *result;
+	xmlnode *item;
+	PurpleAccount *account;
+	gboolean is_block;
+
+	if (!jabber_is_own_account(js, from)) {
+		xmlnode *error, *x;
+		result = jabber_iq_new(js, JABBER_IQ_ERROR);
+		xmlnode_set_attrib(result->node, "id", id);
+		if (from)
+			xmlnode_set_attrib(result->node, "to", from);
+
+		error = xmlnode_new_child(result->node, "error");
+		xmlnode_set_attrib(error, "type", "cancel");
+		x = xmlnode_new_child(error, "not-allowed");
+		xmlnode_set_namespace(x, NS_XMPP_STANZAS);
+
+		jabber_iq_send(result);
+		return;
+	}
+
+	account = purple_connection_get_account(js->gc);
+	is_block = g_str_equal(child->name, "block");
+
+	item = xmlnode_get_child(child, "item");
+	if (!is_block && item == NULL) {
+		/* Unblock everyone */
+		purple_debug_info("jabber", "Received unblock push. Unblocking everyone.\n");
+
+		while (account->deny != NULL) {
+			purple_privacy_deny_remove(account, account->deny->data, TRUE);
+		}
+	} else if (item == NULL) {
+		/* An empty <block/> is bogus */
+		xmlnode *error, *x;
+		result = jabber_iq_new(js, JABBER_IQ_ERROR);
+		xmlnode_set_attrib(result->node, "id", id);
+
+		error = xmlnode_new_child(result->node, "error");
+		xmlnode_set_attrib(error, "type", "modify");
+		x = xmlnode_new_child(error, "bad-request");
+		xmlnode_set_namespace(x, NS_XMPP_STANZAS);
+
+		jabber_iq_send(result);
+		return;
+	} else {
+		for ( ; item; item = xmlnode_get_next_twin(item)) {
+			const char *jid = xmlnode_get_attrib(item, "jid");
+			if (jid == NULL || *jid == '\0')
+				continue;
+
+			if (is_block)
+				purple_privacy_deny_add(account, jid, TRUE);
+			else
+				purple_privacy_deny_remove(account, jid, TRUE);
+		}
+	}
+
+	result = jabber_iq_new(js, JABBER_IQ_RESULT);
+	xmlnode_set_attrib(result->node, "id", id);
+	jabber_iq_send(result);
+}
+
+static void jabber_blocklist_parse(JabberStream *js, const char *from,
+                                   JabberIqType type, const char *id,
+                                   xmlnode *packet, gpointer data)
+{
+	xmlnode *blocklist, *item;
+	PurpleAccount *account;
+
+	blocklist = xmlnode_get_child_with_namespace(packet,
+			"blocklist", NS_SIMPLE_BLOCKING);
+	account = purple_connection_get_account(js->gc);
+
+	if (type == JABBER_IQ_ERROR || blocklist == NULL)
+		return;
+
+	/* This is the only privacy method supported by XEP-0191 */
+	if (account->perm_deny != PURPLE_PRIVACY_DENY_USERS)
+		account->perm_deny = PURPLE_PRIVACY_DENY_USERS;
+
+	/*
+	 * TODO: When account->deny is something more than a hash table, this can
+	 * be re-written to find the set intersection and difference.
+	 */
+	while (account->deny)
+		purple_privacy_deny_remove(account, account->deny->data, TRUE);
+
+	item = xmlnode_get_child(blocklist, "item");
+	while (item != NULL) {
+		const char *jid = xmlnode_get_attrib(item, "jid");
+		purple_privacy_deny_add(account, jid, TRUE);
+		item = xmlnode_get_next_twin(item);
+	}
+}
+
+void jabber_request_block_list(JabberStream *js)
+{
+	JabberIq *iq;
+	xmlnode *blocklist;
+
+	iq = jabber_iq_new(js, JABBER_IQ_GET);
+
+	blocklist = xmlnode_new_child(iq->node, "blocklist");
+	xmlnode_set_namespace(blocklist, NS_SIMPLE_BLOCKING);
+
+	jabber_iq_set_callback(iq, jabber_blocklist_parse, NULL);
+
+	jabber_iq_send(iq);
+}
+
+void jabber_add_deny(PurpleConnection *gc, const char *who)
+{
+	JabberStream *js;
+	JabberIq *iq;
+	xmlnode *block, *item;
+
+	g_return_if_fail(who != NULL && *who != '\0');
+
+	js = purple_connection_get_protocol_data(gc);
+	if (js == NULL)
+		return;
+
+	if (js->server_caps & JABBER_CAP_GOOGLE_ROSTER)
+	{
+		jabber_google_roster_add_deny(js, who);
+		return;
+	}
+
+	if (!(js->server_caps & JABBER_CAP_BLOCKING))
+	{
+		purple_notify_error(NULL, _("Server doesn't support blocking"),
+							_("Server doesn't support blocking"), NULL);
+		return;
+	}
+
+	iq = jabber_iq_new(js, JABBER_IQ_SET);
+
+	block = xmlnode_new_child(iq->node, "block");
+	xmlnode_set_namespace(block, NS_SIMPLE_BLOCKING);
+
+	item = xmlnode_new_child(block, "item");
+	xmlnode_set_attrib(item, "jid", who);
+
+	jabber_iq_send(iq);
+}
+
+void jabber_rem_deny(PurpleConnection *gc, const char *who)
+{
+	JabberStream *js;
+	JabberIq *iq;
+	xmlnode *unblock, *item;
+
+	g_return_if_fail(who != NULL && *who != '\0');
+
+	js = purple_connection_get_protocol_data(gc);
+	if (js == NULL)
+		return;
+
+	if (js->server_caps & JABBER_CAP_GOOGLE_ROSTER)
+	{
+		jabber_google_roster_rem_deny(js, who);
+		return;
+	}
+
+	if (!(js->server_caps & JABBER_CAP_BLOCKING))
+		return;
+
+	iq = jabber_iq_new(js, JABBER_IQ_SET);
+
+	unblock = xmlnode_new_child(iq->node, "unblock");
+	xmlnode_set_namespace(unblock, NS_SIMPLE_BLOCKING);
+
+	item = xmlnode_new_child(unblock, "item");
+	xmlnode_set_attrib(item, "jid", who);
+
+	jabber_iq_send(iq);
+}
+
+void jabber_add_feature(const char *namespace, JabberFeatureEnabled cb) {
+	JabberFeature *feat;
+
+	g_return_if_fail(namespace != NULL);
+
+	feat = g_new0(JabberFeature,1);
+	feat->namespace = g_strdup(namespace);
+	feat->is_enabled = cb;
+
+	/* try to remove just in case it already exists in the list */
+	jabber_remove_feature(namespace);
+
+	jabber_features = g_list_append(jabber_features, feat);
+}
+
+void jabber_remove_feature(const char *namespace) {
+	GList *feature;
+	for(feature = jabber_features; feature; feature = feature->next) {
+		JabberFeature *feat = (JabberFeature*)feature->data;
+		if(!strcmp(feat->namespace, namespace)) {
+			g_free(feat->namespace);
+			g_free(feature->data);
+			jabber_features = g_list_delete_link(jabber_features, feature);
+			break;
+		}
+	}
+}
+
+static void jabber_features_destroy(void)
+{
+	while (jabber_features) {
+		JabberFeature *feature = jabber_features->data;
+		g_free(feature->namespace);
+		g_free(feature);
+		jabber_features = g_list_delete_link(jabber_features, jabber_features);
+	}
+}
+
+gint
+jabber_identity_compare(gconstpointer a, gconstpointer b)
+{
+	const JabberIdentity *ac;
+	const JabberIdentity *bc;
+	gint cat_cmp;
+	gint typ_cmp;
+
+	ac = a;
+	bc = b;
+
+	if ((cat_cmp = strcmp(ac->category, bc->category)) == 0) {
+		if ((typ_cmp = strcmp(ac->type, bc->type)) == 0) {
+			if (!ac->lang && !bc->lang) {
+				return 0;
+			} else if (ac->lang && !bc->lang) {
+				return 1;
+			} else if (!ac->lang && bc->lang) {
+				return -1;
+			} else {
+				return strcmp(ac->lang, bc->lang);
+			}
+		} else {
+			return typ_cmp;
+		}
+	} else {
+		return cat_cmp;
+	}
+}
+
+void jabber_add_identity(const gchar *category, const gchar *type,
+                         const gchar *lang, const gchar *name)
+{
+	GList *identity;
+	JabberIdentity *ident;
+
+	/* both required according to XEP-0030 */
+	g_return_if_fail(category != NULL);
+	g_return_if_fail(type != NULL);
+
+	/* Check if this identity is already there... */
+	for (identity = jabber_identities; identity; identity = identity->next) {
+		JabberIdentity *id = identity->data;
+		if (g_str_equal(id->category, category) &&
+			g_str_equal(id->type, type) &&
+			purple_strequal(id->lang, lang))
+			return;
+	}
+
+	ident = g_new0(JabberIdentity, 1);
+	ident->category = g_strdup(category);
+	ident->type = g_strdup(type);
+	ident->lang = g_strdup(lang);
+	ident->name = g_strdup(name);
+	jabber_identities = g_list_insert_sorted(jabber_identities, ident,
+	                                         jabber_identity_compare);
+}
+
+static void jabber_identities_destroy(void)
+{
+	while (jabber_identities) {
+		JabberIdentity *id = jabber_identities->data;
+		g_free(id->category);
+		g_free(id->type);
+		g_free(id->lang);
+		g_free(id->name);
+		g_free(id);
+		jabber_identities = g_list_delete_link(jabber_identities, jabber_identities);
+	}
+}
+
+gboolean jabber_stream_is_ssl(JabberStream *js)
+{
+	return (js->bosh && jabber_bosh_connection_is_ssl(js->bosh)) ||
+	       (!js->bosh && js->gsc);
+}
+
+static gboolean
+inactivity_cb(gpointer data)
+{
+	JabberStream *js = data;
+
+	/* We want whatever is sent to set this.  It's okay because
+	 * the eventloop unsets it via the return FALSE.
+	 */
+	js->inactivity_timer = 0;
+
+	if (js->bosh)
+		jabber_bosh_connection_send_keepalive(js->bosh);
+	else
+		jabber_send_raw(js, "\t", 1);
+
+	return FALSE;
+}
+
+void jabber_stream_restart_inactivity_timer(JabberStream *js)
+{
+	if (js->inactivity_timer != 0) {
+		purple_timeout_remove(js->inactivity_timer);
+		js->inactivity_timer = 0;
+	}
+
+	g_return_if_fail(js->max_inactivity > 0);
+
+	js->inactivity_timer =
+		purple_timeout_add_seconds(js->max_inactivity,
+		                           inactivity_cb, js);
+}
+
+const char *jabber_list_icon(PurpleAccount *a, PurpleBuddy *b)
+{
+	return "jabber";
+}
+
+const char* jabber_list_emblem(PurpleBuddy *b)
+{
+	JabberStream *js;
+	JabberBuddy *jb = NULL;
+	PurpleConnection *gc = purple_account_get_connection(purple_buddy_get_account(b));
+
+	if(!gc)
+		return NULL;
+
+	js = gc->proto_data;
+	if(js)
+		jb = jabber_buddy_find(js, purple_buddy_get_name(b), FALSE);
+
+	if(!PURPLE_BUDDY_IS_ONLINE(b)) {
+		if(jb && (jb->subscription & JABBER_SUB_PENDING ||
+					!(jb->subscription & JABBER_SUB_TO)))
+			return "not-authorized";
+	}
+
+	if (jb) {
+		JabberBuddyResource *jbr = jabber_buddy_find_resource(jb, NULL);
+		if (jbr) {
+			const gchar *client_type =
+				jabber_resource_get_identity_category_type(jbr, "client");
+
+			if (client_type) {
+				if (strcmp(client_type, "phone") == 0) {
+					return "mobile";
+				} else if (strcmp(client_type, "web") == 0) {
+					return "external";
+				} else if (strcmp(client_type, "handheld") == 0) {
+					return "hiptop";
+				} else if (strcmp(client_type, "bot") == 0) {
+					return "bot";
+				}
+				/* the default value "pc" falls through and has no emblem */
+			}
+		}
+	}
+
+	return NULL;
+}
+
+char *jabber_status_text(PurpleBuddy *b)
+{
+	char *ret = NULL;
+	JabberBuddy *jb = NULL;
+	PurpleAccount *account = purple_buddy_get_account(b);
+	PurpleConnection *gc = purple_account_get_connection(account);
+
+	if (gc && gc->proto_data)
+		jb = jabber_buddy_find(gc->proto_data, purple_buddy_get_name(b), FALSE);
+
+	if(jb && !PURPLE_BUDDY_IS_ONLINE(b) && (jb->subscription & JABBER_SUB_PENDING || !(jb->subscription & JABBER_SUB_TO))) {
+		ret = g_strdup(_("Not Authorized"));
+	} else if(jb && !PURPLE_BUDDY_IS_ONLINE(b) && jb->error_msg) {
+		ret = g_strdup(jb->error_msg);
+	} else {
+		PurplePresence *presence = purple_buddy_get_presence(b);
+		PurpleStatus *status = purple_presence_get_active_status(presence);
+		const char *message;
+
+		if((message = purple_status_get_attr_string(status, "message"))) {
+			ret = g_markup_escape_text(message, -1);
+		} else if (purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_TUNE)) {
+			PurpleStatus *status = purple_presence_get_status(presence, "tune");
+			const char *title = purple_status_get_attr_string(status, PURPLE_TUNE_TITLE);
+			const char *artist = purple_status_get_attr_string(status, PURPLE_TUNE_ARTIST);
+			const char *album = purple_status_get_attr_string(status, PURPLE_TUNE_ALBUM);
+			ret = purple_util_format_song_info(title, artist, album, NULL);
+		}
+	}
+
+	return ret;
+}
+
+static void
+jabber_tooltip_add_resource_text(JabberBuddyResource *jbr,
+	PurpleNotifyUserInfo *user_info, gboolean multiple_resources)
+{
+	char *text = NULL;
+	char *res = NULL;
+	char *label, *value;
+	const char *state;
+
+	if(jbr->status) {
+		text = g_markup_escape_text(jbr->status, -1);
+	}
+
+	if(jbr->name)
+		res = g_strdup_printf(" (%s)", jbr->name);
+
+	state = jabber_buddy_state_get_name(jbr->state);
+	if (text != NULL && !purple_utf8_strcasecmp(state, text)) {
+		g_free(text);
+		text = NULL;
+	}
+
+	label = g_strdup_printf("%s%s", _("Status"), (res ? res : ""));
+	value = g_strdup_printf("%s%s%s", state, (text ? ": " : ""), (text ? text : ""));
+
+	purple_notify_user_info_add_pair(user_info, label, value);
+	g_free(label);
+	g_free(value);
+	g_free(text);
+
+	/* if the resource is idle, show that */
+	/* only show it if there is more than one resource available for
+	the buddy, since the "general" idleness will be shown anyway,
+	this way we can see see the idleness of lower-priority resources */
+	if (jbr->idle && multiple_resources) {
+		gchar *idle_str =
+			purple_str_seconds_to_string(time(NULL) - jbr->idle);
+		label = g_strdup_printf("%s%s", _("Idle"), (res ? res : ""));
+		purple_notify_user_info_add_pair(user_info, label, idle_str);
+		g_free(idle_str);
+		g_free(label);
+	}
+	g_free(res);
+}
+
+void jabber_tooltip_text(PurpleBuddy *b, PurpleNotifyUserInfo *user_info, gboolean full)
+{
+	JabberBuddy *jb;
+	PurpleAccount *account;
+	PurpleConnection *gc;
+
+	g_return_if_fail(b != NULL);
+
+	account = purple_buddy_get_account(b);
+	g_return_if_fail(account != NULL);
+
+	gc = purple_account_get_connection(account);
+	g_return_if_fail(gc != NULL);
+	g_return_if_fail(gc->proto_data != NULL);
+
+	jb = jabber_buddy_find(gc->proto_data, purple_buddy_get_name(b), FALSE);
+
+	if(jb) {
+		JabberBuddyResource *jbr = NULL;
+		PurplePresence *presence = purple_buddy_get_presence(b);
+		const char *sub;
+		GList *l;
+		const char *mood;
+		gboolean multiple_resources =
+			jb->resources && g_list_next(jb->resources);
+		JabberBuddyResource *top_jbr = jabber_buddy_find_resource(jb, NULL);
+
+		/* resource-specific info for the top resource */
+		if (top_jbr) {
+			jabber_tooltip_add_resource_text(top_jbr, user_info,
+				multiple_resources);
+		}
+
+		for(l=jb->resources; l; l = l->next) {
+			jbr = l->data;
+			/* the remaining resources */
+			if (jbr != top_jbr) {
+				jabber_tooltip_add_resource_text(jbr, user_info,
+					multiple_resources);
+			}
+		}
+
+		if (full) {
+			PurpleStatus *status;
+
+			status = purple_presence_get_status(presence, "mood");
+			mood = purple_status_get_attr_string(status, PURPLE_MOOD_NAME);
+			if(mood && *mood) {
+				const char *moodtext;
+				/* find the mood */
+				PurpleMood *moods = jabber_get_moods(account);
+				const char *description = NULL;
+
+				for (; moods->mood ; moods++) {
+					if (purple_strequal(moods->mood, mood)) {
+						description = moods->description;
+						break;
+					}
+				}
+
+				moodtext = purple_status_get_attr_string(status, PURPLE_MOOD_COMMENT);
+				if(moodtext && *moodtext) {
+					char *moodplustext =
+						g_strdup_printf("%s (%s)", description ? _(description) : mood, moodtext);
+
+					purple_notify_user_info_add_pair(user_info, _("Mood"), moodplustext);
+					g_free(moodplustext);
+				} else
+					purple_notify_user_info_add_pair(user_info, _("Mood"),
+					    description ? _(description) : mood);
+			}
+			if (purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_TUNE)) {
+				PurpleStatus *tune = purple_presence_get_status(presence, "tune");
+				const char *title = purple_status_get_attr_string(tune, PURPLE_TUNE_TITLE);
+				const char *artist = purple_status_get_attr_string(tune, PURPLE_TUNE_ARTIST);
+				const char *album = purple_status_get_attr_string(tune, PURPLE_TUNE_ALBUM);
+				char *playing = purple_util_format_song_info(title, artist, album, NULL);
+				if (playing) {
+					purple_notify_user_info_add_pair(user_info, _("Now Listening"), playing);
+					g_free(playing);
+				}
+			}
+
+			if(jb->subscription & JABBER_SUB_FROM) {
+				if(jb->subscription & JABBER_SUB_TO)
+					sub = _("Both");
+				else if(jb->subscription & JABBER_SUB_PENDING)
+					sub = _("From (To pending)");
+				else
+					sub = _("From");
+			} else {
+				if(jb->subscription & JABBER_SUB_TO)
+					sub = _("To");
+				else if(jb->subscription & JABBER_SUB_PENDING)
+					sub = _("None (To pending)");
+				else
+					sub = _("None");
+			}
+
+			purple_notify_user_info_add_pair(user_info, _("Subscription"), sub);
+
+		}
+
+		if(!PURPLE_BUDDY_IS_ONLINE(b) && jb->error_msg) {
+			purple_notify_user_info_add_pair(user_info, _("Error"), jb->error_msg);
+		}
+	}
+}
+
+GList *jabber_status_types(PurpleAccount *account)
+{
+	PurpleStatusType *type;
+	GList *types = NULL;
+	PurpleValue *priority_value;
+	PurpleValue *buzz_enabled;
+
+	priority_value = purple_value_new(PURPLE_TYPE_INT);
+	purple_value_set_int(priority_value, 1);
+	buzz_enabled = purple_value_new(PURPLE_TYPE_BOOLEAN);
+	purple_value_set_boolean(buzz_enabled, TRUE);
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
+			jabber_buddy_state_get_status_id(JABBER_BUDDY_STATE_ONLINE),
+			NULL, TRUE, TRUE, FALSE,
+			"priority", _("Priority"), priority_value,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			"mood", _("Mood"), purple_value_new(PURPLE_TYPE_STRING),
+			"moodtext", _("Mood Text"), purple_value_new(PURPLE_TYPE_STRING),
+			"nick", _("Nickname"), purple_value_new(PURPLE_TYPE_STRING),
+			"buzz", _("Allow Buzz"), buzz_enabled,
+			NULL);
+	types = g_list_prepend(types, type);
+
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_MOOD,
+	    "mood", NULL, TRUE, TRUE, TRUE,
+			PURPLE_MOOD_NAME, _("Mood Name"), purple_value_new(PURPLE_TYPE_STRING),
+			PURPLE_MOOD_COMMENT, _("Mood Comment"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	types = g_list_prepend(types, type);
+
+	priority_value = purple_value_new(PURPLE_TYPE_INT);
+	purple_value_set_int(priority_value, 1);
+	buzz_enabled = purple_value_new(PURPLE_TYPE_BOOLEAN);
+	purple_value_set_boolean(buzz_enabled, TRUE);
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
+			jabber_buddy_state_get_status_id(JABBER_BUDDY_STATE_CHAT),
+			_("Chatty"), TRUE, TRUE, FALSE,
+			"priority", _("Priority"), priority_value,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			"mood", _("Mood"), purple_value_new(PURPLE_TYPE_STRING),
+			"moodtext", _("Mood Text"), purple_value_new(PURPLE_TYPE_STRING),
+			"nick", _("Nickname"), purple_value_new(PURPLE_TYPE_STRING),
+			"buzz", _("Allow Buzz"), buzz_enabled,
+			NULL);
+	types = g_list_prepend(types, type);
+
+	priority_value = purple_value_new(PURPLE_TYPE_INT);
+	purple_value_set_int(priority_value, 0);
+	buzz_enabled = purple_value_new(PURPLE_TYPE_BOOLEAN);
+	purple_value_set_boolean(buzz_enabled, TRUE);
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AWAY,
+			jabber_buddy_state_get_status_id(JABBER_BUDDY_STATE_AWAY),
+			NULL, TRUE, TRUE, FALSE,
+			"priority", _("Priority"), priority_value,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			"mood", _("Mood"), purple_value_new(PURPLE_TYPE_STRING),
+			"moodtext", _("Mood Text"), purple_value_new(PURPLE_TYPE_STRING),
+			"nick", _("Nickname"), purple_value_new(PURPLE_TYPE_STRING),
+			"buzz", _("Allow Buzz"), buzz_enabled,
+			NULL);
+	types = g_list_prepend(types, type);
+
+	priority_value = purple_value_new(PURPLE_TYPE_INT);
+	purple_value_set_int(priority_value, 0);
+	buzz_enabled = purple_value_new(PURPLE_TYPE_BOOLEAN);
+	purple_value_set_boolean(buzz_enabled, TRUE);
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_EXTENDED_AWAY,
+			jabber_buddy_state_get_status_id(JABBER_BUDDY_STATE_XA),
+			NULL, TRUE, TRUE, FALSE,
+			"priority", _("Priority"), priority_value,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			"mood", _("Mood"), purple_value_new(PURPLE_TYPE_STRING),
+			"moodtext", _("Mood Text"), purple_value_new(PURPLE_TYPE_STRING),
+			"nick", _("Nickname"), purple_value_new(PURPLE_TYPE_STRING),
+			"buzz", _("Allow Buzz"), buzz_enabled,
+			NULL);
+	types = g_list_prepend(types, type);
+
+	priority_value = purple_value_new(PURPLE_TYPE_INT);
+	purple_value_set_int(priority_value, 0);
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_UNAVAILABLE,
+			jabber_buddy_state_get_status_id(JABBER_BUDDY_STATE_DND),
+			_("Do Not Disturb"), TRUE, TRUE, FALSE,
+			"priority", _("Priority"), priority_value,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			"mood", _("Mood"), purple_value_new(PURPLE_TYPE_STRING),
+			"moodtext", _("Mood Text"), purple_value_new(PURPLE_TYPE_STRING),
+			"nick", _("Nickname"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	types = g_list_prepend(types, type);
+
+	/*
+	if(js->protocol_version == JABBER_PROTO_0_9)
+		"Invisible"
+	*/
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_OFFLINE,
+			jabber_buddy_state_get_status_id(JABBER_BUDDY_STATE_UNAVAILABLE),
+			NULL, TRUE, TRUE, FALSE,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	types = g_list_prepend(types, type);
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_TUNE,
+			"tune", NULL, FALSE, TRUE, TRUE,
+			PURPLE_TUNE_ARTIST, _("Tune Artist"), purple_value_new(PURPLE_TYPE_STRING),
+			PURPLE_TUNE_TITLE, _("Tune Title"), purple_value_new(PURPLE_TYPE_STRING),
+			PURPLE_TUNE_ALBUM, _("Tune Album"), purple_value_new(PURPLE_TYPE_STRING),
+			PURPLE_TUNE_GENRE, _("Tune Genre"), purple_value_new(PURPLE_TYPE_STRING),
+			PURPLE_TUNE_COMMENT, _("Tune Comment"), purple_value_new(PURPLE_TYPE_STRING),
+			PURPLE_TUNE_TRACK, _("Tune Track"), purple_value_new(PURPLE_TYPE_STRING),
+			PURPLE_TUNE_TIME, _("Tune Time"), purple_value_new(PURPLE_TYPE_INT),
+			PURPLE_TUNE_YEAR, _("Tune Year"), purple_value_new(PURPLE_TYPE_INT),
+			PURPLE_TUNE_URL, _("Tune URL"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	types = g_list_prepend(types, type);
+
+	return g_list_reverse(types);
+}
+
+static void
+jabber_password_change_result_cb(JabberStream *js, const char *from,
+                                 JabberIqType type, const char *id,
+                                 xmlnode *packet, gpointer data)
+{
+	if (type == JABBER_IQ_RESULT) {
+		purple_notify_info(js->gc, _("Password Changed"), _("Password Changed"),
+				_("Your password has been changed."));
+
+		purple_account_set_password(js->gc->account, (char *)data);
+	} else {
+		char *msg = jabber_parse_error(js, packet, NULL);
+
+		purple_notify_error(js->gc, _("Error changing password"),
+				_("Error changing password"), msg);
+		g_free(msg);
+	}
+
+	g_free(data);
+}
+
+static void jabber_password_change_cb(JabberStream *js,
+		PurpleRequestFields *fields)
+{
+	const char *p1, *p2;
+	JabberIq *iq;
+	xmlnode *query, *y;
+
+	p1 = purple_request_fields_get_string(fields, "password1");
+	p2 = purple_request_fields_get_string(fields, "password2");
+
+	if(strcmp(p1, p2)) {
+		purple_notify_error(js->gc, NULL, _("New passwords do not match."), NULL);
+		return;
+	}
+
+	iq = jabber_iq_new_query(js, JABBER_IQ_SET, "jabber:iq:register");
+
+	xmlnode_set_attrib(iq->node, "to", js->user->domain);
+
+	query = xmlnode_get_child(iq->node, "query");
+
+	y = xmlnode_new_child(query, "username");
+	xmlnode_insert_data(y, js->user->node, -1);
+	y = xmlnode_new_child(query, "password");
+	xmlnode_insert_data(y, p1, -1);
+
+	jabber_iq_set_callback(iq, jabber_password_change_result_cb, g_strdup(p1));
+
+	jabber_iq_send(iq);
+}
+
+static void jabber_password_change(PurplePluginAction *action)
+{
+
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	JabberStream *js = gc->proto_data;
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *group;
+	PurpleRequestField *field;
+
+	fields = purple_request_fields_new();
+	group = purple_request_field_group_new(NULL);
+	purple_request_fields_add_group(fields, group);
+
+	field = purple_request_field_string_new("password1", _("Password"),
+			"", FALSE);
+	purple_request_field_string_set_masked(field, TRUE);
+	purple_request_field_set_required(field, TRUE);
+	purple_request_field_group_add_field(group, field);
+
+	field = purple_request_field_string_new("password2", _("Password (again)"),
+			"", FALSE);
+	purple_request_field_string_set_masked(field, TRUE);
+	purple_request_field_set_required(field, TRUE);
+	purple_request_field_group_add_field(group, field);
+
+	purple_request_fields(js->gc, _("Change XMPP Password"),
+			_("Change XMPP Password"), _("Please enter your new password"),
+			fields, _("OK"), G_CALLBACK(jabber_password_change_cb),
+			_("Cancel"), NULL,
+			purple_connection_get_account(gc), NULL, NULL,
+			js);
+}
+
+GList *jabber_actions(PurplePlugin *plugin, gpointer context)
+{
+	PurpleConnection *gc = (PurpleConnection *) context;
+	JabberStream *js = gc->proto_data;
+	GList *m = NULL;
+	PurplePluginAction *act;
+
+	act = purple_plugin_action_new(_("Set User Info..."),
+	                             jabber_setup_set_info);
+	m = g_list_append(m, act);
+
+	/* if (js->protocol_options & CHANGE_PASSWORD) { */
+		act = purple_plugin_action_new(_("Change Password..."),
+		                             jabber_password_change);
+		m = g_list_append(m, act);
+	/* } */
+
+	act = purple_plugin_action_new(_("Search for Users..."),
+	                             jabber_user_search_begin);
+	m = g_list_append(m, act);
+
+	purple_debug_info("jabber", "jabber_actions: have pep: %s\n", js->pep?"YES":"NO");
+
+	if(js->pep)
+		jabber_pep_init_actions(&m);
+
+	if(js->commands)
+		jabber_adhoc_init_server_commands(js, &m);
+
+	return m;
+}
+
+PurpleChat *jabber_find_blist_chat(PurpleAccount *account, const char *name)
+{
+	PurpleBlistNode *gnode, *cnode;
+	JabberID *jid;
+
+	if(!(jid = jabber_id_new(name)))
+		return NULL;
+
+	for(gnode = purple_blist_get_root(); gnode;
+			gnode = purple_blist_node_get_sibling_next(gnode)) {
+		for(cnode = purple_blist_node_get_first_child(gnode);
+				cnode;
+				cnode = purple_blist_node_get_sibling_next(cnode)) {
+			PurpleChat *chat = (PurpleChat*)cnode;
+			const char *room, *server;
+			GHashTable *components;
+			if(!PURPLE_BLIST_NODE_IS_CHAT(cnode))
+				continue;
+
+			if (purple_chat_get_account(chat) != account)
+				continue;
+
+			components = purple_chat_get_components(chat);
+			if(!(room = g_hash_table_lookup(components, "room")))
+				continue;
+			if(!(server = g_hash_table_lookup(components, "server")))
+				continue;
+
+			/* FIXME: Collate is wrong in a few cases here; this should be prepped */
+			if(jid->node && jid->domain &&
+					!g_utf8_collate(room, jid->node) && !g_utf8_collate(server, jid->domain)) {
+				jabber_id_free(jid);
+				return chat;
+			}
+		}
+	}
+	jabber_id_free(jid);
+	return NULL;
+}
+
+void jabber_convo_closed(PurpleConnection *gc, const char *who)
+{
+	JabberStream *js = gc->proto_data;
+	JabberID *jid;
+	JabberBuddy *jb;
+	JabberBuddyResource *jbr;
+
+	if(!(jid = jabber_id_new(who)))
+		return;
+
+	if((jb = jabber_buddy_find(js, who, TRUE)) &&
+			(jbr = jabber_buddy_find_resource(jb, jid->resource))) {
+		if(jbr->thread_id) {
+			g_free(jbr->thread_id);
+			jbr->thread_id = NULL;
+		}
+	}
+
+	jabber_id_free(jid);
+}
+
+
+char *jabber_parse_error(JabberStream *js,
+                         xmlnode *packet,
+                         PurpleConnectionError *reason)
+{
+	xmlnode *error;
+	const char *code = NULL, *text = NULL;
+	const char *xmlns = xmlnode_get_namespace(packet);
+	char *cdata = NULL;
+
+#define SET_REASON(x) \
+	if(reason != NULL) { *reason = x; }
+
+	if((error = xmlnode_get_child(packet, "error"))) {
+		xmlnode *t = xmlnode_get_child_with_namespace(error, "text", NS_XMPP_STANZAS);
+		if (t)
+			cdata = xmlnode_get_data(t);
+#if 0
+		cdata = xmlnode_get_data(error);
+#endif
+		code = xmlnode_get_attrib(error, "code");
+
+		/* Stanza errors */
+		if(xmlnode_get_child(error, "bad-request")) {
+			text = _("Bad Request");
+		} else if(xmlnode_get_child(error, "conflict")) {
+			SET_REASON(PURPLE_CONNECTION_ERROR_NAME_IN_USE);
+			text = _("Conflict");
+		} else if(xmlnode_get_child(error, "feature-not-implemented")) {
+			text = _("Feature Not Implemented");
+		} else if(xmlnode_get_child(error, "forbidden")) {
+			text = _("Forbidden");
+		} else if(xmlnode_get_child(error, "gone")) {
+			text = _("Gone");
+		} else if(xmlnode_get_child(error, "internal-server-error")) {
+			text = _("Internal Server Error");
+		} else if(xmlnode_get_child(error, "item-not-found")) {
+			text = _("Item Not Found");
+		} else if(xmlnode_get_child(error, "jid-malformed")) {
+			text = _("Malformed XMPP ID");
+		} else if(xmlnode_get_child(error, "not-acceptable")) {
+			text = _("Not Acceptable");
+		} else if(xmlnode_get_child(error, "not-allowed")) {
+			text = _("Not Allowed");
+		} else if(xmlnode_get_child(error, "not-authorized")) {
+			text = _("Not Authorized");
+		} else if(xmlnode_get_child(error, "payment-required")) {
+			text = _("Payment Required");
+		} else if(xmlnode_get_child(error, "recipient-unavailable")) {
+			text = _("Recipient Unavailable");
+		} else if(xmlnode_get_child(error, "redirect")) {
+			/* XXX */
+		} else if(xmlnode_get_child(error, "registration-required")) {
+			text = _("Registration Required");
+		} else if(xmlnode_get_child(error, "remote-server-not-found")) {
+			text = _("Remote Server Not Found");
+		} else if(xmlnode_get_child(error, "remote-server-timeout")) {
+			text = _("Remote Server Timeout");
+		} else if(xmlnode_get_child(error, "resource-constraint")) {
+			text = _("Server Overloaded");
+		} else if(xmlnode_get_child(error, "service-unavailable")) {
+			text = _("Service Unavailable");
+		} else if(xmlnode_get_child(error, "subscription-required")) {
+			text = _("Subscription Required");
+		} else if(xmlnode_get_child(error, "unexpected-request")) {
+			text = _("Unexpected Request");
+		} else if(xmlnode_get_child(error, "undefined-condition")) {
+			text = _("Unknown Error");
+		}
+	} else if(xmlns && !strcmp(xmlns, NS_XMPP_SASL)) {
+		/* Most common reason can be the default */
+		SET_REASON(PURPLE_CONNECTION_ERROR_NETWORK_ERROR);
+		if(xmlnode_get_child(packet, "aborted")) {
+			text = _("Authorization Aborted");
+		} else if(xmlnode_get_child(packet, "incorrect-encoding")) {
+			text = _("Incorrect encoding in authorization");
+		} else if(xmlnode_get_child(packet, "invalid-authzid")) {
+			text = _("Invalid authzid");
+		} else if(xmlnode_get_child(packet, "invalid-mechanism")) {
+			text = _("Invalid Authorization Mechanism");
+		} else if(xmlnode_get_child(packet, "mechanism-too-weak")) {
+			SET_REASON(PURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE);
+			text = _("Authorization mechanism too weak");
+		} else if(xmlnode_get_child(packet, "not-authorized")) {
+			SET_REASON(PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED);
+			/* Clear the pasword if it isn't being saved */
+			if (!purple_account_get_remember_password(js->gc->account))
+				purple_account_set_password(js->gc->account, NULL);
+			text = _("Not Authorized");
+		} else if(xmlnode_get_child(packet, "temporary-auth-failure")) {
+			text = _("Temporary Authentication Failure");
+		} else {
+			SET_REASON(PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED);
+			text = _("Authentication Failure");
+		}
+	} else if(!strcmp(packet->name, "stream:error") ||
+			 (!strcmp(packet->name, "error") && xmlns &&
+				!strcmp(xmlns, NS_XMPP_STREAMS))) {
+		/* Most common reason as default: */
+		SET_REASON(PURPLE_CONNECTION_ERROR_NETWORK_ERROR);
+		if(xmlnode_get_child(packet, "bad-format")) {
+			text = _("Bad Format");
+		} else if(xmlnode_get_child(packet, "bad-namespace-prefix")) {
+			text = _("Bad Namespace Prefix");
+		} else if(xmlnode_get_child(packet, "conflict")) {
+			SET_REASON(PURPLE_CONNECTION_ERROR_NAME_IN_USE);
+			text = _("Resource Conflict");
+		} else if(xmlnode_get_child(packet, "connection-timeout")) {
+			text = _("Connection Timeout");
+		} else if(xmlnode_get_child(packet, "host-gone")) {
+			text = _("Host Gone");
+		} else if(xmlnode_get_child(packet, "host-unknown")) {
+			text = _("Host Unknown");
+		} else if(xmlnode_get_child(packet, "improper-addressing")) {
+			text = _("Improper Addressing");
+		} else if(xmlnode_get_child(packet, "internal-server-error")) {
+			text = _("Internal Server Error");
+		} else if(xmlnode_get_child(packet, "invalid-id")) {
+			text = _("Invalid ID");
+		} else if(xmlnode_get_child(packet, "invalid-namespace")) {
+			text = _("Invalid Namespace");
+		} else if(xmlnode_get_child(packet, "invalid-xml")) {
+			text = _("Invalid XML");
+		} else if(xmlnode_get_child(packet, "nonmatching-hosts")) {
+			text = _("Non-matching Hosts");
+		} else if(xmlnode_get_child(packet, "not-authorized")) {
+			text = _("Not Authorized");
+		} else if(xmlnode_get_child(packet, "policy-violation")) {
+			text = _("Policy Violation");
+		} else if(xmlnode_get_child(packet, "remote-connection-failed")) {
+			text = _("Remote Connection Failed");
+		} else if(xmlnode_get_child(packet, "resource-constraint")) {
+			text = _("Resource Constraint");
+		} else if(xmlnode_get_child(packet, "restricted-xml")) {
+			text = _("Restricted XML");
+		} else if(xmlnode_get_child(packet, "see-other-host")) {
+			text = _("See Other Host");
+		} else if(xmlnode_get_child(packet, "system-shutdown")) {
+			text = _("System Shutdown");
+		} else if(xmlnode_get_child(packet, "undefined-condition")) {
+			text = _("Undefined Condition");
+		} else if(xmlnode_get_child(packet, "unsupported-encoding")) {
+			text = _("Unsupported Encoding");
+		} else if(xmlnode_get_child(packet, "unsupported-stanza-type")) {
+			text = _("Unsupported Stanza Type");
+		} else if(xmlnode_get_child(packet, "unsupported-version")) {
+			text = _("Unsupported Version");
+		} else if(xmlnode_get_child(packet, "xml-not-well-formed")) {
+			text = _("XML Not Well Formed");
+		} else {
+			text = _("Stream Error");
+		}
+	}
+
+#undef SET_REASON
+
+	if(text || cdata) {
+		char *ret = g_strdup_printf("%s%s%s", code ? code : "",
+				code ? ": " : "", text ? text : cdata);
+		g_free(cdata);
+		return ret;
+	} else {
+		return NULL;
+	}
+}
+
+static PurpleCmdRet jabber_cmd_chat_config(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+
+	if (!chat)
+		return PURPLE_CMD_RET_FAILED;
+
+	jabber_chat_request_room_configure(chat);
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_chat_register(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+
+	if (!chat)
+		return PURPLE_CMD_RET_FAILED;
+
+	jabber_chat_register(chat);
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_chat_topic(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+
+	if (!chat)
+		return PURPLE_CMD_RET_FAILED;
+
+	if (args && args[0] && *args[0])
+		jabber_chat_change_topic(chat, args[0]);
+	else {
+		const char *cur = purple_conv_chat_get_topic(PURPLE_CONV_CHAT(conv));
+		char *buf, *tmp, *tmp2;
+
+		if (cur) {
+			tmp = g_markup_escape_text(cur, -1);
+			tmp2 = purple_markup_linkify(tmp);
+			buf = g_strdup_printf(_("current topic is: %s"), tmp2);
+			g_free(tmp);
+			g_free(tmp2);
+		} else
+			buf = g_strdup(_("No topic is set"));
+		purple_conv_chat_write(PURPLE_CONV_CHAT(conv), "", buf,
+				PURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_NO_LOG, time(NULL));
+		g_free(buf);
+	}
+
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_chat_nick(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+
+	if(!chat || !args || !args[0])
+		return PURPLE_CMD_RET_FAILED;
+
+	if (!jabber_resourceprep_validate(args[0])) {
+		*error = g_strdup(_("Invalid nickname"));
+		return PURPLE_CMD_RET_FAILED;
+	}
+
+	if (jabber_chat_change_nick(chat, args[0]))
+		return PURPLE_CMD_RET_OK;
+	else
+		return PURPLE_CMD_RET_FAILED;
+}
+
+static PurpleCmdRet jabber_cmd_chat_part(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+
+	if (!chat)
+		return PURPLE_CMD_RET_FAILED;
+
+	jabber_chat_part(chat, args ? args[0] : NULL);
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_chat_ban(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+
+	if(!chat || !args || !args[0])
+		return PURPLE_CMD_RET_FAILED;
+
+	if(!jabber_chat_ban_user(chat, args[0], args[1])) {
+		*error = g_strdup_printf(_("Unable to ban user %s"), args[0]);
+		return PURPLE_CMD_RET_FAILED;
+	}
+
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_chat_affiliate(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+
+	if (!chat || !args || !args[0])
+		return PURPLE_CMD_RET_FAILED;
+
+	if (strcmp(args[0], "owner") != 0 &&
+	    strcmp(args[0], "admin") != 0 &&
+	    strcmp(args[0], "member") != 0 &&
+	    strcmp(args[0], "outcast") != 0 &&
+	    strcmp(args[0], "none") != 0) {
+		*error = g_strdup_printf(_("Unknown affiliation: \"%s\""), args[0]);
+		return PURPLE_CMD_RET_FAILED;
+	}
+
+	if (args[1]) {
+		int i;
+		char **nicks = g_strsplit(args[1], " ", -1);
+
+		for (i = 0; nicks[i]; ++i)
+			if (!jabber_chat_affiliate_user(chat, nicks[i], args[0])) {
+				*error = g_strdup_printf(_("Unable to affiliate user %s as \"%s\""), nicks[i], args[0]);
+				g_strfreev(nicks);
+				return PURPLE_CMD_RET_FAILED;
+			}
+
+		g_strfreev(nicks);
+	} else {
+		jabber_chat_affiliation_list(chat, args[0]);
+	}
+
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_chat_role(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+
+	if (!chat || !args || !args[0])
+		return PURPLE_CMD_RET_FAILED;
+
+	if (strcmp(args[0], "moderator") != 0 &&
+	    strcmp(args[0], "participant") != 0 &&
+	    strcmp(args[0], "visitor") != 0 &&
+	    strcmp(args[0], "none") != 0) {
+		*error = g_strdup_printf(_("Unknown role: \"%s\""), args[0]);
+		return PURPLE_CMD_RET_FAILED;
+	}
+
+	if (args[1]) {
+		int i;
+		char **nicks = g_strsplit(args[1], " ", -1);
+
+		for (i = 0; nicks[i]; i++)
+			if (!jabber_chat_role_user(chat, nicks[i], args[0], NULL)) {
+				*error = g_strdup_printf(_("Unable to set role \"%s\" for user: %s"),
+										 args[0], nicks[i]);
+				g_strfreev(nicks);
+				return PURPLE_CMD_RET_FAILED;
+			}
+
+		g_strfreev(nicks);
+	} else {
+		jabber_chat_role_list(chat, args[0]);
+	}
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_chat_invite(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	if(!args || !args[0])
+		return PURPLE_CMD_RET_FAILED;
+
+	jabber_chat_invite(purple_conversation_get_gc(conv),
+			purple_conv_chat_get_id(PURPLE_CONV_CHAT(conv)), args[1] ? args[1] : "",
+			args[0]);
+
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_chat_join(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+	GHashTable *components;
+	JabberID *jid = NULL;
+	const char *room = NULL, *server = NULL, *handle = NULL;
+
+	if (!chat || !args || !args[0])
+		return PURPLE_CMD_RET_FAILED;
+
+	components = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+
+	if (strchr(args[0], '@'))
+		jid = jabber_id_new(args[0]);
+	if (jid) {
+		room   = jid->node;
+		server = jid->domain;
+		handle = jid->resource ? jid->resource : chat->handle;
+	} else {
+		/* If jabber_id_new failed, the user may have just passed in
+		 * a room name.  For backward compatibility, handle that here.
+		 */
+		if (strchr(args[0], '@')) {
+			*error = g_strdup(_("Invalid XMPP ID"));
+			return PURPLE_CMD_RET_FAILED;
+		}
+
+		room   = args[0];
+		server = chat->server;
+		handle = chat->handle;
+	}
+
+	g_hash_table_insert(components, "room", (gpointer)room);
+	g_hash_table_insert(components, "server", (gpointer)server);
+	g_hash_table_insert(components, "handle", (gpointer)handle);
+
+	if (args[1])
+		g_hash_table_insert(components, "password", args[1]);
+
+	jabber_chat_join(purple_conversation_get_gc(conv), components);
+
+	g_hash_table_destroy(components);
+	jabber_id_free(jid);
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_chat_kick(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+
+	if(!chat || !args || !args[0])
+		return PURPLE_CMD_RET_FAILED;
+
+	if(!jabber_chat_role_user(chat, args[0], "none", args[1])) {
+		*error = g_strdup_printf(_("Unable to kick user %s"), args[0]);
+		return PURPLE_CMD_RET_FAILED;
+	}
+
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_chat_msg(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberChat *chat = jabber_chat_find_by_conv(conv);
+	char *who;
+
+	if (!chat)
+		return PURPLE_CMD_RET_FAILED;
+
+	who = g_strdup_printf("%s@%s/%s", chat->room, chat->server, args[0]);
+
+	jabber_message_send_im(purple_conversation_get_gc(conv), who, args[1], 0);
+
+	g_free(who);
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet jabber_cmd_ping(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	PurpleAccount *account;
+	PurpleConnection *pc;
+
+	if(!args || !args[0])
+		return PURPLE_CMD_RET_FAILED;
+
+	account = purple_conversation_get_account(conv);
+	pc = purple_account_get_connection(account);
+
+	if(!jabber_ping_jid(purple_connection_get_protocol_data(pc), args[0])) {
+		*error = g_strdup_printf(_("Unable to ping user %s"), args[0]);
+		return PURPLE_CMD_RET_FAILED;
+	}
+
+	return PURPLE_CMD_RET_OK;
+}
+
+static gboolean _jabber_send_buzz(JabberStream *js, const char *username, char **error) {
+
+	JabberBuddy *jb;
+	JabberBuddyResource *jbr;
+	PurpleConnection *gc = js->gc;
+	PurpleBuddy *buddy =
+		purple_find_buddy(purple_connection_get_account(gc), username);
+	const gchar *alias =
+		buddy ? purple_buddy_get_contact_alias(buddy) : username;
+
+	if(!username)
+		return FALSE;
+
+	jb = jabber_buddy_find(js, username, FALSE);
+	if(!jb) {
+		*error = g_strdup_printf(_("Unable to buzz, because there is nothing "
+			"known about %s."), alias);
+		return FALSE;
+	}
+
+	jbr = jabber_buddy_find_resource(jb, NULL);
+	if (!jbr) {
+		*error = g_strdup_printf(_("Unable to buzz, because %s might be offline."),
+			alias);
+		return FALSE;
+	}
+
+	if (jabber_resource_has_capability(jbr, NS_ATTENTION)) {
+		xmlnode *buzz, *msg = xmlnode_new("message");
+		gchar *to;
+
+		to = g_strdup_printf("%s/%s", username, jbr->name);
+		xmlnode_set_attrib(msg, "to", to);
+		g_free(to);
+
+		/* avoid offline storage */
+		xmlnode_set_attrib(msg, "type", "headline");
+
+		buzz = xmlnode_new_child(msg, "attention");
+		xmlnode_set_namespace(buzz, NS_ATTENTION);
+
+		jabber_send(js, msg);
+		xmlnode_free(msg);
+
+		return TRUE;
+	} else {
+		*error = g_strdup_printf(_("Unable to buzz, because %s does "
+			"not support it or does not wish to receive buzzes now."), alias);
+		return FALSE;
+	}
+}
+
+static PurpleCmdRet jabber_cmd_buzz(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberStream *js = conv->account->gc->proto_data;
+	const gchar *who;
+	gchar *description;
+	PurpleBuddy *buddy;
+	const char *alias;
+	PurpleAttentionType *attn =
+		purple_get_attention_type_from_code(conv->account, 0);
+
+	if (!args || !args[0]) {
+		/* use the buddy from conversation, if it's a one-to-one conversation */
+		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+			who = purple_conversation_get_name(conv);
+		} else {
+			return PURPLE_CMD_RET_FAILED;
+		}
+	} else {
+		who = args[0];
+	}
+
+	buddy = purple_find_buddy(conv->account, who);
+	if (buddy != NULL)
+		alias = purple_buddy_get_contact_alias(buddy);
+	else
+		alias = who;
+
+	description =
+		g_strdup_printf(purple_attention_type_get_outgoing_desc(attn), alias);
+	purple_conversation_write(conv, NULL, description,
+		PURPLE_MESSAGE_NOTIFY | PURPLE_MESSAGE_SYSTEM, time(NULL));
+	g_free(description);
+	return _jabber_send_buzz(js, who, error)  ? PURPLE_CMD_RET_OK : PURPLE_CMD_RET_FAILED;
+}
+
+GList *jabber_attention_types(PurpleAccount *account)
+{
+	static GList *types = NULL;
+
+	if (!types) {
+		types = g_list_append(types, purple_attention_type_new("Buzz", _("Buzz"),
+				_("%s has buzzed you!"), _("Buzzing %s...")));
+	}
+
+	return types;
+}
+
+gboolean jabber_send_attention(PurpleConnection *gc, const char *username, guint code)
+{
+	JabberStream *js = gc->proto_data;
+	gchar *error = NULL;
+
+	if (!_jabber_send_buzz(js, username, &error)) {
+		PurpleAccount *account = purple_connection_get_account(gc);
+		PurpleConversation *conv =
+			purple_find_conversation_with_account(PURPLE_CONV_TYPE_ANY, username, account);
+		purple_debug_error("jabber", "jabber_send_attention: jabber_cmd_buzz failed with error: %s\n", error ? error : "(NULL)");
+
+		if (conv) {
+			purple_conversation_write(conv, username, error, PURPLE_MESSAGE_ERROR,
+			    time(NULL));
+		}
+
+		g_free(error);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+gboolean jabber_offline_message(const PurpleBuddy *buddy)
+{
+	return TRUE;
+}
+
+#ifdef USE_VV
+gboolean
+jabber_audio_enabled(JabberStream *js, const char *namespace)
+{
+	PurpleMediaManager *manager = purple_media_manager_get();
+	PurpleMediaCaps caps = purple_media_manager_get_ui_caps(manager);
+
+	return (caps & (PURPLE_MEDIA_CAPS_AUDIO | PURPLE_MEDIA_CAPS_AUDIO_SINGLE_DIRECTION));
+}
+
+gboolean
+jabber_video_enabled(JabberStream *js, const char *namespace)
+{
+	PurpleMediaManager *manager = purple_media_manager_get();
+	PurpleMediaCaps caps = purple_media_manager_get_ui_caps(manager);
+
+	return (caps & (PURPLE_MEDIA_CAPS_VIDEO | PURPLE_MEDIA_CAPS_VIDEO_SINGLE_DIRECTION));
+}
+
+typedef struct {
+	PurpleAccount *account;
+	gchar *who;
+	PurpleMediaSessionType type;
+
+} JabberMediaRequest;
+
+static void
+jabber_media_cancel_cb(JabberMediaRequest *request,
+		PurpleRequestFields *fields)
+{
+	g_free(request->who);
+	g_free(request);
+}
+
+static void
+jabber_media_ok_cb(JabberMediaRequest *request, PurpleRequestFields *fields)
+{
+	PurpleRequestField *field =
+			purple_request_fields_get_field(fields, "resource");
+	int selected_id = purple_request_field_choice_get_value(field);
+	GList *labels = purple_request_field_choice_get_labels(field);
+	gchar *who = g_strdup_printf("%s/%s", request->who,
+			(gchar*)g_list_nth_data(labels, selected_id));
+	jabber_initiate_media(request->account, who, request->type);
+
+	g_free(who);
+	g_free(request->who);
+	g_free(request);
+}
+#endif
+
+gboolean
+jabber_initiate_media(PurpleAccount *account, const char *who,
+		      PurpleMediaSessionType type)
+{
+#ifdef USE_VV
+	JabberStream *js = (JabberStream *)
+			purple_account_get_connection(account)->proto_data;
+	JabberBuddy *jb;
+	JabberBuddyResource *jbr = NULL;
+	char *resource = NULL;
+
+	if (!js) {
+		purple_debug_error("jabber",
+				"jabber_initiate_media: NULL stream\n");
+		return FALSE;
+	}
+
+
+	jb = jabber_buddy_find(js, who, FALSE);
+
+	if(!jb || !jb->resources ||
+			(((resource = jabber_get_resource(who)) != NULL)
+			 && (jbr = jabber_buddy_find_resource(jb, resource)) == NULL)) {
+		/* no resources online, we're trying to initiate with someone
+		 * whose presence we're not subscribed to, or
+		 * someone who is offline.  Let's inform the user */
+		char *msg;
+
+		if(!jb) {
+			msg = g_strdup_printf(_("Unable to initiate media with %s: invalid JID"), who);
+		} else if(jb->subscription & JABBER_SUB_TO && !jb->resources) {
+			msg = g_strdup_printf(_("Unable to initiate media with %s: user is not online"), who);
+		} else if(resource) {
+			msg = g_strdup_printf(_("Unable to initiate media with %s: resource is not online"), who);
+		} else {
+			msg = g_strdup_printf(_("Unable to initiate media with %s: not subscribed to user presence"), who);
+		}
+
+		purple_notify_error(account, _("Media Initiation Failed"),
+				_("Media Initiation Failed"), msg);
+		g_free(msg);
+		g_free(resource);
+		return FALSE;
+	} else if(jbr != NULL) {
+		/* they've specified a resource, no need to ask or
+		 * default or anything, just do it */
+
+		g_free(resource);
+
+		if (type & PURPLE_MEDIA_AUDIO &&
+			!jabber_resource_has_capability(jbr,
+				JINGLE_APP_RTP_SUPPORT_AUDIO) &&
+			jabber_resource_has_capability(jbr, NS_GOOGLE_VOICE))
+			return jabber_google_session_initiate(js, who, type);
+		else
+			return jingle_rtp_initiate_media(js, who, type);
+	} else if(!jb->resources->next) {
+		/* only 1 resource online (probably our most common case)
+		 * so no need to ask who to initiate with */
+		gchar *name;
+		gboolean result;
+		jbr = jb->resources->data;
+		name = g_strdup_printf("%s/%s", who, jbr->name);
+		result = jabber_initiate_media(account, name, type);
+		g_free(name);
+		return result;
+	} else {
+		/* we've got multiple resources,
+		 * we need to pick one to initiate with */
+		GList *l;
+		char *msg;
+		PurpleRequestFields *fields;
+		PurpleRequestField *field = purple_request_field_choice_new(
+				"resource", _("Resource"), 0);
+		PurpleRequestFieldGroup *group;
+		JabberMediaRequest *request;
+
+		for(l = jb->resources; l; l = l->next)
+		{
+			JabberBuddyResource *ljbr = l->data;
+			PurpleMediaCaps caps;
+			gchar *name;
+			name = g_strdup_printf("%s/%s", who, ljbr->name);
+			caps = jabber_get_media_caps(account, name);
+			g_free(name);
+
+			if ((type & PURPLE_MEDIA_AUDIO) &&
+					(type & PURPLE_MEDIA_VIDEO)) {
+				if (caps & PURPLE_MEDIA_CAPS_AUDIO_VIDEO) {
+					jbr = ljbr;
+					purple_request_field_choice_add(
+							field, jbr->name);
+				}
+			} else if (type & (PURPLE_MEDIA_AUDIO) &&
+					(caps & PURPLE_MEDIA_CAPS_AUDIO)) {
+				jbr = ljbr;
+				purple_request_field_choice_add(
+						field, jbr->name);
+			}else if (type & (PURPLE_MEDIA_VIDEO) &&
+					(caps & PURPLE_MEDIA_CAPS_VIDEO)) {
+				jbr = ljbr;
+				purple_request_field_choice_add(
+						field, jbr->name);
+			}
+		}
+
+		if (jbr == NULL) {
+			purple_debug_error("jabber",
+					"No resources available\n");
+			return FALSE;
+		}
+
+		if (g_list_length(purple_request_field_choice_get_labels(
+				field)) <= 1) {
+			gchar *name;
+			gboolean result;
+			purple_request_field_destroy(field);
+			name = g_strdup_printf("%s/%s", who, jbr->name);
+			result = jabber_initiate_media(account, name, type);
+			g_free(name);
+			return result;
+		}
+
+		msg = g_strdup_printf(_("Please select the resource of %s with which you would like to start a media session."), who);
+		fields = purple_request_fields_new();
+		group =	purple_request_field_group_new(NULL);
+		request = g_new0(JabberMediaRequest, 1);
+		request->account = account;
+		request->who = g_strdup(who);
+		request->type = type;
+
+		purple_request_field_group_add_field(group, field);
+		purple_request_fields_add_group(fields, group);
+		purple_request_fields(account, _("Select a Resource"), msg,
+				NULL, fields, _("Initiate Media"),
+				G_CALLBACK(jabber_media_ok_cb), _("Cancel"),
+				G_CALLBACK(jabber_media_cancel_cb),
+				account, who, NULL, request);
+
+		g_free(msg);
+		return TRUE;
+	}
+#endif
+	return FALSE;
+}
+
+PurpleMediaCaps jabber_get_media_caps(PurpleAccount *account, const char *who)
+{
+#ifdef USE_VV
+	JabberStream *js = (JabberStream *)
+			purple_account_get_connection(account)->proto_data;
+	JabberBuddy *jb;
+	JabberBuddyResource *jbr;
+	PurpleMediaCaps total = PURPLE_MEDIA_CAPS_NONE;
+	gchar *resource;
+	GList *specific = NULL, *l;
+
+	if (!js) {
+		purple_debug_info("jabber",
+				"jabber_can_do_media: NULL stream\n");
+		return FALSE;
+	}
+
+	jb = jabber_buddy_find(js, who, FALSE);
+
+	if (!jb || !jb->resources) {
+		/* no resources online, we're trying to get caps for someone
+		 * whose presence we're not subscribed to, or
+		 * someone who is offline. */
+		return total;
+
+	} else if ((resource = jabber_get_resource(who)) != NULL) {
+		/* they've specified a resource, no need to ask or
+		 * default or anything, just do it */
+		jbr = jabber_buddy_find_resource(jb, resource);
+		g_free(resource);
+
+		if (!jbr) {
+			purple_debug_error("jabber", "jabber_get_media_caps:"
+					" Can't find resource %s\n", who);
+			return total;
+		}
+
+		l = specific = g_list_prepend(specific, jbr);
+
+	} else {
+		/* we've got multiple resources, combine their caps */
+		l = jb->resources;
+	}
+
+	for (; l; l = l->next) {
+		PurpleMediaCaps caps = PURPLE_MEDIA_CAPS_NONE;
+		jbr = l->data;
+
+		if (jabber_resource_has_capability(jbr,
+				JINGLE_APP_RTP_SUPPORT_AUDIO))
+			caps |= PURPLE_MEDIA_CAPS_AUDIO_SINGLE_DIRECTION |
+					PURPLE_MEDIA_CAPS_AUDIO;
+		if (jabber_resource_has_capability(jbr,
+				JINGLE_APP_RTP_SUPPORT_VIDEO))
+			caps |= PURPLE_MEDIA_CAPS_VIDEO_SINGLE_DIRECTION |
+					PURPLE_MEDIA_CAPS_VIDEO;
+		if (caps & PURPLE_MEDIA_CAPS_AUDIO && caps &
+				PURPLE_MEDIA_CAPS_VIDEO)
+			caps |= PURPLE_MEDIA_CAPS_AUDIO_VIDEO;
+		if (caps != PURPLE_MEDIA_CAPS_NONE) {
+			if (!jabber_resource_has_capability(jbr,
+					JINGLE_TRANSPORT_ICEUDP) &&
+					!jabber_resource_has_capability(jbr,
+					JINGLE_TRANSPORT_RAWUDP)) {
+				purple_debug_info("jingle-rtp", "Buddy doesn't "
+						"support the same transport types\n");
+				caps = PURPLE_MEDIA_CAPS_NONE;
+			} else
+				caps |= PURPLE_MEDIA_CAPS_MODIFY_SESSION |
+						PURPLE_MEDIA_CAPS_CHANGE_DIRECTION;
+		}
+		if (jabber_resource_has_capability(jbr, NS_GOOGLE_VOICE)) {
+			caps |= PURPLE_MEDIA_CAPS_AUDIO;
+			if (jabber_resource_has_capability(jbr, NS_GOOGLE_VIDEO))
+				caps |= PURPLE_MEDIA_CAPS_AUDIO_VIDEO;
+		}
+
+		total |= caps;
+	}
+
+	if (specific) {
+		g_list_free(specific);
+	}
+
+	return total;
+#else
+	return PURPLE_MEDIA_CAPS_NONE;
+#endif
+}
+
+gboolean jabber_can_receive_file(PurpleConnection *gc, const char *who)
+{
+	JabberStream *js = gc->proto_data;
+
+	if (js) {
+		JabberBuddy *jb = jabber_buddy_find(js, who, FALSE);
+		GList *iter;
+		gboolean has_resources_without_caps = FALSE;
+
+		/* if we didn't find a JabberBuddy, we don't have presence for this
+		 buddy, let's assume they can receive files, disco should tell us
+		 when actually trying */
+		if (jb == NULL)
+			return TRUE;
+
+		/* find out if there is any resources without caps */
+		for (iter = jb->resources; iter ; iter = g_list_next(iter)) {
+			JabberBuddyResource *jbr = (JabberBuddyResource *) iter->data;
+
+			if (!jabber_resource_know_capabilities(jbr)) {
+				has_resources_without_caps = TRUE;
+			}
+		}
+
+		if (has_resources_without_caps) {
+			/* there is at least one resource which we don't have caps for,
+			 let's assume they can receive files... */
+			return TRUE;
+		} else {
+			/* we have caps for all the resources, see if at least one has
+			 right caps */
+			for (iter = jb->resources; iter ; iter = g_list_next(iter)) {
+				JabberBuddyResource *jbr = (JabberBuddyResource *) iter->data;
+
+				if (jabber_resource_has_capability(jbr, NS_SI_FILE_TRANSFER)
+			    	&& (jabber_resource_has_capability(jbr,
+			    			NS_BYTESTREAMS)
+			        	|| jabber_resource_has_capability(jbr, NS_IBB))) {
+					return TRUE;
+				}
+			}
+			return FALSE;
+		}
+	} else {
+		return TRUE;
+	}
+}
+
+static PurpleCmdRet
+jabber_cmd_mood(PurpleConversation *conv,
+		const char *cmd, char **args, char **error, void *data)
+{
+	JabberStream *js = conv->account->gc->proto_data;
+
+	if (js->pep) {
+		/* if no argument was given, unset mood */
+		if (!args || !args[0]) {
+			jabber_mood_set(js, NULL, NULL);
+		} else if (!args[1]) {
+			jabber_mood_set(js, args[0], NULL);
+		} else {
+			jabber_mood_set(js, args[0], args[1]);
+		}
+
+		return PURPLE_CMD_RET_OK;
+	} else {
+		/* account does not support PEP, can't set a mood */
+		purple_conversation_write(conv, NULL,
+		    _("Account does not support PEP, can't set mood"),
+		    PURPLE_MESSAGE_ERROR, time(NULL));
+		return PURPLE_CMD_RET_FAILED;
+	}
+}
+
+static void jabber_register_commands(PurplePlugin *plugin)
+{
+	GSList *commands = NULL;
+	PurpleCmdId id;
+	id = purple_cmd_register("config", "", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,
+	                  "prpl-jabber", jabber_cmd_chat_config,
+	                  _("config:  Configure a chat room."), NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("configure", "", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,
+	                  "prpl-jabber", jabber_cmd_chat_config,
+	                  _("configure:  Configure a chat room."), NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("nick", "s", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,
+	                  "prpl-jabber", jabber_cmd_chat_nick,
+	                  _("nick &lt;new nickname&gt;:  Change your nickname."),
+	                  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("part", "s", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY |
+	                  PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS, "prpl-jabber",
+	                  jabber_cmd_chat_part, _("part [message]:  Leave the room."),
+	                  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("register", "", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,
+	                  "prpl-jabber", jabber_cmd_chat_register,
+	                  _("register:  Register with a chat room."), NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	/* XXX: there needs to be a core /topic cmd, methinks */
+	id = purple_cmd_register("topic", "s", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY |
+	                  PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS, "prpl-jabber",
+	                  jabber_cmd_chat_topic,
+	                  _("topic [new topic]:  View or change the topic."),
+	                  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("ban", "ws", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY |
+	                  PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS, "prpl-jabber",
+	                  jabber_cmd_chat_ban,
+	                  _("ban &lt;user&gt; [reason]:  Ban a user from the room."),
+	                  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("affiliate", "ws", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY |
+	                  PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS, "prpl-jabber",
+	                  jabber_cmd_chat_affiliate,
+	                  _("affiliate &lt;owner|admin|member|outcast|none&gt; [nick1] [nick2] ...: Get the users with an affiliation or set users' affiliation with the room."),
+	                  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("role", "ws", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY |
+	                  PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS, "prpl-jabber",
+	                  jabber_cmd_chat_role,
+	                  _("role &lt;moderator|participant|visitor|none&gt; [nick1] [nick2] ...: Get the users with a role or set users' role with the room."),
+	                  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("invite", "ws", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY |
+	                  PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS, "prpl-jabber",
+	                  jabber_cmd_chat_invite,
+	                  _("invite &lt;user&gt; [message]:  Invite a user to the room."),
+	                  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("join", "ws", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY |
+	                  PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS, "prpl-jabber",
+	                  jabber_cmd_chat_join,
+	                  _("join: &lt;room[@server]&gt; [password]:  Join a chat."),
+	                  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("kick", "ws", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY |
+	                  PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS, "prpl-jabber",
+	                  jabber_cmd_chat_kick,
+	                  _("kick &lt;user&gt; [reason]:  Kick a user from the room."),
+	                  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("msg", "ws", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_PRPL_ONLY,
+	                  "prpl-jabber", jabber_cmd_chat_msg,
+	                  _("msg &lt;user&gt; &lt;message&gt;:  Send a private message to another user."),
+	                  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("ping", "w", PURPLE_CMD_P_PRPL,
+					  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_IM |
+					  PURPLE_CMD_FLAG_PRPL_ONLY,
+					  "prpl-jabber", jabber_cmd_ping,
+					  _("ping &lt;jid&gt;:	Ping a user/component/server."),
+					  NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("buzz", "w", PURPLE_CMD_P_PRPL,
+					  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_PRPL_ONLY |
+					  PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS,
+					  "prpl-jabber", jabber_cmd_buzz,
+					  _("buzz: Buzz a user to get their attention"), NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	id = purple_cmd_register("mood", "ws", PURPLE_CMD_P_PRPL,
+	    			  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_IM |
+	    			  PURPLE_CMD_FLAG_PRPL_ONLY | PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS,
+	    			  "prpl-jabber", jabber_cmd_mood,
+	    			  _("mood: Set current user mood"), NULL);
+	commands = g_slist_prepend(commands, GUINT_TO_POINTER(id));
+
+	g_hash_table_insert(jabber_cmds, plugin, commands);
+}
+
+static void cmds_free_func(gpointer value)
+{
+	GSList *commands = value;
+	while (commands) {
+		purple_cmd_unregister(GPOINTER_TO_UINT(commands->data));
+		commands = g_slist_delete_link(commands, commands);
+	}
+}
+
+static void jabber_unregister_commands(PurplePlugin *plugin)
+{
+	g_hash_table_remove(jabber_cmds, plugin);
+}
+
+/* IPC functions */
+
+/**
+ * IPC function for determining if a contact supports a certain feature.
+ *
+ * @param account   The PurpleAccount
+ * @param jid       The full JID of the contact.
+ * @param feature   The feature's namespace.
+ *
+ * @return TRUE if supports feature; else FALSE.
+ */
+static gboolean
+jabber_ipc_contact_has_feature(PurpleAccount *account, const gchar *jid,
+                               const gchar *feature)
+{
+	PurpleConnection *gc = purple_account_get_connection(account);
+	JabberStream *js;
+	JabberBuddy *jb;
+	JabberBuddyResource *jbr;
+	gchar *resource;
+
+	if (!purple_account_is_connected(account))
+		return FALSE;
+	js = gc->proto_data;
+
+	if (!(resource = jabber_get_resource(jid)) ||
+	    !(jb = jabber_buddy_find(js, jid, FALSE)) ||
+	    !(jbr = jabber_buddy_find_resource(jb, resource))) {
+		g_free(resource);
+		return FALSE;
+	}
+
+	g_free(resource);
+
+	return jabber_resource_has_capability(jbr, feature);
+}
+
+static void
+jabber_ipc_add_feature(const gchar *feature)
+{
+	if (!feature)
+		return;
+	jabber_add_feature(feature, 0);
+
+	/* send presence with new caps info for all connected accounts */
+	jabber_caps_broadcast_change();
+}
+
+static void
+jabber_do_init(void)
+{
+	GHashTable *ui_info = purple_core_get_ui_info();
+	const gchar *ui_type;
+	const gchar *type = "pc"; /* default client type, if unknown or
+								unspecified */
+	const gchar *ui_name = NULL;
+#ifdef HAVE_CYRUS_SASL
+	/* We really really only want to do this once per process */
+	static gboolean sasl_initialized = FALSE;
+#ifdef _WIN32
+	UINT old_error_mode;
+	gchar *sasldir;
+#endif
+	int ret;
+#endif
+
+	/* XXX - If any other plugin wants SASL this won't be good ... */
+#ifdef HAVE_CYRUS_SASL
+	if (!sasl_initialized) {
+		sasl_initialized = TRUE;
+#ifdef _WIN32
+		sasldir = g_build_filename(wpurple_install_dir(), "sasl2", NULL);
+		sasl_set_path(SASL_PATH_TYPE_PLUGIN, sasldir);
+		g_free(sasldir);
+		/* Suppress error popups for failing to load sasl plugins */
+		old_error_mode = SetErrorMode(SEM_FAILCRITICALERRORS);
+#endif
+		if ((ret = sasl_client_init(NULL)) != SASL_OK) {
+			purple_debug_error("xmpp", "Error (%d) initializing SASL.\n", ret);
+		}
+#ifdef _WIN32
+		/* Restore the original error mode */
+		SetErrorMode(old_error_mode);
+#endif
+	}
+#endif
+
+	jabber_cmds = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, cmds_free_func);
+
+	ui_type = ui_info ? g_hash_table_lookup(ui_info, "client_type") : NULL;
+	if (ui_type) {
+		if (strcmp(ui_type, "pc") == 0 ||
+			strcmp(ui_type, "console") == 0 ||
+			strcmp(ui_type, "phone") == 0 ||
+			strcmp(ui_type, "handheld") == 0 ||
+			strcmp(ui_type, "web") == 0 ||
+			strcmp(ui_type, "bot") == 0) {
+			type = ui_type;
+		}
+	}
+
+	if (ui_info)
+		ui_name = g_hash_table_lookup(ui_info, "name");
+	if (ui_name == NULL)
+		ui_name = PACKAGE;
+
+	jabber_add_identity("client", type, NULL, ui_name);
+
+	/* initialize jabber_features list */
+	jabber_add_feature(NS_LAST_ACTIVITY, 0);
+	jabber_add_feature(NS_OOB_IQ_DATA, 0);
+	jabber_add_feature(NS_ENTITY_TIME, 0);
+	jabber_add_feature("jabber:iq:version", 0);
+	jabber_add_feature("jabber:x:conference", 0);
+	jabber_add_feature(NS_BYTESTREAMS, 0);
+	jabber_add_feature("http://jabber.org/protocol/caps", 0);
+	jabber_add_feature("http://jabber.org/protocol/chatstates", 0);
+	jabber_add_feature(NS_DISCO_INFO, 0);
+	jabber_add_feature(NS_DISCO_ITEMS, 0);
+	jabber_add_feature(NS_IBB, 0);
+	jabber_add_feature("http://jabber.org/protocol/muc", 0);
+	jabber_add_feature("http://jabber.org/protocol/muc#user", 0);
+	jabber_add_feature("http://jabber.org/protocol/si", 0);
+	jabber_add_feature(NS_SI_FILE_TRANSFER, 0);
+	jabber_add_feature(NS_XHTML_IM, 0);
+	jabber_add_feature(NS_PING, 0);
+
+	/* Buzz/Attention */
+	jabber_add_feature(NS_ATTENTION, jabber_buzz_isenabled);
+
+	/* Bits Of Binary */
+	jabber_add_feature(NS_BOB, 0);
+
+	/* Jingle features! */
+	jabber_add_feature(JINGLE, 0);
+
+#ifdef USE_VV
+	jabber_add_feature(NS_GOOGLE_PROTOCOL_SESSION, jabber_audio_enabled);
+	jabber_add_feature(NS_GOOGLE_VOICE, jabber_audio_enabled);
+	jabber_add_feature(NS_GOOGLE_VIDEO, jabber_video_enabled);
+	jabber_add_feature(NS_GOOGLE_CAMERA, jabber_video_enabled);
+	jabber_add_feature(JINGLE_APP_RTP, 0);
+	jabber_add_feature(JINGLE_APP_RTP_SUPPORT_AUDIO, jabber_audio_enabled);
+	jabber_add_feature(JINGLE_APP_RTP_SUPPORT_VIDEO, jabber_video_enabled);
+	jabber_add_feature(JINGLE_TRANSPORT_RAWUDP, 0);
+	jabber_add_feature(JINGLE_TRANSPORT_ICEUDP, 0);
+
+	g_signal_connect(G_OBJECT(purple_media_manager_get()), "ui-caps-changed",
+			G_CALLBACK(jabber_caps_broadcast_change), NULL);
+#endif
+
+	/* reverse order of unload_plugin */
+	jabber_iq_init();
+	jabber_presence_init();
+	jabber_caps_init();
+	/* PEP things should be init via jabber_pep_init, not here */
+	jabber_pep_init();
+	jabber_data_init();
+	jabber_bosh_init();
+
+	/* TODO: Implement adding and retrieving own features via IPC API */
+
+	jabber_ibb_init();
+	jabber_si_init();
+
+	jabber_auth_init();
+}
+
+static void
+jabber_do_uninit(void)
+{
+	/* reverse order of jabber_do_init */
+	jabber_bosh_uninit();
+	jabber_data_uninit();
+	jabber_si_uninit();
+	jabber_ibb_uninit();
+	/* PEP things should be uninit via jabber_pep_uninit, not here */
+	jabber_pep_uninit();
+	jabber_caps_uninit();
+	jabber_presence_uninit();
+	jabber_iq_uninit();
+
+#ifdef USE_VV
+	g_signal_handlers_disconnect_by_func(G_OBJECT(purple_media_manager_get()),
+			G_CALLBACK(jabber_caps_broadcast_change), NULL);
+#endif
+
+	jabber_auth_uninit();
+	jabber_features_destroy();
+	jabber_identities_destroy();
+
+	g_hash_table_destroy(jabber_cmds);
+	jabber_cmds = NULL;
+}
+
+void jabber_plugin_init(PurplePlugin *plugin)
+{
+	++plugin_ref;
+
+	if (plugin_ref == 1)
+		jabber_do_init();
+
+	jabber_register_commands(plugin);
+
+	/* IPC functions */
+	purple_plugin_ipc_register(plugin, "contact_has_feature", PURPLE_CALLBACK(jabber_ipc_contact_has_feature),
+							 purple_marshal_BOOLEAN__POINTER_POINTER_POINTER,
+							 purple_value_new(PURPLE_TYPE_BOOLEAN), 3,
+							 purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_ACCOUNT),
+							 purple_value_new(PURPLE_TYPE_STRING),
+							 purple_value_new(PURPLE_TYPE_STRING));
+
+	purple_plugin_ipc_register(plugin, "add_feature", PURPLE_CALLBACK(jabber_ipc_add_feature),
+							 purple_marshal_VOID__POINTER,
+							 NULL, 1,
+							 purple_value_new(PURPLE_TYPE_STRING));
+
+	purple_plugin_ipc_register(plugin, "register_namespace_watcher",
+	                           PURPLE_CALLBACK(jabber_iq_signal_register),
+	                           purple_marshal_VOID__POINTER_POINTER,
+	                           NULL, 2,
+	                           purple_value_new(PURPLE_TYPE_STRING),  /* node */
+	                           purple_value_new(PURPLE_TYPE_STRING)); /* namespace */
+
+	purple_plugin_ipc_register(plugin, "unregister_namespace_watcher",
+	                           PURPLE_CALLBACK(jabber_iq_signal_unregister),
+	                           purple_marshal_VOID__POINTER_POINTER,
+	                           NULL, 2,
+	                           purple_value_new(PURPLE_TYPE_STRING),  /* node */
+	                           purple_value_new(PURPLE_TYPE_STRING)); /* namespace */
+
+	purple_signal_register(plugin, "jabber-register-namespace-watcher",
+			purple_marshal_VOID__POINTER_POINTER,
+			NULL, 2,
+			purple_value_new(PURPLE_TYPE_STRING),  /* node */
+			purple_value_new(PURPLE_TYPE_STRING)); /* namespace */
+
+	purple_signal_register(plugin, "jabber-unregister-namespace-watcher",
+			purple_marshal_VOID__POINTER_POINTER,
+			NULL, 2,
+			purple_value_new(PURPLE_TYPE_STRING),  /* node */
+			purple_value_new(PURPLE_TYPE_STRING)); /* namespace */
+
+	purple_signal_connect(plugin, "jabber-register-namespace-watcher",
+			plugin, PURPLE_CALLBACK(jabber_iq_signal_register), NULL);
+	purple_signal_connect(plugin, "jabber-unregister-namespace-watcher",
+			plugin, PURPLE_CALLBACK(jabber_iq_signal_unregister), NULL);
+
+
+	purple_signal_register(plugin, "jabber-receiving-xmlnode",
+			purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new_outgoing(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE));
+
+	purple_signal_register(plugin, "jabber-sending-xmlnode",
+			purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new_outgoing(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE));
+
+	/*
+	 * Do not remove this or the plugin will fail. Completely. You have been
+	 * warned!
+	 */
+	purple_signal_connect_priority(plugin, "jabber-sending-xmlnode",
+			plugin, PURPLE_CALLBACK(jabber_send_signal_cb),
+			NULL, PURPLE_SIGNAL_PRIORITY_HIGHEST);
+
+	purple_signal_register(plugin, "jabber-sending-text",
+			     purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+			     purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			     purple_value_new_outgoing(PURPLE_TYPE_STRING));
+
+	purple_signal_register(plugin, "jabber-receiving-message",
+			purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_POINTER_POINTER,
+			purple_value_new(PURPLE_TYPE_BOOLEAN), 6,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new(PURPLE_TYPE_STRING), /* type */
+			purple_value_new(PURPLE_TYPE_STRING), /* id */
+			purple_value_new(PURPLE_TYPE_STRING), /* from */
+			purple_value_new(PURPLE_TYPE_STRING), /* to */
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE));
+
+	purple_signal_register(plugin, "jabber-receiving-iq",
+			purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_POINTER,
+			purple_value_new(PURPLE_TYPE_BOOLEAN), 5,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new(PURPLE_TYPE_STRING), /* type */
+			purple_value_new(PURPLE_TYPE_STRING), /* id */
+			purple_value_new(PURPLE_TYPE_STRING), /* from */
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE));
+
+	purple_signal_register(plugin, "jabber-watched-iq",
+			purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_POINTER,
+			purple_value_new(PURPLE_TYPE_BOOLEAN), 5,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new(PURPLE_TYPE_STRING), /* type */
+			purple_value_new(PURPLE_TYPE_STRING), /* id */
+			purple_value_new(PURPLE_TYPE_STRING), /* from */
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE)); /* child */
+
+	purple_signal_register(plugin, "jabber-receiving-presence",
+			purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER,
+			purple_value_new(PURPLE_TYPE_BOOLEAN), 4,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new(PURPLE_TYPE_STRING), /* type */
+			purple_value_new(PURPLE_TYPE_STRING), /* from */
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE));
+}
+
+void jabber_plugin_uninit(PurplePlugin *plugin)
+{
+	g_return_if_fail(plugin_ref > 0);
+
+	purple_signals_unregister_by_instance(plugin);
+	purple_plugin_ipc_unregister_all(plugin);
+
+	jabber_unregister_commands(plugin);
+
+	--plugin_ref;
+	if (plugin_ref == 0)
+		jabber_do_uninit();
+}
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/jabber/message.c pidgin-2.10.11/libpurple/protocols/jabber/message.c
--- pidgin-2.10.11.orig/libpurple/protocols/jabber/message.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/jabber/message.c	2015-02-10 14:28:16.390685387 +0900
@@ -586,15 +586,20 @@
 				jm->thread_id = xmlnode_get_data(child);
 		} else if(!strcmp(child->name, "body") && !strcmp(xmlns, NS_XMPP_CLIENT)) {
 			if(!jm->body) {
-				char *msg = xmlnode_get_data(child);
-				char *escaped = purple_markup_escape_text(msg, -1);
-				jm->body = purple_strdup_withhtml(escaped);
+				char *tmp, *msg, *escaped;
+				gsize len;
+				tmp = xmlnode_get_data(child);
+				escaped = purple_markup_escape_text(tmp, -1);
+				msg = sanitize_utf(escaped, strlen(escaped), &len);
+				jm->body = purple_strdup_withhtml(msg);
+				g_free(tmp);
 				g_free(escaped);
 				g_free(msg);
 			}
 		} else if(!strcmp(child->name, "html") && !strcmp(xmlns, NS_XHTML_IM)) {
 			if(!jm->xhtml && xmlnode_get_child(child, "body")) {
 				char *c;
+				gsize len;
 
 				const PurpleConnection *gc = js->gc;
 				PurpleAccount *account = purple_connection_get_account(gc);
@@ -645,7 +650,9 @@
 				reformatted_xhtml =
 					jabber_message_xml_to_string_strip_img_smileys(child);
 
-				jm->xhtml = reformatted_xhtml;
+				jm->xhtml =
+					sanitize_utf(reformatted_xhtml,
+								 strlen(reformatted_xhtml), &len);
 
 				/* add known custom emoticons to the conversation */
 				/* note: if there were no smileys in the incoming message, or
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/jabber/si.c pidgin-2.10.11/libpurple/protocols/jabber/si.c
--- pidgin-2.10.11.orig/libpurple/protocols/jabber/si.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/jabber/si.c	2015-02-10 14:28:16.390685387 +0900
@@ -42,6 +42,8 @@
 #define STREAMHOST_CONNECT_TIMEOUT 15
 #define ENABLE_FT_THUMBNAILS 0
 
+#include "util.h"
+
 typedef struct _JabberSIXfer {
 	JabberStream *js;
 
@@ -1237,13 +1239,24 @@
 	JabberIq *iq;
 	xmlnode *si, *file, *feature, *x, *field, *option, *value;
 	char buf[32];
+	gchar *f1 = NULL, *f2 = NULL;
+	gsize dummy;
 #if ENABLE_FT_THUMBNAILS
 	gconstpointer thumb;
 	gsize thumb_size;
 
 	purple_xfer_prepare_thumbnail(xfer, "jpeg,png");
 #endif
-	xfer->filename = g_path_get_basename(xfer->local_filename);
+	/* yaz */
+	f1 = g_filename_display_basename(xfer->local_filename);
+	f2 = botch_utf(f1, strlen(f1), &dummy);
+	if(f2) {
+		xfer->filename = f2;
+		g_free(f1); f1 = NULL;
+	}
+    else {
+		xfer->filename = f1;
+    }
 
 	iq = jabber_iq_new(jsx->js, JABBER_IQ_SET);
 	xmlnode_set_attrib(iq->node, "to", xfer->who);
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/jabber/si.c.orig pidgin-2.10.11/libpurple/protocols/jabber/si.c.orig
--- pidgin-2.10.11.orig/libpurple/protocols/jabber/si.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/jabber/si.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,1824 @@
+/*
+ * purple - Jabber Protocol Plugin
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+
+#include "internal.h"
+
+#include "blist.h"
+#include "debug.h"
+#include "ft.h"
+#include "request.h"
+#include "network.h"
+#include "notify.h"
+
+#include "buddy.h"
+#include "data.h"
+#include "disco.h"
+#include "jabber.h"
+#include "ibb.h"
+#include "iq.h"
+#include "si.h"
+
+#define STREAMHOST_CONNECT_TIMEOUT 15
+#define ENABLE_FT_THUMBNAILS 0
+
+typedef struct _JabberSIXfer {
+	JabberStream *js;
+
+	PurpleProxyConnectData *connect_data;
+	PurpleNetworkListenData *listen_data;
+	guint connect_timeout;
+
+	gboolean accepted;
+
+	char *stream_id;
+	char *iq_id;
+
+	enum {
+		STREAM_METHOD_UNKNOWN     = 0,
+		STREAM_METHOD_BYTESTREAMS = 2 << 1,
+		STREAM_METHOD_IBB         = 2 << 2,
+		STREAM_METHOD_UNSUPPORTED = 2 << 30
+	} stream_method;
+
+	GList *streamhosts;
+	PurpleProxyInfo *gpi;
+
+	char *rxqueue;
+	size_t rxlen;
+	gsize rxmaxlen;
+	int local_streamhost_fd;
+
+	JabberIBBSession *ibb_session;
+	guint ibb_timeout_handle;
+	PurpleCircBuffer *ibb_buffer;
+} JabberSIXfer;
+
+/* some forward declarations */
+static void jabber_si_xfer_ibb_send_init(JabberStream *js, PurpleXfer *xfer);
+
+static PurpleXfer*
+jabber_si_xfer_find(JabberStream *js, const char *sid, const char *from)
+{
+	GList *xfers;
+
+	if(!sid || !from)
+		return NULL;
+
+	for(xfers = js->file_transfers; xfers; xfers = xfers->next) {
+		PurpleXfer *xfer = xfers->data;
+		JabberSIXfer *jsx = xfer->data;
+		if(jsx->stream_id && xfer->who &&
+				!strcmp(jsx->stream_id, sid) && !strcmp(xfer->who, from))
+			return xfer;
+	}
+
+	return NULL;
+}
+
+static void
+jabber_si_free_streamhost(gpointer data, gpointer user_data)
+{
+	JabberBytestreamsStreamhost *sh = data;
+
+	if(!data)
+		return;
+
+	g_free(sh->jid);
+	g_free(sh->host);
+	g_free(sh->zeroconf);
+	g_free(sh);
+}
+
+
+
+static void jabber_si_bytestreams_attempt_connect(PurpleXfer *xfer);
+
+static void
+jabber_si_bytestreams_connect_cb(gpointer data, gint source, const gchar *error_message)
+{
+	PurpleXfer *xfer = data;
+	JabberSIXfer *jsx = xfer->data;
+	JabberIq *iq;
+	xmlnode *query, *su;
+	JabberBytestreamsStreamhost *streamhost = jsx->streamhosts->data;
+
+	purple_proxy_info_destroy(jsx->gpi);
+	jsx->gpi = NULL;
+	jsx->connect_data = NULL;
+
+	if (jsx->connect_timeout > 0)
+		purple_timeout_remove(jsx->connect_timeout);
+	jsx->connect_timeout = 0;
+
+	if(source < 0) {
+		purple_debug_warning("jabber",
+				"si connection failed, jid was %s, host was %s, error was %s\n",
+				streamhost->jid, streamhost->host,
+				error_message ? error_message : "(null)");
+		jsx->streamhosts = g_list_remove(jsx->streamhosts, streamhost);
+		jabber_si_free_streamhost(streamhost, NULL);
+		jabber_si_bytestreams_attempt_connect(xfer);
+		return;
+	}
+
+	/* unknown file transfer type is assumed to be RECEIVE */
+	if(xfer->type == PURPLE_XFER_SEND)
+	{
+		xmlnode *activate;
+		iq = jabber_iq_new_query(jsx->js, JABBER_IQ_SET, NS_BYTESTREAMS);
+		xmlnode_set_attrib(iq->node, "to", streamhost->jid);
+		query = xmlnode_get_child(iq->node, "query");
+		xmlnode_set_attrib(query, "sid", jsx->stream_id);
+		activate = xmlnode_new_child(query, "activate");
+		xmlnode_insert_data(activate, xfer->who, -1);
+
+		/* TODO: We need to wait for an activation result before starting */
+	}
+	else
+	{
+		iq = jabber_iq_new_query(jsx->js, JABBER_IQ_RESULT, NS_BYTESTREAMS);
+		xmlnode_set_attrib(iq->node, "to", xfer->who);
+		jabber_iq_set_id(iq, jsx->iq_id);
+		query = xmlnode_get_child(iq->node, "query");
+		su = xmlnode_new_child(query, "streamhost-used");
+		xmlnode_set_attrib(su, "jid", streamhost->jid);
+	}
+
+	jabber_iq_send(iq);
+
+	purple_xfer_start(xfer, source, NULL, -1);
+}
+
+static gboolean
+connect_timeout_cb(gpointer data)
+{
+	PurpleXfer *xfer = data;
+	JabberSIXfer *jsx = xfer->data;
+
+	purple_debug_info("jabber", "Streamhost connection timeout of %d seconds exceeded.\n", STREAMHOST_CONNECT_TIMEOUT);
+
+	jsx->connect_timeout = 0;
+
+	if (jsx->connect_data != NULL)
+		purple_proxy_connect_cancel(jsx->connect_data);
+	jsx->connect_data = NULL;
+
+	/* Trigger the connect error manually */
+	jabber_si_bytestreams_connect_cb(xfer, -1, "Timeout Exceeded.");
+
+	return FALSE;
+}
+
+static void
+jabber_si_bytestreams_ibb_timeout_remove(JabberSIXfer *jsx)
+{
+	if (jsx->ibb_timeout_handle) {
+		purple_timeout_remove(jsx->ibb_timeout_handle);
+		jsx->ibb_timeout_handle = 0;
+	}
+}
+
+static gboolean
+jabber_si_bytestreams_ibb_timeout_cb(gpointer data)
+{
+	PurpleXfer *xfer = (PurpleXfer *) data;
+	JabberSIXfer *jsx = xfer->data;
+
+	if (jsx && !jsx->ibb_session) {
+		purple_debug_info("jabber",
+			"jabber_si_bytestreams_ibb_timeout called and IBB session not set "
+			" up yet, cancel transfer");
+		jabber_si_bytestreams_ibb_timeout_remove(jsx);
+		purple_xfer_cancel_local(xfer);
+	}
+
+	return FALSE;
+}
+
+static void jabber_si_bytestreams_attempt_connect(PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx = xfer->data;
+	JabberBytestreamsStreamhost *streamhost;
+	JabberID *dstjid;
+
+	if(!jsx->streamhosts) {
+		JabberIq *iq = jabber_iq_new(jsx->js, JABBER_IQ_ERROR);
+		xmlnode *error, *inf;
+
+		if(jsx->iq_id)
+			jabber_iq_set_id(iq, jsx->iq_id);
+
+		xmlnode_set_attrib(iq->node, "to", xfer->who);
+		error = xmlnode_new_child(iq->node, "error");
+		xmlnode_set_attrib(error, "code", "404");
+		xmlnode_set_attrib(error, "type", "cancel");
+		inf = xmlnode_new_child(error, "item-not-found");
+		xmlnode_set_namespace(inf, NS_XMPP_STANZAS);
+
+		jabber_iq_send(iq);
+
+		/* if IBB is available, revert to that before giving up... */
+		if (jsx->stream_method & STREAM_METHOD_IBB) {
+			/* if we are the initializer, init IBB */
+			purple_debug_info("jabber",
+				"jabber_si_bytestreams_attempt_connect: "
+				"no streamhosts found, trying IBB\n");
+			/* if we are the sender, open an IBB session, but not if we already
+			  did it, since we could have received the error <iq/> from the
+			  receiver already... */
+			if (purple_xfer_get_type(xfer) == PURPLE_XFER_SEND
+				&& !jsx->ibb_session) {
+				jabber_si_xfer_ibb_send_init(jsx->js, xfer);
+			} else {
+				/* setup a timeout to cancel waiting for IBB open */
+				jsx->ibb_timeout_handle = purple_timeout_add_seconds(30,
+					jabber_si_bytestreams_ibb_timeout_cb, xfer);
+			}
+			/* if we are the receiver, just wait for IBB open, callback is
+			  already set up... */
+		} else {
+			purple_xfer_cancel_local(xfer);
+		}
+
+		return;
+	}
+
+	streamhost = jsx->streamhosts->data;
+
+	jsx->connect_data = NULL;
+	if (jsx->gpi != NULL)
+		purple_proxy_info_destroy(jsx->gpi);
+	jsx->gpi = NULL;
+
+	dstjid = jabber_id_new(xfer->who);
+
+	/* TODO: Deal with zeroconf */
+
+	if(dstjid != NULL && streamhost->host && streamhost->port > 0) {
+		char *dstaddr, *hash;
+		PurpleAccount *account;
+		jsx->gpi = purple_proxy_info_new();
+		purple_proxy_info_set_type(jsx->gpi, PURPLE_PROXY_SOCKS5);
+		purple_proxy_info_set_host(jsx->gpi, streamhost->host);
+		purple_proxy_info_set_port(jsx->gpi, streamhost->port);
+
+		/* unknown file transfer type is assumed to be RECEIVE */
+		if(xfer->type == PURPLE_XFER_SEND)
+			dstaddr = g_strdup_printf("%s%s@%s/%s%s@%s/%s", jsx->stream_id, jsx->js->user->node, jsx->js->user->domain,
+				jsx->js->user->resource, dstjid->node, dstjid->domain, dstjid->resource);
+		else
+			dstaddr = g_strdup_printf("%s%s@%s/%s%s@%s/%s", jsx->stream_id, dstjid->node, dstjid->domain, dstjid->resource,
+				jsx->js->user->node, jsx->js->user->domain, jsx->js->user->resource);
+
+		/* Per XEP-0065, the 'host' must be SHA1(SID + from JID + to JID) */
+		hash = jabber_calculate_data_hash(dstaddr, strlen(dstaddr), "sha1");
+
+		account = purple_connection_get_account(jsx->js->gc);
+		jsx->connect_data = purple_proxy_connect_socks5_account(NULL, account,
+				jsx->gpi, hash, 0,
+				jabber_si_bytestreams_connect_cb, xfer);
+		g_free(hash);
+		g_free(dstaddr);
+
+		/* When selecting a streamhost, timeout after STREAMHOST_CONNECT_TIMEOUT seconds, otherwise it takes forever */
+		if (xfer->type != PURPLE_XFER_SEND && jsx->connect_data != NULL)
+			jsx->connect_timeout = purple_timeout_add_seconds(
+				STREAMHOST_CONNECT_TIMEOUT, connect_timeout_cb, xfer);
+
+		jabber_id_free(dstjid);
+	}
+
+	if (jsx->connect_data == NULL)
+	{
+		jsx->streamhosts = g_list_remove(jsx->streamhosts, streamhost);
+		jabber_si_free_streamhost(streamhost, NULL);
+		jabber_si_bytestreams_attempt_connect(xfer);
+	}
+}
+
+void jabber_bytestreams_parse(JabberStream *js, const char *from,
+                              JabberIqType type, const char *id, xmlnode *query)
+{
+	PurpleXfer *xfer;
+	JabberSIXfer *jsx;
+	xmlnode *streamhost;
+	const char *sid;
+
+	if(type != JABBER_IQ_SET)
+		return;
+
+	if(!from)
+		return;
+
+	if(!(sid = xmlnode_get_attrib(query, "sid")))
+		return;
+
+	if(!(xfer = jabber_si_xfer_find(js, sid, from)))
+		return;
+
+	jsx = xfer->data;
+
+	if(!jsx->accepted)
+		return;
+
+	if(jsx->iq_id)
+		g_free(jsx->iq_id);
+	jsx->iq_id = g_strdup(id);
+
+	for(streamhost = xmlnode_get_child(query, "streamhost"); streamhost;
+			streamhost = xmlnode_get_next_twin(streamhost)) {
+		const char *jid, *host = NULL, *port, *zeroconf;
+		int portnum = 0;
+
+		if((jid = xmlnode_get_attrib(streamhost, "jid")) &&
+				((zeroconf = xmlnode_get_attrib(streamhost, "zeroconf")) ||
+				((host = xmlnode_get_attrib(streamhost, "host")) &&
+				(port = xmlnode_get_attrib(streamhost, "port")) &&
+				(portnum = atoi(port))))) {
+			JabberBytestreamsStreamhost *sh = g_new0(JabberBytestreamsStreamhost, 1);
+			sh->jid = g_strdup(jid);
+			sh->host = g_strdup(host);
+			sh->port = portnum;
+			sh->zeroconf = g_strdup(zeroconf);
+			/* If there were a lot of these, it'd be worthwhile to prepend and reverse. */
+			jsx->streamhosts = g_list_append(jsx->streamhosts, sh);
+		}
+	}
+
+	jabber_si_bytestreams_attempt_connect(xfer);
+}
+
+
+static void
+jabber_si_xfer_bytestreams_send_read_again_resp_cb(gpointer data, gint source,
+		PurpleInputCondition cond)
+{
+	PurpleXfer *xfer = data;
+	JabberSIXfer *jsx = xfer->data;
+	int len;
+
+	len = write(source, jsx->rxqueue + jsx->rxlen, jsx->rxmaxlen - jsx->rxlen);
+	if (len < 0 && errno == EAGAIN)
+		return;
+	else if (len < 0) {
+		purple_input_remove(xfer->watcher);
+		xfer->watcher = 0;
+		g_free(jsx->rxqueue);
+		jsx->rxqueue = NULL;
+		close(source);
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+	jsx->rxlen += len;
+
+	if (jsx->rxlen < jsx->rxmaxlen)
+		return;
+
+	purple_input_remove(xfer->watcher);
+	xfer->watcher = 0;
+	g_free(jsx->rxqueue);
+	jsx->rxqueue = NULL;
+
+	/* Before actually starting sending the file, we need to wait until the
+	 * recipient sends the IQ result with <streamhost-used/>
+	 */
+	purple_debug_info("jabber", "SOCKS5 connection negotiation completed. "
+					  "Waiting for IQ result to start file transfer.\n");
+}
+
+static void
+jabber_si_xfer_bytestreams_send_read_again_cb(gpointer data, gint source,
+		PurpleInputCondition cond)
+{
+	PurpleXfer *xfer = data;
+	JabberSIXfer *jsx = xfer->data;
+	char buffer[42]; /* 40 for DST.ADDR + 2 bytes for port number*/
+	int len;
+	char *dstaddr, *hash;
+	const char *host;
+
+	purple_debug_info("jabber", "in jabber_si_xfer_bytestreams_send_read_again_cb\n");
+
+	if(jsx->rxlen < 5) {
+		purple_debug_info("jabber", "reading the first 5 bytes\n");
+		len = read(source, buffer, 5 - jsx->rxlen);
+		if(len < 0 && errno == EAGAIN)
+			return;
+		else if(len <= 0) {
+			purple_input_remove(xfer->watcher);
+			xfer->watcher = 0;
+			close(source);
+			purple_xfer_cancel_remote(xfer);
+			return;
+		}
+		jsx->rxqueue = g_realloc(jsx->rxqueue, len + jsx->rxlen);
+		memcpy(jsx->rxqueue + jsx->rxlen, buffer, len);
+		jsx->rxlen += len;
+		return;
+	} else if(jsx->rxqueue[0] != 0x05 || jsx->rxqueue[1] != 0x01 ||
+			jsx->rxqueue[3] != 0x03 || jsx->rxqueue[4] != 40) {
+		purple_debug_info("jabber", "Invalid socks5 conn req. header[0x%x,0x%x,0x%x,0x%x,0x%x]\n",
+				  jsx->rxqueue[0], jsx->rxqueue[1], jsx->rxqueue[2],
+				  jsx->rxqueue[3], jsx->rxqueue[4]);
+		purple_input_remove(xfer->watcher);
+		xfer->watcher = 0;
+		close(source);
+		purple_xfer_cancel_remote(xfer);
+		return;
+	} else if(jsx->rxlen - 5 < (size_t)jsx->rxqueue[4] + 2) {
+		/* Upper-bound of 257 (jsx->rxlen = 5, jsx->rxqueue[4] = 0xFF) */
+		unsigned short to_read = jsx->rxqueue[4] + 2 - (jsx->rxlen - 5);
+		purple_debug_info("jabber", "reading %u bytes for DST.ADDR + port num (trying to read %hu now)\n",
+				  jsx->rxqueue[4] + 2, to_read);
+		len = read(source, buffer, to_read);
+		if(len < 0 && errno == EAGAIN)
+			return;
+		else if(len <= 0) {
+			purple_input_remove(xfer->watcher);
+			xfer->watcher = 0;
+			close(source);
+			purple_xfer_cancel_remote(xfer);
+			return;
+		}
+		jsx->rxqueue = g_realloc(jsx->rxqueue, len + jsx->rxlen);
+		memcpy(jsx->rxqueue + jsx->rxlen, buffer, len);
+		jsx->rxlen += len;
+	}
+
+	/* Have we not read all of DST.ADDR and the following 2-byte port number? */
+	if(jsx->rxlen - 5 < (size_t)jsx->rxqueue[4] + 2)
+		return;
+
+	purple_input_remove(xfer->watcher);
+	xfer->watcher = 0;
+
+	dstaddr = g_strdup_printf("%s%s@%s/%s%s", jsx->stream_id,
+			jsx->js->user->node, jsx->js->user->domain,
+			jsx->js->user->resource, xfer->who);
+
+	/* Per XEP-0065, the 'host' must be SHA1(SID + from JID + to JID) */
+	hash = jabber_calculate_data_hash(dstaddr, strlen(dstaddr), "sha1");
+
+	if(strncmp(hash, jsx->rxqueue + 5, 40) ||
+			jsx->rxqueue[45] != 0x00 || jsx->rxqueue[46] != 0x00) {
+		if (jsx->rxqueue[45] != 0x00 || jsx->rxqueue[46] != 0x00)
+			purple_debug_error("jabber", "Got SOCKS5 BS conn with the wrong DST.PORT"
+						     " (must be 0 - got[0x%x,0x%x]).\n",
+						     jsx->rxqueue[45], jsx->rxqueue[46]);
+		else
+			purple_debug_error("jabber", "Got SOCKS5 BS conn with the wrong DST.ADDR"
+						     " (expected '%s' - got '%.40s').\n",
+						     hash, jsx->rxqueue + 5);
+		close(source);
+		purple_xfer_cancel_remote(xfer);
+		g_free(hash);
+		g_free(dstaddr);
+		return;
+	}
+
+	g_free(hash);
+	g_free(dstaddr);
+
+	g_free(jsx->rxqueue);
+	host = purple_network_get_my_ip(jsx->js->fd);
+
+	jsx->rxmaxlen = 5 + strlen(host) + 2;
+	jsx->rxqueue = g_malloc(jsx->rxmaxlen);
+	jsx->rxlen = 0;
+
+	jsx->rxqueue[0] = 0x05;
+	jsx->rxqueue[1] = 0x00;
+	jsx->rxqueue[2] = 0x00;
+	jsx->rxqueue[3] = 0x03;
+	jsx->rxqueue[4] = strlen(host);
+	memcpy(jsx->rxqueue + 5, host, strlen(host));
+	jsx->rxqueue[5+strlen(host)] = 0x00;
+	jsx->rxqueue[6+strlen(host)] = 0x00;
+
+	xfer->watcher = purple_input_add(source, PURPLE_INPUT_WRITE,
+		jabber_si_xfer_bytestreams_send_read_again_resp_cb, xfer);
+	jabber_si_xfer_bytestreams_send_read_again_resp_cb(xfer, source,
+		PURPLE_INPUT_WRITE);
+}
+
+static void
+jabber_si_xfer_bytestreams_send_read_response_cb(gpointer data, gint source,
+		PurpleInputCondition cond)
+{
+	PurpleXfer *xfer = data;
+	JabberSIXfer *jsx = xfer->data;
+	int len;
+
+	len = write(source, jsx->rxqueue + jsx->rxlen, jsx->rxmaxlen - jsx->rxlen);
+	if (len < 0 && errno == EAGAIN)
+		return;
+	else if (len < 0) {
+		purple_input_remove(xfer->watcher);
+		xfer->watcher = 0;
+		g_free(jsx->rxqueue);
+		jsx->rxqueue = NULL;
+		close(source);
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+	jsx->rxlen += len;
+
+	if (jsx->rxlen < jsx->rxmaxlen)
+		return;
+
+	purple_input_remove(xfer->watcher);
+	xfer->watcher = 0;
+
+	/* If we sent a "Success", wait for a response, otherwise give up and cancel */
+	if (jsx->rxqueue[1] == 0x00) {
+		xfer->watcher = purple_input_add(source, PURPLE_INPUT_READ,
+			jabber_si_xfer_bytestreams_send_read_again_cb, xfer);
+		g_free(jsx->rxqueue);
+		jsx->rxqueue = NULL;
+		jsx->rxlen = 0;
+	} else {
+		close(source);
+		purple_xfer_cancel_remote(xfer);
+	}
+}
+
+static void
+jabber_si_xfer_bytestreams_send_read_cb(gpointer data, gint source,
+		PurpleInputCondition cond)
+{
+	PurpleXfer *xfer = data;
+	JabberSIXfer *jsx = xfer->data;
+	int i;
+	int len;
+	char buffer[256];
+
+	purple_debug_info("jabber", "in jabber_si_xfer_bytestreams_send_read_cb\n");
+
+	xfer->fd = source;
+
+	/** Try to read the SOCKS5 header */
+	if(jsx->rxlen < 2) {
+		purple_debug_info("jabber", "reading those first two bytes\n");
+		len = read(source, buffer, 2 - jsx->rxlen);
+		if(len < 0 && errno == EAGAIN)
+			return;
+		else if(len <= 0) {
+			purple_input_remove(xfer->watcher);
+			xfer->watcher = 0;
+			close(source);
+			purple_xfer_cancel_remote(xfer);
+			return;
+		}
+		jsx->rxqueue = g_realloc(jsx->rxqueue, len + jsx->rxlen);
+		memcpy(jsx->rxqueue + jsx->rxlen, buffer, len);
+		jsx->rxlen += len;
+		return;
+	} else if(jsx->rxlen - 2 < (size_t)jsx->rxqueue[1]) {
+		/* Has a maximum value of 255 (jsx->rxlen = 2, jsx->rxqueue[1] = 0xFF) */
+		unsigned short to_read = jsx->rxqueue[1] - (jsx->rxlen - 2);
+		purple_debug_info("jabber", "reading %u bytes for auth methods (trying to read %hu now)\n",
+				  jsx->rxqueue[1], to_read);
+		len = read(source, buffer, to_read);
+		if(len < 0 && errno == EAGAIN)
+			return;
+		else if(len <= 0) {
+			purple_input_remove(xfer->watcher);
+			xfer->watcher = 0;
+			close(source);
+			purple_xfer_cancel_remote(xfer);
+			return;
+		}
+		jsx->rxqueue = g_realloc(jsx->rxqueue, len + jsx->rxlen);
+		memcpy(jsx->rxqueue + jsx->rxlen, buffer, len);
+		jsx->rxlen += len;
+	}
+
+	/* Have we not read all the auth. method bytes? */
+	if(jsx->rxlen -2 < (size_t)jsx->rxqueue[1])
+		return;
+
+	purple_input_remove(xfer->watcher);
+	xfer->watcher = 0;
+
+	purple_debug_info("jabber", "checking to make sure we're socks FIVE\n");
+
+	if(jsx->rxqueue[0] != 0x05) {
+		close(source);
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	purple_debug_info("jabber", "going to test %hhu different methods\n", jsx->rxqueue[1]);
+
+	for(i=0; i<jsx->rxqueue[1]; i++) {
+
+		purple_debug_info("jabber", "testing %hhu\n", jsx->rxqueue[i+2]);
+		if(jsx->rxqueue[i+2] == 0x00) {
+			g_free(jsx->rxqueue);
+			jsx->rxlen = 0;
+			jsx->rxmaxlen = 2;
+			jsx->rxqueue = g_malloc(jsx->rxmaxlen);
+			jsx->rxqueue[0] = 0x05;
+			jsx->rxqueue[1] = 0x00;
+			xfer->watcher = purple_input_add(source, PURPLE_INPUT_WRITE,
+				jabber_si_xfer_bytestreams_send_read_response_cb,
+				xfer);
+			jabber_si_xfer_bytestreams_send_read_response_cb(xfer,
+				source, PURPLE_INPUT_WRITE);
+			jsx->rxqueue = NULL;
+			jsx->rxlen = 0;
+			return;
+		}
+	}
+
+	g_free(jsx->rxqueue);
+	jsx->rxlen = 0;
+	jsx->rxmaxlen = 2;
+	jsx->rxqueue = g_malloc(jsx->rxmaxlen);
+	jsx->rxqueue[0] = 0x05;
+	jsx->rxqueue[1] = 0xFF;
+	xfer->watcher = purple_input_add(source, PURPLE_INPUT_WRITE,
+		jabber_si_xfer_bytestreams_send_read_response_cb, xfer);
+	jabber_si_xfer_bytestreams_send_read_response_cb(xfer,
+		source, PURPLE_INPUT_WRITE);
+}
+
+static gint
+jabber_si_compare_jid(gconstpointer a, gconstpointer b)
+{
+	const JabberBytestreamsStreamhost *sh = a;
+
+	if(!a)
+		return -1;
+
+	return strcmp(sh->jid, (char *)b);
+}
+
+static void
+jabber_si_xfer_bytestreams_send_connected_cb(gpointer data, gint source,
+		PurpleInputCondition cond)
+{
+	PurpleXfer *xfer = data;
+	JabberSIXfer *jsx = xfer->data;
+	int acceptfd;
+
+	purple_debug_info("jabber", "in jabber_si_xfer_bytestreams_send_connected_cb\n");
+
+	acceptfd = accept(source, NULL, 0);
+	if(acceptfd == -1 && (errno == EAGAIN || errno == EWOULDBLOCK))
+		return;
+	else if(acceptfd == -1) {
+		purple_debug_warning("jabber", "accept: %s\n", g_strerror(errno));
+		/* Don't cancel the ft - allow it to fall to the next streamhost.*/
+		return;
+	}
+
+	purple_input_remove(xfer->watcher);
+	close(source);
+	jsx->local_streamhost_fd = -1;
+
+	_purple_network_set_common_socket_flags(acceptfd);
+
+	xfer->watcher = purple_input_add(acceptfd, PURPLE_INPUT_READ,
+					 jabber_si_xfer_bytestreams_send_read_cb, xfer);
+}
+
+static void
+jabber_si_connect_proxy_cb(JabberStream *js, const char *from,
+                           JabberIqType type, const char *id,
+                           xmlnode *packet, gpointer data)
+{
+	PurpleXfer *xfer = data;
+	JabberSIXfer *jsx;
+	xmlnode *query, *streamhost_used;
+	const char *jid;
+	GList *matched;
+
+	/* TODO: This need to send errors if we don't see what we're looking for */
+
+	/* Make sure that the xfer is actually still valid and we're not just receiving an old iq response */
+	if (!g_list_find(js->file_transfers, xfer)) {
+		purple_debug_error("jabber", "Got bytestreams response for no longer existing xfer (%p)\n", xfer);
+		return;
+	}
+
+	/* In the case of a direct file transfer, this is expected to return */
+	if(!xfer->data)
+		return;
+
+	jsx = xfer->data;
+
+	if(type != JABBER_IQ_RESULT) {
+		purple_debug_info("jabber",
+			    "jabber_si_xfer_connect_proxy_cb: type = error\n");
+		/* if IBB is available, open IBB session */
+		purple_debug_info("jabber",
+			"jabber_si_xfer_connect_proxy_cb: got error, method: %d\n",
+			jsx->stream_method);
+		if (jsx->stream_method & STREAM_METHOD_IBB) {
+			purple_debug_info("jabber", "IBB is possible, try it\n");
+			/* if we are the sender and haven't already opened an IBB
+			  session, do so now (we might already have failed to open
+			  the bytestream proxy ourselves when receiving this <iq/> */
+			if (purple_xfer_get_type(xfer) == PURPLE_XFER_SEND
+				&& !jsx->ibb_session) {
+				jabber_si_xfer_ibb_send_init(js, xfer);
+			} else {
+				jsx->ibb_timeout_handle = purple_timeout_add_seconds(30,
+					jabber_si_bytestreams_ibb_timeout_cb, xfer);
+			}
+			/* if we are receiver, just wait for IBB open stanza, callback
+			  is already set up */
+		} else {
+			purple_xfer_cancel_remote(xfer);
+		}
+		return;
+	}
+
+	if (!from)
+		return;
+
+	if(!(query = xmlnode_get_child(packet, "query")))
+		return;
+
+	if(!(streamhost_used = xmlnode_get_child(query, "streamhost-used")))
+		return;
+
+	if(!(jid = xmlnode_get_attrib(streamhost_used, "jid")))
+		return;
+
+	purple_debug_info("jabber", "jabber_si_connect_proxy_cb() will be looking at jsx %p: jsx->streamhosts is %p and jid is %s\n",
+					  jsx, jsx->streamhosts, jid);
+
+	if(!(matched = g_list_find_custom(jsx->streamhosts, jid, jabber_si_compare_jid)))
+	{
+		gchar *my_jid = g_strdup_printf("%s@%s/%s", jsx->js->user->node,
+			jsx->js->user->domain, jsx->js->user->resource);
+		if (!strcmp(jid, my_jid)) {
+			purple_debug_info("jabber", "Got local SOCKS5 streamhost-used.\n");
+			purple_xfer_start(xfer, xfer->fd, NULL, -1);
+		} else {
+			/* if available, try to revert to IBB... */
+			if (jsx->stream_method & STREAM_METHOD_IBB) {
+				purple_debug_info("jabber",
+					"jabber_si_connect_proxy_cb: trying to revert to IBB\n");
+				if (purple_xfer_get_type(xfer) == PURPLE_XFER_SEND) {
+					jabber_si_xfer_ibb_send_init(jsx->js, xfer);
+				} else {
+					jsx->ibb_timeout_handle = purple_timeout_add_seconds(30,
+						jabber_si_bytestreams_ibb_timeout_cb, xfer);
+				}
+				/* if we are the receiver, we are already set up...*/
+			} else {
+				purple_debug_info("jabber",
+					"streamhost-used does not match any proxy that was offered to target\n");
+				purple_xfer_cancel_local(xfer);
+			}
+		}
+		g_free(my_jid);
+		return;
+	}
+
+	/* Clean up the local streamhost - it isn't going to be used.*/
+	if (xfer->watcher > 0) {
+		purple_input_remove(xfer->watcher);
+		xfer->watcher = 0;
+	}
+	if (jsx->local_streamhost_fd >= 0) {
+		close(jsx->local_streamhost_fd);
+		jsx->local_streamhost_fd = -1;
+	}
+
+	jsx->streamhosts = g_list_remove_link(jsx->streamhosts, matched);
+	g_list_foreach(jsx->streamhosts, jabber_si_free_streamhost, NULL);
+	g_list_free(jsx->streamhosts);
+
+	jsx->streamhosts = matched;
+
+	jabber_si_bytestreams_attempt_connect(xfer);
+}
+
+static void
+jabber_si_xfer_bytestreams_listen_cb(int sock, gpointer data)
+{
+	PurpleXfer *xfer = data;
+	JabberSIXfer *jsx;
+	JabberIq *iq;
+	xmlnode *query, *streamhost;
+	char port[6];
+	GList *tmp;
+	JabberBytestreamsStreamhost *sh, *sh2;
+	int streamhost_count = 0;
+
+	jsx = xfer->data;
+	jsx->listen_data = NULL;
+
+	/* I'm not sure under which conditions this can happen
+	 * (it seems like it shouldn't be possible */
+	if (purple_xfer_get_status(xfer) == PURPLE_XFER_STATUS_CANCEL_LOCAL) {
+		purple_xfer_unref(xfer);
+		return;
+	}
+
+	purple_xfer_unref(xfer);
+
+	iq = jabber_iq_new_query(jsx->js, JABBER_IQ_SET, NS_BYTESTREAMS);
+	xmlnode_set_attrib(iq->node, "to", xfer->who);
+	query = xmlnode_get_child(iq->node, "query");
+
+	xmlnode_set_attrib(query, "sid", jsx->stream_id);
+
+	/* If we successfully started listening locally */
+	if (sock >= 0) {
+		gchar *jid;
+		GList *local_ips =
+			purple_network_get_all_local_system_ips();
+		const char *public_ip;
+		gboolean has_public_ip = FALSE;
+
+		jsx->local_streamhost_fd = sock;
+
+		jid = g_strdup_printf("%s@%s/%s", jsx->js->user->node,
+			jsx->js->user->domain, jsx->js->user->resource);
+		xfer->local_port = purple_network_get_port_from_fd(sock);
+		g_snprintf(port, sizeof(port), "%hu", (guint16)xfer->local_port);
+
+		public_ip = purple_network_get_my_ip(jsx->js->fd);
+
+		/* Include the localhost's IPs (for in-network transfers) */
+		while (local_ips) {
+			gchar *local_ip = local_ips->data;
+			streamhost_count++;
+			streamhost = xmlnode_new_child(query, "streamhost");
+			xmlnode_set_attrib(streamhost, "jid", jid);
+			xmlnode_set_attrib(streamhost, "host", local_ip);
+			xmlnode_set_attrib(streamhost, "port", port);
+			if (purple_strequal(local_ip, public_ip))
+				has_public_ip = TRUE;
+			g_free(local_ip);
+			local_ips = g_list_delete_link(local_ips, local_ips);
+		}
+
+		/* Include the public IP (assuming that there is a port mapped somehow) */
+		if (!has_public_ip && strcmp(public_ip, "0.0.0.0") != 0) {
+			streamhost_count++;
+			streamhost = xmlnode_new_child(query, "streamhost");
+			xmlnode_set_attrib(streamhost, "jid", jid);
+			xmlnode_set_attrib(streamhost, "host", public_ip);
+			xmlnode_set_attrib(streamhost, "port", port);
+		}
+
+		g_free(jid);
+
+		/* The listener for the local proxy */
+		xfer->watcher = purple_input_add(sock, PURPLE_INPUT_READ,
+				jabber_si_xfer_bytestreams_send_connected_cb, xfer);
+	}
+
+	for (tmp = jsx->js->bs_proxies; tmp; tmp = tmp->next) {
+		sh = tmp->data;
+
+		/* TODO: deal with zeroconf proxies */
+
+		if (!(sh->jid && sh->host && sh->port > 0))
+			continue;
+
+		purple_debug_info("jabber", "jabber_si_xfer_bytestreams_listen_cb() will be looking at jsx %p: jsx->streamhosts %p and sh->jid %p\n",
+						  jsx, jsx->streamhosts, sh->jid);
+		if(g_list_find_custom(jsx->streamhosts, sh->jid, jabber_si_compare_jid) != NULL)
+			continue;
+
+		streamhost_count++;
+		streamhost = xmlnode_new_child(query, "streamhost");
+		xmlnode_set_attrib(streamhost, "jid", sh->jid);
+		xmlnode_set_attrib(streamhost, "host", sh->host);
+		g_snprintf(port, sizeof(port), "%hu", (guint16)sh->port);
+		xmlnode_set_attrib(streamhost, "port", port);
+
+		sh2 = g_new0(JabberBytestreamsStreamhost, 1);
+		sh2->jid = g_strdup(sh->jid);
+		sh2->host = g_strdup(sh->host);
+		/*sh2->zeroconf = g_strdup(sh->zeroconf);*/
+		sh2->port = sh->port;
+
+		jsx->streamhosts = g_list_prepend(jsx->streamhosts, sh2);
+	}
+
+	/* We have no way of transferring, cancel the transfer */
+	if (streamhost_count == 0) {
+		jabber_iq_free(iq);
+
+		/* if available, revert to IBB */
+		if (jsx->stream_method & STREAM_METHOD_IBB) {
+			purple_debug_info("jabber",
+				"jabber_si_xfer_bytestreams_listen_cb: trying to revert to IBB\n");
+			if (purple_xfer_get_type(xfer) == PURPLE_XFER_SEND) {
+				/* if we are the sender, init the IBB session... */
+				jabber_si_xfer_ibb_send_init(jsx->js, xfer);
+			} else {
+				jsx->ibb_timeout_handle = purple_timeout_add_seconds(30,
+					jabber_si_bytestreams_ibb_timeout_cb, xfer);
+			}
+			/* if we are the receiver, we should just wait... the IBB open
+			  handler has already been set up... */
+		} else {
+			/* We should probably notify the target,
+			  but this really shouldn't ever happen */
+			purple_xfer_cancel_local(xfer);
+		}
+
+		return;
+	}
+
+	jabber_iq_set_callback(iq, jabber_si_connect_proxy_cb, xfer);
+
+	jabber_iq_send(iq);
+
+}
+
+static void
+jabber_si_xfer_bytestreams_send_init(PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx;
+	PurpleProxyType proxy_type;
+
+	purple_xfer_ref(xfer);
+
+	jsx = xfer->data;
+
+	/* TODO: This should probably be done with an account option instead of
+	 *       piggy-backing on the TOR proxy type. */
+	proxy_type = purple_proxy_info_get_type(
+		purple_proxy_get_setup(purple_connection_get_account(jsx->js->gc)));
+	if (proxy_type == PURPLE_PROXY_TOR) {
+		purple_debug_info("jabber", "Skipping attempting local streamhost.\n");
+		jsx->listen_data = NULL;
+	} else
+		jsx->listen_data = purple_network_listen_range(0, 0, SOCK_STREAM,
+				jabber_si_xfer_bytestreams_listen_cb, xfer);
+
+	if (jsx->listen_data == NULL) {
+		/* We couldn't open a local port.  Perhaps we can use a proxy. */
+		jabber_si_xfer_bytestreams_listen_cb(-1, xfer);
+	}
+
+}
+
+static void
+jabber_si_xfer_ibb_error_cb(JabberIBBSession *sess)
+{
+	PurpleXfer *xfer = (PurpleXfer *) jabber_ibb_session_get_user_data(sess);
+
+	purple_debug_error("jabber", "an error occurred during IBB file transfer\n");
+	purple_xfer_cancel_remote(xfer);
+}
+
+static void
+jabber_si_xfer_ibb_closed_cb(JabberIBBSession *sess)
+{
+	PurpleXfer *xfer = (PurpleXfer *) jabber_ibb_session_get_user_data(sess);
+
+	purple_debug_info("jabber", "the remote user closed the transfer\n");
+	if (purple_xfer_get_bytes_remaining(xfer) > 0) {
+		purple_xfer_cancel_remote(xfer);
+	} else {
+		purple_xfer_set_completed(xfer, TRUE);
+		purple_xfer_end(xfer);
+	}
+}
+
+static void
+jabber_si_xfer_ibb_recv_data_cb(JabberIBBSession *sess, gpointer data,
+	gsize size)
+{
+	PurpleXfer *xfer = (PurpleXfer *) jabber_ibb_session_get_user_data(sess);
+	JabberSIXfer *jsx = (JabberSIXfer *) xfer->data;
+
+	if (size <= purple_xfer_get_bytes_remaining(xfer)) {
+		purple_debug_info("jabber", "about to write %" G_GSIZE_FORMAT " bytes from IBB stream\n",
+			size);
+		purple_circ_buffer_append(jsx->ibb_buffer, data, size);
+		purple_xfer_prpl_ready(xfer);
+	} else {
+		/* trying to write past size of file transfers negotiated size,
+		  reject transfer to protect against malicious behaviour */
+		purple_debug_error("jabber",
+			"IBB file transfer send more data than expected\n");
+		purple_xfer_cancel_remote(xfer);
+	}
+
+}
+
+static gssize
+jabber_si_xfer_ibb_read(guchar **out_buffer, PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx = xfer->data;
+	guchar *buffer;
+	gsize size;
+	gsize tmp;
+
+	size = jsx->ibb_buffer->bufused;
+	*out_buffer = buffer = g_malloc(size);
+	while ((tmp = purple_circ_buffer_get_max_read(jsx->ibb_buffer))) {
+		memcpy(buffer, jsx->ibb_buffer->outptr, tmp);
+		buffer += tmp;
+		purple_circ_buffer_mark_read(jsx->ibb_buffer, tmp);
+	}
+
+	return size;
+}
+
+static gboolean
+jabber_si_xfer_ibb_open_cb(JabberStream *js, const char *who, const char *id,
+                           xmlnode *open)
+{
+	const gchar *sid = xmlnode_get_attrib(open, "sid");
+	PurpleXfer *xfer = jabber_si_xfer_find(js, sid, who);
+	if (xfer) {
+		JabberSIXfer *jsx = (JabberSIXfer *) xfer->data;
+		JabberIBBSession *sess =
+			jabber_ibb_session_create_from_xmlnode(js, who, id, open, xfer);
+
+		jabber_si_bytestreams_ibb_timeout_remove(jsx);
+
+		if (sess) {
+			/* setup callbacks here...*/
+			jabber_ibb_session_set_data_received_callback(sess,
+				jabber_si_xfer_ibb_recv_data_cb);
+			jabber_ibb_session_set_closed_callback(sess,
+				jabber_si_xfer_ibb_closed_cb);
+			jabber_ibb_session_set_error_callback(sess,
+				jabber_si_xfer_ibb_error_cb);
+
+			jsx->ibb_session = sess;
+			/* we handle up to block-size bytes of decoded data, to handle
+			 clients interpreting the block-size attribute as that
+			 (see also remark in ibb.c) */
+			jsx->ibb_buffer =
+				purple_circ_buffer_new(jabber_ibb_session_get_block_size(sess));
+
+			/* set up read function */
+			purple_xfer_set_read_fnc(xfer, jabber_si_xfer_ibb_read);
+
+			/* start the transfer */
+			purple_xfer_start(xfer, -1, NULL, 0);
+			return TRUE;
+		} else {
+			/* failed to create IBB session */
+			purple_debug_error("jabber", "failed to create IBB session\n");
+			purple_xfer_cancel_remote(xfer);
+			return FALSE;
+		}
+	} else {
+		/* we got an IBB <open/> for an unknown file transfer, pass along... */
+		purple_debug_info("jabber",
+			"IBB open did not match any SI file transfer\n");
+		return FALSE;
+	}
+}
+
+static gssize
+jabber_si_xfer_ibb_write(const guchar *buffer, size_t len, PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx = (JabberSIXfer *) xfer->data;
+	JabberIBBSession *sess = jsx->ibb_session;
+	gsize packet_size = len < jabber_ibb_session_get_max_data_size(sess) ?
+		len : jabber_ibb_session_get_max_data_size(sess);
+
+	jabber_ibb_session_send_data(sess, buffer, packet_size);
+
+	return packet_size;
+}
+
+static void
+jabber_si_xfer_ibb_sent_cb(JabberIBBSession *sess)
+{
+	PurpleXfer *xfer = (PurpleXfer *) jabber_ibb_session_get_user_data(sess);
+	gsize remaining = purple_xfer_get_bytes_remaining(xfer);
+
+	if (remaining == 0) {
+		/* close the session */
+		jabber_ibb_session_close(sess);
+		purple_xfer_set_completed(xfer, TRUE);
+		purple_xfer_end(xfer);
+	} else {
+		/* send more... */
+		purple_xfer_prpl_ready(xfer);
+	}
+}
+
+static void
+jabber_si_xfer_ibb_opened_cb(JabberIBBSession *sess)
+{
+	PurpleXfer *xfer = (PurpleXfer *) jabber_ibb_session_get_user_data(sess);
+
+	if (jabber_ibb_session_get_state(sess) == JABBER_IBB_SESSION_OPENED) {
+		purple_xfer_start(xfer, -1, NULL, 0);
+		purple_xfer_prpl_ready(xfer);
+	} else {
+		/* error */
+		purple_xfer_end(xfer);
+	}
+}
+
+static void
+jabber_si_xfer_ibb_send_init(JabberStream *js, PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx = (JabberSIXfer *) xfer->data;
+
+	jsx->ibb_session = jabber_ibb_session_create(js, jsx->stream_id,
+		purple_xfer_get_remote_user(xfer), xfer);
+
+	if (jsx->ibb_session) {
+		/* should set callbacks here... */
+		jabber_ibb_session_set_opened_callback(jsx->ibb_session,
+			jabber_si_xfer_ibb_opened_cb);
+		jabber_ibb_session_set_data_sent_callback(jsx->ibb_session,
+			jabber_si_xfer_ibb_sent_cb);
+		jabber_ibb_session_set_closed_callback(jsx->ibb_session,
+			jabber_si_xfer_ibb_closed_cb);
+		jabber_ibb_session_set_error_callback(jsx->ibb_session,
+			jabber_si_xfer_ibb_error_cb);
+
+		purple_xfer_set_write_fnc(xfer, jabber_si_xfer_ibb_write);
+
+		jsx->ibb_buffer =
+			purple_circ_buffer_new(jabber_ibb_session_get_max_data_size(jsx->ibb_session));
+
+		/* open the IBB session */
+		jabber_ibb_session_open(jsx->ibb_session);
+
+	} else {
+		/* failed to create IBB session */
+		purple_debug_error("jabber",
+			"failed to initiate IBB session for file transfer\n");
+		purple_xfer_cancel_local(xfer);
+	}
+}
+
+static void jabber_si_xfer_send_method_cb(JabberStream *js, const char *from,
+                                          JabberIqType type, const char *id,
+                                          xmlnode *packet, gpointer data)
+{
+	PurpleXfer *xfer = data;
+	xmlnode *si, *feature, *x, *field, *value;
+	gboolean found_method = FALSE;
+
+	if(!(si = xmlnode_get_child_with_namespace(packet, "si", "http://jabber.org/protocol/si"))) {
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	if(!(feature = xmlnode_get_child_with_namespace(si, "feature", "http://jabber.org/protocol/feature-neg"))) {
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	if(!(x = xmlnode_get_child_with_namespace(feature, "x", "jabber:x:data"))) {
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	for(field = xmlnode_get_child(x, "field"); field; field = xmlnode_get_next_twin(field)) {
+		const char *var = xmlnode_get_attrib(field, "var");
+		JabberSIXfer *jsx = (JabberSIXfer *) xfer->data;
+
+		if(var && !strcmp(var, "stream-method")) {
+			if((value = xmlnode_get_child(field, "value"))) {
+				char *val = xmlnode_get_data(value);
+				if(val && !strcmp(val, NS_BYTESTREAMS)) {
+					jabber_si_xfer_bytestreams_send_init(xfer);
+					jsx->stream_method |= STREAM_METHOD_BYTESTREAMS;
+					found_method = TRUE;
+				} else if (val && !strcmp(val, NS_IBB)) {
+					jsx->stream_method |= STREAM_METHOD_IBB;
+					if (!found_method) {
+						/* we haven't tried to init a bytestream session, yet
+						  start IBB right away... */
+						jabber_si_xfer_ibb_send_init(js, xfer);
+						found_method = TRUE;
+					}
+				}
+				g_free(val);
+			}
+		}
+	}
+
+	if (!found_method) {
+		purple_xfer_cancel_remote(xfer);
+	}
+
+}
+
+static void jabber_si_xfer_send_request(PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx = xfer->data;
+	JabberIq *iq;
+	xmlnode *si, *file, *feature, *x, *field, *option, *value;
+	char buf[32];
+#if ENABLE_FT_THUMBNAILS
+	gconstpointer thumb;
+	gsize thumb_size;
+
+	purple_xfer_prepare_thumbnail(xfer, "jpeg,png");
+#endif
+	xfer->filename = g_path_get_basename(xfer->local_filename);
+
+	iq = jabber_iq_new(jsx->js, JABBER_IQ_SET);
+	xmlnode_set_attrib(iq->node, "to", xfer->who);
+	si = xmlnode_new_child(iq->node, "si");
+	xmlnode_set_namespace(si, "http://jabber.org/protocol/si");
+	jsx->stream_id = jabber_get_next_id(jsx->js);
+	xmlnode_set_attrib(si, "id", jsx->stream_id);
+	xmlnode_set_attrib(si, "profile", NS_SI_FILE_TRANSFER);
+
+	file = xmlnode_new_child(si, "file");
+	xmlnode_set_namespace(file, NS_SI_FILE_TRANSFER);
+	xmlnode_set_attrib(file, "name", xfer->filename);
+	g_snprintf(buf, sizeof(buf), "%" G_GSIZE_FORMAT, xfer->size);
+	xmlnode_set_attrib(file, "size", buf);
+	/* maybe later we'll do hash and date attribs */
+
+#if ENABLE_FT_THUMBNAILS
+	/* add thumbnail, if appropriate */
+	if ((thumb = purple_xfer_get_thumbnail(xfer, &thumb_size))) {
+		const gchar *mimetype = purple_xfer_get_thumbnail_mimetype(xfer);
+		JabberData *thumbnail_data =
+			jabber_data_create_from_data(thumb, thumb_size,
+				mimetype, TRUE, jsx->js);
+		xmlnode *thumbnail = xmlnode_new_child(file, "thumbnail");
+		xmlnode_set_namespace(thumbnail, NS_THUMBS);
+		xmlnode_set_attrib(thumbnail, "cid",
+			jabber_data_get_cid(thumbnail_data));
+		xmlnode_set_attrib(thumbnail, "mime-type", mimetype);
+		/* cache data */
+		jabber_data_associate_local(thumbnail_data, NULL);
+	}
+#endif
+
+	feature = xmlnode_new_child(si, "feature");
+	xmlnode_set_namespace(feature, "http://jabber.org/protocol/feature-neg");
+	x = xmlnode_new_child(feature, "x");
+	xmlnode_set_namespace(x, "jabber:x:data");
+	xmlnode_set_attrib(x, "type", "form");
+	field = xmlnode_new_child(x, "field");
+	xmlnode_set_attrib(field, "var", "stream-method");
+	xmlnode_set_attrib(field, "type", "list-single");
+	/* maybe we should add an option to always skip bytestreams for people
+		behind troublesome firewalls */
+	option = xmlnode_new_child(field, "option");
+	value = xmlnode_new_child(option, "value");
+	xmlnode_insert_data(value, NS_BYTESTREAMS, -1);
+	option = xmlnode_new_child(field, "option");
+	value = xmlnode_new_child(option, "value");
+	xmlnode_insert_data(value, NS_IBB, -1);
+
+	jabber_iq_set_callback(iq, jabber_si_xfer_send_method_cb, xfer);
+
+	/* Store the IQ id so that we can cancel the callback */
+	g_free(jsx->iq_id);
+	jsx->iq_id = g_strdup(iq->id);
+
+	jabber_iq_send(iq);
+}
+
+static void jabber_si_xfer_free(PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx = xfer->data;
+
+	if (jsx) {
+		JabberStream *js = jsx->js;
+
+		js->file_transfers = g_list_remove(js->file_transfers, xfer);
+
+		if (jsx->connect_data != NULL)
+			purple_proxy_connect_cancel(jsx->connect_data);
+		if (jsx->listen_data != NULL)
+			purple_network_listen_cancel(jsx->listen_data);
+		if (jsx->iq_id != NULL)
+			jabber_iq_remove_callback_by_id(js, jsx->iq_id);
+		if (jsx->local_streamhost_fd >= 0)
+			close(jsx->local_streamhost_fd);
+		if (purple_xfer_get_type(xfer) == PURPLE_XFER_SEND &&
+			xfer->fd >= 0) {
+			purple_debug_info("jabber", "remove port mapping\n");
+			purple_network_remove_port_mapping(xfer->fd);
+		}
+		if (jsx->connect_timeout > 0)
+			purple_timeout_remove(jsx->connect_timeout);
+		if (jsx->ibb_timeout_handle > 0)
+			purple_timeout_remove(jsx->ibb_timeout_handle);
+
+		if (jsx->streamhosts) {
+			g_list_foreach(jsx->streamhosts, jabber_si_free_streamhost, NULL);
+			g_list_free(jsx->streamhosts);
+		}
+
+		if (jsx->ibb_session) {
+			purple_debug_info("jabber",
+				"jabber_si_xfer_free: destroying IBB session\n");
+			jabber_ibb_session_destroy(jsx->ibb_session);
+		}
+
+		if (jsx->ibb_buffer) {
+			purple_circ_buffer_destroy(jsx->ibb_buffer);
+		}
+
+		purple_debug_info("jabber", "jabber_si_xfer_free(): freeing jsx %p\n", jsx);
+
+		g_free(jsx->stream_id);
+		g_free(jsx->iq_id);
+		/* XXX: free other stuff */
+		g_free(jsx->rxqueue);
+		g_free(jsx);
+		xfer->data = NULL;
+	}
+}
+
+/*
+ * These four functions should only be called from the PurpleXfer functions
+ * (typically purple_xfer_cancel_(remote|local), purple_xfer_end, or
+ * purple_xfer_request_denied.
+ */
+static void jabber_si_xfer_cancel_send(PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx = (JabberSIXfer *) xfer->data;
+
+	/* if there is an IBB session active, send close on that */
+	if (jsx->ibb_session) {
+		jabber_ibb_session_close(jsx->ibb_session);
+	}
+	jabber_si_xfer_free(xfer);
+	purple_debug_info("jabber", "in jabber_si_xfer_cancel_send\n");
+}
+
+
+static void jabber_si_xfer_request_denied(PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx = (JabberSIXfer *) xfer->data;
+	JabberStream *js = jsx->js;
+
+	/*
+	 * TODO: It's probably an error if jsx->iq_id == NULL. g_return_if_fail
+	 * might be warranted.
+	 */
+	if (jsx->iq_id && !jsx->accepted) {
+		JabberIq *iq;
+		xmlnode *error, *child;
+		iq = jabber_iq_new(js, JABBER_IQ_ERROR);
+		xmlnode_set_attrib(iq->node, "to", xfer->who);
+		jabber_iq_set_id(iq, jsx->iq_id);
+
+		error = xmlnode_new_child(iq->node, "error");
+		xmlnode_set_attrib(error, "type", "cancel");
+		child = xmlnode_new_child(error, "forbidden");
+		xmlnode_set_namespace(child, NS_XMPP_STANZAS);
+		child = xmlnode_new_child(error, "text");
+		xmlnode_set_namespace(child, NS_XMPP_STANZAS);
+		xmlnode_insert_data(child, "Offer Declined", -1);
+
+		jabber_iq_send(iq);
+	}
+
+	jabber_si_xfer_free(xfer);
+	purple_debug_info("jabber", "in jabber_si_xfer_request_denied\n");
+}
+
+
+static void jabber_si_xfer_cancel_recv(PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx = (JabberSIXfer *) xfer->data;
+	/* if there is an IBB session active, send close */
+	if (jsx->ibb_session) {
+		jabber_ibb_session_close(jsx->ibb_session);
+	}
+	jabber_si_xfer_free(xfer);
+	purple_debug_info("jabber", "in jabber_si_xfer_cancel_recv\n");
+}
+
+
+static void jabber_si_xfer_end(PurpleXfer *xfer)
+{
+	jabber_si_xfer_free(xfer);
+}
+
+
+static void jabber_si_xfer_send_disco_cb(JabberStream *js, const char *who,
+		JabberCapabilities capabilities, gpointer data)
+{
+	PurpleXfer *xfer = (PurpleXfer *) data;
+	JabberSIXfer *jsx = (JabberSIXfer *) xfer->data;
+
+	if (capabilities & JABBER_CAP_IBB) {
+		purple_debug_info("jabber",
+			"jabber_si_xfer_send_disco_cb: remote JID supports IBB\n");
+		jsx->stream_method |= STREAM_METHOD_IBB;
+	}
+
+	if (capabilities & JABBER_CAP_SI_FILE_XFER) {
+		jabber_si_xfer_send_request(xfer);
+	} else {
+		char *msg = g_strdup_printf(_("Unable to send file to %s, user does not support file transfers"), who);
+		purple_notify_error(js->gc, _("File Send Failed"),
+				_("File Send Failed"), msg);
+		g_free(msg);
+		purple_xfer_cancel_local(xfer);
+	}
+}
+
+static void resource_select_cancel_cb(PurpleXfer *xfer, PurpleRequestFields *fields)
+{
+	purple_xfer_cancel_local(xfer);
+}
+
+static void do_transfer_send(PurpleXfer *xfer, const char *resource)
+{
+	JabberSIXfer *jsx = xfer->data;
+	char **who_v = g_strsplit(xfer->who, "/", 2);
+	char *who;
+	JabberBuddy *jb;
+	JabberBuddyResource *jbr = NULL;
+
+	jb = jabber_buddy_find(jsx->js, who_v[0], FALSE);
+	if (jb) {
+		jbr = jabber_buddy_find_resource(jb, resource);
+	}
+
+	who = g_strdup_printf("%s/%s", who_v[0], resource);
+	g_strfreev(who_v);
+	g_free(xfer->who);
+	xfer->who = who;
+
+	if (jbr && jabber_resource_know_capabilities(jbr)) {
+		char *msg;
+
+		if (jabber_resource_has_capability(jbr, NS_IBB))
+			jsx->stream_method |= STREAM_METHOD_IBB;
+		if (jabber_resource_has_capability(jbr, NS_SI_FILE_TRANSFER)) {
+			jabber_si_xfer_send_request(xfer);
+			return;
+		}
+
+		msg = g_strdup_printf(_("Unable to send file to %s, user does not support file transfers"), who);
+		purple_notify_error(jsx->js->gc, _("File Send Failed"),
+				_("File Send Failed"), msg);
+		g_free(msg);
+		purple_xfer_cancel_local(xfer);
+	} else {
+		jabber_disco_info_do(jsx->js, who,
+				jabber_si_xfer_send_disco_cb, xfer);
+	}
+}
+
+static void resource_select_ok_cb(PurpleXfer *xfer, PurpleRequestFields *fields)
+{
+	PurpleRequestField *field = purple_request_fields_get_field(fields, "resource");
+	int selected_id = purple_request_field_choice_get_value(field);
+	GList *labels = purple_request_field_choice_get_labels(field);
+
+	const char *selected_label = g_list_nth_data(labels, selected_id);
+
+	do_transfer_send(xfer, selected_label);
+}
+
+static void jabber_si_xfer_init(PurpleXfer *xfer)
+{
+	JabberSIXfer *jsx = xfer->data;
+	JabberIq *iq;
+	if(purple_xfer_get_type(xfer) == PURPLE_XFER_SEND) {
+		JabberBuddy *jb;
+		JabberBuddyResource *jbr = NULL;
+		char *resource;
+		GList *resources = NULL;
+
+		if(NULL != (resource = jabber_get_resource(xfer->who))) {
+			/* they've specified a resource, no need to ask or
+			 * default or anything, just do it */
+
+			do_transfer_send(xfer, resource);
+			g_free(resource);
+			return;
+		}
+
+		jb = jabber_buddy_find(jsx->js, xfer->who, TRUE);
+
+		if (jb) {
+			GList *l;
+
+			for (l = jb->resources ; l ; l = g_list_next(l)) {
+				jbr = l->data;
+
+				if (!jabber_resource_know_capabilities(jbr) ||
+				    (jabber_resource_has_capability(jbr, NS_SI_FILE_TRANSFER)
+				     && (jabber_resource_has_capability(jbr, NS_BYTESTREAMS)
+				         || jabber_resource_has_capability(jbr, NS_IBB)))) {
+					resources = g_list_append(resources, jbr);
+				}
+			}
+		}
+
+		if (!resources) {
+			/* no resources online, we're trying to send to someone
+			 * whose presence we're not subscribed to, or
+			 * someone who is offline.  Let's inform the user */
+			char *msg;
+
+			if(!jb) {
+				msg = g_strdup_printf(_("Unable to send file to %s, invalid JID"), xfer->who);
+			} else if(jb->subscription & JABBER_SUB_TO) {
+				msg = g_strdup_printf(_("Unable to send file to %s, user is not online"), xfer->who);
+			} else {
+				msg = g_strdup_printf(_("Unable to send file to %s, not subscribed to user presence"), xfer->who);
+			}
+
+			purple_notify_error(jsx->js->gc, _("File Send Failed"), _("File Send Failed"), msg);
+			g_free(msg);
+		} else if (g_list_length(resources) == 1) {
+			/* only 1 resource online (probably our most common case)
+			 * so no need to ask who to send to */
+			jbr = resources->data;
+			do_transfer_send(xfer, jbr->name);
+		} else {
+			/* we've got multiple resources, we need to pick one to send to */
+			GList *l;
+			char *msg = g_strdup_printf(_("Please select the resource of %s to which you would like to send a file"), xfer->who);
+			PurpleRequestFields *fields = purple_request_fields_new();
+			PurpleRequestField *field = purple_request_field_choice_new("resource", _("Resource"), 0);
+			PurpleRequestFieldGroup *group = purple_request_field_group_new(NULL);
+
+			for(l = resources; l; l = l->next) {
+				jbr = l->data;
+				purple_request_field_choice_add(field, jbr->name);
+			}
+
+			purple_request_field_group_add_field(group, field);
+
+			purple_request_fields_add_group(fields, group);
+
+			purple_request_fields(jsx->js->gc, _("Select a Resource"), msg, NULL, fields,
+					_("Send File"), G_CALLBACK(resource_select_ok_cb), _("Cancel"), G_CALLBACK(resource_select_cancel_cb),
+					jsx->js->gc->account, xfer->who, NULL, xfer);
+
+			g_free(msg);
+		}
+
+		g_list_free(resources);
+	} else {
+		xmlnode *si, *feature, *x, *field, *value;
+
+		iq = jabber_iq_new(jsx->js, JABBER_IQ_RESULT);
+		xmlnode_set_attrib(iq->node, "to", xfer->who);
+		if(jsx->iq_id)
+			jabber_iq_set_id(iq, jsx->iq_id);
+		else
+			purple_debug_error("jabber", "Sending SI result with new IQ id.\n");
+
+		jsx->accepted = TRUE;
+
+		si = xmlnode_new_child(iq->node, "si");
+		xmlnode_set_namespace(si, "http://jabber.org/protocol/si");
+
+		feature = xmlnode_new_child(si, "feature");
+		xmlnode_set_namespace(feature, "http://jabber.org/protocol/feature-neg");
+
+		x = xmlnode_new_child(feature, "x");
+		xmlnode_set_namespace(x, "jabber:x:data");
+		xmlnode_set_attrib(x, "type", "submit");
+		field = xmlnode_new_child(x, "field");
+		xmlnode_set_attrib(field, "var", "stream-method");
+
+		/* we should maybe "remember" if bytestreams has failed before (in the
+			same session) with this JID, and only present IBB as an option to
+			avoid unnessesary timeout */
+		/* maybe we should have an account option to always just try IBB
+			for people who know their firewalls are very restrictive */
+		if (jsx->stream_method & STREAM_METHOD_BYTESTREAMS) {
+			value = xmlnode_new_child(field, "value");
+			xmlnode_insert_data(value, NS_BYTESTREAMS, -1);
+		} else if(jsx->stream_method & STREAM_METHOD_IBB) {
+			value = xmlnode_new_child(field, "value");
+			xmlnode_insert_data(value, NS_IBB, -1);
+		}
+
+		jabber_iq_send(iq);
+	}
+}
+
+PurpleXfer *jabber_si_new_xfer(PurpleConnection *gc, const char *who)
+{
+	JabberStream *js;
+
+	PurpleXfer *xfer;
+	JabberSIXfer *jsx;
+
+	js = gc->proto_data;
+
+	xfer = purple_xfer_new(gc->account, PURPLE_XFER_SEND, who);
+	if (xfer)
+	{
+		xfer->data = jsx = g_new0(JabberSIXfer, 1);
+		jsx->js = js;
+		jsx->local_streamhost_fd = -1;
+
+		jsx->ibb_session = NULL;
+
+		purple_xfer_set_init_fnc(xfer, jabber_si_xfer_init);
+		purple_xfer_set_cancel_send_fnc(xfer, jabber_si_xfer_cancel_send);
+		purple_xfer_set_end_fnc(xfer, jabber_si_xfer_end);
+
+		js->file_transfers = g_list_append(js->file_transfers, xfer);
+	}
+
+	return xfer;
+}
+
+void jabber_si_xfer_send(PurpleConnection *gc, const char *who, const char *file)
+{
+	PurpleXfer *xfer;
+
+	xfer = jabber_si_new_xfer(gc, who);
+
+	if (file)
+		purple_xfer_request_accepted(xfer, file);
+	else
+		purple_xfer_request(xfer);
+}
+
+#if ENABLE_FT_THUMBNAILS
+static void
+jabber_si_thumbnail_cb(JabberData *data, gchar *alt, gpointer userdata)
+{
+	PurpleXfer *xfer = (PurpleXfer *) userdata;
+
+	if (data) {
+		purple_xfer_set_thumbnail(xfer, jabber_data_get_data(data),
+			jabber_data_get_size(data), jabber_data_get_type(data));
+		/* data is ephemeral, get rid of now (the xfer re-owned the thumbnail */
+		jabber_data_destroy(data);
+	}
+
+	purple_xfer_request(xfer);
+}
+#endif
+
+void jabber_si_parse(JabberStream *js, const char *from, JabberIqType type,
+                     const char *id, xmlnode *si)
+{
+	JabberSIXfer *jsx;
+	PurpleXfer *xfer;
+	xmlnode *file, *feature, *x, *field, *option, *value;
+#if ENABLE_FT_THUMBNAILS
+	xmlnode *thumbnail;
+#endif
+	const char *stream_id, *filename, *filesize_c, *profile;
+	guint64 filesize_64 = 0;
+	size_t filesize = 0;
+
+	if(!(profile = xmlnode_get_attrib(si, "profile")) ||
+			strcmp(profile, NS_SI_FILE_TRANSFER))
+		return;
+
+	if(!(stream_id = xmlnode_get_attrib(si, "id")))
+		return;
+
+	if(!(file = xmlnode_get_child(si, "file")))
+		return;
+
+	if(!(filename = xmlnode_get_attrib(file, "name")))
+		return;
+
+	if((filesize_c = xmlnode_get_attrib(file, "size")))
+		filesize_64 = g_ascii_strtoull(filesize_c, NULL, 10);
+
+#ifndef __COVERITY__
+	/* TODO 3.0.0: When the core uses a guint64, this is redundant.
+	 * See #8477.
+	 *
+	 * It may not be necessary on 64-bit machine.
+	 * It raises result_independent_of_operands coverity false positive.
+	 */
+	if (filesize_64 > G_MAXSIZE) {
+		/* Should this pop up a warning? */
+		purple_debug_warning("jabber", "Unable to transfer file (too large)"
+		                     " -- see #8477 for more details.");
+		return;
+	}
+#endif
+	filesize = filesize_64;
+
+	if(!(feature = xmlnode_get_child(si, "feature")))
+		return;
+
+	if(!(x = xmlnode_get_child_with_namespace(feature, "x", "jabber:x:data")))
+		return;
+
+	if(!from)
+		return;
+
+	/* if they've already sent us this file transfer with the same damn id
+	 * then we're gonna ignore it, until I think of something better to do
+	 * with it */
+	if(jabber_si_xfer_find(js, stream_id, from) != NULL)
+		return;
+
+	jsx = g_new0(JabberSIXfer, 1);
+	jsx->local_streamhost_fd = -1;
+
+	jsx->ibb_session = NULL;
+
+	for(field = xmlnode_get_child(x, "field"); field; field = xmlnode_get_next_twin(field)) {
+		const char *var = xmlnode_get_attrib(field, "var");
+		if(var && !strcmp(var, "stream-method")) {
+			for(option = xmlnode_get_child(field, "option"); option;
+					option = xmlnode_get_next_twin(option)) {
+				if((value = xmlnode_get_child(option, "value"))) {
+					char *val;
+					if((val = xmlnode_get_data(value))) {
+						if(!strcmp(val, NS_BYTESTREAMS)) {
+							jsx->stream_method |= STREAM_METHOD_BYTESTREAMS;
+						} else if(!strcmp(val, NS_IBB)) {
+							jsx->stream_method |= STREAM_METHOD_IBB;
+						}
+						g_free(val);
+					}
+				}
+			}
+		}
+	}
+
+	if(jsx->stream_method == STREAM_METHOD_UNKNOWN) {
+		g_free(jsx);
+		return;
+	}
+
+	jsx->js = js;
+	jsx->stream_id = g_strdup(stream_id);
+	jsx->iq_id = g_strdup(id);
+
+	xfer = purple_xfer_new(js->gc->account, PURPLE_XFER_RECEIVE, from);
+	g_return_if_fail(xfer != NULL);
+
+	xfer->data = jsx;
+
+	purple_xfer_set_filename(xfer, filename);
+	if(filesize > 0)
+		purple_xfer_set_size(xfer, filesize);
+
+	purple_xfer_set_init_fnc(xfer, jabber_si_xfer_init);
+	purple_xfer_set_request_denied_fnc(xfer, jabber_si_xfer_request_denied);
+	purple_xfer_set_cancel_recv_fnc(xfer, jabber_si_xfer_cancel_recv);
+	purple_xfer_set_end_fnc(xfer, jabber_si_xfer_end);
+
+	js->file_transfers = g_list_append(js->file_transfers, xfer);
+
+#if ENABLE_FT_THUMBNAILS
+	/* if there is a thumbnail, we should request it... */
+	if ((thumbnail = xmlnode_get_child_with_namespace(file, "thumbnail",
+		NS_THUMBS))) {
+		const char *cid = xmlnode_get_attrib(thumbnail, "cid");
+		if (cid) {
+			jabber_data_request(js, cid, purple_xfer_get_remote_user(xfer),
+			    NULL, TRUE, jabber_si_thumbnail_cb, xfer);
+			return;
+		}
+	}
+#endif
+
+	purple_xfer_request(xfer);
+}
+
+void
+jabber_si_init(void)
+{
+	jabber_iq_register_handler("si", "http://jabber.org/protocol/si", jabber_si_parse);
+
+	jabber_ibb_register_open_handler(jabber_si_xfer_ibb_open_cb);
+}
+
+void
+jabber_si_uninit(void)
+{
+	jabber_ibb_unregister_open_handler(jabber_si_xfer_ibb_open_cb);
+}
+
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/msn/msg.c pidgin-2.10.11/libpurple/protocols/msn/msg.c
--- pidgin-2.10.11.orig/libpurple/protocols/msn/msg.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/msn/msg.c	2015-02-10 14:28:16.390685387 +0900
@@ -108,7 +108,8 @@
 msn_message_new_plain(const char *message)
 {
 	MsnMessage *msg;
-	char *message_cr;
+	char *message_cr, *message_cr2;
+	gsize len;
 
 	msg = msn_message_new(MSN_MSG_TEXT);
 	msg->retries = 1;
@@ -120,8 +121,10 @@
 						 "FN=Segoe%20UI; EF=; CO=0; CS=1;PF=0");
 
 	message_cr = purple_str_add_cr(message);
-	msn_message_set_bin_data(msg, message_cr, strlen(message_cr));
+	message_cr2 = botch_utf((gchar *)message_cr, -1, &len);
+	msn_message_set_bin_data(msg, message_cr2, len);
 	g_free(message_cr);
+	g_free(message_cr2);
 
 	return msg;
 }
@@ -657,16 +660,20 @@
 {
 	PurpleConnection *gc;
 	const char *body;
+	char *body_str;
 	char *body_enc;
 	char *body_final;
-	size_t body_len;
+	char *yaz_body_final;
+	size_t body_len, new_len;
 	const char *passport;
 	const char *value;
 
 	gc = cmdproc->session->account->gc;
 
 	body = msn_message_get_bin_data(msg, &body_len);
-	body_enc = g_markup_escape_text(body, body_len);
+	body_str = sanitize_utf(body, body_len, &new_len);
+	body_enc = g_markup_escape_text(body_str, -1);
+	g_free(body_str);
 
 	passport = msg->remote_user;
 
@@ -701,23 +708,30 @@
 		body_final = body_enc;
 	}
 
+	/* yaz */
+	/* replace 0D 0A with <br> */
+	yaz_body_final = purple_strreplace(body_final, "\r\n", "<br>");
+//	purple_debug_info("yaz msn", "yaz_body_final=%s\n", yaz_body_final);
+	g_free(body_final);
+	body_final = yaz_body_final;
+
 	if (cmdproc->servconn->type == MSN_SERVCONN_SB) {
 		MsnSwitchBoard *swboard = cmdproc->data;
 
 		swboard->flag |= MSN_SB_FLAG_IM;
 
 		if (swboard->current_users > 1 ||
-			((swboard->conv != NULL) &&
-			 purple_conversation_get_type(swboard->conv) == PURPLE_CONV_TYPE_CHAT))
+		    ((swboard->conv != NULL) &&
+		     purple_conversation_get_type(swboard->conv) == PURPLE_CONV_TYPE_CHAT))
 		{
 			/* If current_users is always ok as it should then there is no need to
 			 * check if this is a chat. */
 			if (swboard->current_users <= 1)
 				purple_debug_misc("msn", "plain_msg: current_users(%d)\n",
-								swboard->current_users);
+						  swboard->current_users);
 
 			serv_got_chat_in(gc, swboard->chat_id, passport, 0, body_final,
-							 time(NULL));
+					 time(NULL));
 			if (swboard->conv == NULL)
 			{
 				swboard->conv = purple_find_chat(gc, swboard->chat_id);
@@ -731,7 +745,7 @@
 			if (swboard->conv == NULL)
 			{
 				swboard->conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM,
-										passport, purple_connection_get_account(gc));
+										      passport, purple_connection_get_account(gc));
 				swboard->flag |= MSN_SB_FLAG_IM;
 			}
 		}
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/msn/msn.c pidgin-2.10.11/libpurple/protocols/msn/msn.c
--- pidgin-2.10.11.orig/libpurple/protocols/msn/msn.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/msn/msn.c	2015-02-10 14:28:16.390685387 +0900
@@ -241,33 +241,43 @@
 	MsnSession *session;
 	MsnTransaction *trans;
 	PurpleAccount *account;
-	char real_alias[BUDDY_ALIAS_MAXLEN + 1];
+	const char *real_alias;
 	struct public_alias_closure *closure;
+	gchar *tmp;
+	gsize dummy;
 
 	session = purple_connection_get_protocol_data(pc);
 	cmdproc = session->notification->cmdproc;
 	account = purple_connection_get_account(pc);
 
-	if (alias && *alias) {
-		if (!msn_encode_spaces(alias, real_alias, BUDDY_ALIAS_MAXLEN + 1)) {
-			if (failure_cb) {
-				struct public_alias_closure *closure =
-					g_new0(struct public_alias_closure, 1);
-				closure->account = account;
-				closure->failure_cb = failure_cb;
-				purple_timeout_add(0, set_public_alias_length_error, closure);
-			} else {
-				purple_notify_error(pc, NULL,
-				                    _("Your new MSN friendly name is too long."),
-				                    NULL);
-			}
-			return;
+	if (alias && *alias)
+	{
+		char *tmp = botch_utf(alias, strlen(alias), &dummy);
+		real_alias = purple_url_encode(g_strstrip(tmp));
+		g_free(tmp);
+	}
+	else
+		real_alias = "";
+
+	if (strlen(real_alias) > BUDDY_ALIAS_MAXLEN)
+	{
+		if (failure_cb) {
+			struct public_alias_closure *closure =
+				g_new0(struct public_alias_closure, 1);
+			closure->account = account;
+			closure->failure_cb = failure_cb;
+			purple_timeout_add(0, set_public_alias_length_error, closure);
+		} else {
+			purple_notify_error(pc, NULL,
+			                    _("Your new MSN friendly name is too long."),
+			                    NULL);
 		}
+		return;
+	}
 
-		if (real_alias[0] == '\0')
-			g_strlcpy(real_alias, purple_account_get_username(account), sizeof(real_alias));
-	} else
-		g_strlcpy(real_alias, purple_account_get_username(account), sizeof(real_alias));
+	if (real_alias[0] == '\0') {
+		real_alias = purple_url_encode(purple_account_get_username(account));
+	}
 
 	closure = g_new0(struct public_alias_closure, 1);
 	closure->account = account;
@@ -580,6 +590,23 @@
 }
 
 static void
+msn_ipc_init(PurplePlugin *plugin)
+{
+	purple_plugin_ipc_register(plugin, "msn_set_friendly_name",
+				   PURPLE_CALLBACK(msn_act_id),
+				   purple_marshal_VOID__POINTER_POINTER,
+				   purple_value_new(PURPLE_TYPE_UNKNOWN),2,
+				   purple_value_new(PURPLE_TYPE_POINTER),
+				   purple_value_new(PURPLE_TYPE_POINTER));
+}
+
+static void
+msn_ipc_end(PurplePlugin *plugin)
+{
+	purple_plugin_ipc_unregister_all(plugin);
+}
+
+static void
 enable_mpop_cb(PurpleConnection *pc)
 {
 	MsnSession *session = purple_connection_get_protocol_data(pc);
@@ -1435,13 +1462,18 @@
 msn_send_emoticons(MsnSwitchBoard *swboard, GString *body)
 {
 	MsnMessage *msg;
+	gchar *tmp;
+	gsize len;
 
 	g_return_if_fail(body != NULL);
 
 	msg = msn_message_new(MSN_MSG_SLP);
 	msn_message_set_content_type(msg, "text/x-mms-emoticon");
 	msn_message_set_flag(msg, 'N');
-	msn_message_set_bin_data(msg, body->str, body->len);
+
+	tmp = botch_utf(body->str, -1, &len);
+	msn_message_set_bin_data(msg, tmp, len);
+	g_free(tmp);
 
 	msn_switchboard_send_msg(swboard, msg, TRUE);
 	msn_message_unref(msg);
@@ -2827,6 +2859,9 @@
 	msn_notification_init();
 	msn_switchboard_init();
 
+	// yaz
+	msn_ipc_init(plugin);
+
 	return TRUE;
 }
 
@@ -2835,6 +2870,9 @@
 	msn_notification_end();
 	msn_switchboard_end();
 
+	// yaz
+	msn_ipc_end(plugin);
+
 	return TRUE;
 }
 
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/msn/msn.c.orig pidgin-2.10.11/libpurple/protocols/msn/msn.c.orig
--- pidgin-2.10.11.orig/libpurple/protocols/msn/msn.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/msn/msn.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,3069 @@
+/**
+ * @file msn.c The MSN protocol plugin
+ *
+ * purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+#define PHOTO_SUPPORT 1
+
+#include "internal.h"
+
+#include "debug.h"
+#include "request.h"
+
+#include "accountopt.h"
+#include "contact.h"
+#include "msg.h"
+#include "page.h"
+#include "pluginpref.h"
+#include "prefs.h"
+#include "session.h"
+#include "smiley.h"
+#include "state.h"
+#include "util.h"
+#include "cmds.h"
+#include "core.h"
+#include "prpl.h"
+#include "msnutils.h"
+#include "version.h"
+
+#include "error.h"
+#include "msg.h"
+#include "switchboard.h"
+#include "notification.h"
+#include "slplink.h"
+
+#if PHOTO_SUPPORT
+#define MAX_HTTP_BUDDYICON_BYTES (200 * 1024)
+#include "imgstore.h"
+#endif
+
+typedef struct
+{
+	PurpleConnection *gc;
+	const char *passport;
+
+} MsnMobileData;
+
+typedef struct
+{
+	PurpleConnection *gc;
+	char *name;
+
+} MsnGetInfoData;
+
+typedef struct
+{
+	MsnGetInfoData *info_data;
+	char *stripped;
+	char *url_buffer;
+	PurpleNotifyUserInfo *user_info;
+	char *photo_url_text;
+
+} MsnGetInfoStepTwoData;
+
+typedef struct
+{
+	PurpleConnection *gc;
+	const char *who;
+	char *msg;
+	PurpleMessageFlags flags;
+	time_t when;
+} MsnIMData;
+
+typedef struct
+{
+	char *smile;
+	PurpleSmiley *ps;
+	MsnObject *obj;
+} MsnEmoticon;
+
+static const char *
+msn_normalize(const PurpleAccount *account, const char *str)
+{
+	static char buf[BUF_LEN];
+	char *tmp;
+
+	g_return_val_if_fail(str != NULL, NULL);
+
+	tmp = g_strchomp(g_utf8_strdown(str, -1));
+	g_snprintf(buf, sizeof(buf), "%s%s", tmp,
+			   (strchr(tmp, '@') ? "" : "@hotmail.com"));
+	g_free(tmp);
+
+	return buf;
+}
+
+static gboolean
+msn_send_attention(PurpleConnection *gc, const char *username, guint type)
+{
+	MsnMessage *msg;
+	MsnSession *session;
+	MsnSwitchBoard *swboard;
+
+	msg = msn_message_new_nudge();
+	session = gc->proto_data;
+	swboard = msn_session_get_swboard(session, username, MSN_SB_FLAG_IM);
+
+	msn_switchboard_send_msg(swboard, msg, TRUE);
+	msn_message_unref(msg);
+
+	return TRUE;
+}
+
+static GList *
+msn_attention_types(PurpleAccount *account)
+{
+	static GList *list = NULL;
+
+	if (!list) {
+		list = g_list_append(list, purple_attention_type_new("Nudge", _("Nudge"),
+				_("%s has nudged you!"), _("Nudging %s...")));
+	}
+
+	return list;
+}
+
+static GHashTable *
+msn_get_account_text_table(PurpleAccount *unused)
+{
+	GHashTable *table;
+
+	table = g_hash_table_new(g_str_hash, g_str_equal);
+
+	g_hash_table_insert(table, "login_label", (gpointer)_("Email Address..."));
+
+	return table;
+}
+
+static PurpleCmdRet
+msn_cmd_nudge(PurpleConversation *conv, const gchar *cmd, gchar **args, gchar **error, void *data)
+{
+	PurpleAccount *account = purple_conversation_get_account(conv);
+	PurpleConnection *gc = purple_account_get_connection(account);
+	const gchar *username;
+
+	username = purple_conversation_get_name(conv);
+
+	purple_prpl_send_attention(gc, username, MSN_NUDGE);
+
+	return PURPLE_CMD_RET_OK;
+}
+
+struct public_alias_closure
+{
+	PurpleAccount *account;
+	gpointer success_cb;
+	gpointer failure_cb;
+};
+
+static gboolean
+set_public_alias_length_error(gpointer data)
+{
+	struct public_alias_closure *closure = data;
+	PurpleSetPublicAliasFailureCallback failure_cb = closure->failure_cb;
+
+	failure_cb(closure->account, _("Your new MSN friendly name is too long."));
+	g_free(closure);
+
+	return FALSE;
+}
+
+static void
+prp_success_cb(MsnCmdProc *cmdproc, MsnCommand *cmd)
+{
+	const char *type, *friendlyname;
+	struct public_alias_closure *closure;
+
+	g_return_if_fail(cmd->param_count >= 3);
+	type = cmd->params[1];
+	g_return_if_fail(!strcmp(type, "MFN"));
+
+	closure = cmd->trans->data;
+	friendlyname = purple_url_decode(cmd->params[2]);
+
+	msn_update_contact(cmdproc->session, "Me", MSN_UPDATE_DISPLAY, friendlyname);
+
+	purple_connection_set_display_name(
+		purple_account_get_connection(closure->account),
+		friendlyname);
+	purple_account_set_string(closure->account, "display-name", friendlyname);
+
+	if (closure->success_cb) {
+		PurpleSetPublicAliasSuccessCallback success_cb = closure->success_cb;
+		success_cb(closure->account, friendlyname);
+	}
+}
+
+static void
+prp_error_cb(MsnCmdProc *cmdproc, MsnTransaction *trans, int error)
+{
+	struct public_alias_closure *closure = trans->data;
+	PurpleSetPublicAliasFailureCallback failure_cb = closure->failure_cb;
+	gboolean debug;
+	const char *error_text;
+
+	error_text = msn_error_get_text(error, &debug);
+	failure_cb(closure->account, error_text);
+}
+
+static void
+prp_timeout_cb(MsnCmdProc *cmdproc, MsnTransaction *trans)
+{
+	struct public_alias_closure *closure = trans->data;
+	PurpleSetPublicAliasFailureCallback failure_cb = closure->failure_cb;
+	failure_cb(closure->account, _("Connection Timeout"));
+}
+
+void
+msn_set_public_alias(PurpleConnection *pc, const char *alias,
+                     PurpleSetPublicAliasSuccessCallback success_cb,
+                     PurpleSetPublicAliasFailureCallback failure_cb)
+{
+	MsnCmdProc *cmdproc;
+	MsnSession *session;
+	MsnTransaction *trans;
+	PurpleAccount *account;
+	char real_alias[BUDDY_ALIAS_MAXLEN + 1];
+	struct public_alias_closure *closure;
+
+	session = purple_connection_get_protocol_data(pc);
+	cmdproc = session->notification->cmdproc;
+	account = purple_connection_get_account(pc);
+
+	if (alias && *alias) {
+		if (!msn_encode_spaces(alias, real_alias, BUDDY_ALIAS_MAXLEN + 1)) {
+			if (failure_cb) {
+				struct public_alias_closure *closure =
+					g_new0(struct public_alias_closure, 1);
+				closure->account = account;
+				closure->failure_cb = failure_cb;
+				purple_timeout_add(0, set_public_alias_length_error, closure);
+			} else {
+				purple_notify_error(pc, NULL,
+				                    _("Your new MSN friendly name is too long."),
+				                    NULL);
+			}
+			return;
+		}
+
+		if (real_alias[0] == '\0')
+			g_strlcpy(real_alias, purple_account_get_username(account), sizeof(real_alias));
+	} else
+		g_strlcpy(real_alias, purple_account_get_username(account), sizeof(real_alias));
+
+	closure = g_new0(struct public_alias_closure, 1);
+	closure->account = account;
+	closure->success_cb = success_cb;
+	closure->failure_cb = failure_cb;
+
+	trans = msn_transaction_new(cmdproc, "PRP", "MFN %s", real_alias);
+	msn_transaction_set_data(trans, closure);
+	msn_transaction_set_data_free(trans, g_free);
+	msn_transaction_add_cb(trans, "PRP", prp_success_cb);
+	if (failure_cb) {
+		msn_transaction_set_error_cb(trans, prp_error_cb);
+		msn_transaction_set_timeout_cb(trans, prp_timeout_cb);
+	}
+	msn_cmdproc_send_trans(cmdproc, trans);
+}
+
+static gboolean
+get_public_alias_cb(gpointer data)
+{
+	struct public_alias_closure *closure = data;
+	PurpleGetPublicAliasSuccessCallback success_cb = closure->success_cb;
+	const char *alias;
+
+	alias = purple_account_get_string(closure->account, "display-name",
+	                                  purple_account_get_username(closure->account));
+	success_cb(closure->account, alias);
+	g_free(closure);
+
+	return FALSE;
+}
+
+static void
+msn_get_public_alias(PurpleConnection *pc,
+                     PurpleGetPublicAliasSuccessCallback success_cb,
+                     PurpleGetPublicAliasFailureCallback failure_cb)
+{
+	struct public_alias_closure *closure = g_new0(struct public_alias_closure, 1);
+	PurpleAccount *account = purple_connection_get_account(pc);
+
+	closure->account = account;
+	closure->success_cb = success_cb;
+	purple_timeout_add(0, get_public_alias_cb, closure);
+}
+
+static void
+msn_act_id(PurpleConnection *gc, const char *entry)
+{
+	msn_set_public_alias(gc, entry, NULL, NULL);
+}
+
+static void
+msn_set_prp(PurpleConnection *gc, const char *type, const char *entry)
+{
+	MsnCmdProc *cmdproc;
+	MsnSession *session;
+	MsnTransaction *trans;
+
+	session = gc->proto_data;
+	cmdproc = session->notification->cmdproc;
+
+	if (entry == NULL || *entry == '\0')
+	{
+		trans = msn_transaction_new(cmdproc, "PRP", "%s", type);
+	}
+	else
+	{
+		trans = msn_transaction_new(cmdproc, "PRP", "%s %s", type,
+						 purple_url_encode(entry));
+	}
+	msn_cmdproc_send_trans(cmdproc, trans);
+}
+
+static void
+msn_set_home_phone_cb(PurpleConnection *gc, const char *entry)
+{
+	msn_set_prp(gc, "PHH", entry);
+}
+
+static void
+msn_set_work_phone_cb(PurpleConnection *gc, const char *entry)
+{
+	msn_set_prp(gc, "PHW", entry);
+}
+
+static void
+msn_set_mobile_phone_cb(PurpleConnection *gc, const char *entry)
+{
+	msn_set_prp(gc, "PHM", entry);
+}
+
+static void
+enable_msn_pages_cb(PurpleConnection *gc)
+{
+	msn_set_prp(gc, "MOB", "Y");
+}
+
+static void
+disable_msn_pages_cb(PurpleConnection *gc)
+{
+	msn_set_prp(gc, "MOB", "N");
+}
+
+static void
+send_to_mobile(PurpleConnection *gc, const char *who, const char *entry)
+{
+	MsnTransaction *trans;
+	MsnSession *session;
+	MsnCmdProc *cmdproc;
+	MsnPage *page;
+	MsnMessage *msg;
+	MsnUser *user;
+	char *payload = NULL;
+	const char *mobile_number = NULL;
+	gsize payload_len;
+
+	session = gc->proto_data;
+	cmdproc = session->notification->cmdproc;
+
+	page = msn_page_new();
+	msn_page_set_body(page, entry);
+
+	payload = msn_page_gen_payload(page, &payload_len);
+
+	if ((user = msn_userlist_find_user(session->userlist, who)) &&
+		(mobile_number = msn_user_get_mobile_phone(user)) &&
+		mobile_number[0] == '+') {
+		/* if msn_user_get_mobile_phone() has a + in front, it's a number
+		   that from the buddy's contact card */
+		trans = msn_transaction_new(cmdproc, "PGD", "tel:%s 1 %" G_GSIZE_FORMAT,
+			mobile_number, payload_len);
+	} else {
+		/* otherwise we send to whatever phone number the buddy registered
+		   with msn */
+		trans = msn_transaction_new(cmdproc, "PGD", "%s 1 %" G_GSIZE_FORMAT,
+			who, payload_len);
+	}
+
+	msn_transaction_set_payload(trans, payload, payload_len);
+	g_free(payload);
+
+	msg = msn_message_new_plain(entry);
+	msn_transaction_set_data(trans, msg);
+
+	msn_page_destroy(page);
+
+	msn_cmdproc_send_trans(cmdproc, trans);
+}
+
+static void
+send_to_mobile_cb(MsnMobileData *data, const char *entry)
+{
+	send_to_mobile(data->gc, data->passport, entry);
+	g_free(data);
+}
+
+static void
+close_mobile_page_cb(MsnMobileData *data, const char *entry)
+{
+	g_free(data);
+}
+
+/* -- */
+
+static void
+msn_show_set_friendly_name(PurplePluginAction *action)
+{
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	char *tmp;
+
+	gc = (PurpleConnection *) action->context;
+	account = purple_connection_get_account(gc);
+
+	tmp = g_strdup_printf(_("Set friendly name for %s."),
+	                      purple_account_get_username(account));
+	purple_request_input(gc, _("Set Friendly Name"), tmp,
+					   _("This is the name that other MSN buddies will "
+						 "see you as."),
+					   purple_connection_get_display_name(gc), FALSE, FALSE, NULL,
+					   _("OK"), G_CALLBACK(msn_act_id),
+					   _("Cancel"), NULL,
+					   account, NULL, NULL,
+					   gc);
+	g_free(tmp);
+}
+
+typedef struct MsnLocationData {
+	PurpleAccount *account;
+	MsnSession *session;
+	PurpleRequestFieldGroup *group;
+} MsnLocationData;
+
+static void
+update_endpoint_cb(MsnLocationData *data, PurpleRequestFields *fields)
+{
+	PurpleAccount *account;
+	MsnSession *session;
+	const char *old_name;
+	const char *name;
+	GList *others;
+
+	session = data->session;
+	account = data->account;
+
+	/* Update the current location's name */
+	old_name = purple_account_get_string(account, "endpoint-name", NULL);
+	name = purple_request_fields_get_string(fields, "endpoint-name");
+	if (!g_str_equal(old_name, name)) {
+		purple_account_set_string(account, "endpoint-name", name);
+		msn_notification_send_uux_private_endpointdata(session);
+	}
+
+	/* Sign out other locations */
+	for (others = purple_request_field_group_get_fields(data->group);
+	     others;
+	     others = g_list_next(others)) {
+		PurpleRequestField *field = others->data;
+		if (purple_request_field_get_type(field) != PURPLE_REQUEST_FIELD_BOOLEAN)
+			continue;
+		if (purple_request_field_bool_get_value(field)) {
+			const char *id = purple_request_field_get_id(field);
+			char *user;
+			purple_debug_info("msn", "Disconnecting Endpoint %s\n", id);
+
+			user = g_strdup_printf("%s;%s", purple_account_get_username(account), id);
+			msn_notification_send_uun(session, user, MSN_UNIFIED_NOTIFICATION_MPOP, "goawyplzthxbye");
+			g_free(user);
+		}
+	}
+
+	g_free(data);
+}
+
+static void
+msn_show_locations(PurplePluginAction *action)
+{
+	PurpleConnection *pc;
+	PurpleAccount *account;
+	MsnSession *session;
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *group;
+	PurpleRequestField *field;
+	gboolean have_other_endpoints;
+	GSList *l;
+	MsnLocationData *data;
+
+	pc = (PurpleConnection *)action->context;
+	account = purple_connection_get_account(pc);
+	session = purple_connection_get_protocol_data(pc);
+
+	fields = purple_request_fields_new();
+
+	group = purple_request_field_group_new(_("This Location"));
+	purple_request_fields_add_group(fields, group);
+	field = purple_request_field_label_new("endpoint-label", _("This is the name that identifies this location"));
+	purple_request_field_group_add_field(group, field);
+	field = purple_request_field_string_new("endpoint-name",
+	                                        _("Name"),
+	                                        purple_account_get_string(account, "endpoint-name", NULL),
+	                                        FALSE);
+	purple_request_field_set_required(field, TRUE);
+	purple_request_field_group_add_field(group, field);
+
+	group = purple_request_field_group_new(_("Other Locations"));
+	purple_request_fields_add_group(fields, group);
+
+	have_other_endpoints = FALSE;
+	for (l = session->user->endpoints; l; l = l->next) {
+		MsnUserEndpoint *ep = l->data;
+
+		if (ep->id[0] != '\0' && strncasecmp(ep->id + 1, session->guid, 36) == 0)
+			/* Don't add myself to the list */
+			continue;
+
+		if (!have_other_endpoints) {
+			/* We do in fact have an endpoint other than ourselves... let's
+			   add a label */
+			field = purple_request_field_label_new("others-label",
+					_("You can sign out from other locations here"));
+			purple_request_field_group_add_field(group, field);
+		}
+
+		have_other_endpoints = TRUE;
+		field = purple_request_field_bool_new(ep->id, ep->name, FALSE);
+		purple_request_field_group_add_field(group, field);
+	}
+	if (!have_other_endpoints) {
+		/* TODO: Due to limitations in our current request field API, the
+		   following string will show up with a trailing colon.  This should
+		   be fixed either by adding an "include_colon" boolean, or creating
+		   a separate purple_request_field_label_new_without_colon function,
+		   or by never automatically adding the colon and requiring that
+		   callers add the colon themselves. */
+		field = purple_request_field_label_new("others-label", _("You are not signed in from any other locations."));
+		purple_request_field_group_add_field(group, field);
+	}
+
+	data = g_new0(MsnLocationData, 1);
+	data->account = account;
+	data->session = session;
+	data->group = group;
+
+	purple_request_fields(pc, NULL, NULL, NULL,
+	                      fields,
+	                      _("OK"), G_CALLBACK(update_endpoint_cb),
+	                      _("Cancel"), G_CALLBACK(g_free),
+	                      account, NULL, NULL,
+	                      data);
+}
+
+static void
+enable_mpop_cb(PurpleConnection *pc)
+{
+	MsnSession *session = purple_connection_get_protocol_data(pc);
+
+	purple_debug_info("msn", "Enabling MPOP\n");
+
+	session->enable_mpop = TRUE;
+	msn_annotate_contact(session, "Me", "MSN.IM.MPOP", "1", NULL);
+
+	purple_prpl_got_account_actions(purple_connection_get_account(pc));
+}
+
+static void
+disable_mpop_cb(PurpleConnection *pc)
+{
+	PurpleAccount *account = purple_connection_get_account(pc);
+	MsnSession *session = purple_connection_get_protocol_data(pc);
+	GSList *l;
+
+	purple_debug_info("msn", "Disabling MPOP\n");
+
+	session->enable_mpop = FALSE;
+	msn_annotate_contact(session, "Me", "MSN.IM.MPOP", "0", NULL);
+
+	for (l = session->user->endpoints; l; l = l->next) {
+		MsnUserEndpoint *ep = l->data;
+		char *user;
+
+		if (ep->id[0] != '\0' && strncasecmp(ep->id + 1, session->guid, 36) == 0)
+			/* Don't kick myself */
+			continue;
+
+		purple_debug_info("msn", "Disconnecting Endpoint %s\n", ep->id);
+
+		user = g_strdup_printf("%s;%s", purple_account_get_username(account), ep->id);
+		msn_notification_send_uun(session, user, MSN_UNIFIED_NOTIFICATION_MPOP, "goawyplzthxbye");
+		g_free(user);
+	}
+
+	purple_prpl_got_account_actions(account);
+}
+
+static void
+msn_show_set_mpop(PurplePluginAction *action)
+{
+	PurpleConnection *pc;
+
+	pc = (PurpleConnection *)action->context;
+
+	purple_request_action(pc, NULL, _("Allow multiple logins?"),
+						_("Do you want to allow or disallow connecting from "
+						  "multiple locations simultaneously?"),
+						PURPLE_DEFAULT_ACTION_NONE,
+						purple_connection_get_account(pc), NULL, NULL,
+						pc, 3,
+						_("Allow"), G_CALLBACK(enable_mpop_cb),
+						_("Disallow"), G_CALLBACK(disable_mpop_cb),
+						_("Cancel"), NULL);
+}
+
+static void
+msn_show_set_home_phone(PurplePluginAction *action)
+{
+	PurpleConnection *gc;
+	MsnSession *session;
+
+	gc = (PurpleConnection *) action->context;
+	session = gc->proto_data;
+
+	purple_request_input(gc, NULL, _("Set your home phone number."), NULL,
+					   msn_user_get_home_phone(session->user), FALSE, FALSE, NULL,
+					   _("OK"), G_CALLBACK(msn_set_home_phone_cb),
+					   _("Cancel"), NULL,
+					   purple_connection_get_account(gc), NULL, NULL,
+					   gc);
+}
+
+static void
+msn_show_set_work_phone(PurplePluginAction *action)
+{
+	PurpleConnection *gc;
+	MsnSession *session;
+
+	gc = (PurpleConnection *) action->context;
+	session = gc->proto_data;
+
+	purple_request_input(gc, NULL, _("Set your work phone number."), NULL,
+					   msn_user_get_work_phone(session->user), FALSE, FALSE, NULL,
+					   _("OK"), G_CALLBACK(msn_set_work_phone_cb),
+					   _("Cancel"), NULL,
+					   purple_connection_get_account(gc), NULL, NULL,
+					   gc);
+}
+
+static void
+msn_show_set_mobile_phone(PurplePluginAction *action)
+{
+	PurpleConnection *gc;
+	MsnSession *session;
+
+	gc = (PurpleConnection *) action->context;
+	session = gc->proto_data;
+
+	purple_request_input(gc, NULL, _("Set your mobile phone number."), NULL,
+					   msn_user_get_mobile_phone(session->user), FALSE, FALSE, NULL,
+					   _("OK"), G_CALLBACK(msn_set_mobile_phone_cb),
+					   _("Cancel"), NULL,
+					   purple_connection_get_account(gc), NULL, NULL,
+					   gc);
+}
+
+static void
+msn_show_set_mobile_pages(PurplePluginAction *action)
+{
+	PurpleConnection *gc;
+
+	gc = (PurpleConnection *) action->context;
+
+	purple_request_action(gc, NULL, _("Allow MSN Mobile pages?"),
+						_("Do you want to allow or disallow people on "
+						  "your buddy list to send you MSN Mobile pages "
+						  "to your cell phone or other mobile device?"),
+						PURPLE_DEFAULT_ACTION_NONE,
+						purple_connection_get_account(gc), NULL, NULL,
+						gc, 3,
+						_("Allow"), G_CALLBACK(enable_msn_pages_cb),
+						_("Disallow"), G_CALLBACK(disable_msn_pages_cb),
+						_("Cancel"), NULL);
+}
+
+/* QuLogic: Disabled until confirmed correct. */
+#if 0
+static void
+msn_show_blocked_text(PurplePluginAction *action)
+{
+	PurpleConnection *pc = (PurpleConnection *) action->context;
+	MsnSession *session;
+	char *title;
+
+	session = pc->proto_data;
+
+	title = g_strdup_printf(_("Blocked Text for %s"), session->account->username);
+	if (session->blocked_text == NULL) {
+		purple_notify_formatted(pc, title, title, NULL, _("No text is blocked for this account."), NULL, NULL);
+	} else {
+		char *blocked_text;
+		blocked_text = g_strdup_printf(_("MSN servers are currently blocking the following regular expressions:<br/>%s"),
+		                               session->blocked_text);
+
+		purple_notify_formatted(pc, title, title, NULL, blocked_text, NULL, NULL);
+		g_free(blocked_text);
+	}
+	g_free(title);
+}
+#endif
+
+static void
+msn_show_hotmail_inbox(PurplePluginAction *action)
+{
+	PurpleConnection *gc;
+	MsnSession *session;
+
+	gc = (PurpleConnection *) action->context;
+	session = gc->proto_data;
+
+	if (!session->passport_info.email_enabled) {
+		purple_notify_error(gc, NULL,
+						  _("This account does not have email enabled."), NULL);
+		return;
+	}
+
+	/** apparently the correct value is 777, use 750 as a failsafe */
+	if ((session->passport_info.mail_url == NULL)
+		|| (time (NULL) - session->passport_info.mail_timestamp >= 750)) {
+		MsnTransaction *trans;
+		MsnCmdProc *cmdproc;
+
+		cmdproc = session->notification->cmdproc;
+
+		trans = msn_transaction_new(cmdproc, "URL", "%s", "INBOX");
+		msn_transaction_set_data(trans, GUINT_TO_POINTER(TRUE));
+
+		msn_cmdproc_send_trans(cmdproc, trans);
+
+	} else
+		purple_notify_uri(gc, session->passport_info.mail_url);
+}
+
+static void
+show_send_to_mobile_cb(PurpleBlistNode *node, gpointer ignored)
+{
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+	MsnMobileData *data;
+	PurpleAccount *account;
+	const char *name;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy *) node;
+	account = purple_buddy_get_account(buddy);
+	gc = purple_account_get_connection(account);
+	name = purple_buddy_get_name(buddy);
+
+	data = g_new0(MsnMobileData, 1);
+	data->gc = gc;
+	data->passport = name;
+
+	purple_request_input(gc, NULL, _("Send a mobile message."), NULL,
+					   NULL, TRUE, FALSE, NULL,
+					   _("Page"), G_CALLBACK(send_to_mobile_cb),
+					   _("Close"), G_CALLBACK(close_mobile_page_cb),
+					   account, name, NULL,
+					   data);
+}
+
+static gboolean
+msn_offline_message(const PurpleBuddy *buddy) {
+	return TRUE;
+}
+
+void
+msn_send_privacy(PurpleConnection *gc)
+{
+	PurpleAccount *account;
+	MsnSession *session;
+	MsnCmdProc *cmdproc;
+	MsnTransaction *trans;
+
+	account = purple_connection_get_account(gc);
+	session = gc->proto_data;
+	cmdproc = session->notification->cmdproc;
+
+	if (account->perm_deny == PURPLE_PRIVACY_ALLOW_ALL ||
+	    account->perm_deny == PURPLE_PRIVACY_DENY_USERS)
+		trans = msn_transaction_new(cmdproc, "BLP", "%s", "AL");
+	else
+		trans = msn_transaction_new(cmdproc, "BLP", "%s", "BL");
+
+	msn_cmdproc_send_trans(cmdproc, trans);
+}
+
+static void
+initiate_chat_cb(PurpleBlistNode *node, gpointer data)
+{
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+	PurpleAccount *account;
+
+	MsnSession *session;
+	MsnSwitchBoard *swboard;
+
+	const char *alias;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy *) node;
+	account = purple_buddy_get_account(buddy);
+	gc = purple_account_get_connection(account);
+
+	session = gc->proto_data;
+
+	swboard = msn_switchboard_new(session);
+	msn_switchboard_request(swboard);
+	msn_switchboard_request_add_user(swboard, purple_buddy_get_name(buddy));
+
+	/* TODO: This might move somewhere else, after USR might be */
+	swboard->chat_id = msn_switchboard_get_chat_id();
+	swboard->conv = serv_got_joined_chat(gc, swboard->chat_id, "MSN Chat");
+	swboard->flag = MSN_SB_FLAG_IM;
+
+	/* Local alias > Display name > Username */
+	if ((alias = purple_account_get_alias(account)) == NULL)
+		if ((alias = purple_connection_get_display_name(gc)) == NULL)
+			alias = purple_account_get_username(account);
+
+	purple_conv_chat_add_user(PURPLE_CONV_CHAT(swboard->conv),
+	                          alias, NULL, PURPLE_CBFLAGS_NONE, TRUE);
+}
+
+static void
+t_msn_xfer_init(PurpleXfer *xfer)
+{
+	msn_request_ft(xfer);
+}
+
+static void
+t_msn_xfer_cancel_send(PurpleXfer *xfer)
+{
+	MsnSlpLink *slplink = xfer->data;
+	msn_slplink_unref(slplink);
+}
+
+static PurpleXfer*
+msn_new_xfer(PurpleConnection *gc, const char *who)
+{
+	MsnSession *session;
+	PurpleXfer *xfer;
+
+	session = gc->proto_data;
+
+	xfer = purple_xfer_new(gc->account, PURPLE_XFER_SEND, who);
+
+	g_return_val_if_fail(xfer != NULL, NULL);
+
+	xfer->data = msn_slplink_ref(msn_session_get_slplink(session, who));
+
+	purple_xfer_set_init_fnc(xfer, t_msn_xfer_init);
+	purple_xfer_set_cancel_send_fnc(xfer, t_msn_xfer_cancel_send);
+
+	return xfer;
+}
+
+static void
+msn_send_file(PurpleConnection *gc, const char *who, const char *file)
+{
+	PurpleXfer *xfer = msn_new_xfer(gc, who);
+
+	if (file)
+		purple_xfer_request_accepted(xfer, file);
+	else
+		purple_xfer_request(xfer);
+}
+
+static gboolean
+msn_can_receive_file(PurpleConnection *gc, const char *who)
+{
+	PurpleAccount *account;
+	gchar *normal;
+	gboolean ret;
+
+	account = purple_connection_get_account(gc);
+
+	normal = g_strdup(msn_normalize(account, purple_account_get_username(account)));
+	ret = strcmp(normal, msn_normalize(account, who));
+	g_free(normal);
+
+	if (ret) {
+		MsnSession *session = gc->proto_data;
+		if (session) {
+			MsnUser *user = msn_userlist_find_user(session->userlist, who);
+			if (user) {
+				/* Include these too: MSN_CAP_MOBILE_ON|MSN_CAP_WEB_WATCH ? */
+				if ((user->clientid & MSN_CAP_VIA_WEBIM) ||
+						user->networkid == MSN_NETWORK_YAHOO)
+					ret = FALSE;
+				else
+					ret = TRUE;
+			}
+		} else
+			ret = FALSE;
+	}
+
+	return ret;
+}
+
+/**************************************************************************
+ * Protocol Plugin ops
+ **************************************************************************/
+
+static const char *
+msn_list_icon(PurpleAccount *a, PurpleBuddy *b)
+{
+	return "msn";
+}
+
+static const char *
+msn_list_emblems(PurpleBuddy *b)
+{
+	MsnUser *user = purple_buddy_get_protocol_data(b);
+
+	if (user != NULL) {
+		if (user->clientid & MSN_CAP_BOT)
+			return "bot";
+		if (user->clientid & MSN_CAP_VIA_MOBILE)
+			return "mobile";
+#if 0
+		/* XXX: Since we don't support this, there's no point in showing it just yet */
+		if (user->clientid & MSN_CAP_SCHANNEL)
+			return "secure";
+#endif
+		if (user->clientid & MSN_CAP_VIA_WEBIM)
+			return "external";
+		if (user->networkid == MSN_NETWORK_YAHOO)
+			return "yahoo";
+	}
+
+	return NULL;
+}
+
+/*
+ * Set the User status text
+ */
+static char *
+msn_status_text(PurpleBuddy *buddy)
+{
+	PurplePresence *presence;
+	PurpleStatus *status;
+	const char *msg;
+
+	presence = purple_buddy_get_presence(buddy);
+	status = purple_presence_get_active_status(presence);
+
+	/* Official client says media takes precedence over message */
+	/* I say message take precedence over media! Plus prpl-jabber agrees
+	   too */
+	msg = purple_status_get_attr_string(status, "message");
+	if (msg && *msg)
+		return g_markup_escape_text(msg, -1);
+
+	if (purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_TUNE)) {
+		const char *title, *game, *office;
+		char *media, *esc;
+		status = purple_presence_get_status(presence, "tune");
+		title = purple_status_get_attr_string(status, PURPLE_TUNE_TITLE);
+
+		game = purple_status_get_attr_string(status, "game");
+		office = purple_status_get_attr_string(status, "office");
+
+		if (title && *title) {
+			const char *artist = purple_status_get_attr_string(status, PURPLE_TUNE_ARTIST);
+			const char *album = purple_status_get_attr_string(status, PURPLE_TUNE_ALBUM);
+			media = purple_util_format_song_info(title, artist, album, NULL);
+			return media;
+		}
+		else if (game && *game)
+			media = g_strdup_printf("Playing %s", game);
+		else if (office && *office)
+			media = g_strdup_printf("Editing %s", office);
+		else
+			return NULL;
+		esc = g_markup_escape_text(media, -1);
+		g_free(media);
+		return esc;
+	}
+
+	return NULL;
+}
+
+static void
+msn_tooltip_text(PurpleBuddy *buddy, PurpleNotifyUserInfo *user_info, gboolean full)
+{
+	MsnUser *user;
+	PurplePresence *presence = purple_buddy_get_presence(buddy);
+	PurpleStatus *status = purple_presence_get_active_status(presence);
+
+	user = purple_buddy_get_protocol_data(buddy);
+
+	if (purple_presence_is_online(presence))
+	{
+		const char *psm, *name;
+		const char *mediatype = NULL;
+		char *currentmedia = NULL;
+
+		psm = purple_status_get_attr_string(status, "message");
+		if (purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_TUNE)) {
+			PurpleStatus *tune = purple_presence_get_status(presence, "tune");
+			const char *title = purple_status_get_attr_string(tune, PURPLE_TUNE_TITLE);
+			const char *game = purple_status_get_attr_string(tune, "game");
+			const char *office = purple_status_get_attr_string(tune, "office");
+			if (title && *title) {
+				const char *artist = purple_status_get_attr_string(tune, PURPLE_TUNE_ARTIST);
+				const char *album = purple_status_get_attr_string(tune, PURPLE_TUNE_ALBUM);
+				mediatype = _("Now Listening");
+				currentmedia = purple_util_format_song_info(title, artist, album, NULL);
+			} else if (game && *game) {
+				mediatype = _("Playing a game");
+				currentmedia = g_strdup(game);
+			} else if (office && *office) {
+				mediatype = _("Working");
+				currentmedia = g_strdup(office);
+			}
+		}
+
+		if (!purple_status_is_available(status)) {
+			name = purple_status_get_name(status);
+		} else {
+			name = NULL;
+		}
+
+		if (name != NULL && *name) {
+			char *tmp2;
+
+			tmp2 = g_markup_escape_text(name, -1);
+			if (purple_presence_is_idle(presence)) {
+				char *idle;
+				char *tmp3;
+				/* Never know what those translations might end up like... */
+				idle = g_markup_escape_text(_("Idle"), -1);
+				tmp3 = g_strdup_printf("%s/%s", tmp2, idle);
+				g_free(idle);
+				g_free(tmp2);
+				tmp2 = tmp3;
+			}
+
+			if (psm != NULL && *psm) {
+				purple_notify_user_info_add_pair_plaintext(user_info, tmp2, psm);
+			} else {
+				purple_notify_user_info_add_pair(user_info, _("Status"), tmp2);
+			}
+
+			g_free(tmp2);
+		} else {
+			if (psm != NULL && *psm) {
+				if (purple_presence_is_idle(presence)) {
+					purple_notify_user_info_add_pair_plaintext(user_info, _("Idle"), psm);
+				} else {
+					purple_notify_user_info_add_pair_plaintext(user_info, _("Status"), psm);
+				}
+			} else {
+				if (purple_presence_is_idle(presence)) {
+					purple_notify_user_info_add_pair(user_info, _("Status"),
+						_("Idle"));
+				} else {
+					purple_notify_user_info_add_pair(user_info, _("Status"),
+						purple_status_get_name(status));
+				}
+			}
+		}
+
+		if (currentmedia) {
+			purple_notify_user_info_add_pair(user_info, mediatype, currentmedia);
+			g_free(currentmedia);
+		}
+	}
+
+	/* XXX: This is being shown in non-full tooltips because the
+	 * XXX: blocked icon overlay isn't always accurate for MSN.
+	 * XXX: This can die as soon as purple_privacy_check() knows that
+	 * XXX: this prpl always honors both the allow and deny lists. */
+	/* While the above comment may be strictly correct (the privacy API needs
+	 * rewriteing), purple_privacy_check() is going to be more accurate at
+	 * indicating whether a particular buddy is going to be able to message
+	 * you, which is the important information that this is trying to convey.
+	 */
+	if (full && user)
+	{
+		const char *phone;
+
+		purple_notify_user_info_add_pair(user_info, _("Has you"),
+									   ((user->list_op & (1 << MSN_LIST_RL)) ? _("Yes") : _("No")));
+
+		purple_notify_user_info_add_pair(user_info, _("Blocked"),
+									   ((user->list_op & (1 << MSN_LIST_BL)) ? _("Yes") : _("No")));
+
+		phone = msn_user_get_home_phone(user);
+		if (phone != NULL)
+			purple_notify_user_info_add_pair(user_info, _("Home Phone Number"), phone);
+
+		phone = msn_user_get_work_phone(user);
+		if (phone != NULL)
+			purple_notify_user_info_add_pair(user_info, _("Work Phone Number"), phone);
+
+		phone = msn_user_get_mobile_phone(user);
+		if (phone != NULL)
+			purple_notify_user_info_add_pair(user_info, _("Mobile Phone Number"), phone);
+	}
+}
+
+static GList *
+msn_status_types(PurpleAccount *account)
+{
+	PurpleStatusType *status;
+	GList *types = NULL;
+
+	status = purple_status_type_new_with_attrs(
+				PURPLE_STATUS_AVAILABLE, NULL, NULL, TRUE, TRUE, FALSE,
+				"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+				NULL);
+	types = g_list_append(types, status);
+
+	status = purple_status_type_new_with_attrs(
+			PURPLE_STATUS_AWAY, NULL, NULL, TRUE, TRUE, FALSE,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	types = g_list_append(types, status);
+
+	status = purple_status_type_new_with_attrs(
+			PURPLE_STATUS_AWAY, "brb", _("Be Right Back"), TRUE, TRUE, FALSE,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	types = g_list_append(types, status);
+
+	status = purple_status_type_new_with_attrs(
+			PURPLE_STATUS_UNAVAILABLE, "busy", _("Busy"), TRUE, TRUE, FALSE,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	types = g_list_append(types, status);
+	status = purple_status_type_new_with_attrs(
+			PURPLE_STATUS_UNAVAILABLE, "phone", _("On the Phone"), TRUE, TRUE, FALSE,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	types = g_list_append(types, status);
+	status = purple_status_type_new_with_attrs(
+			PURPLE_STATUS_AWAY, "lunch", _("Out to Lunch"), TRUE, TRUE, FALSE,
+			"message", _("Message"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	types = g_list_append(types, status);
+
+	status = purple_status_type_new_full(PURPLE_STATUS_INVISIBLE,
+			NULL, NULL, TRUE, TRUE, FALSE);
+	types = g_list_append(types, status);
+
+	status = purple_status_type_new_full(PURPLE_STATUS_OFFLINE,
+			NULL, NULL, TRUE, TRUE, FALSE);
+	types = g_list_append(types, status);
+
+	status = purple_status_type_new_full(PURPLE_STATUS_MOBILE,
+			"mobile", NULL, FALSE, FALSE, TRUE);
+	types = g_list_append(types, status);
+
+	status = purple_status_type_new_with_attrs(PURPLE_STATUS_TUNE,
+			"tune", NULL, FALSE, TRUE, TRUE,
+			PURPLE_TUNE_ARTIST, _("Tune Artist"), purple_value_new(PURPLE_TYPE_STRING),
+			PURPLE_TUNE_ALBUM, _("Tune Album"), purple_value_new(PURPLE_TYPE_STRING),
+			PURPLE_TUNE_TITLE, _("Tune Title"), purple_value_new(PURPLE_TYPE_STRING),
+			"game", _("Game Title"), purple_value_new(PURPLE_TYPE_STRING),
+			"office", _("Office Title"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	types = g_list_append(types, status);
+
+	return types;
+}
+
+static GList *
+msn_actions(PurplePlugin *plugin, gpointer context)
+{
+	PurpleConnection *gc;
+	MsnSession *session;
+	GList *m = NULL;
+	PurplePluginAction *act;
+
+	gc = (PurpleConnection *) context;
+	session = gc->proto_data;
+
+	act = purple_plugin_action_new(_("Set Friendly Name..."),
+								 msn_show_set_friendly_name);
+	m = g_list_append(m, act);
+	m = g_list_append(m, NULL);
+
+	if (session->enable_mpop)
+	{
+		act = purple_plugin_action_new(_("View Locations..."),
+		                               msn_show_locations);
+		m = g_list_append(m, act);
+		m = g_list_append(m, NULL);
+	}
+
+	act = purple_plugin_action_new(_("Set Home Phone Number..."),
+								 msn_show_set_home_phone);
+	m = g_list_append(m, act);
+
+	act = purple_plugin_action_new(_("Set Work Phone Number..."),
+			msn_show_set_work_phone);
+	m = g_list_append(m, act);
+
+	act = purple_plugin_action_new(_("Set Mobile Phone Number..."),
+			msn_show_set_mobile_phone);
+	m = g_list_append(m, act);
+	m = g_list_append(m, NULL);
+
+#if 0
+	act = purple_plugin_action_new(_("Enable/Disable Mobile Devices..."),
+			msn_show_set_mobile_support);
+	m = g_list_append(m, act);
+#endif
+
+	act = purple_plugin_action_new(_("Allow/Disallow Multiple Logins..."),
+			msn_show_set_mpop);
+	m = g_list_append(m, act);
+
+	act = purple_plugin_action_new(_("Allow/Disallow Mobile Pages..."),
+			msn_show_set_mobile_pages);
+	m = g_list_append(m, act);
+
+/* QuLogic: Disabled until confirmed correct. */
+#if 0
+	m = g_list_append(m, NULL);
+	act = purple_plugin_action_new(_("View Blocked Text..."),
+			msn_show_blocked_text);
+	m = g_list_append(m, act);
+#endif
+
+	m = g_list_append(m, NULL);
+	act = purple_plugin_action_new(_("Open Hotmail Inbox"),
+			msn_show_hotmail_inbox);
+	m = g_list_append(m, act);
+
+	return m;
+}
+
+static GList *
+msn_buddy_menu(PurpleBuddy *buddy)
+{
+	MsnUser *user;
+
+	GList *m = NULL;
+	PurpleMenuAction *act;
+
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	user = purple_buddy_get_protocol_data(buddy);
+
+	if (user != NULL)
+	{
+		if (user->mobile)
+		{
+			act = purple_menu_action_new(_("Send to Mobile"),
+			                           PURPLE_CALLBACK(show_send_to_mobile_cb),
+			                           NULL, NULL);
+			m = g_list_append(m, act);
+		}
+	}
+
+	if (g_ascii_strcasecmp(purple_buddy_get_name(buddy),
+				purple_account_get_username(purple_buddy_get_account(buddy))))
+	{
+		act = purple_menu_action_new(_("Initiate _Chat"),
+		                           PURPLE_CALLBACK(initiate_chat_cb),
+		                           NULL, NULL);
+		m = g_list_append(m, act);
+	}
+
+	return m;
+}
+
+static GList *
+msn_blist_node_menu(PurpleBlistNode *node)
+{
+	if(PURPLE_BLIST_NODE_IS_BUDDY(node))
+	{
+		return msn_buddy_menu((PurpleBuddy *) node);
+	}
+	else
+	{
+		return NULL;
+	}
+}
+
+static void
+msn_login(PurpleAccount *account)
+{
+	PurpleConnection *gc;
+	MsnSession *session;
+	const char *username;
+	const char *host;
+	gboolean http_method = FALSE;
+	int port;
+
+	gc = purple_account_get_connection(account);
+
+	if (!purple_ssl_is_supported())
+	{
+		purple_connection_error_reason(gc,
+			PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,
+			_("SSL support is needed for MSN. Please install a supported "
+			  "SSL library."));
+		return;
+	}
+
+	http_method = purple_account_get_bool(account, "http_method", FALSE);
+
+	if (http_method)
+		host = purple_account_get_string(account, "http_method_server", MSN_HTTPCONN_SERVER);
+	else
+		host = purple_account_get_string(account, "server", MSN_SERVER);
+	port = purple_account_get_int(account, "port", MSN_PORT);
+
+	session = msn_session_new(account);
+
+	gc->proto_data = session;
+	gc->flags |= PURPLE_CONNECTION_HTML | PURPLE_CONNECTION_FORMATTING_WBFO | PURPLE_CONNECTION_NO_BGCOLOR |
+		PURPLE_CONNECTION_NO_FONTSIZE | PURPLE_CONNECTION_NO_URLDESC | PURPLE_CONNECTION_ALLOW_CUSTOM_SMILEY;
+
+	msn_session_set_login_step(session, MSN_LOGIN_STEP_START);
+
+	/* Hmm, I don't like this. */
+	/* XXX shx: Me neither */
+	username = msn_normalize(account, purple_account_get_username(account));
+
+	if (strcmp(username, purple_account_get_username(account)))
+		purple_account_set_username(account, username);
+
+	username = purple_account_get_string(account, "display-name", NULL);
+	purple_connection_set_display_name(gc, username);
+
+	if (purple_account_get_string(account, "endpoint-name", NULL) == NULL) {
+		GHashTable *ui_info = purple_core_get_ui_info();
+		const gchar *ui_name = ui_info ? g_hash_table_lookup(ui_info, "name") : NULL;
+		purple_account_set_string(account, "endpoint-name",
+				ui_name && *ui_name ? ui_name : PACKAGE_NAME);
+	}
+
+	if (!msn_session_connect(session, host, port, http_method))
+		purple_connection_error_reason(gc,
+			PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+			_("Unable to connect"));
+}
+
+static void
+msn_close(PurpleConnection *gc)
+{
+	MsnSession *session;
+
+	session = gc->proto_data;
+
+	g_return_if_fail(session != NULL);
+
+	msn_session_destroy(session);
+
+	gc->proto_data = NULL;
+}
+
+static gboolean
+msn_send_me_im(gpointer data)
+{
+	MsnIMData *imdata = data;
+	serv_got_im(imdata->gc, imdata->who, imdata->msg, imdata->flags, imdata->when);
+	g_free(imdata->msg);
+	g_free(imdata);
+	return FALSE;
+}
+
+static GString*
+msn_msg_emoticon_add(GString *current, MsnEmoticon *emoticon)
+{
+	MsnObject *obj;
+	char *strobj;
+
+	if (emoticon == NULL)
+		return current;
+
+	obj = emoticon->obj;
+
+	if (!obj)
+		return current;
+
+	strobj = msn_object_to_string(obj);
+
+	if (current)
+		g_string_append_printf(current, "\t%s\t%s", emoticon->smile, strobj);
+	else {
+		current = g_string_new("");
+		g_string_printf(current, "%s\t%s", emoticon->smile, strobj);
+	}
+
+	g_free(strobj);
+
+	return current;
+}
+
+static void
+msn_send_emoticons(MsnSwitchBoard *swboard, GString *body)
+{
+	MsnMessage *msg;
+
+	g_return_if_fail(body != NULL);
+
+	msg = msn_message_new(MSN_MSG_SLP);
+	msn_message_set_content_type(msg, "text/x-mms-emoticon");
+	msn_message_set_flag(msg, 'N');
+	msn_message_set_bin_data(msg, body->str, body->len);
+
+	msn_switchboard_send_msg(swboard, msg, TRUE);
+	msn_message_unref(msg);
+}
+
+static void msn_emoticon_destroy(MsnEmoticon *emoticon)
+{
+	if (emoticon->obj)
+		msn_object_destroy(emoticon->obj);
+	g_free(emoticon->smile);
+	g_free(emoticon);
+}
+
+static GSList* msn_msg_grab_emoticons(const char *msg, const char *username)
+{
+	GSList *list;
+	GList *smileys;
+	PurpleSmiley *smiley;
+	PurpleStoredImage *img;
+	char *ptr;
+	MsnEmoticon *emoticon;
+	int length;
+
+	list = NULL;
+	smileys = purple_smileys_get_all();
+	length = strlen(msg);
+
+	for (; smileys; smileys = g_list_delete_link(smileys, smileys)) {
+		smiley = smileys->data;
+
+		ptr = g_strstr_len(msg, length, purple_smiley_get_shortcut(smiley));
+
+		if (!ptr)
+			continue;
+
+		img = purple_smiley_get_stored_image(smiley);
+
+		emoticon = g_new0(MsnEmoticon, 1);
+		emoticon->smile = g_strdup(purple_smiley_get_shortcut(smiley));
+		emoticon->ps = smiley;
+		emoticon->obj = msn_object_new_from_image(img,
+				purple_imgstore_get_filename(img),
+				username, MSN_OBJECT_EMOTICON);
+
+		purple_imgstore_unref(img);
+		list = g_slist_prepend(list, emoticon);
+	}
+
+	return list;
+}
+
+void
+msn_send_im_message(MsnSession *session, MsnMessage *msg)
+{
+	MsnEmoticon *smile;
+	GSList *smileys;
+	GString *emoticons = NULL;
+	const char *username = purple_account_get_username(session->account);
+	MsnSwitchBoard *swboard = msn_session_get_swboard(session, msg->remote_user, MSN_SB_FLAG_IM);
+
+	smileys = msn_msg_grab_emoticons(msg->body, username);
+	while (smileys) {
+		smile = (MsnEmoticon *)smileys->data;
+		emoticons = msn_msg_emoticon_add(emoticons, smile);
+		msn_emoticon_destroy(smile);
+		smileys = g_slist_delete_link(smileys, smileys);
+	}
+
+	if (emoticons) {
+		msn_send_emoticons(swboard, emoticons);
+		g_string_free(emoticons, TRUE);
+	}
+
+	msn_switchboard_send_msg(swboard, msg, TRUE);
+}
+
+static int
+msn_send_im(PurpleConnection *gc, const char *who, const char *message,
+			PurpleMessageFlags flags)
+{
+	PurpleAccount *account;
+	PurpleBuddy *buddy = purple_find_buddy(gc->account, who);
+	MsnSession *session;
+	MsnSwitchBoard *swboard;
+	MsnMessage *msg;
+	char *msgformat;
+	char *msgtext;
+	size_t msglen;
+	const char *username;
+
+	purple_debug_info("msn", "send IM {%s} to %s\n", message, who);
+	account = purple_connection_get_account(gc);
+	username = purple_account_get_username(account);
+
+	session = gc->proto_data;
+	swboard = msn_session_find_swboard(session, who);
+
+	if (!strncmp("tel:+", who, 5)) {
+		char *text = purple_markup_strip_html(message);
+		send_to_mobile(gc, who, text);
+		g_free(text);
+		return 1;
+	}
+
+	if (buddy) {
+		PurplePresence *p = purple_buddy_get_presence(buddy);
+		if (purple_presence_is_status_primitive_active(p, PURPLE_STATUS_MOBILE)) {
+			char *text = purple_markup_strip_html(message);
+			send_to_mobile(gc, who, text);
+			g_free(text);
+			return 1;
+		}
+	}
+
+	msn_import_html(message, &msgformat, &msgtext);
+	msglen = strlen(msgtext);
+	if (msglen == 0) {
+		/* Stuff like <hr> will be ignored. Don't send an empty message
+		   if that's all there is. */
+		g_free(msgtext);
+		g_free(msgformat);
+
+		return 0;
+	}
+
+	if (msglen + strlen(msgformat) + strlen(VERSION) > 1564)
+	{
+		g_free(msgformat);
+		g_free(msgtext);
+
+		return -E2BIG;
+	}
+
+	msg = msn_message_new_plain(msgtext);
+	msg->remote_user = g_strdup(who);
+	msn_message_set_header(msg, "X-MMS-IM-Format", msgformat);
+
+	g_free(msgformat);
+	g_free(msgtext);
+
+	if (g_ascii_strcasecmp(who, username))
+	{
+		if (flags & PURPLE_MESSAGE_AUTO_RESP) {
+			msn_message_set_flag(msg, 'U');
+		}
+
+		if (msn_user_is_yahoo(account, who) || !(msn_user_is_online(account, who) || swboard != NULL)) {
+			/*we send the online and offline Message to Yahoo User via UBM*/
+			purple_debug_info("msn", "send to offline or Yahoo user\n");
+			msn_notification_send_uum(session, msg);
+		} else {
+			purple_debug_info("msn", "send via switchboard\n");
+			msn_send_im_message(session, msg);
+		}
+	}
+	else
+	{
+		char *body_str, *body_enc, *pre, *post;
+		const char *format;
+		MsnIMData *imdata = g_new0(MsnIMData, 1);
+		/*
+		 * In MSN, you can't send messages to yourself, so
+		 * we'll fake like we received it ;)
+		 */
+		body_str = msn_message_to_string(msg);
+		body_enc = g_markup_escape_text(body_str, -1);
+		g_free(body_str);
+
+		format = msn_message_get_header_value(msg, "X-MMS-IM-Format");
+		msn_parse_format(format, &pre, &post);
+		body_str = g_strdup_printf("%s%s%s", pre ? pre :  "",
+								   body_enc ? body_enc : "", post ? post : "");
+		g_free(body_enc);
+		g_free(pre);
+		g_free(post);
+
+		serv_got_typing_stopped(gc, who);
+		imdata->gc = gc;
+		imdata->who = who;
+		imdata->msg = body_str;
+		imdata->flags = flags & ~PURPLE_MESSAGE_SEND;
+		imdata->when = time(NULL);
+		purple_timeout_add(0, msn_send_me_im, imdata);
+	}
+
+	msn_message_unref(msg);
+
+	return 1;
+}
+
+static unsigned int
+msn_send_typing(PurpleConnection *gc, const char *who, PurpleTypingState state)
+{
+	PurpleAccount *account;
+	MsnSession *session;
+	MsnSwitchBoard *swboard;
+	MsnMessage *msg;
+
+	account = purple_connection_get_account(gc);
+	session = gc->proto_data;
+
+	/*
+	 * TODO: I feel like this should be "if (state != PURPLE_TYPING)"
+	 *       but this is how it was before, and I don't want to break
+	 *       anything. --KingAnt
+	 */
+	if (state == PURPLE_NOT_TYPING)
+		return 0;
+
+	if (!g_ascii_strcasecmp(who, purple_account_get_username(account)))
+	{
+		/* We'll just fake it, since we're sending to ourself. */
+		serv_got_typing(gc, who, MSN_TYPING_RECV_TIMEOUT, PURPLE_TYPING);
+
+		return MSN_TYPING_SEND_TIMEOUT;
+	}
+
+	swboard = msn_session_find_swboard(session, who);
+
+	if (swboard == NULL || !msn_switchboard_can_send(swboard))
+		return 0;
+
+	swboard->flag |= MSN_SB_FLAG_IM;
+
+	msg = msn_message_new(MSN_MSG_TYPING);
+	msn_message_set_content_type(msg, "text/x-msmsgscontrol");
+	msn_message_set_flag(msg, 'U');
+	msn_message_set_header(msg, "TypingUser",
+						 purple_account_get_username(account));
+	msn_message_set_bin_data(msg, "\r\n", 2);
+
+	msn_switchboard_send_msg(swboard, msg, FALSE);
+
+	msn_message_unref(msg);
+
+	return MSN_TYPING_SEND_TIMEOUT;
+}
+
+static void
+msn_set_status(PurpleAccount *account, PurpleStatus *status)
+{
+	PurpleConnection *gc;
+	MsnSession *session;
+
+	gc = purple_account_get_connection(account);
+
+	if (gc != NULL)
+	{
+		session = gc->proto_data;
+		msn_change_status(session);
+	}
+}
+
+static void
+msn_set_idle(PurpleConnection *gc, int idle)
+{
+	MsnSession *session;
+
+	session = gc->proto_data;
+
+	msn_change_status(session);
+}
+
+/*
+ * Actually adds a buddy once we have the response from FQY
+ */
+static void
+add_pending_buddy(MsnSession *session,
+                  const char *who,
+                  MsnNetwork network,
+                  MsnUser *user)
+{
+	char *group;
+	MsnUserList *userlist;
+	MsnUser *user2;
+
+	g_return_if_fail(user != NULL);
+
+	if (network == MSN_NETWORK_UNKNOWN) {
+		purple_debug_error("msn", "Network in FQY response was unknown.  "
+				"Assuming %s is a passport user and adding anyway.\n", who);
+		network = MSN_NETWORK_PASSPORT;
+	}
+
+	group = msn_user_remove_pending_group(user);
+
+	userlist = session->userlist;
+	user2 = msn_userlist_find_user(userlist, who);
+	if (user2 != NULL) {
+		/* User already in userlist, so just update it. */
+		msn_user_unref(user);
+		user = user2;
+	} else {
+		msn_userlist_add_user(userlist, user);
+		msn_user_unref(user);
+	}
+
+	msn_user_set_network(user, network);
+	msn_userlist_add_buddy(userlist, who, group);
+
+	g_free(group);
+}
+
+static void
+msn_add_buddy(PurpleConnection *pc, PurpleBuddy *buddy, PurpleGroup *group, const char *message)
+{
+	PurpleAccount *account;
+	const char *bname, *gname;
+	MsnSession *session;
+	MsnUserList *userlist;
+	MsnUser *user;
+
+	account = purple_connection_get_account(pc);
+	session = purple_connection_get_protocol_data(pc);
+	bname = purple_buddy_get_name(buddy);
+
+	if (!session->logged_in)
+	{
+		purple_debug_error("msn", "msn_add_buddy called before connected\n");
+
+		return;
+	}
+
+	/* XXX - Would group ever be NULL here?  I don't think so...
+	 * shx: Yes it should; MSN handles non-grouped buddies, and this is only
+	 * internal.
+	 * KingAnt: But PurpleBuddys must always exist inside PurpleGroups, so
+	 * won't group always be non-NULL here?
+	 */
+	bname = msn_normalize(account, bname);
+	gname = group ? purple_group_get_name(group) : NULL;
+	purple_debug_info("msn", "Add user:%s to group:%s\n",
+	                  bname, gname ? gname : "(null)");
+
+	if (!msn_email_is_valid(bname)) {
+		gchar *buf;
+		buf = g_strdup_printf(_("Unable to add the buddy %s because the username is invalid.  Usernames must be valid email addresses."), bname);
+		if (!purple_conv_present_error(bname, account, buf))
+			purple_notify_error(pc, NULL, _("Unable to Add"), buf);
+		g_free(buf);
+
+		/* Remove from local list */
+		purple_blist_remove_buddy(buddy);
+
+		return;
+	}
+
+	/* Make sure name is normalized */
+	purple_blist_rename_buddy(buddy, bname);
+
+	userlist = session->userlist;
+	user = msn_userlist_find_user(userlist, bname);
+	if (user && user->authorized) {
+		message = NULL;
+	}
+	if ((user != NULL) && (user->networkid != MSN_NETWORK_UNKNOWN)) {
+		/* We already know this buddy and their network. This function knows
+		   what to do with users already in the list and stuff... */
+		msn_user_set_invite_message(user, message);
+		msn_userlist_add_buddy(userlist, bname, gname);
+	} else {
+		char **tokens;
+		char *fqy;
+		/* We need to check the network for this buddy first */
+		user = msn_user_new(userlist, bname, NULL);
+		msn_user_set_invite_message(user, message);
+		msn_user_set_pending_group(user, gname);
+		msn_user_set_network(user, MSN_NETWORK_UNKNOWN);
+		/* Should probably re-use the msn_add_contact_xml function here */
+		tokens = g_strsplit(bname, "@", 2);
+		fqy = g_strdup_printf("<ml><d n=\"%s\"><c n=\"%s\"/></d></ml>",
+		                      tokens[1],
+		                      tokens[0]);
+		/* TODO: I think user will leak if we disconnect before receiving
+		         a response to this FQY request */
+		msn_notification_send_fqy(session, fqy, strlen(fqy),
+		                          (MsnFqyCb)add_pending_buddy, user);
+		g_free(fqy);
+		g_strfreev(tokens);
+	}
+}
+
+static void
+msn_rem_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group)
+{
+	MsnSession *session;
+	MsnUserList *userlist;
+
+	session = gc->proto_data;
+	userlist = session->userlist;
+
+	if (!session->logged_in)
+		return;
+
+	/* XXX - Does buddy->name need to be msn_normalize'd here?  --KingAnt */
+	msn_userlist_rem_buddy(userlist, purple_buddy_get_name(buddy));
+}
+
+static void
+msn_add_permit(PurpleConnection *gc, const char *who)
+{
+	MsnSession *session;
+	MsnUserList *userlist;
+	MsnUser *user;
+
+	session = gc->proto_data;
+	userlist = session->userlist;
+	user = msn_userlist_find_user(userlist, who);
+
+	if (!session->logged_in)
+		return;
+
+	if (user != NULL && user->list_op & MSN_LIST_BL_OP) {
+		msn_userlist_rem_buddy_from_list(userlist, who, MSN_LIST_BL);
+
+		/* delete contact from Block list and add it to Allow in the callback */
+		msn_del_contact_from_list(session, NULL, who, MSN_LIST_BL);
+	} else {
+		/* just add the contact to Allow list */
+		msn_add_contact_to_list(session, NULL, who, MSN_LIST_AL);
+	}
+
+
+	msn_userlist_add_buddy_to_list(userlist, who, MSN_LIST_AL);
+}
+
+static void
+msn_add_deny(PurpleConnection *gc, const char *who)
+{
+	MsnSession *session;
+	MsnUserList *userlist;
+	MsnUser *user;
+
+	session = gc->proto_data;
+	userlist = session->userlist;
+	user = msn_userlist_find_user(userlist, who);
+
+	if (!session->logged_in)
+		return;
+
+	if (user != NULL && user->list_op & MSN_LIST_AL_OP) {
+		msn_userlist_rem_buddy_from_list(userlist, who, MSN_LIST_AL);
+
+		/* delete contact from Allow list and add it to Block in the callback */
+		msn_del_contact_from_list(session, NULL, who, MSN_LIST_AL);
+	} else {
+		/* just add the contact to Block list */
+		msn_add_contact_to_list(session, NULL, who, MSN_LIST_BL);
+	}
+
+	msn_userlist_add_buddy_to_list(userlist, who, MSN_LIST_BL);
+}
+
+static void
+msn_rem_permit(PurpleConnection *gc, const char *who)
+{
+	MsnSession *session;
+	MsnUserList *userlist;
+	MsnUser *user;
+
+	session = gc->proto_data;
+	userlist = session->userlist;
+
+	if (!session->logged_in)
+		return;
+
+	user = msn_userlist_find_user(userlist, who);
+
+	msn_userlist_rem_buddy_from_list(userlist, who, MSN_LIST_AL);
+
+	msn_del_contact_from_list(session, NULL, who, MSN_LIST_AL);
+
+	if (user != NULL && user->list_op & MSN_LIST_RL_OP)
+		msn_userlist_add_buddy_to_list(userlist, who, MSN_LIST_BL);
+}
+
+static void
+msn_rem_deny(PurpleConnection *gc, const char *who)
+{
+	MsnSession *session;
+	MsnUserList *userlist;
+	MsnUser *user;
+
+	session = gc->proto_data;
+	userlist = session->userlist;
+
+	if (!session->logged_in)
+		return;
+
+	user = msn_userlist_find_user(userlist, who);
+
+	msn_userlist_rem_buddy_from_list(userlist, who, MSN_LIST_BL);
+
+	msn_del_contact_from_list(session, NULL, who, MSN_LIST_BL);
+
+	if (user != NULL && user->list_op & MSN_LIST_RL_OP)
+		msn_userlist_add_buddy_to_list(userlist, who, MSN_LIST_AL);
+}
+
+static void
+msn_set_permit_deny(PurpleConnection *gc)
+{
+	msn_send_privacy(gc);
+}
+
+static void
+msn_chat_invite(PurpleConnection *gc, int id, const char *msg,
+				const char *who)
+{
+	MsnSession *session;
+	MsnSwitchBoard *swboard;
+
+	session = gc->proto_data;
+
+	swboard = msn_session_find_swboard_with_id(session, id);
+
+	if (swboard == NULL)
+	{
+		/* if we have no switchboard, everyone else left the chat already */
+		swboard = msn_switchboard_new(session);
+		msn_switchboard_request(swboard);
+		swboard->chat_id = id;
+		swboard->conv = purple_find_chat(gc, id);
+	}
+
+	swboard->flag |= MSN_SB_FLAG_IM;
+
+	msn_switchboard_request_add_user(swboard, who);
+}
+
+static void
+msn_chat_leave(PurpleConnection *gc, int id)
+{
+	MsnSession *session;
+	MsnSwitchBoard *swboard;
+	PurpleConversation *conv;
+
+	session = gc->proto_data;
+
+	swboard = msn_session_find_swboard_with_id(session, id);
+
+	/* if swboard is NULL we were the only person left anyway */
+	if (swboard == NULL)
+		return;
+
+	conv = swboard->conv;
+
+	msn_switchboard_release(swboard, MSN_SB_FLAG_IM);
+
+	/* If other switchboards managed to associate themselves with this
+	 * conv, make sure they know it's gone! */
+	if (conv != NULL)
+	{
+		while ((swboard = msn_session_find_swboard_with_conv(session, conv)) != NULL)
+			swboard->conv = NULL;
+	}
+}
+
+static int
+msn_chat_send(PurpleConnection *gc, int id, const char *message, PurpleMessageFlags flags)
+{
+	PurpleAccount *account;
+	MsnSession *session;
+	const char *username;
+	MsnSwitchBoard *swboard;
+	MsnMessage *msg;
+	char *msgformat;
+	char *msgtext;
+	size_t msglen;
+	MsnEmoticon *smile;
+	GSList *smileys;
+	GString *emoticons = NULL;
+
+	account = purple_connection_get_account(gc);
+	session = gc->proto_data;
+	username = purple_account_get_username(account);
+	swboard = msn_session_find_swboard_with_id(session, id);
+
+	if (swboard == NULL)
+		return -EINVAL;
+
+	if (!swboard->ready)
+		return 0;
+
+	swboard->flag |= MSN_SB_FLAG_IM;
+
+	msn_import_html(message, &msgformat, &msgtext);
+	msglen = strlen(msgtext);
+
+	if ((msglen == 0) || (msglen + strlen(msgformat) + strlen(VERSION) > 1564))
+	{
+		g_free(msgformat);
+		g_free(msgtext);
+
+		return -E2BIG;
+	}
+
+	msg = msn_message_new_plain(msgtext);
+	msn_message_set_header(msg, "X-MMS-IM-Format", msgformat);
+
+	smileys = msn_msg_grab_emoticons(msg->body, username);
+	while (smileys) {
+		smile = (MsnEmoticon *)smileys->data;
+		emoticons = msn_msg_emoticon_add(emoticons, smile);
+		if (purple_conv_custom_smiley_add(swboard->conv, smile->smile,
+		                                  "sha1", purple_smiley_get_checksum(smile->ps),
+		                                  FALSE)) {
+			gconstpointer data;
+			size_t len;
+			data = purple_smiley_get_data(smile->ps, &len);
+			purple_conv_custom_smiley_write(swboard->conv, smile->smile, data, len);
+			purple_conv_custom_smiley_close(swboard->conv, smile->smile);
+		}
+		msn_emoticon_destroy(smile);
+		smileys = g_slist_delete_link(smileys, smileys);
+	}
+
+	if (emoticons) {
+		msn_send_emoticons(swboard, emoticons);
+		g_string_free(emoticons, TRUE);
+	}
+
+	msn_switchboard_send_msg(swboard, msg, FALSE);
+	msn_message_unref(msg);
+
+	g_free(msgformat);
+	g_free(msgtext);
+
+	serv_got_chat_in(gc, id, purple_account_get_username(account), flags,
+					 message, time(NULL));
+
+	return 0;
+}
+
+static void
+msn_keepalive(PurpleConnection *gc)
+{
+	MsnSession *session;
+	MsnTransaction *trans;
+
+	session = gc->proto_data;
+
+	if (!session->http_method)
+	{
+		MsnCmdProc *cmdproc;
+
+		cmdproc = session->notification->cmdproc;
+
+		trans = msn_transaction_new(cmdproc, "PNG", NULL);
+		msn_transaction_set_saveable(trans, FALSE);
+		msn_cmdproc_send_trans(cmdproc, trans);
+	}
+}
+
+static void msn_alias_buddy(PurpleConnection *pc, const char *name, const char *alias)
+{
+	MsnSession *session;
+
+	session = pc->proto_data;
+
+	msn_update_contact(session, name, MSN_UPDATE_ALIAS, alias);
+}
+
+static void
+msn_group_buddy(PurpleConnection *gc, const char *who,
+				const char *old_group_name, const char *new_group_name)
+{
+	MsnSession *session;
+	MsnUserList *userlist;
+
+	session = gc->proto_data;
+	userlist = session->userlist;
+
+	msn_userlist_move_buddy(userlist, who, old_group_name, new_group_name);
+}
+
+static void
+msn_rename_group(PurpleConnection *gc, const char *old_name,
+				 PurpleGroup *group, GList *moved_buddies)
+{
+	MsnSession *session;
+	const char *gname;
+
+	session = gc->proto_data;
+
+	g_return_if_fail(session != NULL);
+	g_return_if_fail(session->userlist != NULL);
+
+	gname = purple_group_get_name(group);
+	if (msn_userlist_find_group_with_name(session->userlist, old_name) != NULL)
+	{
+		msn_contact_rename_group(session, old_name, gname);
+	}
+	else
+	{
+		/* not found */
+		msn_add_group(session, NULL, gname);
+	}
+}
+
+static void
+msn_convo_closed(PurpleConnection *gc, const char *who)
+{
+	MsnSession *session;
+	MsnSwitchBoard *swboard;
+	PurpleConversation *conv;
+
+	session = gc->proto_data;
+
+	swboard = msn_session_find_swboard(session, who);
+
+	/*
+	 * Don't perform an assertion here. If swboard is NULL, then the
+	 * switchboard was either closed by the other party, or the person
+	 * is talking to himself.
+	 */
+	if (swboard == NULL)
+		return;
+
+	conv = swboard->conv;
+
+	/* If we release the switchboard here, it may still have messages
+	   pending ACK which would result in incorrect unsent message errors.
+	   Just let it timeout... This is *so* going to screw with people who
+	   use dumb clients that report "User has closed the conversation window" */
+	/* msn_switchboard_release(swboard, MSN_SB_FLAG_IM); */
+	swboard->conv = NULL;
+
+	/* If other switchboards managed to associate themselves with this
+	 * conv, make sure they know it's gone! */
+	if (conv != NULL)
+	{
+		while ((swboard = msn_session_find_swboard_with_conv(session, conv)) != NULL)
+			swboard->conv = NULL;
+	}
+}
+
+static void
+msn_set_buddy_icon(PurpleConnection *gc, PurpleStoredImage *img)
+{
+	MsnSession *session;
+	MsnUser *user;
+
+	session = gc->proto_data;
+	user = session->user;
+
+	msn_user_set_buddy_icon(user, img);
+
+	msn_change_status(session);
+}
+
+static void
+msn_remove_group(PurpleConnection *gc, PurpleGroup *group)
+{
+	MsnSession *session;
+	const char *gname;
+
+	session = gc->proto_data;
+	gname = purple_group_get_name(group);
+
+	purple_debug_info("msn", "Remove group %s\n", gname);
+	/*we can't delete the default group*/
+	if(!strcmp(gname, MSN_INDIVIDUALS_GROUP_NAME)||
+		!strcmp(gname, MSN_NON_IM_GROUP_NAME))
+	{
+		purple_debug_info("msn", "This group can't be removed, returning.\n");
+		return ;
+	}
+
+	msn_del_group(session, gname);
+}
+
+/**
+ * Extract info text from info_data and add it to user_info
+ */
+static gboolean
+msn_tooltip_extract_info_text(PurpleNotifyUserInfo *user_info, MsnGetInfoData *info_data)
+{
+	PurpleBuddy *b;
+
+	b = purple_find_buddy(purple_connection_get_account(info_data->gc),
+						info_data->name);
+
+	if (b)
+	{
+		char *tmp;
+		const char *alias;
+
+		alias = purple_buddy_get_local_buddy_alias(b);
+		if (alias && alias[0])
+		{
+			purple_notify_user_info_add_pair_plaintext(user_info, _("Alias"), alias);
+		}
+
+		if ((alias = purple_buddy_get_server_alias(b)) != NULL)
+		{
+			char *nicktext = g_markup_escape_text(alias, -1);
+			tmp = g_strdup_printf("<font sml=\"msn\">%s</font>", nicktext);
+			purple_notify_user_info_add_pair(user_info, _("Nickname"), tmp);
+			g_free(tmp);
+			g_free(nicktext);
+		}
+
+		/* Add the tooltip information */
+		msn_tooltip_text(b, user_info, TRUE);
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+#if PHOTO_SUPPORT
+
+static char *
+msn_get_photo_url(const char *url_text)
+{
+	char *p, *q;
+
+	if ((p = strstr(url_text, PHOTO_URL)) != NULL)
+	{
+		p += strlen(PHOTO_URL);
+	}
+	if (p && (strncmp(p, "http://", strlen("http://")) == 0) && ((q = strchr(p, '"')) != NULL))
+			return g_strndup(p, q - p);
+
+	return NULL;
+}
+
+static void msn_got_photo(PurpleUtilFetchUrlData *url_data, gpointer data,
+		const gchar *url_text, gsize len, const gchar *error_message);
+
+#endif
+
+#if 0
+static char *msn_info_date_reformat(const char *field, size_t len)
+{
+	char *tmp = g_strndup(field, len);
+	time_t t = purple_str_to_time(tmp, FALSE, NULL, NULL, NULL);
+
+	g_free(tmp);
+	return g_strdup(purple_date_format_short(localtime(&t)));
+}
+#endif
+
+#define MSN_GOT_INFO_GET_FIELD(a, b) \
+	found = purple_markup_extract_info_field(stripped, stripped_len, user_info, \
+			"\n" a ":", 0, "\n", 0, "Undisclosed", b, 0, NULL, NULL); \
+	if (found) \
+		sect_info = TRUE;
+
+#define MSN_GOT_INFO_GET_FIELD_NO_SEARCH(a, b) \
+	found = purple_markup_extract_info_field(stripped, stripped_len, user_info, \
+			"\n" a ":", 0, "\n", 0, "Undisclosed", b, 0, NULL, msn_info_strip_search_link); \
+	if (found) \
+		sect_info = TRUE;
+
+static char *
+msn_info_strip_search_link(const char *field, size_t len)
+{
+	const char *c;
+	if ((c = strstr(field, " (http://")) == NULL)
+		return g_strndup(field, len);
+	return g_strndup(field, c - field);
+}
+
+static void
+msn_got_info(PurpleUtilFetchUrlData *url_data, gpointer data,
+		const gchar *url_text, size_t len, const gchar *error_message)
+{
+	MsnGetInfoData *info_data = (MsnGetInfoData *)data;
+	MsnSession *session;
+	PurpleNotifyUserInfo *user_info;
+	char *stripped, *p, *q, *tmp;
+	char *user_url = NULL;
+	gboolean found;
+	gboolean has_tooltip_text = FALSE;
+	gboolean has_info = FALSE;
+	gboolean sect_info = FALSE;
+	gboolean has_contact_info = FALSE;
+	char *url_buffer;
+	int stripped_len;
+#if PHOTO_SUPPORT
+	char *photo_url_text = NULL;
+	MsnGetInfoStepTwoData *info2_data = NULL;
+#endif
+
+	purple_debug_info("msn", "In msn_got_info,url_text:{%s}\n",url_text);
+
+	session = purple_connection_get_protocol_data(info_data->gc);
+	session->url_datas = g_slist_remove(session->url_datas, url_data);
+
+	user_info = purple_notify_user_info_new();
+	has_tooltip_text = msn_tooltip_extract_info_text(user_info, info_data);
+
+	if (error_message != NULL || url_text == NULL || strcmp(url_text, "") == 0)
+	{
+		purple_notify_user_info_add_pair(user_info,
+				_("Error retrieving profile"), NULL);
+
+		purple_notify_userinfo(info_data->gc, info_data->name, user_info, NULL, NULL);
+		purple_notify_user_info_destroy(user_info);
+
+		g_free(info_data->name);
+		g_free(info_data);
+		return;
+	}
+
+	url_buffer = g_strdup(url_text);
+
+	/* If they have a homepage link, MSN masks it such that we need to
+	 * fetch the url out before purple_markup_strip_html() nukes it */
+	/* I don't think this works with the new spaces profiles - Stu 3/2/06 */
+	if ((p = strstr(url_text,
+			"Take a look at my </font><A class=viewDesc title=\"")) != NULL)
+	{
+		p += 50;
+
+		if ((q = strchr(p, '"')) != NULL)
+			user_url = g_strndup(p, q - p);
+	}
+
+	/*
+	 * purple_markup_strip_html() doesn't strip out character entities like &nbsp;
+	 * and &#183;
+	 */
+	while ((p = strstr(url_buffer, "&nbsp;")) != NULL)
+	{
+		*p = ' '; /* Turn &nbsp;'s into ordinary blanks */
+		p += 1;
+		memmove(p, p + 5, strlen(p + 5));
+		url_buffer[strlen(url_buffer) - 5] = '\0';
+	}
+
+	while ((p = strstr(url_buffer, "&#183;")) != NULL)
+	{
+		memmove(p, p + 6, strlen(p + 6));
+		url_buffer[strlen(url_buffer) - 6] = '\0';
+	}
+
+	/* Nuke the nasty \r's that just get in the way */
+	purple_str_strip_char(url_buffer, '\r');
+
+	/* MSN always puts in &#39; for apostrophes...replace them */
+	while ((p = strstr(url_buffer, "&#39;")) != NULL)
+	{
+		*p = '\'';
+		memmove(p + 1, p + 5, strlen(p + 5));
+		url_buffer[strlen(url_buffer) - 4] = '\0';
+	}
+
+	/* Nuke the html, it's easier than trying to parse the horrid stuff */
+	stripped = purple_markup_strip_html(url_buffer);
+	stripped_len = strlen(stripped);
+
+	purple_debug_misc("msn", "stripped = %p\n", stripped);
+	purple_debug_misc("msn", "url_buffer = %p\n", url_buffer);
+
+	/* General section header */
+	if (has_tooltip_text)
+		purple_notify_user_info_add_section_break(user_info);
+
+	purple_notify_user_info_add_section_header(user_info, _("General"));
+
+	/* Extract their Name and put it in */
+	MSN_GOT_INFO_GET_FIELD("Name", _("Name"));
+
+	/* General */
+	MSN_GOT_INFO_GET_FIELD("Nickname", _("Nickname"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Age", _("Age"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Gender", _("Gender"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Occupation", _("Occupation"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Location", _("Location"));
+
+	/* Extract their Interests and put it in */
+	found = purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			"\nInterests\t", 0, " (/default.aspx?page=searchresults", 0,
+			"Undisclosed", _("Hobbies and Interests") /* _("Interests") */,
+			0, NULL, NULL);
+
+	if (found)
+		sect_info = TRUE;
+
+	MSN_GOT_INFO_GET_FIELD("More about me", _("A Little About Me"));
+
+	if (sect_info)
+	{
+		has_info = TRUE;
+		sect_info = FALSE;
+	}
+    else
+    {
+		/* Remove the section header */
+		purple_notify_user_info_remove_last_item(user_info);
+		if (has_tooltip_text)
+			purple_notify_user_info_remove_last_item(user_info);
+	}
+
+	/* Social */
+	purple_notify_user_info_add_section_break(user_info);
+	purple_notify_user_info_add_section_header(user_info, _("Social"));
+
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Marital status", _("Marital Status"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Interested in", _("Interests"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Pets", _("Pets"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Hometown", _("Hometown"));
+	MSN_GOT_INFO_GET_FIELD("Places lived", _("Places Lived"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Fashion", _("Fashion"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Humor", _("Humor"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Music", _("Music"));
+	MSN_GOT_INFO_GET_FIELD_NO_SEARCH("Favorite quote", _("Favorite Quote"));
+
+	if (sect_info)
+	{
+		has_info = TRUE;
+		sect_info = FALSE;
+	}
+    else
+    {
+		/* Remove the section header */
+		purple_notify_user_info_remove_last_item(user_info);
+		purple_notify_user_info_remove_last_item(user_info);
+	}
+
+	/* Contact Info */
+	/* Personal */
+	purple_notify_user_info_add_section_break(user_info);
+	purple_notify_user_info_add_section_header(user_info, _("Contact Info"));
+	purple_notify_user_info_add_section_header(user_info, _("Personal"));
+
+	MSN_GOT_INFO_GET_FIELD("Name", _("Name"));
+	MSN_GOT_INFO_GET_FIELD("Significant other", _("Significant Other"));
+	MSN_GOT_INFO_GET_FIELD("Home phone", _("Home Phone"));
+	MSN_GOT_INFO_GET_FIELD("Home phone 2", _("Home Phone 2"));
+	MSN_GOT_INFO_GET_FIELD("Home address", _("Home Address"));
+	MSN_GOT_INFO_GET_FIELD("Personal Mobile", _("Personal Mobile"));
+	MSN_GOT_INFO_GET_FIELD("Home fax", _("Home Fax"));
+	MSN_GOT_INFO_GET_FIELD("Personal email", _("Personal Email"));
+	MSN_GOT_INFO_GET_FIELD("Personal IM", _("Personal IM"));
+	MSN_GOT_INFO_GET_FIELD("Birthday", _("Birthday"));
+	MSN_GOT_INFO_GET_FIELD("Anniversary", _("Anniversary"));
+	MSN_GOT_INFO_GET_FIELD("Notes", _("Notes"));
+
+	if (sect_info)
+	{
+		has_info = TRUE;
+		sect_info = FALSE;
+		has_contact_info = TRUE;
+	}
+    else
+    {
+		/* Remove the section header */
+		purple_notify_user_info_remove_last_item(user_info);
+	}
+
+	/* Business */
+	purple_notify_user_info_add_section_header(user_info, _("Work"));
+	MSN_GOT_INFO_GET_FIELD("Name", _("Name"));
+	MSN_GOT_INFO_GET_FIELD("Job title", _("Job Title"));
+	MSN_GOT_INFO_GET_FIELD("Company", _("Company"));
+	MSN_GOT_INFO_GET_FIELD("Department", _("Department"));
+	MSN_GOT_INFO_GET_FIELD("Profession", _("Profession"));
+	MSN_GOT_INFO_GET_FIELD("Work phone 1", _("Work Phone"));
+	MSN_GOT_INFO_GET_FIELD("Work phone 2", _("Work Phone 2"));
+	MSN_GOT_INFO_GET_FIELD("Work address", _("Work Address"));
+	MSN_GOT_INFO_GET_FIELD("Work mobile", _("Work Mobile"));
+	MSN_GOT_INFO_GET_FIELD("Work pager", _("Work Pager"));
+	MSN_GOT_INFO_GET_FIELD("Work fax", _("Work Fax"));
+	MSN_GOT_INFO_GET_FIELD("Work email", _("Work Email"));
+	MSN_GOT_INFO_GET_FIELD("Work IM", _("Work IM"));
+	MSN_GOT_INFO_GET_FIELD("Start date", _("Start Date"));
+	MSN_GOT_INFO_GET_FIELD("Notes", _("Notes"));
+
+	if (sect_info)
+	{
+		has_info = TRUE;
+		sect_info = FALSE;
+		has_contact_info = TRUE;
+	}
+    else
+    {
+		/* Remove the section header */
+		purple_notify_user_info_remove_last_item(user_info);
+	}
+
+	if (!has_contact_info)
+	{
+		/* Remove the Contact Info section header */
+		purple_notify_user_info_remove_last_item(user_info);
+	}
+
+#if 0 /* these probably don't show up any more */
+	/*
+	 * The fields, 'A Little About Me', 'Favorite Things', 'Hobbies
+	 * and Interests', 'Favorite Quote', and 'My Homepage' may or may
+	 * not appear, in any combination. However, they do appear in
+	 * certain order, so we can successively search to pin down the
+	 * distinct values.
+	 */
+
+	/* Check if they have A Little About Me */
+	found = purple_markup_extract_info_field(stripped, stripped_len, s,
+			" A Little About Me \n\n", 0, "Favorite Things", '\n', NULL,
+			_("A Little About Me"), 0, NULL, NULL);
+
+	if (!found)
+	{
+		found = purple_markup_extract_info_field(stripped, stripped_len, s,
+				" A Little About Me \n\n", 0, "Hobbies and Interests", '\n',
+				NULL, _("A Little About Me"), 0, NULL, NULL);
+	}
+
+	if (!found)
+	{
+		found = purple_markup_extract_info_field(stripped, stripped_len, s,
+				" A Little About Me \n\n", 0, "Favorite Quote", '\n', NULL,
+				_("A Little About Me"), 0, NULL, NULL);
+	}
+
+	if (!found)
+	{
+		found = purple_markup_extract_info_field(stripped, stripped_len, s,
+				" A Little About Me \n\n", 0, "My Homepage \n\nTake a look",
+				'\n',
+				NULL, _("A Little About Me"), 0, NULL, NULL);
+	}
+
+	if (!found)
+	{
+		purple_markup_extract_info_field(stripped, stripped_len, s,
+				" A Little About Me \n\n", 0, "last updated", '\n', NULL,
+				_("A Little About Me"), 0, NULL, NULL);
+	}
+
+	if (found)
+		has_info = TRUE;
+
+	/* Check if they have Favorite Things */
+	found = purple_markup_extract_info_field(stripped, stripped_len, s,
+			" Favorite Things \n\n", 0, "Hobbies and Interests", '\n', NULL,
+			_("Favorite Things"), 0, NULL, NULL);
+
+	if (!found)
+	{
+		found = purple_markup_extract_info_field(stripped, stripped_len, s,
+				" Favorite Things \n\n", 0, "Favorite Quote", '\n', NULL,
+				_("Favorite Things"), 0, NULL, NULL);
+	}
+
+	if (!found)
+	{
+		found = purple_markup_extract_info_field(stripped, stripped_len, s,
+				" Favorite Things \n\n", 0, "My Homepage \n\nTake a look", '\n',
+				NULL, _("Favorite Things"), 0, NULL, NULL);
+	}
+
+	if (!found)
+	{
+		purple_markup_extract_info_field(stripped, stripped_len, s,
+				" Favorite Things \n\n", 0, "last updated", '\n', NULL,
+				_("Favorite Things"), 0, NULL, NULL);
+	}
+
+	if (found)
+		has_info = TRUE;
+
+	/* Check if they have Hobbies and Interests */
+	found = purple_markup_extract_info_field(stripped, stripped_len, s,
+			" Hobbies and Interests \n\n", 0, "Favorite Quote", '\n', NULL,
+			_("Hobbies and Interests"), 0, NULL, NULL);
+
+	if (!found)
+	{
+		found = purple_markup_extract_info_field(stripped, stripped_len, s,
+				" Hobbies and Interests \n\n", 0, "My Homepage \n\nTake a look",
+				'\n', NULL, _("Hobbies and Interests"), 0, NULL, NULL);
+	}
+
+	if (!found)
+	{
+		purple_markup_extract_info_field(stripped, stripped_len, s,
+				" Hobbies and Interests \n\n", 0, "last updated", '\n', NULL,
+				_("Hobbies and Interests"), 0, NULL, NULL);
+	}
+
+	if (found)
+		has_info = TRUE;
+
+	/* Check if they have Favorite Quote */
+	found = purple_markup_extract_info_field(stripped, stripped_len, s,
+			"Favorite Quote \n\n", 0, "My Homepage \n\nTake a look", '\n', NULL,
+			_("Favorite Quote"), 0, NULL, NULL);
+
+	if (!found)
+	{
+		purple_markup_extract_info_field(stripped, stripped_len, s,
+				"Favorite Quote \n\n", 0, "last updated", '\n', NULL,
+				_("Favorite Quote"), 0, NULL, NULL);
+	}
+
+	if (found)
+		has_info = TRUE;
+
+	/* Extract the last updated date and put it in */
+	found = purple_markup_extract_info_field(stripped, stripped_len, s,
+			" last updated:", 1, "\n", 0, NULL, _("Last Updated"), 0,
+			NULL, msn_info_date_reformat);
+
+	if (found)
+		has_info = TRUE;
+#endif
+
+	/* If we were able to fetch a homepage url earlier, stick it in there */
+	if (user_url != NULL)
+	{
+		tmp = g_strdup_printf("<a href=\"%s\">%s</a>", user_url, user_url);
+		purple_notify_user_info_add_pair(user_info, _("Homepage"), tmp);
+		g_free(tmp);
+		g_free(user_url);
+
+		has_info = TRUE;
+	}
+
+	if (!has_info)
+	{
+		/* MSN doesn't actually distinguish between "unknown member" and
+		 * a known member with an empty profile. Try to explain this fact.
+		 * Note that if we have a nonempty tooltip_text, we know the user
+		 * exists.
+		 */
+		/* This doesn't work with the new spaces profiles - Stu 3/2/06
+		char *p = strstr(url_buffer, "Unknown Member </TITLE>");
+		 * This might not work for long either ... */
+		/* Nope, it failed some time before 5/2/07 :(
+		char *p = strstr(url_buffer, "form id=\"SpacesSearch\" name=\"SpacesSearch\"");
+		 * Let's see how long this one holds out for ... */
+		char *p = strstr(url_buffer, "<form id=\"profile_form\" name=\"profile_form\" action=\"http&#58;&#47;&#47;spaces.live.com&#47;profile.aspx&#63;cid&#61;0\"");
+		PurpleBuddy *b = purple_find_buddy
+				(purple_connection_get_account(info_data->gc), info_data->name);
+		purple_notify_user_info_add_pair(user_info,
+				_("Error retrieving profile"), NULL);
+		purple_notify_user_info_add_pair(user_info, NULL,
+				((p && b) ? _("The user has not created a public profile.") :
+					(p ? _("MSN reported not being able to find the user's profile. "
+							"This either means that the user does not exist, "
+							"or that the user exists "
+							"but has not created a public profile.") :
+						_("Could not find "	/* This should never happen */
+							"any information in the user's profile. "
+							"The user most likely does not exist."))));
+	}
+
+	/* put a link to the actual profile URL */
+	purple_notify_user_info_add_section_break(user_info);
+	tmp = g_strdup_printf("<a href=\"%s%s\">%s</a>",
+			PROFILE_URL, info_data->name, _("View web profile"));
+	purple_notify_user_info_add_pair(user_info, NULL, tmp);
+	g_free(tmp);
+
+#if PHOTO_SUPPORT
+	/* Find the URL to the photo; must be before the marshalling [Bug 994207] */
+	photo_url_text = msn_get_photo_url(url_text);
+	purple_debug_info("msn", "photo url:{%s}\n", photo_url_text ? photo_url_text : "(null)");
+
+	/* Marshall the existing state */
+	info2_data = g_new0(MsnGetInfoStepTwoData, 1);
+	info2_data->info_data = info_data;
+	info2_data->stripped = stripped;
+	info2_data->url_buffer = url_buffer;
+	info2_data->user_info = user_info;
+	info2_data->photo_url_text = photo_url_text;
+
+	/* Try to put the photo in there too, if there's one */
+	if (photo_url_text)
+	{
+		url_data = purple_util_fetch_url_len(photo_url_text, FALSE, NULL, FALSE,
+		                                     MAX_HTTP_BUDDYICON_BYTES,
+		                                     msn_got_photo, info2_data);
+		session->url_datas = g_slist_prepend(session->url_datas, url_data);
+	}
+	else
+	{
+		/* Finish the Get Info and show the user something */
+		msn_got_photo(NULL, info2_data, NULL, 0, NULL);
+	}
+}
+
+static void
+msn_got_photo(PurpleUtilFetchUrlData *url_data, gpointer user_data,
+		const gchar *url_text, gsize len, const gchar *error_message)
+{
+	MsnGetInfoStepTwoData *info2_data = (MsnGetInfoStepTwoData *)user_data;
+	int id = -1;
+
+	/* Unmarshall the saved state */
+	MsnGetInfoData *info_data = info2_data->info_data;
+	char *stripped = info2_data->stripped;
+	char *url_buffer = info2_data->url_buffer;
+	PurpleNotifyUserInfo *user_info = info2_data->user_info;
+	char *photo_url_text = info2_data->photo_url_text;
+
+	if (url_data) {
+		MsnSession *session = purple_connection_get_protocol_data(info_data->gc);
+		session->url_datas = g_slist_remove(session->url_datas, url_data);
+	}
+
+	if (url_text && error_message)
+	{
+		purple_debug_warning("msn", "invalid connection. ignoring buddy photo info.\n");
+		g_free(stripped);
+		g_free(url_buffer);
+		purple_notify_user_info_destroy(user_info);
+		g_free(info_data->name);
+		g_free(info_data);
+		g_free(photo_url_text);
+		g_free(info2_data);
+
+		return;
+	}
+
+	/* Try to put the photo in there too, if there's one and is readable */
+	if (url_text && len != 0)
+	{
+		if (strstr(url_text, "400 Bad Request")
+			|| strstr(url_text, "403 Forbidden")
+			|| strstr(url_text, "404 Not Found"))
+		{
+
+			purple_debug_info("msn", "Error getting %s: %s\n",
+					photo_url_text, url_text);
+		}
+		else
+		{
+			char buf[1024];
+			purple_debug_info("msn", "%s is %" G_GSIZE_FORMAT " bytes\n", photo_url_text, len);
+			id = purple_imgstore_add_with_id(g_memdup(url_text, len), len, NULL);
+			g_snprintf(buf, sizeof(buf), "<img id=\"%d\"><br>", id);
+			purple_notify_user_info_prepend_pair(user_info, NULL, buf);
+		}
+	}
+
+	/* We continue here from msn_got_info, as if nothing has happened */
+#endif
+	purple_notify_userinfo(info_data->gc, info_data->name, user_info, NULL, NULL);
+
+	g_free(stripped);
+	g_free(url_buffer);
+	purple_notify_user_info_destroy(user_info);
+	g_free(info_data->name);
+	g_free(info_data);
+#if PHOTO_SUPPORT
+	g_free(photo_url_text);
+	g_free(info2_data);
+	if (id != -1)
+		purple_imgstore_unref_by_id(id);
+#endif
+}
+
+static void
+msn_get_info(PurpleConnection *gc, const char *name)
+{
+	MsnSession *session = purple_connection_get_protocol_data(gc);
+	MsnGetInfoData *data;
+	char *url;
+	PurpleUtilFetchUrlData *url_data;
+
+	data       = g_new0(MsnGetInfoData, 1);
+	data->gc   = gc;
+	data->name = g_strdup(name);
+
+	url = g_strdup_printf("%s%s", PROFILE_URL, name);
+
+	url_data = purple_util_fetch_url(url, FALSE,
+	                                 "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)",
+	                                 TRUE, msn_got_info, data);
+	session->url_datas = g_slist_prepend(session->url_datas, url_data);
+
+	g_free(url);
+}
+
+static gboolean msn_load(PurplePlugin *plugin)
+{
+	msn_notification_init();
+	msn_switchboard_init();
+
+	return TRUE;
+}
+
+static gboolean msn_unload(PurplePlugin *plugin)
+{
+	msn_notification_end();
+	msn_switchboard_end();
+
+	return TRUE;
+}
+
+static PurpleAccount *find_acct(const char *prpl, const char *acct_id)
+{
+	PurpleAccount *acct = NULL;
+
+	/* If we have a specific acct, use it */
+	if (acct_id) {
+		acct = purple_accounts_find(acct_id, prpl);
+		if (acct && !purple_account_is_connected(acct))
+			acct = NULL;
+	} else { /* Otherwise find an active account for the protocol */
+		GList *l = purple_accounts_get_all();
+		while (l) {
+			if (!strcmp(prpl, purple_account_get_protocol_id(l->data))
+					&& purple_account_is_connected(l->data)) {
+				acct = l->data;
+				break;
+			}
+			l = l->next;
+		}
+	}
+
+	return acct;
+}
+
+static gboolean msn_uri_handler(const char *proto, const char *cmd, GHashTable *params)
+{
+	char *acct_id = g_hash_table_lookup(params, "account");
+	PurpleAccount *acct;
+
+	if (g_ascii_strcasecmp(proto, "msnim"))
+		return FALSE;
+
+	acct = find_acct("prpl-msn", acct_id);
+
+	if (!acct)
+		return FALSE;
+
+	/* msnim:chat?contact=user@domain.tld */
+	if (!g_ascii_strcasecmp(cmd, "Chat")) {
+		char *sname = g_hash_table_lookup(params, "contact");
+		if (sname) {
+			PurpleConversation *conv = purple_find_conversation_with_account(
+				PURPLE_CONV_TYPE_IM, sname, acct);
+			if (conv == NULL)
+				conv = purple_conversation_new(PURPLE_CONV_TYPE_IM, acct, sname);
+			purple_conversation_present(conv);
+		}
+		/*else
+			**If pidgindialogs_im() was in the core, we could use it here.
+			 * It is all purple_request_* based, but I'm not sure it really belongs in the core
+			pidgindialogs_im();*/
+
+		return TRUE;
+	}
+	/* msnim:add?contact=user@domain.tld */
+	else if (!g_ascii_strcasecmp(cmd, "Add")) {
+		char *name = g_hash_table_lookup(params, "contact");
+		purple_blist_request_add_buddy(acct, name, NULL, NULL);
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+
+static PurplePluginProtocolInfo prpl_info =
+{
+	OPT_PROTO_MAIL_CHECK|OPT_PROTO_INVITE_MESSAGE,
+	NULL,                               /* user_splits */
+	NULL,                               /* protocol_options */
+	{"png,gif", 0, 0, 96, 96, 0, PURPLE_ICON_SCALE_SEND},   /* icon_spec */
+	msn_list_icon,                      /* list_icon */
+	msn_list_emblems,                   /* list_emblems */
+	msn_status_text,                    /* status_text */
+	msn_tooltip_text,                   /* tooltip_text */
+	msn_status_types,                   /* away_states */
+	msn_blist_node_menu,                /* blist_node_menu */
+	NULL,                               /* chat_info */
+	NULL,                               /* chat_info_defaults */
+	msn_login,                          /* login */
+	msn_close,                          /* close */
+	msn_send_im,                        /* send_im */
+	NULL,                               /* set_info */
+	msn_send_typing,                    /* send_typing */
+	msn_get_info,                       /* get_info */
+	msn_set_status,                     /* set_away */
+	msn_set_idle,                       /* set_idle */
+	NULL,                               /* change_passwd */
+	NULL,                               /* add_buddy */
+	NULL,                               /* add_buddies */
+	msn_rem_buddy,                      /* remove_buddy */
+	NULL,                               /* remove_buddies */
+	msn_add_permit,                     /* add_permit */
+	msn_add_deny,                       /* add_deny */
+	msn_rem_permit,                     /* rem_permit */
+	msn_rem_deny,                       /* rem_deny */
+	msn_set_permit_deny,                /* set_permit_deny */
+	NULL,                               /* join_chat */
+	NULL,                               /* reject chat invite */
+	NULL,                               /* get_chat_name */
+	msn_chat_invite,                    /* chat_invite */
+	msn_chat_leave,                     /* chat_leave */
+	NULL,                               /* chat_whisper */
+	msn_chat_send,                      /* chat_send */
+	msn_keepalive,                      /* keepalive */
+	NULL,                               /* register_user */
+	NULL,                               /* get_cb_info */
+	NULL,                               /* get_cb_away */
+	msn_alias_buddy,                    /* alias_buddy */
+	msn_group_buddy,                    /* group_buddy */
+	msn_rename_group,                   /* rename_group */
+	NULL,                               /* buddy_free */
+	msn_convo_closed,                   /* convo_closed */
+	msn_normalize,                      /* normalize */
+	msn_set_buddy_icon,                 /* set_buddy_icon */
+	msn_remove_group,                   /* remove_group */
+	NULL,                               /* get_cb_real_name */
+	NULL,                               /* set_chat_topic */
+	NULL,                               /* find_blist_chat */
+	NULL,                               /* roomlist_get_list */
+	NULL,                               /* roomlist_cancel */
+	NULL,                               /* roomlist_expand_category */
+	msn_can_receive_file,               /* can_receive_file */
+	msn_send_file,                      /* send_file */
+	msn_new_xfer,                       /* new_xfer */
+	msn_offline_message,                /* offline_message */
+	NULL,                               /* whiteboard_prpl_ops */
+	NULL,                               /* send_raw */
+	NULL,                               /* roomlist_room_serialize */
+	NULL,                               /* unregister_user */
+	msn_send_attention,                 /* send_attention */
+	msn_attention_types,                /* attention_types */
+	sizeof(PurplePluginProtocolInfo),	/* struct_size */
+	msn_get_account_text_table,         /* get_account_text_table */
+	NULL,                               /* initiate_media */
+	NULL,                               /* get_media_caps */
+	NULL,                               /* get_moods */
+	msn_set_public_alias,               /* set_public_alias */
+	msn_get_public_alias,               /* get_public_alias */
+	msn_add_buddy,                      /* add_buddy_with_invite */
+	NULL                                /* add_buddies_with_invite */
+};
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	PURPLE_MAJOR_VERSION,
+	PURPLE_MINOR_VERSION,
+	PURPLE_PLUGIN_PROTOCOL,                           /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                          /**< priority       */
+
+	"prpl-msn",                                       /**< id             */
+	"MSN",                                            /**< name           */
+	DISPLAY_VERSION,                                  /**< version        */
+	N_("Windows Live Messenger Protocol Plugin"),     /**< summary        */
+	N_("Windows Live Messenger Protocol Plugin"),     /**< description    */
+	NULL,                                             /**< author         */
+	PURPLE_WEBSITE,                                   /**< homepage       */
+
+	msn_load,                                         /**< load           */
+	msn_unload,                                       /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	&prpl_info,                                       /**< extra_info     */
+	NULL,                                             /**< prefs_info     */
+	msn_actions,
+
+	/* padding */
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(PurplePlugin *plugin)
+{
+	PurpleAccountOption *option;
+
+	option = purple_account_option_string_new(_("Server"), "server",
+											MSN_SERVER);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options,
+											   option);
+
+	option = purple_account_option_int_new(_("Port"), "port", MSN_PORT);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options,
+											   option);
+
+	option = purple_account_option_bool_new(_("Use HTTP Method"),
+										  "http_method", FALSE);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options,
+											   option);
+
+	option = purple_account_option_string_new(_("HTTP Method Server"),
+										  "http_method_server", MSN_HTTPCONN_SERVER);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options,
+											   option);
+
+	option = purple_account_option_bool_new(_("Show custom smileys"),
+										  "custom_smileys", TRUE);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options,
+											   option);
+
+	option = purple_account_option_bool_new(_("Allow direct connections"),
+										  "direct_connect", TRUE);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options,
+											   option);
+
+	option = purple_account_option_bool_new(_("Allow connecting from multiple locations"),
+										  "mpop", TRUE);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options,
+											   option);
+
+	purple_cmd_register("nudge", "", PURPLE_CMD_P_PRPL,
+	                  PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_PRPL_ONLY,
+	                 "prpl-msn", msn_cmd_nudge,
+	                  _("nudge: nudge a user to get their attention"), NULL);
+
+	purple_prefs_remove("/plugins/prpl/msn");
+
+	purple_signal_connect(purple_get_core(), "uri-handler", plugin,
+		PURPLE_CALLBACK(msn_uri_handler), NULL);
+}
+
+PURPLE_INIT_PLUGIN(msn, init_plugin, info);
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/oscar/encoding.c pidgin-2.10.11/libpurple/protocols/oscar/encoding.c
--- pidgin-2.10.11.orig/libpurple/protocols/oscar/encoding.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/oscar/encoding.c	2015-02-10 14:28:16.390685387 +0900
@@ -107,13 +107,32 @@
 	gchar *extracted_encoding = encoding_extract(encoding);
 
 	if (extracted_encoding == NULL || *extracted_encoding == '\0') {
-		purple_debug_info("oscar", "Empty encoding, assuming UTF-8\n");
+		purple_debug_info("yaz oscar", "Empty encoding, validate as UTF-8\n");
+		if(g_utf8_validate(text, textlen, NULL)){
+			gsize newlen;
+			utf8 = sanitize_utf(text, textlen, &newlen);
+			goto done;
+		}
+		// not UTF-8
+		purple_debug_info("yaz oscar", "Empty encoding, assuming UTF-16BE\n");
+		sanitize_ucs((gchar *)text, textlen);
+		utf8 = g_convert(text, textlen, "UTF-8", "UTF-16BE", NULL, NULL, NULL);
+		if(utf8){
+			if(!g_utf8_validate(utf8, strlen(utf8), NULL)){
+				purple_debug_info("yaz oscar", "Invalid conversion\n");
+				g_free(utf8);
+				utf8 = NULL;
+			}
+		} else {
+			purple_debug_info("yaz oscar", "Conversion failed\n");
+		}
 	} else if (!g_ascii_strcasecmp(extracted_encoding, "iso-8859-1")) {
 		glib_encoding = "iso-8859-1";
 	} else if (!g_ascii_strcasecmp(extracted_encoding, "ISO-8859-1-Windows-3.1-Latin-1") || !g_ascii_strcasecmp(extracted_encoding, "us-ascii")) {
 		glib_encoding = "Windows-1252";
 	} else if (!g_ascii_strcasecmp(extracted_encoding, "unicode-2-0")) {
 		glib_encoding = "UTF-16BE";
+		sanitize_ucs((gchar *)text, textlen);
 	} else if (g_ascii_strcasecmp(extracted_encoding, "utf-8")) {
 		glib_encoding = extracted_encoding;
 	}
@@ -135,6 +154,7 @@
 			utf8 = g_strndup(text, textlen);
 	}
 
+done:
 	g_free(extracted_encoding);
 	return utf8;
 }
@@ -143,13 +163,13 @@
 oscar_utf8_try_convert(PurpleAccount *account, OscarData *od, const gchar *msg)
 {
 	const char *charset = NULL;
-	char *ret = NULL;
+	char *ret = NULL, *ret2 = NULL;
 
 	if (msg == NULL)
 		return NULL;
 
 	if (g_utf8_validate(msg, -1, NULL))
-		return g_strdup(msg);
+		return sanitize_utf(msg, -1, NULL);
 
 	if (od->icq)
 		charset = purple_account_get_string(account, "encoding", NULL);
@@ -160,13 +180,15 @@
 	if(!ret)
 		ret = purple_utf8_try_convert(msg);
 
-	return ret;
+	ret2 = sanitize_utf(ret, -1, NULL);
+	g_free(ret);
+	return ret2;
 }
 
 static gchar *
 oscar_convert_to_utf8(const gchar *data, gsize datalen, const char *charsetstr, gboolean fallback)
 {
-	gchar *ret = NULL;
+	gchar *ret = NULL, *ret2 = NULL;
 	GError *err = NULL;
 
 	if ((charsetstr == NULL) || (*charsetstr == '\0'))
@@ -186,7 +208,9 @@
 			purple_debug_warning("oscar", "String is not valid UTF-8.\n");
 	}
 
-	return ret;
+	ret2 = sanitize_utf(ret, -1, NULL);
+	g_free(ret);
+	return ret2;
 }
 
 gchar *
@@ -211,13 +235,14 @@
 	} else if (charset == AIM_CHARSET_ASCII) {
 		/* Should just be "ASCII" */
 		charsetstr1 = "ASCII";
-		charsetstr2 = purple_account_get_string(account, "encoding", OSCAR_DEFAULT_CUSTOM_ENCODING);
-	} else if (charset == 0x000d) {
+		charsetstr2 = "UTF-8";
+        charsetstr3 = purple_account_get_string(account, "encoding", OSCAR_DEFAULT_CUSTOM_ENCODING);
+	} else if (charset == AIM_CHARSET_QUIRKUTF8) {
 		/* iChat sending unicode over a Direct IM connection = UTF-8 */
-		/* Mobile AIM client on multiple devices (including Blackberry Tour, Nokia 3100, and LG VX6000) = ISO-8859-1 */
-		charsetstr1 = "UTF-8";
-		charsetstr2 = "ISO-8859-1";
-		charsetstr3 = purple_account_get_string(account, "encoding", OSCAR_DEFAULT_CUSTOM_ENCODING);
+        /* Mobile AIM client on a Nokia 3100 and an LG VX6000 */
+        charsetstr1 = "UTF-8";
+        charsetstr2 = "ISO-8859-1";
+        charsetstr3 = purple_account_get_string(account, "encoding", OSCAR_DEFAULT_CUSTOM_ENCODING);
 	} else {
 		/* Unknown, hope for valid UTF-8... */
 		charsetstr1 = "UTF-8";
@@ -281,5 +306,13 @@
 	if (charsetstr != NULL) {
 		*charsetstr = msg_charset == AIM_CHARSET_ASCII ? "us-ascii" : "unicode-2-0";
 	}
-	return g_convert(msg, -1, msg_charset == AIM_CHARSET_ASCII ? "ASCII" : "UTF-16BE", "UTF-8", NULL, result_len, NULL);
+	if (msg_charset == AIM_CHARSET_ASCII) {
+		return g_convert(msg, -1, "ASCII", "UTF-8", NULL, result_len, NULL);
+	}
+	else {
+		char *ucs = NULL;
+		ucs = g_convert(msg, -1, "UTF-16BE", "UTF-8", NULL, result_len, NULL);
+		botch_ucs(ucs, *result_len);
+		return ucs;
+	}
 }
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/oscar/family_icbm.c pidgin-2.10.11/libpurple/protocols/oscar/family_icbm.c
--- pidgin-2.10.11.orig/libpurple/protocols/oscar/family_icbm.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/oscar/family_icbm.c	2015-02-10 14:28:16.390685387 +0900
@@ -53,6 +53,7 @@
 #endif
 
 #include "util.h"
+#include "debug.h" /* yaz */
 
 static const char * const errcodereason[] = {
 	N_("Invalid error"),
@@ -413,6 +414,9 @@
 	guchar cookie[8];
 	GSList *outer_tlvlist = NULL, *inner_tlvlist = NULL;
 	ByteStream hdrbs;
+	// yaz
+	char *ucs = NULL;
+	gsize bytes;
 
 	if (!od || !(conn = flap_connection_findbygroup(od, SNAC_FAMILY_ICBM)))
 		return -EINVAL;
@@ -451,15 +455,51 @@
 	 * raw data, followed by a series of TLVs.
 	 *
 	 */
+#if 0
 	byte_stream_new(&hdrbs, 2+8+16+6+4+4+strlen(msg)+4+2+1+strlen(roomname)+2);
 
 	byte_stream_put16(&hdrbs, 0x0000); /* Unknown! */
 	byte_stream_putraw(&hdrbs, cookie, sizeof(cookie)); /* I think... */
 	byte_stream_putcaps(&hdrbs, OSCAR_CAPABILITY_CHAT);
+#endif
+	//yaz
+	// convert msg to ascii first. if it succeed, send as plain ascii.
+	// if it fails, convert msg into UTF-16BE, and send it. 
+	ucs = g_convert(msg, strlen(msg), "ASCII", "UTF-8", NULL, &bytes, NULL);
+	if(ucs){
+		byte_stream_new(&hdrbs, 2+8+16+6+4+4+strlen(msg)+4+2+1+strlen(roomname)+2);
+
+		byte_stream_put16(&hdrbs, 0x0000); /* Unknown! */
+		byte_stream_putraw(&hdrbs, cookie, sizeof(cookie)); /* I think... */
+		byte_stream_putcaps(&hdrbs, OSCAR_CAPABILITY_CHAT);
+
+		aim_tlvlist_add_16(&inner_tlvlist, 0x000a, 0x0001);
+		aim_tlvlist_add_noval(&inner_tlvlist, 0x000f);
+		aim_tlvlist_add_raw(&inner_tlvlist, 0x000c, strlen(msg), (guint8 *)msg);
+		free(ucs);
+	} else {
+		byte_stream_new(&hdrbs, 2+8+16+6+4+4+strlen(msg)+4+2+1+strlen(roomname)+2+4+11);
 
+		byte_stream_put16(&hdrbs, 0x0000); /* Unknown! */
+		byte_stream_putraw(&hdrbs, cookie, sizeof(cookie)); /* I think... */
+		byte_stream_putcaps(&hdrbs, OSCAR_CAPABILITY_CHAT);
+
+		aim_tlvlist_add_16(&inner_tlvlist, 0x000a, 0x0001);
+		aim_tlvlist_add_raw(&inner_tlvlist, 0x000d, 11, (guint8 *)"unicode-2-0");
+		aim_tlvlist_add_noval(&inner_tlvlist, 0x000f);
+		//yaz
+		ucs = g_convert(msg, strlen(msg), "UTF-16BE", "UTF-8", NULL, &bytes, NULL);
+		if(ucs){
+			botch_ucs(ucs, bytes);
+			aim_tlvlist_add_raw(&inner_tlvlist, 0x000c, bytes, (guint8 *)ucs);
+			free(ucs);
+		}
+	}
+#if 0
 	aim_tlvlist_add_16(&inner_tlvlist, 0x000a, 0x0001);
 	aim_tlvlist_add_noval(&inner_tlvlist, 0x000f);
 	aim_tlvlist_add_str(&inner_tlvlist, 0x000c, msg);
+#endif
 	aim_tlvlist_add_chatroom(&inner_tlvlist, 0x2711, exchange, roomname, instance);
 	aim_tlvlist_write(&hdrbs, &inner_tlvlist);
 
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/oscar/odc.c pidgin-2.10.11/libpurple/protocols/oscar/odc.c
--- pidgin-2.10.11.orig/libpurple/protocols/oscar/odc.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/oscar/odc.c	2015-02-10 14:28:16.394018882 +0900
@@ -102,18 +102,23 @@
 	byte_stream_new(&bs, length + frame->payload.len);
 	byte_stream_putraw(&bs, conn->magic, 4);
 	byte_stream_put16(&bs, length);
+
 	byte_stream_put16(&bs, frame->type);
 	byte_stream_put16(&bs, frame->subtype);
 	byte_stream_put16(&bs, 0x0000);
+
 	byte_stream_putraw(&bs, frame->cookie, 8);
 	byte_stream_put16(&bs, 0x0000);
 	byte_stream_put16(&bs, 0x0000);
 	byte_stream_put16(&bs, 0x0000);
 	byte_stream_put16(&bs, 0x0000);
+
 	byte_stream_put32(&bs, frame->payload.len);
 	byte_stream_put16(&bs, frame->encoding);
 	byte_stream_put16(&bs, 0x0000);
 	byte_stream_put16(&bs, 0x0000);
+	byte_stream_put16(&bs, 0x0000);
+
 	byte_stream_put16(&bs, frame->flags);
 	byte_stream_put16(&bs, 0x0000);
 	byte_stream_put16(&bs, 0x0000);
@@ -497,11 +502,14 @@
 	frame->type = byte_stream_get16(bs);
 	frame->subtype = byte_stream_get16(bs);
 	byte_stream_advance(bs, 2);
+
 	byte_stream_getrawbuf(bs, frame->cookie, 8);
 	byte_stream_advance(bs, 8);
+
 	frame->payload.len = byte_stream_get32(bs);
 	frame->encoding = byte_stream_get16(bs);
 	byte_stream_advance(bs, 4);
+
 	frame->flags = byte_stream_get16(bs);
 	byte_stream_advance(bs, 4);
 	byte_stream_getrawbuf(bs, frame->bn, 32);
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/oscar/oft.c pidgin-2.10.11/libpurple/protocols/oscar/oft.c
--- pidgin-2.10.11.orig/libpurple/protocols/oscar/oft.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/oscar/oft.c	2015-02-10 14:28:16.394018882 +0900
@@ -652,6 +652,8 @@
 {
 	PeerConnection *conn;
 	size_t size;
+	gchar *f1 = NULL, *f2 = NULL;
+	gsize dummy;
 
 	conn = xfer->data;
 	conn->flags |= PEER_CONNECTION_FLAG_APPROVED;
@@ -689,7 +691,16 @@
 	strncpy((gchar *)conn->xferdata.idstring, "Cool FileXfer", 31);
 	conn->xferdata.modtime = 0;
 	conn->xferdata.cretime = 0;
-	xfer->filename = g_path_get_basename(xfer->local_filename);
+
+	/* yaz */
+	f1 = g_filename_display_basename(xfer->local_filename);
+	f2 = botch_utf(f1, strlen(f1), &dummy);
+	if(f2){
+		purple_xfer_set_filename(xfer, (char *)f2);
+	}
+	g_free(f1); f1 = NULL;
+	g_free(f2); f2 = NULL;
+
 	conn->xferdata.name_length = MAX(64, strlen(xfer->filename) + 1);
 	conn->xferdata.name = (guchar *)g_strndup(xfer->filename, conn->xferdata.name_length - 1);
 
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/oscar/oscar.c pidgin-2.10.11/libpurple/protocols/oscar/oscar.c
--- pidgin-2.10.11.orig/libpurple/protocols/oscar/oscar.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/oscar/oscar.c	2015-02-10 14:28:16.394018882 +0900
@@ -1881,7 +1881,7 @@
 	 * for this suck-ass part of the protocol by splitting the string into at
 	 * most 1 baby string.
 	 */
-	msg1 = g_strsplit(args->msg, "\376", (args->type == 0x01 ? 1 : 0));
+	msg1 = g_strsplit(args->msg, "\376", (args->type == 0x01 ? 1 : 0)); // \376 is 0xfe
 	for (numtoks=0; msg1[numtoks]; numtoks++);
 	msg2 = (gchar **)g_malloc((numtoks+1)*sizeof(gchar *));
 	for (i=0; msg1[i]; i++) {
@@ -3178,8 +3178,6 @@
 {
 	GString *msg;
 	GString *data;
-	gchar *tmp;
-	gsize tmplen;
 	guint16 charset;
 	GData *attribs;
 	const char *start, *end, *last;
@@ -3240,11 +3238,9 @@
 
 	g_string_append(msg, "</BODY></HTML>");
 
-	/* Convert the message to a good encoding */
-	tmp = oscar_encode_im(msg->str, &tmplen, &charset, NULL);
-	g_string_free(msg, TRUE);
-	msg = g_string_new_len(tmp, tmplen);
-	g_free(tmp);
+	/* iChat and AIM6 use 0x000d to send UTF8.
+       moreover, AIM6 persists only to UTF8! --yaz */
+    charset = AIM_CHARSET_QUIRKUTF8;
 
 	/* Append any binary data that we may have */
 	if (oscar_id) {
@@ -3382,10 +3378,14 @@
 			/* Messaging an SMS (mobile) user--strip HTML */
 			tmp2 = purple_markup_strip_html(tmp1);
 			is_html = FALSE;
-		} else {
+		} else if (od->icq) {
 			/* ICQ 6 wants its HTML wrapped in these tags. Oblige it. */
 			tmp2 = g_strdup_printf("<HTML><BODY>%s</BODY></HTML>", tmp1);
 			is_html = TRUE;
+		} else {
+			/* otherwise */
+			tmp2 = g_strdup(tmp1);
+			is_html = FALSE;
 		}
 		g_free(tmp1);
 		tmp1 = tmp2;
@@ -4555,7 +4555,7 @@
 				message, buf2);
 	}
 
-	aim_chat_send_im(od, c->conn, 0, buf2, len, charsetstr, "en");
+	aim_chat_send_im(od, c->conn, 0, buf2, len, charsetstr, "JA");
 	g_free(buf2);
 	g_free(buf);
 
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/oscar/oscar.c.orig pidgin-2.10.11/libpurple/protocols/oscar/oscar.c.orig
--- pidgin-2.10.11.orig/libpurple/protocols/oscar/oscar.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/oscar/oscar.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,5795 @@
+/*
+ * purple
+ *
+ * Some code copyright (C) 1998-1999, Mark Spencer <markster@marko.net>
+ * Some code copyright (C) 1999-2001, Eric Warmenhoven
+ * Some code copyright (C) 2001-2003, Sean Egan
+ * Some code copyright (C) 2001-2007, Mark Doliner <thekingant@users.sourceforge.net>
+ * Some code copyright (C) 2005, Jonathan Clark <ardentlygnarly@users.sourceforge.net>
+ * Some code copyright (C) 2007, ComBOTS Product GmbH (htfv) <foss@combots.com>
+ * Some code copyright (C) 2008, Aman Gupta
+ *
+ * Most libfaim code copyright (C) 1998-2001 Adam Fritzler <afritz@auk.cx>
+ * Some libfaim code copyright (C) 2001-2004 Mark Doliner <thekingant@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+
+#include "internal.h"
+
+#include "account.h"
+#include "accountopt.h"
+#include "buddyicon.h"
+#include "cipher.h"
+#include "conversation.h"
+#include "core.h"
+#include "debug.h"
+#include "encoding.h"
+#include "imgstore.h"
+#include "network.h"
+#include "notify.h"
+#include "privacy.h"
+#include "prpl.h"
+#include "proxy.h"
+#include "request.h"
+#include "util.h"
+#include "version.h"
+#include "visibility.h"
+
+#include "oscarcommon.h"
+#include "oscar.h"
+#include "peer.h"
+
+#define AIMHASHDATA "http://pidgin.im/aim_data.php3"
+
+#define OSCAR_CONNECT_STEPS 6
+
+static guint64 purple_caps =
+	OSCAR_CAPABILITY_CHAT
+		| OSCAR_CAPABILITY_BUDDYICON
+		| OSCAR_CAPABILITY_DIRECTIM
+		| OSCAR_CAPABILITY_SENDFILE
+		| OSCAR_CAPABILITY_UNICODE
+		| OSCAR_CAPABILITY_INTEROPERATE
+		| OSCAR_CAPABILITY_SHORTCAPS
+		| OSCAR_CAPABILITY_TYPING
+		| OSCAR_CAPABILITY_ICQSERVERRELAY
+		| OSCAR_CAPABILITY_NEWCAPS
+		| OSCAR_CAPABILITY_XTRAZ
+		| OSCAR_CAPABILITY_HTML_MSGS;
+
+static guint8 features_aim[] = {0x01, 0x01, 0x01, 0x02};
+static guint8 features_icq[] = {0x01};
+
+struct create_room {
+	char *name;
+	int exchange;
+};
+
+struct oscar_ask_directim_data
+{
+	OscarData *od;
+	char *who;
+};
+
+/* All the libfaim->purple callback functions */
+
+/* Only used when connecting with the old-style BUCP login */
+static int purple_parse_auth_resp  (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_login      (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_auth_securid_request(OscarData *, FlapConnection *, FlapFrame *, ...);
+
+static int purple_handle_redirect  (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_info_change      (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_account_confirm  (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_oncoming   (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_offgoing   (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_incoming_im(OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_misses     (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_clientauto (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_motd       (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_chatnav_info     (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_conv_chat_join        (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_conv_chat_leave       (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_conv_chat_info_update (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_conv_chat_incoming_msg(OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_email_parseupdate(OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_icon_parseicon   (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_searcherror(OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_searchreply(OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_bosrights        (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_connerr          (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_mtn        (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_locaterights(OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_buddyrights(OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_parse_genericerr (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_memrequest       (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_selfinfo         (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_popup            (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_ssi_parseerr     (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_ssi_parserights  (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_ssi_parselist    (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_ssi_parseack     (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_ssi_parseaddmod  (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_ssi_authgiven    (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_ssi_authrequest  (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_ssi_authreply    (OscarData *, FlapConnection *, FlapFrame *, ...);
+static int purple_ssi_gotadded     (OscarData *, FlapConnection *, FlapFrame *, ...);
+
+static void purple_icons_fetch(PurpleConnection *gc);
+
+void oscar_set_info(PurpleConnection *gc, const char *info);
+static void oscar_set_info_and_status(PurpleAccount *account, gboolean setinfo, const char *rawinfo, gboolean setstatus, PurpleStatus *status);
+static void oscar_set_extended_status(PurpleConnection *gc);
+static gboolean purple_ssi_rerequestdata(gpointer data);
+
+void oscar_free_name_data(struct name_data *data) {
+	g_free(data->name);
+	g_free(data->nick);
+	g_free(data);
+}
+
+#ifdef _WIN32
+const char *oscar_get_locale_charset(void) {
+	static const char *charset = NULL;
+	if (charset == NULL)
+		g_get_charset(&charset);
+	return charset;
+}
+#endif
+
+static char *oscar_icqstatus(int state) {
+	/* Make a cute little string that shows the status of the dude or dudet */
+	if (state & AIM_ICQ_STATE_CHAT)
+		return g_strdup(_("Free For Chat"));
+	else if (state & AIM_ICQ_STATE_DND)
+		return g_strdup(_("Do Not Disturb"));
+	else if (state & AIM_ICQ_STATE_OUT)
+		return g_strdup(_("Not Available"));
+	else if (state & AIM_ICQ_STATE_BUSY)
+		return g_strdup(_("Occupied"));
+	else if (state & AIM_ICQ_STATE_AWAY)
+		return g_strdup(_("Away"));
+	else if (state & AIM_ICQ_STATE_WEBAWARE)
+		return g_strdup(_("Web Aware"));
+	else if (state & AIM_ICQ_STATE_INVISIBLE)
+		return g_strdup(_("Invisible"));
+	else if (state & AIM_ICQ_STATE_EVIL)
+		return g_strdup(_("Evil"));
+	else if (state & AIM_ICQ_STATE_DEPRESSION)
+		return g_strdup(_("Depression"));
+	else if (state & AIM_ICQ_STATE_ATHOME)
+		return g_strdup(_("At home"));
+	else if (state & AIM_ICQ_STATE_ATWORK)
+		return g_strdup(_("At work"));
+	else if (state & AIM_ICQ_STATE_LUNCH)
+		return g_strdup(_("At lunch"));
+	else
+		return g_strdup(_("Online"));
+}
+
+static char *extract_name(const char *name) {
+	char *tmp, *x;
+	int i, j;
+
+	if (!name)
+		return NULL;
+
+	x = strchr(name, '-');
+	if (!x)
+		return NULL;
+
+	x = strchr(x + 1, '-');
+	if (!x)
+		return NULL;
+
+	tmp = g_strdup(++x);
+
+	for (i = 0, j = 0; x[i]; i++) {
+		char hex[3];
+		if (x[i] != '%') {
+			tmp[j++] = x[i];
+			continue;
+		}
+		strncpy(hex, x + ++i, 2);
+		hex[2] = 0;
+		i++;
+		tmp[j++] = strtol(hex, NULL, 16);
+	}
+
+	tmp[j] = 0;
+	return tmp;
+}
+
+static struct chat_connection *
+find_oscar_chat(PurpleConnection *gc, int id)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	GSList *cur;
+	struct chat_connection *cc;
+
+	for (cur = od->oscar_chats; cur != NULL; cur = cur->next)
+	{
+		cc = (struct chat_connection *)cur->data;
+		if (cc->id == id)
+			return cc;
+	}
+
+	return NULL;
+}
+
+static struct chat_connection *
+find_oscar_chat_by_conn(PurpleConnection *gc, FlapConnection *conn)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	GSList *cur;
+	struct chat_connection *cc;
+
+	for (cur = od->oscar_chats; cur != NULL; cur = cur->next)
+	{
+		cc = (struct chat_connection *)cur->data;
+		if (cc->conn == conn)
+			return cc;
+	}
+
+	return NULL;
+}
+
+static struct chat_connection *
+find_oscar_chat_by_conv(PurpleConnection *gc, PurpleConversation *conv)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	GSList *cur;
+	struct chat_connection *cc;
+
+	for (cur = od->oscar_chats; cur != NULL; cur = cur->next)
+	{
+		cc = (struct chat_connection *)cur->data;
+		if (cc->conv == conv)
+			return cc;
+	}
+
+	return NULL;
+}
+
+void
+oscar_chat_destroy(struct chat_connection *cc)
+{
+	g_free(cc->name);
+	g_free(cc->show);
+	g_free(cc);
+}
+
+static void
+oscar_chat_kill(PurpleConnection *gc, struct chat_connection *cc)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	/* Notify the conversation window that we've left the chat */
+	serv_got_chat_left(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(cc->conv)));
+
+	/* Destroy the chat_connection */
+	od->oscar_chats = g_slist_remove(od->oscar_chats, cc);
+	oscar_chat_destroy(cc);
+}
+
+/**
+ * This is called from the callback functions for establishing
+ * a TCP connection with an oscar host if an error occurred.
+ */
+static void
+connection_common_error_cb(FlapConnection *conn, const gchar *error_message)
+{
+	OscarData *od;
+	PurpleConnection *gc;
+
+	od = conn->od;
+	gc = od->gc;
+
+	purple_debug_error("oscar", "unable to connect to FLAP "
+			"server of type 0x%04hx\n", conn->type);
+
+	if (conn->type == SNAC_FAMILY_AUTH)
+	{
+		/* This only happens when connecting with the old-style BUCP login */
+		gchar *msg;
+		msg = g_strdup_printf(_("Unable to connect to authentication server: %s"),
+				error_message);
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, msg);
+		g_free(msg);
+	}
+	else if (conn->type == SNAC_FAMILY_LOCATE)
+	{
+		gchar *msg;
+		msg = g_strdup_printf(_("Unable to connect to BOS server: %s"),
+				error_message);
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, msg);
+		g_free(msg);
+	}
+	else
+	{
+		/* Maybe we should call this for BOS connections, too? */
+		flap_connection_schedule_destroy(conn,
+				OSCAR_DISCONNECT_COULD_NOT_CONNECT, error_message);
+	}
+}
+
+/**
+ * This is called from the callback functions for establishing
+ * a TCP connection with an oscar host. Depending on the type
+ * of host, we do a few different things here.
+ */
+static void
+connection_common_established_cb(FlapConnection *conn)
+{
+	OscarData *od;
+	PurpleConnection *gc;
+	PurpleAccount *account;
+
+	od = conn->od;
+	gc = od->gc;
+	account = purple_connection_get_account(gc);
+
+	purple_debug_info("oscar", "connected to FLAP server of type 0x%04hx\n",
+			conn->type);
+
+	if (conn->cookie == NULL)
+		flap_connection_send_version(od, conn);
+	else
+	{
+		if (purple_account_get_bool(account, "use_clientlogin", OSCAR_DEFAULT_USE_CLIENTLOGIN))
+		{
+			ClientInfo aiminfo = CLIENTINFO_PURPLE_AIM;
+			ClientInfo icqinfo = CLIENTINFO_PURPLE_ICQ;
+			flap_connection_send_version_with_cookie_and_clientinfo(od,
+					conn, conn->cookielen, conn->cookie,
+					od->icq ? &icqinfo : &aiminfo,
+					purple_account_get_bool(account, "allow_multiple_logins", OSCAR_DEFAULT_ALLOW_MULTIPLE_LOGINS));
+		} else {
+			flap_connection_send_version_with_cookie(od, conn,
+					conn->cookielen, conn->cookie);
+		}
+
+
+		g_free(conn->cookie);
+		conn->cookie = NULL;
+	}
+
+	if (conn->type == SNAC_FAMILY_AUTH)
+	{
+		/* This only happens when connecting with the old-style BUCP login */
+		aim_request_login(od, conn, purple_account_get_username(account));
+		purple_debug_info("oscar", "Username sent, waiting for response\n");
+		purple_connection_update_progress(gc, _("Username sent"), 1, OSCAR_CONNECT_STEPS);
+	}
+	else if (conn->type == SNAC_FAMILY_LOCATE)
+	{
+		purple_connection_update_progress(gc, _("Connection established, cookie sent"), 4, OSCAR_CONNECT_STEPS);
+	}
+	else if (conn->type == SNAC_FAMILY_CHAT)
+	{
+		od->oscar_chats = g_slist_prepend(od->oscar_chats, conn->new_conn_data);
+		conn->new_conn_data = NULL;
+	}
+}
+
+static void
+connection_established_cb(gpointer data, gint source, const gchar *error_message)
+{
+	FlapConnection *conn;
+
+	conn = data;
+
+	conn->connect_data = NULL;
+	conn->fd = source;
+
+	if (source < 0)
+	{
+		connection_common_error_cb(conn, error_message);
+		return;
+	}
+
+	conn->watcher_incoming = purple_input_add(conn->fd,
+			PURPLE_INPUT_READ, flap_connection_recv_cb, conn);
+	connection_common_established_cb(conn);
+}
+
+static void
+ssl_connection_established_cb(gpointer data, PurpleSslConnection *gsc,
+		PurpleInputCondition cond)
+{
+	FlapConnection *conn;
+
+	conn = data;
+
+	purple_ssl_input_add(gsc, flap_connection_recv_cb_ssl, conn);
+	connection_common_established_cb(conn);
+}
+
+static void
+ssl_connection_error_cb(PurpleSslConnection *gsc, PurpleSslErrorType error,
+		gpointer data)
+{
+	FlapConnection *conn;
+
+	conn = data;
+
+	if (conn->watcher_outgoing)
+	{
+		purple_input_remove(conn->watcher_outgoing);
+		conn->watcher_outgoing = 0;
+	}
+
+	/* sslconn frees the connection on error */
+	conn->gsc = NULL;
+
+	connection_common_error_cb(conn, purple_ssl_strerror(error));
+}
+
+static void
+flap_connection_established_bos(OscarData *od, FlapConnection *conn)
+{
+	PurpleConnection *gc = od->gc;
+
+	aim_srv_reqpersonalinfo(od, conn);
+
+	purple_debug_info("oscar", "ssi: requesting rights and list\n");
+	aim_ssi_reqrights(od);
+	aim_ssi_reqdata(od);
+	if (od->getblisttimer > 0)
+		purple_timeout_remove(od->getblisttimer);
+	od->getblisttimer = purple_timeout_add_seconds(30, purple_ssi_rerequestdata, od);
+
+	aim_locate_reqrights(od);
+	aim_buddylist_reqrights(od, conn);
+	aim_im_reqparams(od);
+	aim_bos_reqrights(od, conn); /* TODO: Don't call this with ssi */
+
+	purple_connection_update_progress(gc, _("Finalizing connection"), 5, OSCAR_CONNECT_STEPS);
+}
+
+static void
+flap_connection_established_admin(OscarData *od, FlapConnection *conn)
+{
+	aim_srv_clientready(od, conn);
+	purple_debug_info("oscar", "connected to admin\n");
+
+	if (od->chpass) {
+		purple_debug_info("oscar", "changing password\n");
+		aim_admin_changepasswd(od, conn, od->newp, od->oldp);
+		g_free(od->oldp);
+		od->oldp = NULL;
+		g_free(od->newp);
+		od->newp = NULL;
+		od->chpass = FALSE;
+	}
+	if (od->setnick) {
+		purple_debug_info("oscar", "formatting username\n");
+		aim_admin_setnick(od, conn, od->newformatting);
+		g_free(od->newformatting);
+		od->newformatting = NULL;
+		od->setnick = FALSE;
+	}
+	if (od->conf) {
+		purple_debug_info("oscar", "confirming account\n");
+		aim_admin_reqconfirm(od, conn);
+		od->conf = FALSE;
+	}
+	if (od->reqemail) {
+		purple_debug_info("oscar", "requesting email address\n");
+		aim_admin_getinfo(od, conn, 0x0011);
+		od->reqemail = FALSE;
+	}
+	if (od->setemail) {
+		purple_debug_info("oscar", "setting email address\n");
+		aim_admin_setemail(od, conn, od->email);
+		g_free(od->email);
+		od->email = NULL;
+		od->setemail = FALSE;
+	}
+}
+
+static void
+flap_connection_established_chat(OscarData *od, FlapConnection *conn)
+{
+	PurpleConnection *gc = od->gc;
+	struct chat_connection *chatcon;
+	static int id = 1;
+
+	aim_srv_clientready(od, conn);
+
+	chatcon = find_oscar_chat_by_conn(gc, conn);
+	if (chatcon) {
+		chatcon->id = id;
+		chatcon->conv = serv_got_joined_chat(gc, id++, chatcon->show);
+	}
+}
+
+static void
+flap_connection_established_chatnav(OscarData *od, FlapConnection *conn)
+{
+	aim_srv_clientready(od, conn);
+	aim_chatnav_reqrights(od, conn);
+}
+
+static void
+flap_connection_established_alert(OscarData *od, FlapConnection *conn)
+{
+	aim_email_sendcookies(od);
+	aim_email_activate(od);
+	aim_srv_clientready(od, conn);
+}
+
+static void
+flap_connection_established_bart(OscarData *od, FlapConnection *conn)
+{
+	PurpleConnection *gc = od->gc;
+
+	aim_srv_clientready(od, conn);
+
+	od->iconconnecting = FALSE;
+
+	purple_icons_fetch(gc);
+}
+
+static int
+flap_connection_established(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	purple_debug_info("oscar", "FLAP connection of type 0x%04hx is "
+			"now fully connected\n", conn->type);
+	if (conn->type == SNAC_FAMILY_LOCATE)
+		flap_connection_established_bos(od, conn);
+	else if (conn->type == SNAC_FAMILY_ADMIN)
+		flap_connection_established_admin(od, conn);
+	else if (conn->type == SNAC_FAMILY_CHAT)
+		flap_connection_established_chat(od, conn);
+	else if (conn->type == SNAC_FAMILY_CHATNAV)
+		flap_connection_established_chatnav(od, conn);
+	else if (conn->type == SNAC_FAMILY_ALERT)
+		flap_connection_established_alert(od, conn);
+	else if (conn->type == SNAC_FAMILY_BART)
+		flap_connection_established_bart(od, conn);
+
+	return 1;
+}
+
+static void
+idle_reporting_pref_cb(const char *name, PurplePrefType type,
+		gconstpointer value, gpointer data)
+{
+	PurpleConnection *gc;
+	OscarData *od;
+	gboolean report_idle;
+	guint32 presence;
+
+	gc = data;
+	od = purple_connection_get_protocol_data(gc);
+	report_idle = strcmp((const char *)value, "none") != 0;
+	presence = aim_ssi_getpresence(od->ssi.local);
+
+	if (report_idle)
+		aim_ssi_setpresence(od, presence | AIM_SSI_PRESENCE_FLAG_SHOWIDLE);
+	else
+		aim_ssi_setpresence(od, presence & ~AIM_SSI_PRESENCE_FLAG_SHOWIDLE);
+}
+
+/**
+ * Should probably make a "Use recent buddies group" account preference
+ * so that this option is surfaced to the user.
+ */
+static void
+recent_buddies_pref_cb(const char *name, PurplePrefType type,
+		gconstpointer value, gpointer data)
+{
+	PurpleConnection *gc;
+	OscarData *od;
+	guint32 presence;
+
+	gc = data;
+	od = purple_connection_get_protocol_data(gc);
+	presence = aim_ssi_getpresence(od->ssi.local);
+
+	if (value)
+		aim_ssi_setpresence(od, presence & ~AIM_SSI_PRESENCE_FLAG_NORECENTBUDDIES);
+	else
+		aim_ssi_setpresence(od, presence | AIM_SSI_PRESENCE_FLAG_NORECENTBUDDIES);
+}
+
+static const gchar *login_servers[] = {
+	AIM_DEFAULT_LOGIN_SERVER,
+	AIM_DEFAULT_SSL_LOGIN_SERVER,
+	ICQ_DEFAULT_LOGIN_SERVER,
+	ICQ_DEFAULT_SSL_LOGIN_SERVER,
+};
+
+static const gchar *
+get_login_server(gboolean is_icq, gboolean use_ssl)
+{
+	return login_servers[(is_icq ? 2 : 0) + (use_ssl ? 1 : 0)];
+}
+
+static gint
+compare_handlers(gconstpointer a, gconstpointer b)
+{
+	guint aa = GPOINTER_TO_UINT(a);
+	guint bb = GPOINTER_TO_UINT(b);
+	guint family1 = aa >> 16;
+	guint family2 = bb >> 16;
+	guint subtype1 = aa & 0xFFFF;
+	guint subtype2 = bb & 0xFFFF;
+	if (family1 != family2) {
+		return family1 - family2;
+	}
+	return subtype1 - subtype2;
+}
+
+#if !GLIB_CHECK_VERSION(2,14,0)
+static void hash_table_get_list_of_keys(gpointer key, gpointer value, gpointer user_data)
+{
+	GList **handlers = (GList **)user_data;
+
+	*handlers = g_list_prepend(*handlers, key);
+}
+#endif /* GLIB < 2.14.0 */
+
+void
+oscar_login(PurpleAccount *account)
+{
+	PurpleConnection *gc;
+	OscarData *od;
+	const gchar *encryption_type;
+	GList *handlers;
+	GList *sorted_handlers;
+	GList *cur;
+	GString *msg = g_string_new("");
+
+	gc = purple_account_get_connection(account);
+	od = oscar_data_new();
+	od->gc = gc;
+	purple_connection_set_protocol_data(gc, od);
+
+	oscar_data_addhandler(od, AIM_CB_FAM_SPECIAL, AIM_CB_SPECIAL_CONNERR, purple_connerr, 0);
+	oscar_data_addhandler(od, AIM_CB_FAM_SPECIAL, AIM_CB_SPECIAL_CONNINITDONE, flap_connection_established, 0);
+
+	oscar_data_addhandler(od, SNAC_FAMILY_ADMIN, 0x0003, purple_info_change, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_ADMIN, 0x0005, purple_info_change, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_ADMIN, 0x0007, purple_account_confirm, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_ALERT, 0x0001, purple_parse_genericerr, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_ALERT, SNAC_SUBTYPE_ALERT_MAILSTATUS, purple_email_parseupdate, 0);
+
+	/* These are only needed when connecting with the old-style BUCP login */
+	oscar_data_addhandler(od, SNAC_FAMILY_AUTH, 0x0003, purple_parse_auth_resp, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_AUTH, 0x0007, purple_parse_login, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_AUTH, SNAC_SUBTYPE_AUTH_SECURID_REQUEST, purple_parse_auth_securid_request, 0);
+
+	oscar_data_addhandler(od, SNAC_FAMILY_BART, SNAC_SUBTYPE_BART_RESPONSE, purple_icon_parseicon, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_BOS, 0x0001, purple_parse_genericerr, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_BOS, 0x0003, purple_bosrights, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_BUDDY, 0x0001, purple_parse_genericerr, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_BUDDY, SNAC_SUBTYPE_BUDDY_RIGHTSINFO, purple_parse_buddyrights, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_BUDDY, SNAC_SUBTYPE_BUDDY_ONCOMING, purple_parse_oncoming, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_BUDDY, SNAC_SUBTYPE_BUDDY_OFFGOING, purple_parse_offgoing, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_CHAT, 0x0001, purple_parse_genericerr, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_CHAT, SNAC_SUBTYPE_CHAT_USERJOIN, purple_conv_chat_join, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_CHAT, SNAC_SUBTYPE_CHAT_USERLEAVE, purple_conv_chat_leave, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_CHAT, SNAC_SUBTYPE_CHAT_ROOMINFOUPDATE, purple_conv_chat_info_update, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_CHAT, SNAC_SUBTYPE_CHAT_INCOMINGMSG, purple_conv_chat_incoming_msg, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_CHATNAV, 0x0001, purple_parse_genericerr, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_CHATNAV, SNAC_SUBTYPE_CHATNAV_INFO, purple_chatnav_info, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_ERROR, purple_ssi_parseerr, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_RIGHTSINFO, purple_ssi_parserights, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_LIST, purple_ssi_parselist, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_SRVACK, purple_ssi_parseack, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_ADD, purple_ssi_parseaddmod, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_MOD, purple_ssi_parseaddmod, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_RECVAUTH, purple_ssi_authgiven, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_RECVAUTHREQ, purple_ssi_authrequest, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_RECVAUTHREP, purple_ssi_authreply, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_FEEDBAG, SNAC_SUBTYPE_FEEDBAG_ADDED, purple_ssi_gotadded, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_ICBM, SNAC_SUBTYPE_ICBM_INCOMING, purple_parse_incoming_im, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_ICBM, SNAC_SUBTYPE_ICBM_MISSEDCALL, purple_parse_misses, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_ICBM, SNAC_SUBTYPE_ICBM_CLIENTAUTORESP, purple_parse_clientauto, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_ICBM, SNAC_SUBTYPE_ICBM_MTN, purple_parse_mtn, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_LOCATE, SNAC_SUBTYPE_LOCATE_RIGHTSINFO, purple_parse_locaterights, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_OSERVICE, 0x0001, purple_parse_genericerr, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_OSERVICE, 0x000f, purple_selfinfo, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_OSERVICE, 0x001f, purple_memrequest, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_OSERVICE, SNAC_SUBTYPE_OSERVICE_REDIRECT, purple_handle_redirect, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_OSERVICE, SNAC_SUBTYPE_OSERVICE_MOTD, purple_parse_motd, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_POPUP, 0x0002, purple_popup, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_USERLOOKUP, SNAC_SUBTYPE_USERLOOKUP_ERROR, purple_parse_searcherror, 0);
+	oscar_data_addhandler(od, SNAC_FAMILY_USERLOOKUP, 0x0003, purple_parse_searchreply, 0);
+
+	g_string_append(msg, "Registered handlers: ");
+#if GLIB_CHECK_VERSION(2,14,0)
+	handlers = g_hash_table_get_keys(od->handlerlist);
+#else
+	handlers = NULL;
+	g_hash_table_foreach(od->handlerlist, hash_table_get_list_of_keys, &handlers);
+#endif /* GLIB < 2.14.0 */
+	sorted_handlers = g_list_sort(g_list_copy(handlers), compare_handlers);
+	for (cur = sorted_handlers; cur; cur = cur->next) {
+		guint x = GPOINTER_TO_UINT(cur->data);
+		g_string_append_printf(msg, "%04x/%04x, ", x >> 16, x & 0xFFFF);
+	}
+	g_list_free(sorted_handlers);
+	g_list_free(handlers);
+	purple_debug_misc("oscar", "%s\n", msg->str);
+	g_string_free(msg, TRUE);
+
+	purple_debug_misc("oscar", "oscar_login: gc = %p\n", gc);
+
+	if (!oscar_util_valid_name(purple_account_get_username(account))) {
+		gchar *buf;
+		buf = g_strdup_printf(_("Unable to sign on as %s because the username is invalid.  Usernames must be a valid email address, or start with a letter and contain only letters, numbers and spaces, or contain only numbers."), purple_account_get_username(account));
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_INVALID_SETTINGS, buf);
+		g_free(buf);
+		return;
+	}
+
+	gc->flags |= PURPLE_CONNECTION_HTML;
+	if (g_str_equal(purple_account_get_protocol_id(account), "prpl-icq")) {
+		od->icq = TRUE;
+	} else {
+		gc->flags |= PURPLE_CONNECTION_AUTO_RESP;
+	}
+
+	/* Set this flag based on the protocol_id rather than the username,
+	   because that is what's tied to the get_moods prpl callback. */
+	if (g_str_equal(purple_account_get_protocol_id(account), "prpl-icq"))
+		gc->flags |= PURPLE_CONNECTION_SUPPORT_MOODS;
+
+	od->default_port = purple_account_get_int(account, "port", OSCAR_DEFAULT_LOGIN_PORT);
+
+	encryption_type = purple_account_get_string(account, "encryption", OSCAR_DEFAULT_ENCRYPTION);
+	if (!purple_ssl_is_supported() && strcmp(encryption_type, OSCAR_REQUIRE_ENCRYPTION) == 0) {
+		purple_connection_error_reason(
+			gc,
+			PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,
+			_("You required encryption in your account settings, but encryption is not supported by your system."));
+		return;
+	}
+	od->use_ssl = purple_ssl_is_supported() && strcmp(encryption_type, OSCAR_NO_ENCRYPTION) != 0;
+
+	/* Connect to core Purple signals */
+	purple_prefs_connect_callback(gc, "/purple/away/idle_reporting", idle_reporting_pref_cb, gc);
+	purple_prefs_connect_callback(gc, "/plugins/prpl/oscar/recent_buddies", recent_buddies_pref_cb, gc);
+
+	/*
+	 * On 2008-03-05 AOL released some documentation on the OSCAR protocol
+	 * which includes a new login method called clientLogin.  It is similar
+	 * (though not the same?) as what the AIM 6.0 series uses to
+	 * authenticate.
+	 *
+	 * AIM 5.9 and lower use an MD5-based login procedure called "BUCP".
+	 * This authentication method is used for both ICQ and AIM when
+	 * clientLogin is not enabled.
+	 */
+	if (purple_account_get_bool(account, "use_clientlogin", OSCAR_DEFAULT_USE_CLIENTLOGIN)) {
+		send_client_login(od, purple_account_get_username(account));
+	} else {
+		FlapConnection *newconn;
+		const char *server;
+
+		newconn = flap_connection_new(od, SNAC_FAMILY_AUTH);
+
+		if (od->use_ssl) {
+			server = purple_account_get_string(account, "server", get_login_server(od->icq, TRUE));
+
+			/*
+			 * If the account's server is what the oscar prpl has offered as
+			 * the default login server through the vast eons (all two of
+			 * said default options, AFAIK) and the user wants SSL, we'll
+			 * do what we know is best for them and change the setting out
+			 * from under them to the SSL login server.
+			 */
+			if (!strcmp(server, get_login_server(od->icq, FALSE)) || !strcmp(server, AIM_ALT_LOGIN_SERVER)) {
+				purple_debug_info("oscar", "Account uses SSL, so changing server to default SSL server\n");
+				purple_account_set_string(account, "server", get_login_server(od->icq, TRUE));
+				server = get_login_server(od->icq, TRUE);
+			}
+
+			newconn->gsc = purple_ssl_connect(account, server,
+					purple_account_get_int(account, "port", OSCAR_DEFAULT_LOGIN_PORT),
+					ssl_connection_established_cb, ssl_connection_error_cb, newconn);
+		} else {
+			server = purple_account_get_string(account, "server", get_login_server(od->icq, FALSE));
+
+			/*
+			 * See the comment above. We do the reverse here. If they don't want
+			 * SSL but their server is set to OSCAR_DEFAULT_SSL_LOGIN_SERVER,
+			 * set it back to the default.
+			 */
+			if (!strcmp(server, get_login_server(od->icq, TRUE))) {
+				purple_debug_info("oscar", "Account does not use SSL, so changing server back to non-SSL\n");
+				purple_account_set_string(account, "server", get_login_server(od->icq, FALSE));
+				server = get_login_server(od->icq, FALSE);
+			}
+
+			newconn->connect_data = purple_proxy_connect(NULL, account, server,
+					purple_account_get_int(account, "port", OSCAR_DEFAULT_LOGIN_PORT),
+					connection_established_cb, newconn);
+		}
+
+		if (newconn->gsc == NULL && newconn->connect_data == NULL) {
+			purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+					_("Unable to connect"));
+			return;
+		}
+	}
+
+	purple_connection_update_progress(gc, _("Connecting"), 0, OSCAR_CONNECT_STEPS);
+}
+
+void
+oscar_close(PurpleConnection *gc)
+{
+	OscarData *od;
+
+	od = purple_connection_get_protocol_data(gc);
+
+	while (od->oscar_chats)
+	{
+		struct chat_connection *cc = od->oscar_chats->data;
+		od->oscar_chats = g_slist_remove(od->oscar_chats, cc);
+		oscar_chat_destroy(cc);
+	}
+	while (od->create_rooms)
+	{
+		struct create_room *cr = od->create_rooms->data;
+		g_free(cr->name);
+		od->create_rooms = g_slist_remove(od->create_rooms, cr);
+		g_free(cr);
+	}
+	oscar_data_destroy(od);
+	purple_connection_set_protocol_data(gc, NULL);
+
+	purple_prefs_disconnect_by_handle(gc);
+
+	purple_debug_info("oscar", "Signed off.\n");
+}
+
+/* XXX - Should use purple_util_fetch_url for the below stuff */
+struct pieceofcrap {
+	PurpleConnection *gc;
+	unsigned long offset;
+	unsigned long len;
+	char *modname;
+	int fd;
+	FlapConnection *conn;
+	unsigned int inpa;
+};
+
+static void damn_you(gpointer data, gint source, PurpleInputCondition c)
+{
+	struct pieceofcrap *pos = data;
+	OscarData *od = purple_connection_get_protocol_data(pos->gc);
+	char in = '\0';
+	int x = 0;
+	unsigned char m[17];
+	GString *msg;
+
+	while (read(pos->fd, &in, 1) == 1) {
+		if (in == '\n')
+			x++;
+		else if (in != '\r')
+			x = 0;
+		if (x == 2)
+			break;
+		in = '\0';
+	}
+	if (in != '\n') {
+		char buf[256];
+		g_snprintf(buf, sizeof(buf), _("You may be disconnected shortly.  "
+				"If so, check %s for updates."),
+				oscar_get_ui_info_string("website", PURPLE_WEBSITE));
+		purple_notify_warning(pos->gc, NULL,
+							_("Unable to get a valid AIM login hash."),
+							buf);
+		purple_input_remove(pos->inpa);
+		close(pos->fd);
+		g_free(pos);
+		return;
+	}
+	if (read(pos->fd, m, 16) != 16)
+	{
+		purple_debug_warning("oscar", "Could not read full AIM login hash "
+				"from " AIMHASHDATA "--that's bad.\n");
+	}
+	m[16] = '\0';
+
+	msg = g_string_new("Sending hash: ");
+	for (x = 0; x < 16; x++)
+		g_string_append_printf(msg, "%02hhx ", (unsigned char)m[x]);
+	g_string_append(msg, "\n");
+	purple_debug_misc("oscar", "%s", msg->str);
+	g_string_free(msg, TRUE);
+
+	purple_input_remove(pos->inpa);
+	close(pos->fd);
+	aim_sendmemblock(od, pos->conn, 0, 16, m, AIM_SENDMEMBLOCK_FLAG_ISHASH);
+	g_free(pos);
+}
+
+static void
+straight_to_hell(gpointer data, gint source, const gchar *error_message)
+{
+	struct pieceofcrap *pos = data;
+	gchar *buf;
+	gssize result;
+
+	pos->fd = source;
+
+	if (source < 0) {
+		buf = g_strdup_printf(_("You may be disconnected shortly.  "
+				"If so, check %s for updates."),
+				oscar_get_ui_info_string("website", PURPLE_WEBSITE));
+		purple_notify_warning(pos->gc, NULL,
+							_("Unable to get a valid AIM login hash."),
+							buf);
+		g_free(buf);
+		g_free(pos->modname);
+		g_free(pos);
+		return;
+	}
+
+	buf = g_strdup_printf("GET " AIMHASHDATA "?offset=%ld&len=%ld&modname=%s HTTP/1.0\n\n",
+			pos->offset, pos->len, pos->modname ? pos->modname : "");
+	result = send(pos->fd, buf, strlen(buf), 0);
+	if (result < 0)
+		purple_debug_error("oscar", "Error writing %" G_GSIZE_FORMAT
+				" bytes to fetch AIM hash data: %s\n",
+				strlen(buf), g_strerror(errno));
+	else if ((gsize)result != strlen(buf))
+		purple_debug_error("oscar", "Tried to write %"
+				G_GSIZE_FORMAT " bytes to fetch AIM hash data but "
+				"instead wrote %" G_GSSIZE_FORMAT " bytes\n",
+				strlen(buf), result);
+	g_free(buf);
+	g_free(pos->modname);
+	pos->inpa = purple_input_add(pos->fd, PURPLE_INPUT_READ, damn_you, pos);
+	return;
+}
+
+/* size of icbmui.ocm, the largest module in AIM 3.5 */
+#define AIM_MAX_FILE_SIZE 98304
+
+static int purple_memrequest(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	va_list ap;
+	struct pieceofcrap *pos;
+	guint32 offset, len;
+	char *modname;
+
+	va_start(ap, fr);
+	offset = va_arg(ap, guint32);
+	len = va_arg(ap, guint32);
+	modname = va_arg(ap, char *);
+	va_end(ap);
+
+	purple_debug_misc("oscar", "offset: %u, len: %u, file: %s\n",
+					offset, len, (modname ? modname : "aim.exe"));
+
+	if (len == 0) {
+		purple_debug_misc("oscar", "len is 0, hashing NULL\n");
+		aim_sendmemblock(od, conn, offset, len, NULL,
+				AIM_SENDMEMBLOCK_FLAG_ISREQUEST);
+		return 1;
+	}
+
+	pos = g_new0(struct pieceofcrap, 1);
+	pos->gc = od->gc;
+	pos->conn = conn;
+
+	pos->offset = offset;
+	pos->len = len;
+	pos->modname = g_strdup(modname);
+
+	if (purple_proxy_connect(pos->gc, pos->gc->account, "pidgin.im", 80,
+			straight_to_hell, pos) == NULL)
+	{
+		char buf[256];
+		g_free(pos->modname);
+		g_free(pos);
+
+		g_snprintf(buf, sizeof(buf), _("You may be disconnected shortly.  "
+			"If so, check %s for updates."),
+			oscar_get_ui_info_string("website", PURPLE_WEBSITE));
+		purple_notify_warning(pos->gc, NULL,
+							_("Unable to get a valid login hash."),
+							buf);
+	}
+
+	return 1;
+}
+
+int oscar_connect_to_bos(PurpleConnection *gc, OscarData *od, const char *host, guint16 port, guint8 *cookie, guint16 cookielen, const char *tls_certname)
+{
+	PurpleAccount *account;
+	FlapConnection *conn;
+
+	account = purple_connection_get_account(gc);
+
+	conn = flap_connection_new(od, SNAC_FAMILY_LOCATE);
+	conn->cookielen = cookielen;
+	conn->cookie = g_memdup(cookie, cookielen);
+
+	/*
+	 * Use TLS only if the server provided us with a tls_certname. The server might not specify a tls_certname even if we requested to use TLS,
+	 * and that is something we should be prepared to.
+	 */
+	if (tls_certname)
+	{
+		conn->gsc = purple_ssl_connect_with_ssl_cn(account, host, port,
+				ssl_connection_established_cb, ssl_connection_error_cb,
+				tls_certname, conn);
+	}
+	else
+	{
+		conn->connect_data = purple_proxy_connect(NULL,
+				account, host, port,
+				connection_established_cb, conn);
+	}
+
+	if (conn->gsc == NULL && conn->connect_data == NULL)
+	{
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, _("Unable to connect"));
+		return 0;
+	}
+
+	od->default_port = port;
+
+	purple_connection_update_progress(gc, _("Received authorization"), 3, OSCAR_CONNECT_STEPS);
+
+	return 1;
+}
+
+/**
+ * Only used when connecting with the old-style BUCP login.
+ */
+static int
+purple_parse_auth_resp(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	PurpleConnection *gc = od->gc;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	char *host; int port;
+	size_t i;
+	FlapConnection *newconn;
+	va_list ap;
+	struct aim_authresp_info *info;
+
+	port = purple_account_get_int(account, "port", od->default_port);
+
+	va_start(ap, fr);
+	info = va_arg(ap, struct aim_authresp_info *);
+	va_end(ap);
+
+	purple_debug_info("oscar",
+			   "inside auth_resp (Username: %s)\n", info->bn);
+
+	if (info->errorcode || !info->bosip || !info->cookielen || !info->cookie) {
+		char buf[256];
+		switch (info->errorcode) {
+		case 0x01:
+			/* Unregistered username */
+			purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_INVALID_USERNAME, _("Username does not exist"));
+			break;
+		case 0x05:
+			/* Incorrect password */
+			if (!purple_account_get_remember_password(account))
+				purple_account_set_password(account, NULL);
+			purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED, _("Incorrect password"));
+			break;
+		case 0x11:
+			/* Suspended account */
+			purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED, _("Your account is currently suspended"));
+			break;
+		case 0x02:
+		case 0x14:
+			/* service temporarily unavailable */
+			purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, _("The AOL Instant Messenger service is temporarily unavailable."));
+			break;
+		case 0x18:
+			/* username connecting too frequently */
+			purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_OTHER_ERROR, _("Your username has been connecting and disconnecting too frequently. Wait ten minutes and try again. If you continue to try, you will need to wait even longer."));
+			break;
+		case 0x1c:
+		{
+			/* client too old */
+			g_snprintf(buf, sizeof(buf), _("The client version you are using is too old. Please upgrade at %s"),
+					oscar_get_ui_info_string("website", PURPLE_WEBSITE));
+			purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_OTHER_ERROR, buf);
+			break;
+		}
+		case 0x1d:
+			/* IP address connecting too frequently */
+			purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_OTHER_ERROR, _("Your IP address has been connecting and disconnecting too frequently. Wait a minute and try again. If you continue to try, you will need to wait even longer."));
+			break;
+		default:
+			purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED, _("Unknown reason"));
+			break;
+		}
+		purple_debug_info("oscar", "Login Error Code 0x%04hx\n", info->errorcode);
+		purple_debug_info("oscar", "Error URL: %s\n", info->errorurl ? info->errorurl : "");
+		return 1;
+	}
+
+	purple_debug_misc("oscar", "Reg status: %hu\n"
+							   "Email: %s\n"
+							   "BOSIP: %s\n",
+							   info->regstatus,
+							   info->email ? info->email : "null",
+							   info->bosip ? info->bosip : "null");
+	purple_debug_info("oscar", "Closing auth connection...\n");
+	flap_connection_schedule_destroy(conn, OSCAR_DISCONNECT_DONE, NULL);
+
+	for (i = 0; i < strlen(info->bosip); i++) {
+		if (info->bosip[i] == ':') {
+			port = atoi(&(info->bosip[i+1]));
+			break;
+		}
+	}
+	host = g_strndup(info->bosip, i);
+	newconn = flap_connection_new(od, SNAC_FAMILY_LOCATE);
+	newconn->cookielen = info->cookielen;
+	newconn->cookie = g_memdup(info->cookie, info->cookielen);
+
+	if (od->use_ssl)
+	{
+		/*
+		 * This shouldn't be hardcoded to "bos.oscar.aol.com" except that
+		 * the server isn't sending us a name to use for comparing the
+		 * certificate common name.
+		 */
+		newconn->gsc = purple_ssl_connect_with_ssl_cn(account, host, port,
+				ssl_connection_established_cb, ssl_connection_error_cb,
+				"bos.oscar.aol.com", newconn);
+	}
+	else
+	{
+		newconn->connect_data = purple_proxy_connect(NULL, account, host, port,
+				connection_established_cb, newconn);
+	}
+
+	g_free(host);
+	if (newconn->gsc == NULL && newconn->connect_data == NULL)
+	{
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, _("Unable to connect"));
+		return 0;
+	}
+
+	purple_connection_update_progress(gc, _("Received authorization"), 3, OSCAR_CONNECT_STEPS);
+
+	return 1;
+}
+
+/**
+ * Only used when connecting with the old-style BUCP login.
+ */
+static void
+purple_parse_auth_securid_request_yes_cb(gpointer user_data, const char *msg)
+{
+	PurpleConnection *gc = user_data;
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	aim_auth_securid_send(od, msg);
+}
+
+/**
+ * Only used when connecting with the old-style BUCP login.
+ */
+static void
+purple_parse_auth_securid_request_no_cb(gpointer user_data, const char *value)
+{
+	PurpleConnection *gc = user_data;
+
+	/* Disconnect */
+	purple_connection_error_reason(gc,
+		PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
+		_("The SecurID key entered is invalid"));
+}
+
+/**
+ * Only used when connecting with the old-style BUCP login.
+ */
+static int
+purple_parse_auth_securid_request(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	PurpleConnection *gc = od->gc;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	gchar *primary;
+
+	purple_debug_info("oscar", "Got SecurID request\n");
+
+	primary = g_strdup_printf("Enter the SecurID key for %s.", purple_account_get_username(account));
+	purple_request_input(gc, NULL, _("Enter SecurID"), primary,
+					   _("Enter the 6 digit number from the digital display."),
+					   FALSE, FALSE, NULL,
+					   _("_OK"), G_CALLBACK(purple_parse_auth_securid_request_yes_cb),
+					   _("_Cancel"), G_CALLBACK(purple_parse_auth_securid_request_no_cb),
+					   account, NULL, NULL,
+					   gc);
+	g_free(primary);
+
+	return 1;
+}
+
+/**
+ * Only used when connecting with the old-style BUCP login.
+ */
+static int
+purple_parse_login(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	ClientInfo aiminfo = CLIENTINFO_PURPLE_AIM;
+	ClientInfo icqinfo = CLIENTINFO_PURPLE_ICQ;
+	va_list ap;
+	char *key;
+	gboolean truncate_pass;
+
+	gc = od->gc;
+	account = purple_connection_get_account(gc);
+
+	va_start(ap, fr);
+	key = va_arg(ap, char *);
+	truncate_pass = va_arg(ap, int);
+	va_end(ap);
+
+	aim_send_login(od, conn, purple_account_get_username(account),
+			purple_connection_get_password(gc), truncate_pass,
+			od->icq ? &icqinfo : &aiminfo, key,
+			purple_account_get_bool(account, "allow_multiple_logins", OSCAR_DEFAULT_ALLOW_MULTIPLE_LOGINS));
+
+	purple_connection_update_progress(gc, _("Password sent"), 2, OSCAR_CONNECT_STEPS);
+
+	return 1;
+}
+
+static int
+purple_handle_redirect(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	PurpleConnection *gc = od->gc;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	char *host, *separator;
+	int port;
+	FlapConnection *newconn;
+	va_list ap;
+	struct aim_redirect_data *redir;
+
+	va_start(ap, fr);
+	redir = va_arg(ap, struct aim_redirect_data *);
+	va_end(ap);
+
+	port = od->default_port;
+	separator = strchr(redir->ip, ':');
+	if (separator != NULL)
+	{
+		host = g_strndup(redir->ip, separator - redir->ip);
+		port = atoi(separator + 1);
+	}
+	else
+		host = g_strdup(redir->ip);
+
+	if (!redir->use_ssl) {
+		const gchar *encryption_type = purple_account_get_string(account, "encryption", OSCAR_DEFAULT_ENCRYPTION);
+		if (strcmp(encryption_type, OSCAR_OPPORTUNISTIC_ENCRYPTION) == 0) {
+			purple_debug_warning("oscar", "We won't use SSL for FLAP type 0x%04hx.\n", redir->group);
+		} else if (strcmp(encryption_type, OSCAR_REQUIRE_ENCRYPTION) == 0) {
+			purple_debug_error("oscar", "FLAP server %s:%d of type 0x%04hx doesn't support encryption.", host, port, redir->group);
+			purple_connection_error_reason(
+				gc,
+				PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,
+				_("You required encryption in your account settings, but one of the servers doesn't support it."));
+			return 0;
+		}
+	}
+
+	/*
+	 * These FLAP servers advertise SSL (type "0x02"), but SSL connections to these hosts
+	 * die a painful death. iChat and Miranda, when using SSL, still do these in plaintext.
+	 */
+	if (redir->use_ssl && (redir->group == SNAC_FAMILY_ADMIN ||
+	                       redir->group == SNAC_FAMILY_BART))
+	{
+		purple_debug_info("oscar", "Ignoring broken SSL for FLAP type 0x%04hx.\n", redir->group);
+		redir->use_ssl = 0;
+	}
+
+	purple_debug_info("oscar", "Connecting to FLAP server %s:%d of type 0x%04hx\n", host, port, redir->group);
+
+	newconn = flap_connection_new(od, redir->group);
+	newconn->cookielen = redir->cookielen;
+	newconn->cookie = g_memdup(redir->cookie, redir->cookielen);
+	if (newconn->type == SNAC_FAMILY_CHAT)
+	{
+		struct chat_connection *cc;
+		cc = g_new0(struct chat_connection, 1);
+		cc->conn = newconn;
+		cc->gc = gc;
+		cc->name = g_strdup(redir->chat.room);
+		cc->exchange = redir->chat.exchange;
+		cc->instance = redir->chat.instance;
+		cc->show = extract_name(redir->chat.room);
+		newconn->new_conn_data = cc;
+		purple_debug_info("oscar", "Connecting to chat room %s exchange %hu\n", cc->name, cc->exchange);
+	}
+
+
+	if (redir->use_ssl)
+	{
+		newconn->gsc = purple_ssl_connect_with_ssl_cn(account, host, port,
+				ssl_connection_established_cb, ssl_connection_error_cb,
+				redir->ssl_cert_cn, newconn);
+	}
+	else
+	{
+		newconn->connect_data = purple_proxy_connect(NULL, account, host, port,
+				connection_established_cb, newconn);
+	}
+
+	if (newconn->gsc == NULL && newconn->connect_data == NULL)
+	{
+		flap_connection_schedule_destroy(newconn,
+				OSCAR_DISCONNECT_COULD_NOT_CONNECT,
+				_("Unable to initialize connection"));
+		purple_debug_error("oscar", "Unable to connect to FLAP server "
+				"of type 0x%04hx\n", redir->group);
+	}
+	g_free(host);
+
+	return 1;
+}
+
+
+static int purple_parse_oncoming(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	PurpleBuddy *buddy = NULL;
+	PurpleStatus *previous_status = NULL;
+	struct buddyinfo *bi;
+	time_t time_idle = 0, signon = 0;
+	int type = 0;
+	gboolean buddy_is_away = FALSE;
+	const char *status_id;
+	va_list ap;
+	aim_userinfo_t *info;
+	char *message;
+	char *itmsurl = NULL;
+
+	gc = od->gc;
+	account = purple_connection_get_account(gc);
+
+	va_start(ap, fr);
+	info = va_arg(ap, aim_userinfo_t *);
+	va_end(ap);
+
+	g_return_val_if_fail(info != NULL, 1);
+	g_return_val_if_fail(info->bn != NULL, 1);
+
+	buddy = purple_find_buddy(account, info->bn);
+	if (buddy) {
+		previous_status = purple_presence_get_active_status(purple_buddy_get_presence(buddy));
+	}
+
+	/*
+	 * If this is an AIM buddy and their name has formatting, set their
+	 * server alias.
+	 */
+	if (!oscar_util_valid_name_icq(info->bn)) {
+		gboolean bn_has_formatting = FALSE;
+		char *c;
+		for (c = info->bn; *c != '\0'; c++) {
+			if (!islower(*c)) {
+				bn_has_formatting = TRUE;
+				break;
+			}
+		}
+		serv_got_alias(gc, info->bn,
+				bn_has_formatting ? info->bn : NULL);
+	}
+
+	if (info->present & AIM_USERINFO_PRESENT_FLAGS) {
+		if (info->flags & AIM_FLAG_AWAY)
+			buddy_is_away = TRUE;
+	}
+	if (info->present & AIM_USERINFO_PRESENT_ICQEXTSTATUS) {
+		type = info->icqinfo.status;
+		if (!(info->icqinfo.status & AIM_ICQ_STATE_CHAT) &&
+		      (info->icqinfo.status != AIM_ICQ_STATE_NORMAL)) {
+			buddy_is_away = TRUE;
+		}
+	}
+
+	if (oscar_util_valid_name_icq(info->bn)) {
+		if (type & AIM_ICQ_STATE_CHAT)
+			status_id = OSCAR_STATUS_ID_FREE4CHAT;
+		else if (type & AIM_ICQ_STATE_DND)
+			status_id = OSCAR_STATUS_ID_DND;
+		else if (type & AIM_ICQ_STATE_OUT)
+			status_id = OSCAR_STATUS_ID_NA;
+		else if (type & AIM_ICQ_STATE_BUSY)
+			status_id = OSCAR_STATUS_ID_OCCUPIED;
+		else if (type & AIM_ICQ_STATE_AWAY)
+			status_id = OSCAR_STATUS_ID_AWAY;
+		else if (type & AIM_ICQ_STATE_INVISIBLE)
+			status_id = OSCAR_STATUS_ID_INVISIBLE;
+		else if (type & AIM_ICQ_STATE_EVIL)
+			status_id = OSCAR_STATUS_ID_EVIL;
+		else if (type & AIM_ICQ_STATE_DEPRESSION)
+			status_id = OSCAR_STATUS_ID_DEPRESSION;
+		else if (type & AIM_ICQ_STATE_ATHOME)
+			status_id = OSCAR_STATUS_ID_ATHOME;
+		else if (type & AIM_ICQ_STATE_ATWORK)
+			status_id = OSCAR_STATUS_ID_ATWORK;
+		else if (type & AIM_ICQ_STATE_LUNCH)
+			status_id = OSCAR_STATUS_ID_LUNCH;
+		else
+			status_id = OSCAR_STATUS_ID_AVAILABLE;
+	} else {
+		if (type & AIM_ICQ_STATE_INVISIBLE)
+			status_id = OSCAR_STATUS_ID_INVISIBLE;
+		else if (buddy_is_away)
+			status_id = OSCAR_STATUS_ID_AWAY;
+		else
+			status_id = OSCAR_STATUS_ID_AVAILABLE;
+	}
+
+	if (info->flags & AIM_FLAG_WIRELESS) {
+		purple_prpl_got_user_status(account, info->bn, OSCAR_STATUS_ID_MOBILE, NULL);
+	} else {
+		purple_prpl_got_user_status_deactive(account, info->bn, OSCAR_STATUS_ID_MOBILE);
+	}
+
+	message = (info->status && info->status_len > 0)
+			? oscar_encoding_to_utf8(info->status_encoding, info->status, info->status_len)
+			: NULL;
+
+	if (strcmp(status_id, OSCAR_STATUS_ID_AVAILABLE) == 0) {
+		/* TODO: If itmsurl is NULL, does that mean the URL has been
+		   cleared?  Or does it mean the URL should remain unchanged? */
+		if (info->itmsurl != NULL) {
+			itmsurl = (info->itmsurl_len > 0) ? oscar_encoding_to_utf8(info->itmsurl_encoding, info->itmsurl, info->itmsurl_len) : NULL;
+		} else if (previous_status != NULL && purple_status_is_available(previous_status)) {
+			itmsurl = g_strdup(purple_status_get_attr_string(previous_status, "itmsurl"));
+		}
+		purple_debug_info("oscar", "Activating status '%s' for buddy %s, message = '%s', itmsurl = '%s'\n", status_id, info->bn, message ? message : "(null)", itmsurl ? itmsurl : "(null)");
+		purple_prpl_got_user_status(account, info->bn, status_id, "message", message, "itmsurl", itmsurl, NULL);
+	} else {
+		purple_debug_info("oscar", "Activating status '%s' for buddy %s, message = '%s'\n", status_id, info->bn, message ? message : "(null)");
+		purple_prpl_got_user_status(account, info->bn, status_id, "message", message, NULL);
+	}
+
+	g_free(message);
+	g_free(itmsurl);
+
+	/* Login time stuff */
+	if (info->present & AIM_USERINFO_PRESENT_ONLINESINCE)
+		signon = info->onlinesince;
+	else if (info->present & AIM_USERINFO_PRESENT_SESSIONLEN)
+		signon = time(NULL) - info->sessionlen;
+	purple_prpl_got_user_login_time(account, info->bn, signon);
+
+	/* Idle time stuff */
+	/* info->idletime is the number of minutes that this user has been idle */
+	if (info->present & AIM_USERINFO_PRESENT_IDLE)
+		time_idle = time(NULL) - info->idletime * 60;
+
+	if (time_idle > 0)
+		purple_prpl_got_user_idle(account, info->bn, TRUE, time_idle);
+	else
+		purple_prpl_got_user_idle(account, info->bn, FALSE, 0);
+
+	/* Server stored icon stuff */
+	bi = g_hash_table_lookup(od->buddyinfo, purple_normalize(account, info->bn));
+	if (!bi) {
+		bi = g_new0(struct buddyinfo, 1);
+		g_hash_table_insert(od->buddyinfo, g_strdup(purple_normalize(account, info->bn)), bi);
+	}
+	bi->typingnot = FALSE;
+	bi->ico_informed = FALSE;
+	bi->ipaddr = info->icqinfo.ipaddr;
+
+	if (info->iconcsumlen) {
+		const char *saved_b16 = NULL;
+		char *b16 = NULL;
+		PurpleBuddy *b = NULL;
+
+		b16 = purple_base16_encode(info->iconcsum, info->iconcsumlen);
+		b = purple_find_buddy(account, info->bn);
+		if (b != NULL)
+			saved_b16 = purple_buddy_icons_get_checksum_for_user(b);
+
+		if (!b16 || !saved_b16 || strcmp(b16, saved_b16)) {
+			/* Invalidate the old icon for this user */
+			purple_buddy_icons_set_for_user(account, info->bn, NULL, 0, NULL);
+
+			/* Fetch the new icon (if we're not already doing so) */
+			if (g_slist_find_custom(od->requesticon, info->bn,
+					(GCompareFunc)oscar_util_name_compare) == NULL)
+			{
+				od->requesticon = g_slist_prepend(od->requesticon,
+						g_strdup(purple_normalize(account, info->bn)));
+				purple_icons_fetch(gc);
+			}
+		}
+		g_free(b16);
+	}
+
+	return 1;
+}
+
+static int purple_parse_offgoing(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	va_list ap;
+	aim_userinfo_t *info;
+
+	va_start(ap, fr);
+	info = va_arg(ap, aim_userinfo_t *);
+	va_end(ap);
+
+	purple_prpl_got_user_status(account, info->bn, OSCAR_STATUS_ID_OFFLINE, NULL);
+	purple_prpl_got_user_status_deactive(account, info->bn, OSCAR_STATUS_ID_MOBILE);
+	g_hash_table_remove(od->buddyinfo, purple_normalize(gc->account, info->bn));
+
+	return 1;
+}
+
+static int incomingim_chan1(OscarData *od, FlapConnection *conn, aim_userinfo_t *userinfo, struct aim_incomingim_ch1_args *args) {
+	PurpleConnection *gc = od->gc;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	PurpleMessageFlags flags = 0;
+	struct buddyinfo *bi;
+	PurpleStoredImage *img;
+	gchar *tmp;
+	const char *start, *end;
+	GData *attribs;
+
+	purple_debug_misc("oscar", "Received IM from %s\n", userinfo->bn);
+
+	bi = g_hash_table_lookup(od->buddyinfo, purple_normalize(account, userinfo->bn));
+	if (!bi) {
+		bi = g_new0(struct buddyinfo, 1);
+		g_hash_table_insert(od->buddyinfo, g_strdup(purple_normalize(account, userinfo->bn)), bi);
+	}
+
+	if (args->icbmflags & AIM_IMFLAGS_AWAY)
+		flags |= PURPLE_MESSAGE_AUTO_RESP;
+
+	if (args->icbmflags & AIM_IMFLAGS_TYPINGNOT)
+		bi->typingnot = TRUE;
+	else
+		bi->typingnot = FALSE;
+
+	if ((args->icbmflags & AIM_IMFLAGS_HASICON) && (args->iconlen) && (args->iconsum) && (args->iconstamp)) {
+		purple_debug_misc("oscar", "%s has an icon\n", userinfo->bn);
+		if ((args->iconlen != bi->ico_len) || (args->iconsum != bi->ico_csum) || (args->iconstamp != bi->ico_time)) {
+			bi->ico_need = TRUE;
+			bi->ico_len = args->iconlen;
+			bi->ico_csum = args->iconsum;
+			bi->ico_time = args->iconstamp;
+		}
+	}
+
+	img = purple_buddy_icons_find_account_icon(account);
+	if ((img != NULL) &&
+	    (args->icbmflags & AIM_IMFLAGS_BUDDYREQ) && !bi->ico_sent && bi->ico_informed) {
+		gconstpointer data = purple_imgstore_get_data(img);
+		size_t len = purple_imgstore_get_size(img);
+		purple_debug_info("oscar",
+				"Sending buddy icon to %s (%" G_GSIZE_FORMAT " bytes)\n",
+				userinfo->bn, len);
+		aim_im_sendch2_icon(od, userinfo->bn, data, len,
+			purple_buddy_icons_get_account_icon_timestamp(account),
+			aimutil_iconsum(data, len));
+	}
+	purple_imgstore_unref(img);
+
+	tmp = g_strdup(args->msg);
+
+	/*
+	 * Convert iChat color tags to normal font tags.
+	 */
+	if (purple_markup_find_tag("body", tmp, &start, &end, &attribs))
+	{
+		int len;
+		char *tmp2, *body;
+		const char *ichattextcolor, *ichatballooncolor;
+		const char *slash_body_start, *slash_body_end = NULL; /* </body> */
+		GData *unused;
+
+		/*
+		 * Find the ending </body> so we can strip off the outer <html/>
+		 * and <body/>
+		 */
+		if (purple_markup_find_tag("/body", end + 1, &slash_body_start, &slash_body_end, &unused))
+		{
+			body = g_strndup(start, slash_body_end - start + 1);
+			g_datalist_clear(&unused);
+		}
+		else
+		{
+			purple_debug_warning("oscar", "Broken message contains <body> but not </body>!\n");
+			/* Take everything after <body> */
+			body = g_strdup(start);
+		}
+
+		ichattextcolor = g_datalist_get_data(&attribs, "ichattextcolor");
+		if (ichattextcolor != NULL)
+		{
+			tmp2 = g_strdup_printf("<font color=\"%s\">%s</font>", ichattextcolor, body);
+			g_free(body);
+			body = tmp2;
+		}
+
+		ichatballooncolor = g_datalist_get_data(&attribs, "ichatballooncolor");
+		if (ichatballooncolor != NULL)
+		{
+			tmp2 = g_strdup_printf("<font back=\"%s\">%s</font>", ichatballooncolor, body);
+			g_free(body);
+			body = tmp2;
+		}
+
+		g_datalist_clear(&attribs);
+
+		len = start - tmp;
+		tmp2 = g_strdup_printf("%.*s%s%s", len, tmp, body, slash_body_end ? slash_body_end + 1: "</body>");
+		g_free(tmp);
+		g_free(body);
+
+		tmp = tmp2;
+	}
+
+	/*
+	 * Are there <html/> surrounding tags? If so, strip them out, too.
+	 */
+	if (purple_markup_find_tag("html", tmp, &start, &end, &attribs))
+	{
+		gchar *tmp2;
+		int len;
+
+		g_datalist_clear(&attribs);
+
+		len = start - tmp;
+		tmp2 = g_strdup_printf("%.*s%s", len, tmp, end + 1);
+		g_free(tmp);
+		tmp = tmp2;
+	}
+
+	if (purple_markup_find_tag("/html", tmp, &start, &end, &attribs))
+	{
+		gchar *tmp2;
+		int len;
+
+		g_datalist_clear(&attribs);
+
+		len = start - tmp;
+		tmp2 = g_strdup_printf("%.*s%s", len, tmp, end + 1);
+		g_free(tmp);
+		tmp = tmp2;
+	}
+
+	serv_got_im(gc, userinfo->bn, tmp, flags, (args->icbmflags & AIM_IMFLAGS_OFFLINE) ? args->timestamp : time(NULL));
+	g_free(tmp);
+
+	return 1;
+}
+
+static int
+incomingim_chan2(OscarData *od, FlapConnection *conn, aim_userinfo_t *userinfo, IcbmArgsCh2 *args)
+{
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	PurpleMessageFlags flags = 0;
+	char *message = NULL;
+
+	g_return_val_if_fail(od != NULL, 0);
+	g_return_val_if_fail(od->gc != NULL, 0);
+
+	gc = od->gc;
+	account = purple_connection_get_account(gc);
+	od = purple_connection_get_protocol_data(gc);
+
+	if (args == NULL)
+		return 0;
+
+	purple_debug_misc("oscar", "Incoming rendezvous message of type %"
+			G_GUINT64_FORMAT ", user %s, status %hu\n",
+			args->type, userinfo->bn, args->status);
+
+	if (args->msg != NULL) {
+		message = oscar_encoding_to_utf8(args->encoding, args->msg, args->msglen);
+	}
+
+	if (args->type & OSCAR_CAPABILITY_CHAT)
+	{
+		char *utf8name, *tmp;
+		GHashTable *components;
+
+		if (!args->info.chat.roominfo.name || !args->info.chat.roominfo.exchange) {
+			g_free(message);
+			return 1;
+		}
+		utf8name = oscar_encoding_to_utf8(args->encoding, args->info.chat.roominfo.name, args->info.chat.roominfo.namelen);
+
+		tmp = extract_name(utf8name);
+		if (tmp != NULL)
+		{
+			g_free(utf8name);
+			utf8name = tmp;
+		}
+
+		components = g_hash_table_new_full(g_str_hash, g_str_equal, g_free,
+				g_free);
+		g_hash_table_replace(components, g_strdup("room"), utf8name);
+		g_hash_table_replace(components, g_strdup("exchange"),
+				g_strdup_printf("%d", args->info.chat.roominfo.exchange));
+		serv_got_chat_invite(gc,
+				     utf8name,
+				     userinfo->bn,
+				     message,
+				     components);
+	}
+
+	else if ((args->type & OSCAR_CAPABILITY_SENDFILE) || (args->type & OSCAR_CAPABILITY_DIRECTIM))
+	{
+		if (args->status == AIM_RENDEZVOUS_PROPOSE)
+		{
+			peer_connection_got_proposition(od, userinfo->bn, message, args);
+		}
+		else if (args->status == AIM_RENDEZVOUS_CANCEL)
+		{
+			/* The other user cancelled a peer request */
+			PeerConnection *conn;
+
+			conn = peer_connection_find_by_cookie(od, userinfo->bn, args->cookie);
+			/*
+			 * If conn is NULL it means we haven't tried to create
+			 * a connection with that user.  They may be trying to
+			 * do something malicious.
+			 */
+			if (conn != NULL)
+			{
+				peer_connection_destroy(conn, OSCAR_DISCONNECT_REMOTE_CLOSED, NULL);
+			}
+		}
+		else if (args->status == AIM_RENDEZVOUS_CONNECTED)
+		{
+			/*
+			 * Remote user has accepted our peer request.  If we
+			 * wanted to we could look up the PeerConnection using
+			 * args->cookie, but we don't need to do anything here.
+			 */
+		}
+	}
+
+	else if (args->type & OSCAR_CAPABILITY_GETFILE)
+	{
+	}
+
+	else if (args->type & OSCAR_CAPABILITY_TALK)
+	{
+	}
+
+	else if (args->type & OSCAR_CAPABILITY_BUDDYICON)
+	{
+		purple_buddy_icons_set_for_user(account, userinfo->bn,
+									  g_memdup(args->info.icon.icon, args->info.icon.length),
+									  args->info.icon.length,
+									  NULL);
+	}
+
+	else if (args->type & OSCAR_CAPABILITY_ICQSERVERRELAY)
+	{
+		purple_debug_info("oscar", "Got an ICQ Server Relay message of "
+				"type %d\n", args->info.rtfmsg.msgtype);
+
+		if (args->info.rtfmsg.msgtype == 1) {
+			if (args->info.rtfmsg.msg != NULL) {
+				char *rtfmsg;
+				const char *encoding = args->encoding;
+				size_t len = strlen(args->info.rtfmsg.msg);
+				char *tmp, *tmp2;
+
+				if (encoding == NULL && !g_utf8_validate(args->info.rtfmsg.msg, len, NULL)) {
+					/* Yet another wonderful Miranda-related hack. If their user disables the "Send Unicode messages" setting,
+					 * Miranda sends us ch2 messages in whatever Windows codepage is set as default on their user's system (instead of UTF-8).
+					 * Of course, they don't bother to specify that codepage. Let's just fallback to the encoding OUR users can
+					 * specify in account options as a last resort.
+					 */
+					encoding = purple_account_get_string(account, "encoding", OSCAR_DEFAULT_CUSTOM_ENCODING);
+					purple_debug_info("oscar", "Miranda, is that you? Using '%s' as encoding\n", encoding);
+				}
+
+				rtfmsg = oscar_encoding_to_utf8(encoding, args->info.rtfmsg.msg, len);
+
+				/* Channel 2 messages are supposed to be plain-text (never mind the name "rtfmsg", even
+				 * the official client doesn't parse them as RTF). Therefore, we should escape them before
+				 * showing to the user. */
+				tmp = g_markup_escape_text(rtfmsg, -1);
+				g_free(rtfmsg);
+				tmp2 = purple_strreplace(tmp, "\r\n", "<br>");
+				g_free(tmp);
+
+				serv_got_im(gc, userinfo->bn, tmp2, flags, time(NULL));
+				aim_im_send_icq_confirmation(od, userinfo->bn, args->cookie);
+				g_free(tmp2);
+			}
+		} else if (args->info.rtfmsg.msgtype == 26) {
+			purple_debug_info("oscar", "Sending X-Status Reply\n");
+			icq_relay_xstatus(od, userinfo->bn, args->cookie);
+		}
+	}
+	else
+	{
+		purple_debug_error("oscar", "Unknown request class %"
+				G_GUINT64_FORMAT "\n", args->type);
+	}
+
+	g_free(message);
+
+	return 1;
+}
+
+/* When someone sends you buddies */
+static void
+purple_icq_buddyadd(struct name_data *data)
+{
+	PurpleConnection *gc = data->gc;
+
+	purple_blist_request_add_buddy(purple_connection_get_account(gc), data->name, NULL, data->nick);
+
+	oscar_free_name_data(data);
+}
+
+static int
+incomingim_chan4(OscarData *od, FlapConnection *conn, aim_userinfo_t *userinfo, struct aim_incomingim_ch4_args *args, time_t t)
+{
+	PurpleConnection *gc = od->gc;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	gchar **msg1, **msg2;
+	int i, numtoks;
+
+	if (!args->type || !args->msg || !args->uin)
+		return 1;
+
+	purple_debug_info("oscar",
+		"Received a channel 4 message of type 0x%02hx.\n",
+		(guint16)args->type);
+
+	/*
+	 * Split up the message at the delimeter character, then convert each
+	 * string to UTF-8.  Unless, of course, this is a type 1 message.  If
+	 * this is a type 1 message, then the delimiter 0xfe could be a valid
+	 * character in whatever encoding the message was sent in.  Type 1
+	 * messages are always made up of only one part, so we can easily account
+	 * for this suck-ass part of the protocol by splitting the string into at
+	 * most 1 baby string.
+	 */
+	msg1 = g_strsplit(args->msg, "\376", (args->type == 0x01 ? 1 : 0));
+	for (numtoks=0; msg1[numtoks]; numtoks++);
+	msg2 = (gchar **)g_malloc((numtoks+1)*sizeof(gchar *));
+	for (i=0; msg1[i]; i++) {
+		gchar *uin = g_strdup_printf("%u", args->uin);
+
+		purple_str_strip_char(msg1[i], '\r');
+		/* TODO: Should use an encoding other than ASCII? */
+		msg2[i] = oscar_decode_im(account, uin, AIM_CHARSET_ASCII, msg1[i], strlen(msg1[i]));
+		g_free(uin);
+	}
+	msg2[i] = NULL;
+
+	switch (args->type) {
+		case 0x01: { /* MacICQ message or basic offline message */
+			if (i >= 1) {
+				gchar *uin = g_strdup_printf("%u", args->uin);
+				gchar *tmp;
+
+				/* If the message came from an ICQ user then escape any HTML */
+				tmp = g_markup_escape_text(msg2[0], -1);
+
+				if (t) { /* This is an offline message */
+					/* The timestamp is UTC-ish, so we need to get the offset */
+#ifdef HAVE_TM_GMTOFF
+					time_t now;
+					struct tm *tm;
+					now = time(NULL);
+					tm = localtime(&now);
+					t += tm->tm_gmtoff;
+#else
+#	ifdef HAVE_TIMEZONE
+					tzset();
+					t -= timezone;
+#	endif
+#endif
+					serv_got_im(gc, uin, tmp, 0, t);
+				} else { /* This is a message from MacICQ/Miranda */
+					serv_got_im(gc, uin, tmp, 0, time(NULL));
+				}
+				g_free(uin);
+				g_free(tmp);
+			}
+		} break;
+
+		case 0x04: { /* Someone sent you a URL */
+			if (i >= 2) {
+				if (msg2[1] != NULL) {
+					gchar *uin = g_strdup_printf("%u", args->uin);
+					gchar *message = g_strdup_printf("<A HREF=\"%s\">%s</A>",
+													 msg2[1],
+													 (msg2[0] && msg2[0][0]) ? msg2[0] : msg2[1]);
+					serv_got_im(gc, uin, message, 0, time(NULL));
+					g_free(uin);
+					g_free(message);
+				}
+			}
+		} break;
+
+		case 0x06: { /* Someone requested authorization */
+			if (i >= 6) {
+				gchar *bn = g_strdup_printf("%u", args->uin);
+				gchar *reason = NULL;
+
+				if (msg2[5] != NULL)
+					reason = oscar_decode_im(account, bn, AIM_CHARSET_LATIN_1, msg2[5], strlen(msg2[5]));
+
+				purple_debug_info("oscar",
+						   "Received an authorization request from UIN %u\n",
+						   args->uin);
+				aim_icq_getalias(od, bn, TRUE, reason);
+				g_free(bn);
+				g_free(reason);
+			}
+		} break;
+
+		case 0x07: { /* Someone has denied you authorization */
+			if (i >= 1) {
+				gchar *dialog_msg = g_strdup_printf(_("The user %u has denied your request to add them to your buddy list for the following reason:\n%s"), args->uin, msg2[0] ? msg2[0] : _("No reason given."));
+				purple_notify_info(gc, NULL, _("ICQ authorization denied."),
+								 dialog_msg);
+				g_free(dialog_msg);
+			}
+		} break;
+
+		case 0x08: { /* Someone has granted you authorization */
+			gchar *dialog_msg = g_strdup_printf(_("The user %u has granted your request to add them to your buddy list."), args->uin);
+			purple_notify_info(gc, NULL, "ICQ authorization accepted.",
+							 dialog_msg);
+			g_free(dialog_msg);
+		} break;
+
+		case 0x09: { /* Message from the Godly ICQ server itself, I think */
+			if (i >= 5) {
+				gchar *dialog_msg = g_strdup_printf(_("You have received a special message\n\nFrom: %s [%s]\n%s"), msg2[0], msg2[3], msg2[5]);
+				purple_notify_info(gc, NULL, "ICQ Server Message", dialog_msg);
+				g_free(dialog_msg);
+			}
+		} break;
+
+		case 0x0d: { /* Someone has sent you a pager message from http://www.icq.com/your_uin */
+			if (i >= 6) {
+				gchar *dialog_msg = g_strdup_printf(_("You have received an ICQ page\n\nFrom: %s [%s]\n%s"), msg2[0], msg2[3], msg2[5]);
+				purple_notify_info(gc, NULL, "ICQ Page", dialog_msg);
+				g_free(dialog_msg);
+			}
+		} break;
+
+		case 0x0e: { /* Someone has emailed you at your_uin@pager.icq.com */
+			if (i >= 6) {
+				gchar *dialog_msg = g_strdup_printf(_("You have received an ICQ email from %s [%s]\n\nMessage is:\n%s"), msg2[0], msg2[3], msg2[5]);
+				purple_notify_info(gc, NULL, "ICQ Email", dialog_msg);
+				g_free(dialog_msg);
+			}
+		} break;
+
+		case 0x12: {
+			/* Ack for authorizing/denying someone.  Or possibly an ack for sending any system notice */
+			/* Someone added you to their buddy list? */
+		} break;
+
+		case 0x13: { /* Someone has sent you some ICQ buddies */
+			guint i, num;
+			gchar **text;
+			text = g_strsplit(args->msg, "\376", 0);
+			if (text) {
+				/* Read the number of contacts that we were sent */
+				errno = 0;
+				num = text[0] ? strtoul(text[0], NULL, 10) : 0;
+
+				if (num > 0 && errno == 0) {
+					for (i=0; i<num; i++) {
+						struct name_data *data;
+						gchar *message;
+
+						if (!text[i*2 + 1] || !text[i*2 + 2]) {
+							/* We're missing the contact name or nickname.  Bail out. */
+							gchar *tmp = g_strescape(args->msg, NULL);
+							purple_debug_error("oscar", "Unknown syntax parsing "
+									"ICQ buddies.  args->msg=%s\n", tmp);
+							g_free(tmp);
+							break;
+						}
+
+						message = g_strdup_printf(_("ICQ user %u has sent you a buddy: %s (%s)"), args->uin, text[i*2+2], text[i*2+1]);
+
+						data = g_new(struct name_data, 1);
+						data->gc = gc;
+						data->name = g_strdup(text[i*2+1]);
+						data->nick = g_strdup(text[i*2+2]);
+
+						purple_request_action(gc, NULL, message,
+								_("Do you want to add this buddy "
+								  "to your buddy list?"),
+								PURPLE_DEFAULT_ACTION_NONE,
+								purple_connection_get_account(gc), data->name, NULL,
+								data, 2,
+								_("_Add"), G_CALLBACK(purple_icq_buddyadd),
+								_("_Decline"), G_CALLBACK(oscar_free_name_data));
+						g_free(message);
+					}
+				} else {
+					gchar *tmp = g_strescape(args->msg, NULL);
+					purple_debug_error("oscar", "Unknown syntax parsing "
+							"ICQ buddies.  args->msg=%s\n", tmp);
+					g_free(tmp);
+				}
+				g_strfreev(text);
+			}
+		} break;
+
+		case 0x1a: { /* Handle SMS or someone has sent you a greeting card or requested buddies? */
+			ByteStream qbs;
+			guint16 smstype;
+			guint32 taglen, smslen;
+			char *tagstr = NULL, *smsmsg = NULL;
+			xmlnode *xmlroot = NULL, *xmltmp = NULL;
+			gchar *uin = NULL, *message = NULL;
+
+			/* From libicq2000-0.3.2/src/ICQ.cpp */
+			byte_stream_init(&qbs, (guint8 *)args->msg, args->msglen);
+			byte_stream_advance(&qbs, 21);
+			/* expected:	01 00 00 20 00 0e 28 f6 00 11 e7 d3 11 bc f3 00 04 ac 96 9d c2 | 00 00 | 06 00 00 00 | 49 43 51 53 43 53 ...*/
+			/* unexpected:	00 00 26 00 81 1a 18 bc 0e 6c 18 47 a5 91 6f 18 dc c7 6f 1a | 00 00 | 0d 00 00 00 | 49 43 51 57 65 62 4d 65 73 73 61 67 65 ... */
+			smstype = byte_stream_getle16(&qbs);
+			if (smstype != 0)
+				break;
+			taglen = byte_stream_getle32(&qbs);
+			if (taglen > 2000) {
+				/* Avoid trying to allocate large amounts of memory, in
+				   case we get something unexpected. */
+				break;
+			}
+			tagstr = byte_stream_getstr(&qbs, taglen);
+			if (tagstr == NULL)
+				break;
+			byte_stream_advance(&qbs, 3);
+			byte_stream_advance(&qbs, 4);
+			smslen = byte_stream_getle32(&qbs);
+			if (smslen > 2000) {
+				/* Avoid trying to allocate large amounts of memory, in
+				   case we get something unexpected. */
+				g_free(tagstr);
+				break;
+			}
+			smsmsg = byte_stream_getstr(&qbs, smslen);
+
+			/* Check if this is an SMS being sent from server */
+			if ((smstype == 0) && (!strcmp(tagstr, "ICQSMS")) && (smsmsg != NULL))
+			{
+				xmlroot = xmlnode_from_str(smsmsg, -1);
+				if (xmlroot != NULL)
+				{
+					xmltmp = xmlnode_get_child(xmlroot, "sender");
+					if (xmltmp != NULL)
+						uin = xmlnode_get_data(xmltmp);
+
+					xmltmp = xmlnode_get_child(xmlroot, "text");
+					if (xmltmp != NULL)
+						message = xmlnode_get_data(xmltmp);
+
+					if ((uin != NULL) && (message != NULL))
+							serv_got_im(gc, uin, message, 0, time(NULL));
+
+					g_free(uin);
+					g_free(message);
+					xmlnode_free(xmlroot);
+				}
+			}
+			g_free(tagstr);
+			g_free(smsmsg);
+		} break;
+
+		default: {
+			purple_debug_info("oscar",
+					   "Received a channel 4 message of unknown type "
+					   "(type 0x%02hhx).\n", args->type);
+		} break;
+	}
+
+	g_strfreev(msg1);
+	g_strfreev(msg2);
+
+	return 1;
+}
+
+static int purple_parse_incoming_im(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	guint16 channel;
+	int ret = 0;
+	aim_userinfo_t *userinfo;
+	va_list ap;
+
+	va_start(ap, fr);
+	channel = (guint16)va_arg(ap, unsigned int);
+	userinfo = va_arg(ap, aim_userinfo_t *);
+
+	switch (channel) {
+		case 1: { /* standard message */
+			struct aim_incomingim_ch1_args *args;
+			args = va_arg(ap, struct aim_incomingim_ch1_args *);
+			ret = incomingim_chan1(od, conn, userinfo, args);
+		} break;
+
+		case 2: { /* rendezvous */
+			IcbmArgsCh2 *args;
+			args = va_arg(ap, IcbmArgsCh2 *);
+			ret = incomingim_chan2(od, conn, userinfo, args);
+		} break;
+
+		case 4: { /* ICQ */
+			struct aim_incomingim_ch4_args *args;
+			args = va_arg(ap, struct aim_incomingim_ch4_args *);
+			ret = incomingim_chan4(od, conn, userinfo, args, 0);
+		} break;
+
+		default: {
+			purple_debug_warning("oscar",
+					   "ICBM received on unsupported channel (channel "
+					   "0x%04hx).", channel);
+		} break;
+	}
+
+	va_end(ap);
+
+	return ret;
+}
+
+static int purple_parse_misses(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	char *buf;
+	va_list ap;
+	guint16 nummissed, reason;
+	aim_userinfo_t *userinfo;
+
+	va_start(ap, fr);
+	va_arg(ap, unsigned int); /* guint16 chan */
+	userinfo = va_arg(ap, aim_userinfo_t *);
+	nummissed = (guint16)va_arg(ap, unsigned int);
+	reason = (guint16)va_arg(ap, unsigned int);
+	va_end(ap);
+
+	switch(reason) {
+		case 0: /* Invalid (0) */
+			buf = g_strdup_printf(
+				   dngettext(PACKAGE,
+				   "You missed %hu message from %s because it was invalid.",
+				   "You missed %hu messages from %s because they were invalid.",
+				   nummissed),
+				   nummissed,
+				   userinfo->bn);
+			break;
+		case 1: /* Message too large */
+			buf = g_strdup_printf(
+				   dngettext(PACKAGE,
+				   "You missed %hu message from %s because it was too large.",
+				   "You missed %hu messages from %s because they were too large.",
+				   nummissed),
+				   nummissed,
+				   userinfo->bn);
+			break;
+		case 2: /* Rate exceeded */
+			buf = g_strdup_printf(
+				   dngettext(PACKAGE,
+				   "You missed %hu message from %s because the rate limit has been exceeded.",
+				   "You missed %hu messages from %s because the rate limit has been exceeded.",
+				   nummissed),
+				   nummissed,
+				   userinfo->bn);
+			break;
+		case 3: /* Evil Sender */
+			buf = g_strdup_printf(
+				   dngettext(PACKAGE,
+				   "You missed %hu message from %s because his/her warning level is too high.",
+				   "You missed %hu messages from %s because his/her warning level is too high.",
+				   nummissed),
+				   nummissed,
+				   userinfo->bn);
+			break;
+		case 4: /* Evil Receiver */
+			buf = g_strdup_printf(
+				   dngettext(PACKAGE,
+				   "You missed %hu message from %s because your warning level is too high.",
+				   "You missed %hu messages from %s because your warning level is too high.",
+				   nummissed),
+				   nummissed,
+				   userinfo->bn);
+			break;
+		default:
+			buf = g_strdup_printf(
+				   dngettext(PACKAGE,
+				   "You missed %hu message from %s for an unknown reason.",
+				   "You missed %hu messages from %s for an unknown reason.",
+				   nummissed),
+				   nummissed,
+				   userinfo->bn);
+			break;
+	}
+
+	if (!purple_conv_present_error(userinfo->bn, account, buf))
+		purple_notify_error(od->gc, NULL, buf, NULL);
+	g_free(buf);
+
+	return 1;
+}
+
+static int
+purple_parse_clientauto_ch2(OscarData *od, const char *who, guint16 reason, const guchar *cookie)
+{
+	if (reason == 0x0003)
+	{
+		/* Rendezvous was refused. */
+		PeerConnection *conn;
+
+		conn = peer_connection_find_by_cookie(od, who, cookie);
+
+		if (conn == NULL)
+		{
+			purple_debug_info("oscar", "Received a rendezvous cancel message "
+					"for a nonexistant connection from %s.\n", who);
+		}
+		else
+		{
+			peer_connection_destroy(conn, OSCAR_DISCONNECT_REMOTE_REFUSED, NULL);
+		}
+	}
+	else
+	{
+		purple_debug_warning("oscar", "Received an unknown rendezvous "
+				"message from %s.  Type 0x%04hx\n", who, reason);
+	}
+
+	return 0;
+}
+
+static int purple_parse_clientauto_ch4(OscarData *od, char *who, guint16 reason, guint32 state, char *msg) {
+	PurpleConnection *gc = od->gc;
+
+	switch(reason) {
+		case 0x0003: { /* Reply from an ICQ status message request */
+			char *statusmsg, **splitmsg;
+			PurpleNotifyUserInfo *user_info;
+
+			/* Split at (carriage return/newline)'s, then rejoin later with BRs between. */
+			statusmsg = oscar_icqstatus(state);
+			splitmsg = g_strsplit(msg, "\r\n", 0);
+
+			user_info = purple_notify_user_info_new();
+
+			purple_notify_user_info_add_pair(user_info, _("UIN"), who);
+			purple_notify_user_info_add_pair(user_info, _("Status"), statusmsg);
+			purple_notify_user_info_add_section_break(user_info);
+			purple_notify_user_info_add_pair(user_info, NULL, g_strjoinv("<BR>", splitmsg));
+
+			g_free(statusmsg);
+			g_strfreev(splitmsg);
+
+			purple_notify_userinfo(gc, who, user_info, NULL, NULL);
+			purple_notify_user_info_destroy(user_info);
+
+		} break;
+
+		case 0x0006: { /* Reply from an ICQ status message request */
+			char *statusmsg, **splitmsg;
+			PurpleNotifyUserInfo *user_info;
+
+			/* Split at (carriage return/newline)'s, then rejoin later with BRs between. */
+			statusmsg = oscar_icqstatus(state);
+			splitmsg = g_strsplit(msg, "\r\n", 0);
+
+			user_info = purple_notify_user_info_new();
+
+			purple_notify_user_info_add_pair(user_info, _("UIN"), who);
+			purple_notify_user_info_add_pair(user_info, _("Status"), statusmsg);
+			purple_notify_user_info_add_section_break(user_info);
+			purple_notify_user_info_add_pair(user_info, NULL, g_strjoinv("<BR>", splitmsg));
+
+			g_free(statusmsg);
+			g_strfreev(splitmsg);
+
+			purple_notify_userinfo(gc, who, user_info, NULL, NULL);
+			purple_notify_user_info_destroy(user_info);
+
+		} break;
+
+		default: {
+			purple_debug_warning("oscar",
+					   "Received an unknown client auto-response from %s.  "
+					   "Type 0x%04hx\n", who, reason);
+		} break;
+	} /* end of switch */
+
+	return 0;
+}
+
+static int purple_parse_clientauto(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	va_list ap;
+	guint16 chan, reason;
+	char *who;
+	int ret = 1;
+
+	va_start(ap, fr);
+	chan = (guint16)va_arg(ap, unsigned int);
+	who = va_arg(ap, char *);
+	reason = (guint16)va_arg(ap, unsigned int);
+
+	if (chan == 0x0002) { /* File transfer declined */
+		guchar *cookie = va_arg(ap, guchar *);
+		ret = purple_parse_clientauto_ch2(od, who, reason, cookie);
+	} else if (chan == 0x0004) { /* ICQ message */
+		guint32 state = 0;
+		char *msg = NULL;
+		if (reason == 0x0003) {
+			state = va_arg(ap, guint32);
+			msg = va_arg(ap, char *);
+		}
+		ret = purple_parse_clientauto_ch4(od, who, reason, state, msg);
+	}
+
+	va_end(ap);
+
+	return ret;
+}
+
+static int purple_parse_genericerr(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	va_list ap;
+	guint16 reason;
+
+	va_start(ap, fr);
+	reason = (guint16) va_arg(ap, unsigned int);
+	va_end(ap);
+
+	purple_debug_error("oscar", "snac threw error (reason 0x%04hx: %s)\n",
+			reason, oscar_get_msgerr_reason(reason));
+	return 1;
+}
+
+static int purple_parse_mtn(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	va_list ap;
+	guint16 channel, event;
+	char *bn;
+
+	va_start(ap, fr);
+	channel = (guint16) va_arg(ap, unsigned int);
+	bn = va_arg(ap, char *);
+	event = (guint16) va_arg(ap, unsigned int);
+	va_end(ap);
+
+	switch (event) {
+		case 0x0000: { /* Text has been cleared */
+			serv_got_typing_stopped(gc, bn);
+		} break;
+
+		case 0x0001: { /* Paused typing */
+			serv_got_typing(gc, bn, 0, PURPLE_TYPED);
+		} break;
+
+		case 0x0002: { /* Typing */
+			serv_got_typing(gc, bn, 0, PURPLE_TYPING);
+		} break;
+
+		case 0x000f: { /* Closed IM window */
+			serv_got_typing_stopped(gc, bn);
+		} break;
+
+		default: {
+			purple_debug_info("oscar", "Received unknown typing "
+					"notification message from %s.  Channel is 0x%04x "
+					"and event is 0x%04hx.\n", bn, channel, event);
+		} break;
+	}
+
+	return 1;
+}
+
+static int purple_parse_motd(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	char *msg;
+	guint16 id;
+	va_list ap;
+
+	va_start(ap, fr);
+	id  = (guint16) va_arg(ap, unsigned int);
+	msg = va_arg(ap, char *);
+	va_end(ap);
+
+	purple_debug_misc("oscar",
+			   "MOTD: %s (%hu)\n", msg ? msg : "Unknown", id);
+	if (id < 4)
+		purple_notify_warning(od->gc, NULL,
+							_("Your AIM connection may be lost."), NULL);
+
+	return 1;
+}
+
+static int purple_chatnav_info(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	va_list ap;
+	guint16 type;
+
+	va_start(ap, fr);
+	type = (guint16) va_arg(ap, unsigned int);
+
+	switch(type) {
+		case 0x0002: {
+			GString *msg = g_string_new("");
+			guint8 maxrooms;
+			struct aim_chat_exchangeinfo *exchanges;
+			int exchangecount, i;
+
+			maxrooms = (guint8) va_arg(ap, unsigned int);
+			exchangecount = va_arg(ap, int);
+			exchanges = va_arg(ap, struct aim_chat_exchangeinfo *);
+
+			g_string_append_printf(msg, "chat info: Max Concurrent Rooms: %hhd, Exchange List (%d total): ", maxrooms, exchangecount);
+			for (i = 0; i < exchangecount; i++) {
+				g_string_append_printf(msg, "%hu", exchanges[i].number);
+				if (exchanges[i].name) {
+					g_string_append_printf(msg, " %s", exchanges[i].name);
+				}
+				g_string_append(msg, ", ");
+			}
+			purple_debug_misc("oscar", "%s\n", msg->str);
+			g_string_free(msg, TRUE);
+
+			while (od->create_rooms) {
+				struct create_room *cr = od->create_rooms->data;
+				purple_debug_info("oscar",
+						   "creating room %s\n", cr->name);
+				aim_chatnav_createroom(od, conn, cr->name, cr->exchange);
+				g_free(cr->name);
+				od->create_rooms = g_slist_remove(od->create_rooms, cr);
+				g_free(cr);
+			}
+			}
+			break;
+		case 0x0008: {
+			char *fqcn, *name, *ck;
+			guint16 instance, flags, maxmsglen, maxoccupancy, unknown, exchange;
+			guint8 createperms;
+			guint32 createtime;
+
+			fqcn = va_arg(ap, char *);
+			instance = (guint16)va_arg(ap, unsigned int);
+			exchange = (guint16)va_arg(ap, unsigned int);
+			flags = (guint16)va_arg(ap, unsigned int);
+			createtime = va_arg(ap, guint32);
+			maxmsglen = (guint16)va_arg(ap, unsigned int);
+			maxoccupancy = (guint16)va_arg(ap, unsigned int);
+			createperms = (guint8)va_arg(ap, unsigned int);
+			unknown = (guint16)va_arg(ap, unsigned int);
+			name = va_arg(ap, char *);
+			ck = va_arg(ap, char *);
+
+			purple_debug_misc("oscar",
+					"created room: %s %hu %hu %hu %u %hu %hu %hhu %hu %s %s\n",
+					fqcn ? fqcn : "(null)", exchange, instance, flags, createtime,
+					maxmsglen, maxoccupancy, createperms, unknown,
+					name ? name : "(null)", ck);
+			aim_chat_join(od, exchange, ck, instance);
+			}
+			break;
+		default:
+			purple_debug_warning("oscar",
+					   "chatnav info: unknown type (%04hx)\n", type);
+			break;
+	}
+
+	va_end(ap);
+
+	return 1;
+}
+
+static int purple_conv_chat_join(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	va_list ap;
+	int count, i;
+	aim_userinfo_t *info;
+	PurpleConnection *gc = od->gc;
+
+	struct chat_connection *c = NULL;
+
+	va_start(ap, fr);
+	count = va_arg(ap, int);
+	info  = va_arg(ap, aim_userinfo_t *);
+	va_end(ap);
+
+	c = find_oscar_chat_by_conn(gc, conn);
+	if (!c)
+		return 1;
+
+	for (i = 0; i < count; i++)
+		purple_conv_chat_add_user(PURPLE_CONV_CHAT(c->conv), info[i].bn, NULL, PURPLE_CBFLAGS_NONE, TRUE);
+
+	return 1;
+}
+
+static int purple_conv_chat_leave(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	va_list ap;
+	int count, i;
+	aim_userinfo_t *info;
+	PurpleConnection *gc = od->gc;
+
+	struct chat_connection *c = NULL;
+
+	va_start(ap, fr);
+	count = va_arg(ap, int);
+	info  = va_arg(ap, aim_userinfo_t *);
+	va_end(ap);
+
+	c = find_oscar_chat_by_conn(gc, conn);
+	if (!c)
+		return 1;
+
+	for (i = 0; i < count; i++)
+		purple_conv_chat_remove_user(PURPLE_CONV_CHAT(c->conv), info[i].bn, NULL);
+
+	return 1;
+}
+
+static int purple_conv_chat_info_update(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	va_list ap;
+	guint16 maxmsglen, maxvisiblemsglen;
+	PurpleConnection *gc = od->gc;
+	struct chat_connection *ccon = find_oscar_chat_by_conn(gc, conn);
+
+	if (!ccon)
+		return 1;
+
+	va_start(ap, fr);
+	maxmsglen = (guint16)va_arg(ap, unsigned int);
+	maxvisiblemsglen = (guint16)va_arg(ap, unsigned int);
+	va_end(ap);
+
+	purple_debug_misc("oscar",
+			   "inside chat_info_update (maxmsglen = %hu, maxvislen = %hu)\n",
+			   maxmsglen, maxvisiblemsglen);
+
+	ccon->maxlen = maxmsglen;
+	ccon->maxvis = maxvisiblemsglen;
+
+	return 1;
+}
+
+static int purple_conv_chat_incoming_msg(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	struct chat_connection *ccon = find_oscar_chat_by_conn(gc, conn);
+	gchar *utf8;
+	va_list ap;
+	aim_userinfo_t *info;
+	int len;
+	char *msg;
+	char *charset;
+
+	if (!ccon)
+		return 1;
+
+	va_start(ap, fr);
+	info = va_arg(ap, aim_userinfo_t *);
+	len = va_arg(ap, int);
+	msg = va_arg(ap, char *);
+	charset = va_arg(ap, char *);
+	va_end(ap);
+
+	utf8 = oscar_encoding_to_utf8(charset, msg, len);
+	serv_got_chat_in(gc, ccon->id, info->bn, 0, utf8, time(NULL));
+	g_free(utf8);
+
+	return 1;
+}
+
+static int purple_email_parseupdate(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	va_list ap;
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	struct aim_emailinfo *emailinfo;
+	int havenewmail;
+	char *alertitle, *alerturl;
+
+	gc = od->gc;
+	account = purple_connection_get_account(gc);
+
+	va_start(ap, fr);
+	emailinfo = va_arg(ap, struct aim_emailinfo *);
+	havenewmail = va_arg(ap, int);
+	alertitle = va_arg(ap, char *);
+	alerturl  = va_arg(ap, char *);
+	va_end(ap);
+
+	if (account != NULL && emailinfo != NULL && purple_account_get_check_mail(account) &&
+			emailinfo->unread && havenewmail) {
+		gchar *to = g_strdup_printf("%s%s%s",
+				purple_account_get_username(account),
+				emailinfo->domain ? "@" : "",
+				emailinfo->domain ? emailinfo->domain : "");
+		const char *tos[2] = { to };
+		const char *urls[2] = { emailinfo->url };
+		purple_notify_emails(gc, emailinfo->nummsgs, FALSE, NULL, NULL,
+				tos, urls, NULL, NULL);
+		g_free(to);
+	}
+
+	if (alertitle)
+		purple_debug_misc("oscar", "Got an alert '%s' %s\n", alertitle, alerturl ? alerturl : "");
+
+	return 1;
+}
+
+static int purple_icon_parseicon(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	va_list ap;
+	char *bn;
+	guint8 *iconcsum, *icon;
+	guint16 iconcsumlen, iconlen;
+
+	va_start(ap, fr);
+	bn = va_arg(ap, char *);
+	va_arg(ap, int); /* iconsumtype */
+	iconcsum = va_arg(ap, guint8 *);
+	iconcsumlen = va_arg(ap, int);
+	icon = va_arg(ap, guint8 *);
+	iconlen = va_arg(ap, int);
+	va_end(ap);
+
+	/*
+	 * Some AIM clients will send a blank GIF image with iconlen 90 when
+	 * no icon is set.  Ignore these.
+	 */
+	if ((iconlen > 0) && (iconlen != 90)) {
+		char *b16 = purple_base16_encode(iconcsum, iconcsumlen);
+		purple_buddy_icons_set_for_user(purple_connection_get_account(gc),
+									  bn, g_memdup(icon, iconlen), iconlen, b16);
+		g_free(b16);
+	}
+
+	return 1;
+}
+
+static void
+purple_icons_fetch(PurpleConnection *gc)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	aim_userinfo_t *userinfo;
+	FlapConnection *conn;
+
+	conn = flap_connection_getbytype(od, SNAC_FAMILY_BART);
+	if (!conn) {
+		if (!od->iconconnecting) {
+			aim_srv_requestnew(od, SNAC_FAMILY_BART);
+			od->iconconnecting = TRUE;
+		}
+		return;
+	}
+
+	if (od->set_icon) {
+		PurpleAccount *account = purple_connection_get_account(gc);
+		PurpleStoredImage *img = purple_buddy_icons_find_account_icon(account);
+		if (img == NULL) {
+			aim_ssi_delicon(od);
+		} else {
+			purple_debug_info("oscar",
+				   "Uploading icon to icon server\n");
+			aim_bart_upload(od, purple_imgstore_get_data(img),
+			                purple_imgstore_get_size(img));
+			purple_imgstore_unref(img);
+		}
+		od->set_icon = FALSE;
+	}
+
+	while (od->requesticon != NULL)
+	{
+		userinfo = aim_locate_finduserinfo(od, (char *)od->requesticon->data);
+		if ((userinfo != NULL) && (userinfo->iconcsumlen > 0))
+			aim_bart_request(od, od->requesticon->data, userinfo->iconcsumtype, userinfo->iconcsum, userinfo->iconcsumlen);
+
+		g_free(od->requesticon->data);
+		od->requesticon = g_slist_delete_link(od->requesticon, od->requesticon);
+	}
+
+	purple_debug_misc("oscar", "no more icons to request\n");
+}
+
+static int purple_selfinfo(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	va_list ap;
+	aim_userinfo_t *info;
+
+	va_start(ap, fr);
+	info = va_arg(ap, aim_userinfo_t *);
+	va_end(ap);
+
+	purple_connection_set_display_name(od->gc, info->bn);
+
+	return 1;
+}
+
+static int purple_connerr(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	va_list ap;
+	guint16 code;
+	char *msg;
+
+	va_start(ap, fr);
+	code = (guint16)va_arg(ap, int);
+	msg = va_arg(ap, char *);
+	va_end(ap);
+
+	purple_debug_info("oscar", "Disconnected.  Code is 0x%04x and msg is %s\n",
+					code, (msg != NULL ? msg : ""));
+
+	g_return_val_if_fail(conn != NULL, 1);
+
+	if (conn->type == SNAC_FAMILY_CHAT) {
+		struct chat_connection *cc;
+		PurpleConversation *conv = NULL;
+
+		cc = find_oscar_chat_by_conn(gc, conn);
+		if (cc != NULL)
+		{
+			conv = purple_find_chat(gc, cc->id);
+
+			if (conv != NULL)
+			{
+				/*
+				 * TOOD: Have flap_connection_destroy_cb() send us the
+				 *       error message stored in 'tmp', which should be
+				 *       human-friendly, and print that to the chat room.
+				 */
+				gchar *buf;
+				buf = g_strdup_printf(_("You have been disconnected from chat "
+										"room %s."), cc->name);
+				purple_conversation_write(conv, NULL, buf, PURPLE_MESSAGE_ERROR, time(NULL));
+				g_free(buf);
+			}
+			oscar_chat_kill(gc, cc);
+		}
+	}
+
+	return 1;
+}
+
+static int purple_parse_locaterights(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	PurpleConnection *gc = od->gc;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	va_list ap;
+	guint16 maxsiglen;
+
+	va_start(ap, fr);
+	maxsiglen = (guint16) va_arg(ap, int);
+	va_end(ap);
+
+	purple_debug_misc("oscar",
+			   "locate rights: max sig len = %d\n", maxsiglen);
+
+	od->rights.maxsiglen = od->rights.maxawaymsglen = (guint)maxsiglen;
+
+	aim_locate_setcaps(od, purple_caps);
+	oscar_set_info_and_status(account, TRUE, account->user_info, TRUE,
+							  purple_account_get_active_status(account));
+
+	return 1;
+}
+
+static int purple_parse_buddyrights(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	va_list ap;
+	guint16 maxbuddies, maxwatchers;
+
+	va_start(ap, fr);
+	maxbuddies = (guint16) va_arg(ap, unsigned int);
+	maxwatchers = (guint16) va_arg(ap, unsigned int);
+	va_end(ap);
+
+	purple_debug_misc("oscar",
+			   "buddy list rights: Max buddies = %hu / Max watchers = %hu\n", maxbuddies, maxwatchers);
+
+	od->rights.maxbuddies = (guint)maxbuddies;
+	od->rights.maxwatchers = (guint)maxwatchers;
+
+	return 1;
+}
+
+static void oscar_format_username(PurpleConnection *gc, const char *new_display_name)
+{
+	OscarData *od;
+	const char *old_display_name, *username;
+	char *tmp, *at_sign;
+
+	old_display_name = purple_connection_get_display_name(gc);
+	if (old_display_name && strchr(old_display_name, '@')) {
+		purple_debug_info("oscar", "Cowardly refusing to attempt to format "
+				"screen name because the current formatting according to "
+				"the server (%s) appears to be an email address\n",
+				old_display_name);
+		return;
+	}
+
+	username = purple_account_get_username(purple_connection_get_account(gc));
+	if (oscar_util_name_compare(username, new_display_name)) {
+		purple_notify_error(gc, NULL, _("The new formatting is invalid."),
+						  _("Username formatting can change only capitalization and whitespace."));
+		return;
+	}
+
+	tmp = g_strdup(new_display_name);
+
+	/*
+	 * If our local username is an email address then strip off the domain.
+	 * This allows formatting to work if the user entered their username as
+	 * 'something@aim.com' or possibly other AOL-owned domains.
+	 */
+	at_sign = strchr(tmp, '@');
+	if (at_sign)
+		at_sign[0] = '\0';
+
+	od = purple_connection_get_protocol_data(gc);
+	if (!flap_connection_getbytype(od, SNAC_FAMILY_ADMIN)) {
+		/* We don't have a connection to an "admin" server.  Make one. */
+		od->setnick = TRUE;
+		g_free(od->newformatting);
+		od->newformatting = tmp;
+		aim_srv_requestnew(od, SNAC_FAMILY_ADMIN);
+	} else {
+		aim_admin_setnick(od, flap_connection_getbytype(od, SNAC_FAMILY_ADMIN), tmp);
+		g_free(tmp);
+	}
+}
+
+static int purple_bosrights(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	PurpleStatus *status;
+	gboolean is_available;
+	PurplePresence *presence;
+	const char *username, *message, *itmsurl;
+	char *tmp;
+	va_list ap;
+	guint16 maxpermits, maxdenies;
+
+	gc = od->gc;
+	od = purple_connection_get_protocol_data(gc);
+	account = purple_connection_get_account(gc);
+
+	va_start(ap, fr);
+	maxpermits = (guint16) va_arg(ap, unsigned int);
+	maxdenies = (guint16) va_arg(ap, unsigned int);
+	va_end(ap);
+
+	purple_debug_misc("oscar",
+			   "BOS rights: Max permit = %hu / Max deny = %hu\n", maxpermits, maxdenies);
+
+	od->rights.maxpermits = (guint)maxpermits;
+	od->rights.maxdenies = (guint)maxdenies;
+
+	purple_debug_info("oscar", "buddy list loaded\n");
+
+	if (purple_account_get_user_info(account) != NULL)
+		serv_set_info(gc, purple_account_get_user_info(account));
+
+	username = purple_account_get_username(account);
+	if (!od->icq && strcmp(username, purple_connection_get_display_name(gc)) != 0) {
+		/*
+		 * Format the username for AIM accounts if it's different
+		 * than what's currently set.
+		 */
+		oscar_format_username(gc, username);
+	}
+
+	/* Set our available message based on the current status */
+	status = purple_account_get_active_status(account);
+	is_available = purple_status_is_available(status);
+	if (is_available)
+		message = purple_status_get_attr_string(status, "message");
+	else
+		message = NULL;
+	tmp = purple_markup_strip_html(message);
+	itmsurl = purple_status_get_attr_string(status, "itmsurl");
+	aim_srv_setextrainfo(od, FALSE, 0, is_available, tmp, itmsurl);
+	aim_srv_set_dc_info(od);
+	g_free(tmp);
+
+	presence = purple_status_get_presence(status);
+	aim_srv_setidle(od, !purple_presence_is_idle(presence) ? 0 : time(NULL) - purple_presence_get_idle_time(presence));
+
+	if (od->icq) {
+		oscar_set_extended_status(gc);
+		aim_icq_setsecurity(od,
+			purple_account_get_bool(account, "authorization", OSCAR_DEFAULT_AUTHORIZATION),
+			purple_account_get_bool(account, "web_aware", OSCAR_DEFAULT_WEB_AWARE));
+	}
+
+	aim_srv_requestnew(od, SNAC_FAMILY_ALERT);
+	aim_srv_requestnew(od, SNAC_FAMILY_CHATNAV);
+
+	od->bos.have_rights = TRUE;
+
+	/*
+	 * If we've already received our feedbag data then we're not waiting on
+	 * anything else, so send the server clientready.
+	 *
+	 * Normally we get bos rights before we get our feedbag data, so this
+	 * rarely (never?) happens.  And I'm not sure it actually matters if we
+	 * wait for bos rights before calling clientready.  But it seems safer
+	 * to do it this way.
+	 */
+	if (od->ssi.received_data) {
+		aim_srv_clientready(od, conn);
+
+		/* Request offline messages for AIM and ICQ */
+		aim_im_reqofflinemsgs(od);
+
+		purple_connection_set_state(gc, PURPLE_CONNECTED);
+	}
+
+	return 1;
+}
+
+static int purple_popup(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	PurpleConnection *gc = od->gc;
+	gchar *text;
+	va_list ap;
+	char *msg, *url;
+
+	va_start(ap, fr);
+	msg = va_arg(ap, char *);
+	url = va_arg(ap, char *);
+	va_arg(ap, int); /* guint16 wid */
+	va_arg(ap, int); /* guint16 hei */
+	va_arg(ap, int); /* guint16 delay */
+	va_end(ap);
+
+	text = g_strdup_printf("%s<br><a href=\"%s\">%s</a>", msg, url, url);
+	purple_notify_formatted(gc, NULL, _("Pop-Up Message"), NULL, text, NULL, NULL);
+	g_free(text);
+
+	return 1;
+}
+
+static void oscar_searchresults_add_buddy_cb(PurpleConnection *gc, GList *row, void *user_data)
+{
+	purple_blist_request_add_buddy(purple_connection_get_account(gc),
+								 g_list_nth_data(row, 0), NULL, NULL);
+}
+
+static int purple_parse_searchreply(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	PurpleConnection *gc = od->gc;
+	PurpleNotifySearchResults *results;
+	PurpleNotifySearchColumn *column;
+	gchar *secondary;
+	int i, num;
+	va_list ap;
+	char *email, *usernames;
+
+	va_start(ap, fr);
+	email = va_arg(ap, char *);
+	num = va_arg(ap, int);
+	usernames = va_arg(ap, char *);
+	va_end(ap);
+
+	results = purple_notify_searchresults_new();
+
+	if (results == NULL) {
+		purple_debug_error("oscar", "purple_parse_searchreply: "
+						 "Unable to display the search results.\n");
+		purple_notify_error(gc, NULL,
+						  _("Unable to display the search results."),
+						  NULL);
+		return 1;
+	}
+
+	secondary = g_strdup_printf(
+					dngettext(PACKAGE, "The following username is associated with %s",
+						 "The following usernames are associated with %s",
+						 num),
+					email);
+
+	column = purple_notify_searchresults_column_new(_("Username"));
+	purple_notify_searchresults_column_add(results, column);
+
+	for (i = 0; i < num; i++) {
+		GList *row;
+		row = g_list_append(NULL, g_strdup(&usernames[i * (MAXSNLEN + 1)]));
+		purple_notify_searchresults_row_add(results, row);
+	}
+	purple_notify_searchresults_button_add(results, PURPLE_NOTIFY_BUTTON_ADD,
+										 oscar_searchresults_add_buddy_cb);
+	purple_notify_searchresults(gc, NULL, NULL, secondary, results, NULL, NULL);
+
+	g_free(secondary);
+
+	return 1;
+}
+
+static int purple_parse_searcherror(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	va_list ap;
+	char *email;
+	char *buf;
+
+	va_start(ap, fr);
+	email = va_arg(ap, char *);
+	va_end(ap);
+
+	buf = g_strdup_printf(_("No results found for email address %s"), email);
+	purple_notify_error(od->gc, NULL, buf, NULL);
+	g_free(buf);
+
+	return 1;
+}
+
+static int purple_account_confirm(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	guint16 status;
+	va_list ap;
+	char msg[256];
+
+	va_start(ap, fr);
+	status = (guint16) va_arg(ap, unsigned int); /* status code of confirmation request */
+	va_end(ap);
+
+	purple_debug_info("oscar",
+			   "account confirmation returned status 0x%04x (%s)\n", status,
+			status ? "unknown" : "email sent");
+	if (!status) {
+		g_snprintf(msg, sizeof(msg), _("You should receive an email asking to confirm %s."),
+				purple_account_get_username(purple_connection_get_account(gc)));
+		purple_notify_info(gc, NULL, _("Account Confirmation Requested"), msg);
+	}
+
+	return 1;
+}
+
+static int purple_info_change(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	va_list ap;
+	guint16 perms, err;
+	char *url, *bn, *email;
+	int change;
+
+	va_start(ap, fr);
+	change = va_arg(ap, int);
+	perms = (guint16) va_arg(ap, unsigned int);
+	err = (guint16) va_arg(ap, unsigned int);
+	url = va_arg(ap, char *);
+	bn = va_arg(ap, char *);
+	email = va_arg(ap, char *);
+	va_end(ap);
+
+	purple_debug_misc("oscar",
+					"account info: because of %s, perms=0x%04x, err=0x%04x, url=%s, bn=%s, email=%s\n",
+					change ? "change" : "request", perms, err,
+					(url != NULL) ? url : "(null)",
+					(bn != NULL) ? bn : "(null)",
+					(email != NULL) ? email : "(null)");
+
+	if ((err > 0) && (url != NULL)) {
+		char *dialog_msg;
+
+		if (err == 0x0001)
+			dialog_msg = g_strdup_printf(_("Error 0x%04x: Unable to format username because the requested name differs from the original."), err);
+		else if (err == 0x0006)
+			dialog_msg = g_strdup_printf(_("Error 0x%04x: Unable to format username because it is invalid."), err);
+		else if (err == 0x00b)
+			dialog_msg = g_strdup_printf(_("Error 0x%04x: Unable to format username because the requested name is too long."), err);
+		else if (err == 0x001d)
+			dialog_msg = g_strdup_printf(_("Error 0x%04x: Unable to change email address because there is already a request pending for this username."), err);
+		else if (err == 0x0021)
+			dialog_msg = g_strdup_printf(_("Error 0x%04x: Unable to change email address because the given address has too many usernames associated with it."), err);
+		else if (err == 0x0023)
+			dialog_msg = g_strdup_printf(_("Error 0x%04x: Unable to change email address because the given address is invalid."), err);
+		else
+			dialog_msg = g_strdup_printf(_("Error 0x%04x: Unknown error."), err);
+		purple_notify_error(gc, NULL,
+				_("Error Changing Account Info"), dialog_msg);
+		g_free(dialog_msg);
+		return 1;
+	}
+
+	if (email != NULL) {
+		char *dialog_msg = g_strdup_printf(_("The email address for %s is %s"),
+						   purple_account_get_username(purple_connection_get_account(gc)), email);
+		purple_notify_info(gc, NULL, _("Account Info"), dialog_msg);
+		g_free(dialog_msg);
+	}
+
+	return 1;
+}
+
+void
+oscar_keepalive(PurpleConnection *gc)
+{
+	OscarData *od;
+	GSList *l;
+
+	od = purple_connection_get_protocol_data(gc);
+	for (l = od->oscar_connections; l; l = l->next) {
+		flap_connection_send_keepalive(od, l->data);
+	}
+}
+
+unsigned int
+oscar_send_typing(PurpleConnection *gc, const char *name, PurpleTypingState state)
+{
+	OscarData *od;
+	PeerConnection *conn;
+
+	od = purple_connection_get_protocol_data(gc);
+	conn = peer_connection_find_by_type(od, name, OSCAR_CAPABILITY_DIRECTIM);
+
+	if ((conn != NULL) && (conn->ready))
+	{
+		peer_odc_send_typing(conn, state);
+	}
+	else {
+		/* Don't send if this turkey is in our deny list */
+		GSList *list;
+		for (list=gc->account->deny; (list && oscar_util_name_compare(name, list->data)); list=list->next);
+		if (!list) {
+			struct buddyinfo *bi = g_hash_table_lookup(od->buddyinfo, purple_normalize(gc->account, name));
+			if (bi && bi->typingnot) {
+				if (state == PURPLE_TYPING)
+					aim_im_sendmtn(od, 0x0001, name, 0x0002);
+				else if (state == PURPLE_TYPED)
+					aim_im_sendmtn(od, 0x0001, name, 0x0001);
+				else
+					aim_im_sendmtn(od, 0x0001, name, 0x0000);
+			}
+		}
+	}
+	return 0;
+}
+
+/* TODO: Move this into odc.c! */
+static void
+purple_odc_send_im(PeerConnection *conn, const char *message, PurpleMessageFlags imflags)
+{
+	GString *msg;
+	GString *data;
+	gchar *tmp;
+	gsize tmplen;
+	guint16 charset;
+	GData *attribs;
+	const char *start, *end, *last;
+	int oscar_id = 0;
+
+	msg = g_string_new("<HTML><BODY>");
+	data = g_string_new("<BINARY>");
+	last = message;
+
+	/* for each valid IMG tag... */
+	while (last && *last && purple_markup_find_tag("img", last, &start, &end, &attribs))
+	{
+		PurpleStoredImage *image = NULL;
+		const char *id;
+
+		if (start - last) {
+			g_string_append_len(msg, last, start - last);
+		}
+
+		id = g_datalist_get_data(&attribs, "id");
+
+		/* ... if it refers to a valid purple image ... */
+		if (id && (image = purple_imgstore_find_by_id(atoi(id)))) {
+			/* ... append the message from start to the tag ... */
+			unsigned long size = purple_imgstore_get_size(image);
+			const char *filename = purple_imgstore_get_filename(image);
+			gconstpointer imgdata = purple_imgstore_get_data(image);
+
+			oscar_id++;
+
+			/* ... insert a new img tag with the oscar id ... */
+			if (filename)
+				g_string_append_printf(msg,
+					"<IMG SRC=\"%s\" ID=\"%d\" DATASIZE=\"%lu\">",
+					filename, oscar_id, size);
+			else
+				g_string_append_printf(msg,
+					"<IMG ID=\"%d\" DATASIZE=\"%lu\">",
+					oscar_id, size);
+
+			/* ... and append the data to the binary section ... */
+			g_string_append_printf(data, "<DATA ID=\"%d\" SIZE=\"%lu\">",
+				oscar_id, size);
+			g_string_append_len(data, imgdata, size);
+			g_string_append(data, "</DATA>");
+		}
+			/* If the tag is invalid, skip it, thus no else here */
+
+		g_datalist_clear(&attribs);
+
+		/* continue from the end of the tag */
+		last = end + 1;
+	}
+
+	/* append any remaining message data */
+	if (last && *last)
+		g_string_append(msg, last);
+
+	g_string_append(msg, "</BODY></HTML>");
+
+	/* Convert the message to a good encoding */
+	tmp = oscar_encode_im(msg->str, &tmplen, &charset, NULL);
+	g_string_free(msg, TRUE);
+	msg = g_string_new_len(tmp, tmplen);
+	g_free(tmp);
+
+	/* Append any binary data that we may have */
+	if (oscar_id) {
+		msg = g_string_append_len(msg, data->str, data->len);
+		msg = g_string_append(msg, "</BINARY>");
+	}
+	g_string_free(data, TRUE);
+
+	purple_debug_info("oscar", "sending direct IM %s using charset %i", msg->str, charset);
+
+	peer_odc_send_im(conn, msg->str, msg->len, charset,
+			imflags & PURPLE_MESSAGE_AUTO_RESP);
+	g_string_free(msg, TRUE);
+}
+
+int
+oscar_send_im(PurpleConnection *gc, const char *name, const char *message, PurpleMessageFlags imflags)
+{
+	OscarData *od;
+	PurpleAccount *account;
+	PeerConnection *conn;
+	int ret;
+	char *tmp1, *tmp2;
+	gboolean is_sms, is_html;
+
+	od = purple_connection_get_protocol_data(gc);
+	account = purple_connection_get_account(gc);
+	ret = 0;
+
+	is_sms = oscar_util_valid_name_sms(name);
+
+	if (od->icq && is_sms) {
+		/*
+		 * We're sending to a phone number and this is ICQ,
+		 * so send the message as an SMS using aim_icq_sendsms()
+		 */
+		int ret;
+		purple_debug_info("oscar", "Sending SMS to %s.\n", name);
+		ret = aim_icq_sendsms(od, name, message, purple_account_get_username(account));
+		return (ret >= 0 ? 1 : ret);
+	}
+
+	if (imflags & PURPLE_MESSAGE_AUTO_RESP)
+		tmp1 = oscar_util_format_string(message, name);
+	else
+		tmp1 = g_strdup(message);
+
+	conn = peer_connection_find_by_type(od, name, OSCAR_CAPABILITY_DIRECTIM);
+	if ((conn != NULL) && (conn->ready))
+	{
+		/* If we're directly connected, send a direct IM */
+		purple_debug_info("oscar", "Sending direct IM with flags %i\n", imflags);
+		purple_odc_send_im(conn, tmp1, imflags);
+	} else {
+		struct buddyinfo *bi;
+		struct aim_sendimext_args args;
+		PurpleConversation *conv;
+		PurpleStoredImage *img;
+		PurpleBuddy *buddy;
+
+		conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, name, account);
+
+		if (strstr(tmp1, "<IMG "))
+			purple_conversation_write(conv, "",
+			                        _("Your IM Image was not sent. "
+			                        "You must be Direct Connected to send IM Images."),
+			                        PURPLE_MESSAGE_ERROR, time(NULL));
+
+		buddy = purple_find_buddy(account, name);
+
+		bi = g_hash_table_lookup(od->buddyinfo, purple_normalize(account, name));
+		if (!bi) {
+			bi = g_new0(struct buddyinfo, 1);
+			g_hash_table_insert(od->buddyinfo, g_strdup(purple_normalize(account, name)), bi);
+		}
+
+		args.flags = 0;
+
+		if (!is_sms && (!buddy || !PURPLE_BUDDY_IS_ONLINE(buddy)))
+			args.flags |= AIM_IMFLAGS_OFFLINE;
+
+		if (od->icq) {
+			args.features = features_icq;
+			args.featureslen = sizeof(features_icq);
+		} else {
+			args.features = features_aim;
+			args.featureslen = sizeof(features_aim);
+
+			if (imflags & PURPLE_MESSAGE_AUTO_RESP)
+				args.flags |= AIM_IMFLAGS_AWAY;
+		}
+
+		if (bi->ico_need) {
+			purple_debug_info("oscar",
+					   "Sending buddy icon request with message\n");
+			args.flags |= AIM_IMFLAGS_BUDDYREQ;
+			bi->ico_need = FALSE;
+		}
+
+		img = purple_buddy_icons_find_account_icon(account);
+		if (img) {
+			gconstpointer data = purple_imgstore_get_data(img);
+			args.iconlen = purple_imgstore_get_size(img);
+			args.iconsum = aimutil_iconsum(data, args.iconlen);
+			args.iconstamp = purple_buddy_icons_get_account_icon_timestamp(account);
+
+			if ((args.iconlen != bi->ico_me_len) || (args.iconsum != bi->ico_me_csum) || (args.iconstamp != bi->ico_me_time)) {
+				bi->ico_informed = FALSE;
+				bi->ico_sent     = FALSE;
+			}
+
+			/*
+			 * TODO:
+			 * For some reason sending our icon to people only works
+			 * when we're the ones who initiated the conversation.  If
+			 * the other person sends the first IM then they never get
+			 * the icon.  We should fix that.
+			 */
+			if (!bi->ico_informed) {
+				purple_debug_info("oscar",
+						   "Claiming to have a buddy icon\n");
+				args.flags |= AIM_IMFLAGS_HASICON;
+				bi->ico_me_len = args.iconlen;
+				bi->ico_me_csum = args.iconsum;
+				bi->ico_me_time = args.iconstamp;
+				bi->ico_informed = TRUE;
+			}
+
+			purple_imgstore_unref(img);
+		}
+
+		args.destbn = name;
+
+		if (oscar_util_valid_name_sms(name)) {
+			/* Messaging an SMS (mobile) user--strip HTML */
+			tmp2 = purple_markup_strip_html(tmp1);
+			is_html = FALSE;
+		} else {
+			/* ICQ 6 wants its HTML wrapped in these tags. Oblige it. */
+			tmp2 = g_strdup_printf("<HTML><BODY>%s</BODY></HTML>", tmp1);
+			is_html = TRUE;
+		}
+		g_free(tmp1);
+		tmp1 = tmp2;
+
+		args.msg = oscar_encode_im(tmp1, &args.msglen, &args.charset, NULL);
+		if (is_html && (args.msglen > MAXMSGLEN)) {
+			/* If the length was too long, try stripping the HTML and then running it back through
+			* purple_strdup_withhtml() and the encoding process. The result may be shorter. */
+			g_free((char *)args.msg);
+
+			tmp2 = purple_markup_strip_html(tmp1);
+			g_free(tmp1);
+
+			/* re-escape the entities */
+			tmp1 = g_markup_escape_text(tmp2, -1);
+			g_free(tmp2);
+
+			tmp2 = purple_strdup_withhtml(tmp1);
+			g_free(tmp1);
+			tmp1 = tmp2;
+
+			args.msg = oscar_encode_im(tmp1, &args.msglen, &args.charset, NULL);
+			purple_debug_info("oscar", "Sending %s as %s because the original was too long.\n",
+								  message, (char *)args.msg);
+		}
+
+		purple_debug_info("oscar", "Sending IM, charset=0x%04hx, length=%" G_GSIZE_FORMAT "\n", args.charset, args.msglen);
+		ret = aim_im_sendch1_ext(od, &args);
+		g_free((char *)args.msg);
+	}
+
+	g_free(tmp1);
+
+	if (ret >= 0)
+		return 1;
+
+	return ret;
+}
+
+/*
+ * As of 26 June 2006, ICQ users can request AIM info from
+ * everyone, and can request ICQ info from ICQ users, and
+ * AIM users can only request AIM info.
+ */
+void oscar_get_info(PurpleConnection *gc, const char *name) {
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	if (od->icq && oscar_util_valid_name_icq(name))
+		aim_icq_getallinfo(od, name);
+	else
+		aim_locate_getinfoshort(od, name, 0x00000003);
+}
+
+void oscar_set_idle(PurpleConnection *gc, int time) {
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	aim_srv_setidle(od, time);
+}
+
+void
+oscar_set_info(PurpleConnection *gc, const char *rawinfo)
+{
+	PurpleAccount *account;
+	PurpleStatus *status;
+
+	account = purple_connection_get_account(gc);
+	status = purple_account_get_active_status(account);
+	oscar_set_info_and_status(account, TRUE, rawinfo, FALSE, status);
+}
+
+static guint32
+oscar_get_extended_status(PurpleConnection *gc)
+{
+	PurpleAccount *account;
+	PurpleStatus *status;
+	const gchar *status_id;
+	guint32 data = 0x00000000;
+
+	account = purple_connection_get_account(gc);
+	status = purple_account_get_active_status(account);
+	status_id = purple_status_get_id(status);
+
+	data |= AIM_ICQ_STATE_HIDEIP;
+	if (purple_account_get_bool(account, "web_aware", OSCAR_DEFAULT_WEB_AWARE))
+		data |= AIM_ICQ_STATE_WEBAWARE;
+
+	if (!strcmp(status_id, OSCAR_STATUS_ID_AVAILABLE))
+		data |= AIM_ICQ_STATE_NORMAL;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_AWAY))
+		data |= AIM_ICQ_STATE_AWAY;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_DND))
+		data |= AIM_ICQ_STATE_AWAY | AIM_ICQ_STATE_DND | AIM_ICQ_STATE_BUSY;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_NA))
+		data |= AIM_ICQ_STATE_OUT | AIM_ICQ_STATE_AWAY;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_OCCUPIED))
+		data |= AIM_ICQ_STATE_AWAY | AIM_ICQ_STATE_BUSY;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_FREE4CHAT))
+		data |= AIM_ICQ_STATE_CHAT;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_INVISIBLE))
+		data |= AIM_ICQ_STATE_INVISIBLE;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_EVIL))
+		data |= AIM_ICQ_STATE_EVIL;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_DEPRESSION))
+		data |= AIM_ICQ_STATE_DEPRESSION;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_ATWORK))
+		data |= AIM_ICQ_STATE_ATWORK;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_ATHOME))
+		data |= AIM_ICQ_STATE_ATHOME;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_LUNCH))
+		data |= AIM_ICQ_STATE_LUNCH;
+	else if (!strcmp(status_id, OSCAR_STATUS_ID_CUSTOM))
+		data |= AIM_ICQ_STATE_OUT | AIM_ICQ_STATE_AWAY;
+
+	return data;
+}
+
+static void
+oscar_set_extended_status(PurpleConnection *gc)
+{
+	aim_srv_setextrainfo(purple_connection_get_protocol_data(gc), TRUE, oscar_get_extended_status(gc), FALSE, NULL, NULL);
+}
+
+static void
+oscar_set_info_and_status(PurpleAccount *account, gboolean setinfo, const char *rawinfo,
+						  gboolean setstatus, PurpleStatus *status)
+{
+	PurpleConnection *gc = purple_account_get_connection(account);
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	PurpleStatusType *status_type;
+	PurpleStatusPrimitive primitive;
+
+	char *info_encoding = NULL;
+	char *info = NULL;
+	gsize infolen = 0;
+
+	char *away_encoding = NULL;
+	char *away = NULL;
+	gsize awaylen = 0;
+
+	char *status_text = NULL;
+	const char *itmsurl = NULL;
+
+	status_type = purple_status_get_type(status);
+	primitive = purple_status_type_get_primitive(status_type);
+
+	if (!setinfo)
+	{
+		/* Do nothing! */
+	}
+	else if (od->rights.maxsiglen == 0)
+	{
+		purple_notify_warning(gc, NULL, _("Unable to set AIM profile."),
+							_("You have probably requested to set your "
+							  "profile before the login procedure completed.  "
+							  "Your profile remains unset; try setting it "
+							  "again when you are fully connected."));
+	}
+	else if (rawinfo != NULL)
+	{
+		char *htmlinfo = purple_strdup_withhtml(rawinfo);
+		info = oscar_encode_im(htmlinfo, &infolen, NULL, &info_encoding);
+		g_free(htmlinfo);
+
+		if (infolen > od->rights.maxsiglen)
+		{
+			gchar *errstr;
+			errstr = g_strdup_printf(dngettext(PACKAGE, "The maximum profile length of %d byte "
+									 "has been exceeded.  It has been truncated for you.",
+									 "The maximum profile length of %d bytes "
+									 "has been exceeded.  It has been truncated for you.",
+									 od->rights.maxsiglen), od->rights.maxsiglen);
+			purple_notify_warning(gc, NULL, _("Profile too long."), errstr);
+			g_free(errstr);
+		}
+	}
+
+	if (setstatus)
+	{
+		const char *status_html;
+
+		status_html = purple_status_get_attr_string(status, "message");
+
+		if (status_html == NULL || primitive == PURPLE_STATUS_AVAILABLE || primitive == PURPLE_STATUS_INVISIBLE)
+		{
+			/* This is needed for us to un-set any previous away message. */
+			away = g_strdup("");
+		}
+		else
+		{
+			gchar *linkified;
+
+			/* We do this for icq too so that they work for old third party clients */
+			linkified = purple_markup_linkify(status_html);
+			away = oscar_encode_im(linkified, &awaylen, NULL, &away_encoding);
+			g_free(linkified);
+
+			if (awaylen > od->rights.maxawaymsglen)
+			{
+				gchar *errstr;
+
+				errstr = g_strdup_printf(dngettext(PACKAGE, "The maximum away message length of %d byte "
+										 "has been exceeded.  It has been truncated for you.",
+										 "The maximum away message length of %d bytes "
+										 "has been exceeded.  It has been truncated for you.",
+										 od->rights.maxawaymsglen), od->rights.maxawaymsglen);
+				purple_notify_warning(gc, NULL, _("Away message too long."), errstr);
+				g_free(errstr);
+			}
+		}
+	}
+
+	aim_locate_setprofile(od,
+			info_encoding, info, MIN(infolen, od->rights.maxsiglen),
+			away_encoding, away, MIN(awaylen, od->rights.maxawaymsglen));
+	g_free(info);
+	g_free(away);
+
+	if (setstatus)
+	{
+		const char *status_html;
+
+		status_html = purple_status_get_attr_string(status, "message");
+		if (status_html != NULL)
+		{
+			status_text = purple_markup_strip_html(status_html);
+			/* If the status_text is longer than 251 characters then truncate it */
+			if (strlen(status_text) > MAXAVAILMSGLEN)
+			{
+				char *tmp = g_utf8_find_prev_char(status_text, &status_text[MAXAVAILMSGLEN - 2]);
+				strcpy(tmp, "...");
+			}
+		}
+
+		itmsurl = purple_status_get_attr_string(status, "itmsurl");
+
+		aim_srv_setextrainfo(od, TRUE, oscar_get_extended_status(gc), TRUE, status_text, itmsurl);
+		g_free(status_text);
+	}
+}
+
+static void
+oscar_set_icq_permdeny(PurpleAccount *account)
+{
+	PurpleConnection *gc = purple_account_get_connection(account);
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	gboolean invisible = purple_account_is_status_active(account, OSCAR_STATUS_ID_INVISIBLE);
+
+	/*
+	 * For ICQ the permit/deny setting controls who can see you
+	 * online. Mimicking the official client's behavior, we use PURPLE_PRIVACY_ALLOW_USERS
+	 * when our status is "invisible" and PURPLE_PRIVACY_DENY_USERS otherwise.
+	 * In the former case, we are visible only to buddies on our "permanently visible" list.
+	 * In the latter, we are invisible only to buddies on our "permanently invisible" list.
+	 */
+	aim_ssi_setpermdeny(od, invisible ? PURPLE_PRIVACY_ALLOW_USERS : PURPLE_PRIVACY_DENY_USERS);
+}
+
+void
+oscar_set_status(PurpleAccount *account, PurpleStatus *status)
+{
+	PurpleConnection *pc;
+	OscarData *od;
+
+	purple_debug_info("oscar", "Set status to %s\n", purple_status_get_name(status));
+
+	/* Either setting a new status active or setting a status inactive.
+	 * (Only possible for independent status (i.e. X-Status moods.) */
+	if (!purple_status_is_active(status) && !purple_status_is_independent(status))
+		return;
+
+	if (!purple_account_is_connected(account))
+		return;
+
+	pc = purple_account_get_connection(account);
+	od = purple_connection_get_protocol_data(pc);
+
+	/* There's no need to do the stuff below for mood updates. */
+	if (purple_status_type_get_primitive(purple_status_get_type(status)) == PURPLE_STATUS_MOOD) {
+		aim_locate_setcaps(od, purple_caps);
+		return;
+	}
+
+	if (od->icq) {
+		/* Set visibility */
+		oscar_set_icq_permdeny(account);
+	}
+
+	/* Set the AIM-style away message for both AIM and ICQ accounts */
+	oscar_set_info_and_status(account, FALSE, NULL, TRUE, status);
+}
+
+void
+oscar_add_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group, const char *msg)
+{
+	OscarData *od;
+	PurpleAccount *account;
+	const char *bname, *gname;
+
+	od = purple_connection_get_protocol_data(gc);
+	account = purple_connection_get_account(gc);
+	bname = purple_buddy_get_name(buddy);
+	gname = purple_group_get_name(group);
+
+	if (!oscar_util_valid_name(bname)) {
+		gchar *buf;
+		buf = g_strdup_printf(_("Unable to add the buddy %s because the username is invalid.  Usernames must be a valid email address, or start with a letter and contain only letters, numbers and spaces, or contain only numbers."), bname);
+		if (!purple_conv_present_error(bname, account, buf))
+			purple_notify_error(gc, NULL, _("Unable to Add"), buf);
+		g_free(buf);
+
+		/* Remove from local list */
+		purple_blist_remove_buddy(buddy);
+
+		return;
+	}
+
+	if (od->ssi.received_data) {
+		if (!aim_ssi_itemlist_finditem(od->ssi.local, gname, bname, AIM_SSI_TYPE_BUDDY)) {
+			purple_debug_info("oscar",
+					   "ssi: adding buddy %s to group %s\n", bname, gname);
+			aim_ssi_addbuddy(od, bname, gname, NULL, purple_buddy_get_alias_only(buddy), NULL, NULL, 0);
+
+			/* Mobile users should always be online */
+			if (bname[0] == '+') {
+				purple_prpl_got_user_status(account, bname,
+						OSCAR_STATUS_ID_AVAILABLE, NULL);
+				purple_prpl_got_user_status(account, bname,
+						OSCAR_STATUS_ID_MOBILE, NULL);
+			}
+		} else if (aim_ssi_waitingforauth(od->ssi.local,
+		                                  aim_ssi_itemlist_findparentname(od->ssi.local, bname),
+		                                  bname)) {
+			/* Not authorized -- Re-request authorization */
+			oscar_auth_sendrequest(gc, bname, msg);
+		}
+	}
+
+	/* XXX - Should this be done from AIM accounts, as well? */
+	if (od->icq)
+		aim_icq_getalias(od, bname, FALSE, NULL);
+}
+
+void oscar_remove_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group) {
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	if (od->ssi.received_data) {
+		const char *gname = purple_group_get_name(group);
+		const char *bname = purple_buddy_get_name(buddy);
+		purple_debug_info("oscar",
+				   "ssi: deleting buddy %s from group %s\n", bname, gname);
+		aim_ssi_delbuddy(od, bname, gname);
+	}
+}
+
+void oscar_move_buddy(PurpleConnection *gc, const char *name, const char *old_group, const char *new_group) {
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	if (od->ssi.received_data && strcmp(old_group, new_group)) {
+		purple_debug_info("oscar",
+				   "ssi: moving buddy %s from group %s to group %s\n", name, old_group, new_group);
+		aim_ssi_movebuddy(od, old_group, new_group, name);
+	}
+}
+
+void oscar_alias_buddy(PurpleConnection *gc, const char *name, const char *alias) {
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	if (od->ssi.received_data) {
+		char *gname = aim_ssi_itemlist_findparentname(od->ssi.local, name);
+		if (gname) {
+			purple_debug_info("oscar",
+					   "ssi: changing the alias for buddy %s to %s\n", name, alias ? alias : "(none)");
+			aim_ssi_aliasbuddy(od, gname, name, alias);
+		}
+	}
+}
+
+/*
+ * FYI, the OSCAR SSI code removes empty groups automatically.
+ */
+void oscar_rename_group(PurpleConnection *gc, const char *old_name, PurpleGroup *group, GList *moved_buddies) {
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	if (od->ssi.received_data) {
+		const char *gname = purple_group_get_name(group);
+		if (aim_ssi_itemlist_finditem(od->ssi.local, gname, NULL, AIM_SSI_TYPE_GROUP)) {
+			GList *cur, *groups = NULL;
+			PurpleAccount *account = purple_connection_get_account(gc);
+
+			/* Make a list of what the groups each buddy is in */
+			for (cur = moved_buddies; cur != NULL; cur = cur->next) {
+				PurpleBlistNode *node = cur->data;
+				/* node is PurpleBuddy, parent is a PurpleContact.
+				 * We must go two levels up to get the Group */
+				groups = g_list_append(groups,
+						purple_buddy_get_group((PurpleBuddy*)node));
+			}
+
+			purple_account_remove_buddies(account, moved_buddies, groups);
+			purple_account_add_buddies(account, moved_buddies);
+			g_list_free(groups);
+			purple_debug_info("oscar",
+					   "ssi: moved all buddies from group %s to %s\n", old_name, gname);
+		} else {
+			aim_ssi_rename_group(od, old_name, gname);
+			purple_debug_info("oscar",
+					   "ssi: renamed group %s to %s\n", old_name, gname);
+		}
+	}
+}
+
+void oscar_remove_group(PurpleConnection *gc, PurpleGroup *group)
+{
+	aim_ssi_delgroup(purple_connection_get_protocol_data(gc), purple_group_get_name(group));
+}
+
+static gboolean purple_ssi_rerequestdata(gpointer data) {
+	OscarData *od = data;
+
+	aim_ssi_reqdata(od);
+
+	return TRUE;
+}
+
+static int purple_ssi_parseerr(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	va_list ap;
+	guint16 reason;
+
+	va_start(ap, fr);
+	reason = (guint16)va_arg(ap, unsigned int);
+	va_end(ap);
+
+	purple_debug_error("oscar", "ssi: SNAC error %hu\n", reason);
+
+	if (reason == 0x0005) {
+		if (od->getblisttimer > 0)
+			purple_timeout_remove(od->getblisttimer);
+		else
+			/* We only show this error the first time it happens */
+			purple_notify_error(gc, NULL,
+					_("Unable to Retrieve Buddy List"),
+					_("The AIM servers were temporarily unable to send "
+					"your buddy list.  Your buddy list is not lost, and "
+					"will probably become available in a few minutes."));
+		od->getblisttimer = purple_timeout_add_seconds(30, purple_ssi_rerequestdata, od);
+		return 1;
+	}
+
+	return 1;
+}
+
+static int purple_ssi_parserights(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	int i;
+	va_list ap;
+	int numtypes;
+	guint16 *maxitems;
+	GString *msg;
+
+	va_start(ap, fr);
+	numtypes = va_arg(ap, int);
+	maxitems = va_arg(ap, guint16 *);
+	va_end(ap);
+
+	msg = g_string_new("ssi rights:");
+	for (i=0; i<numtypes; i++)
+		g_string_append_printf(msg, " max type 0x%04x=%hd,", i, maxitems[i]);
+	g_string_append(msg, "\n");
+	purple_debug_misc("oscar", "%s", msg->str);
+	g_string_free(msg, TRUE);
+
+	if (numtypes >= 0)
+		od->rights.maxbuddies = maxitems[0];
+	if (numtypes >= 1)
+		od->rights.maxgroups = maxitems[1];
+	if (numtypes >= 2)
+		od->rights.maxpermits = maxitems[2];
+	if (numtypes >= 3)
+		od->rights.maxdenies = maxitems[3];
+
+	return 1;
+}
+
+static int purple_ssi_parselist(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	PurpleGroup *g;
+	PurpleBuddy *b;
+	GSList *cur, *next, *buddies;
+	struct aim_ssi_item *curitem;
+	guint32 tmp;
+	PurpleStoredImage *img;
+	va_list ap;
+	guint16 deny_entry_type = aim_ssi_getdenyentrytype(od);
+
+	gc = od->gc;
+	od = purple_connection_get_protocol_data(gc);
+	account = purple_connection_get_account(gc);
+
+	va_start(ap, fr);
+	va_arg(ap, int); /* guint16 fmtver */
+	va_arg(ap, int); /* guint16 numitems */
+	va_arg(ap, guint32); /* timestamp */
+	va_end(ap);
+
+	/* Don't attempt to re-request our buddy list later */
+	if (od->getblisttimer != 0) {
+		purple_timeout_remove(od->getblisttimer);
+		od->getblisttimer = 0;
+	}
+
+	purple_debug_info("oscar", "ssi: syncing local list and server list\n");
+
+	/* Clean the buddy list */
+	aim_ssi_cleanlist(od);
+
+	/*** Begin code for pruning buddies from local list if they're not in server list ***/
+
+	/* Buddies */
+	cur = NULL;
+	for (buddies = purple_find_buddies(account, NULL);
+			buddies;
+			buddies = g_slist_delete_link(buddies, buddies))
+	{
+		PurpleGroup *g;
+		const char *gname;
+		const char *bname;
+
+		b = buddies->data;
+		g = purple_buddy_get_group(b);
+		gname = purple_group_get_name(g);
+		bname = purple_buddy_get_name(b);
+
+		if (aim_ssi_itemlist_exists(od->ssi.local, bname)) {
+			/* If the buddy is an ICQ user then load his nickname */
+			const char *servernick = purple_blist_node_get_string((PurpleBlistNode*)b, "servernick");
+			char *alias;
+			const char *balias;
+			if (servernick)
+				serv_got_alias(gc, bname, servernick);
+
+			/* Store local alias on server */
+			alias = aim_ssi_getalias(od->ssi.local, gname, bname);
+			balias = purple_buddy_get_local_buddy_alias(b);
+			if (!alias && balias && *balias)
+				aim_ssi_aliasbuddy(od, gname, bname, balias);
+			g_free(alias);
+		} else {
+			purple_debug_info("oscar",
+					"ssi: removing buddy %s from local list\n", bname);
+			/* Queue the buddy for removal from the local list */
+			cur = g_slist_prepend(cur, b);
+		}
+	}
+	while (cur != NULL) {
+		purple_blist_remove_buddy(cur->data);
+		cur = g_slist_delete_link(cur, cur);
+	}
+
+	/* Permit list (ICQ doesn't have one) */
+	if (!od->icq) {
+		next = account->permit;
+		while (next != NULL) {
+			cur = next;
+			next = next->next;
+			if (!aim_ssi_itemlist_finditem(od->ssi.local, NULL, cur->data, AIM_SSI_TYPE_PERMIT)) {
+				purple_debug_info("oscar",
+						"ssi: removing permit %s from local list\n", (const char *)cur->data);
+				purple_privacy_permit_remove(account, cur->data, TRUE);
+			}
+		}
+	}
+
+	/* Deny list */
+	next = account->deny;
+	while (next != NULL) {
+		cur = next;
+		next = next->next;
+		if (!aim_ssi_itemlist_finditem(od->ssi.local, NULL, cur->data, deny_entry_type)) {
+			purple_debug_info("oscar",
+					"ssi: removing deny %s from local list\n", (const char *)cur->data);
+			purple_privacy_deny_remove(account, cur->data, TRUE);
+		}
+	}
+
+	/* Presence settings (idle time visibility) */
+	tmp = aim_ssi_getpresence(od->ssi.local);
+	if (tmp != 0xFFFFFFFF) {
+		const char *idle_reporting_pref;
+		gboolean report_idle;
+
+		idle_reporting_pref = purple_prefs_get_string("/purple/away/idle_reporting");
+		report_idle = strcmp(idle_reporting_pref, "none") != 0;
+
+		if (report_idle)
+			aim_ssi_setpresence(od, tmp | AIM_SSI_PRESENCE_FLAG_SHOWIDLE);
+		else
+			aim_ssi_setpresence(od, tmp & ~AIM_SSI_PRESENCE_FLAG_SHOWIDLE);
+	}
+
+	/*** End code for pruning buddies from local list ***/
+
+	/*** Begin code for adding from server list to local list ***/
+
+	for (curitem=od->ssi.local; curitem; curitem=curitem->next) {
+		if (curitem->name && !g_utf8_validate(curitem->name, -1, NULL)) {
+			/* Got node with invalid UTF-8 in the name.  Skip it. */
+			purple_debug_warning("oscar", "ssi: server list contains item of "
+					"type 0x%04hx with a non-utf8 name\n", curitem->type);
+			continue;
+		}
+
+		switch (curitem->type) {
+			case AIM_SSI_TYPE_BUDDY: { /* Buddy */
+				if (curitem->name) {
+					struct aim_ssi_item *groupitem;
+					char *gname, *gname_utf8, *alias, *alias_utf8;
+
+					groupitem = aim_ssi_itemlist_find(od->ssi.local, curitem->gid, 0x0000);
+					gname = groupitem ? groupitem->name : NULL;
+					gname_utf8 = oscar_utf8_try_convert(account, od, gname);
+
+					g = purple_find_group(gname_utf8 ? gname_utf8 : _("Orphans"));
+					if (g == NULL) {
+						g = purple_group_new(gname_utf8 ? gname_utf8 : _("Orphans"));
+						purple_blist_add_group(g, NULL);
+					}
+
+					alias = aim_ssi_getalias(od->ssi.local, gname, curitem->name);
+					alias_utf8 = oscar_utf8_try_convert(account, od, alias);
+
+					b = purple_find_buddy_in_group(account, curitem->name, g);
+					if (b) {
+						/* Get server stored alias */
+						purple_blist_alias_buddy(b, alias_utf8);
+					} else {
+						b = purple_buddy_new(account, curitem->name, alias_utf8);
+
+						purple_debug_info("oscar",
+								   "ssi: adding buddy %s to group %s to local list\n", curitem->name, gname);
+						purple_blist_add_buddy(b, NULL, g, NULL);
+					}
+
+					/* Mobile users should always be online */
+					if (curitem->name[0] == '+') {
+						purple_prpl_got_user_status(account,
+								purple_buddy_get_name(b),
+								OSCAR_STATUS_ID_AVAILABLE, NULL);
+						purple_prpl_got_user_status(account,
+								purple_buddy_get_name(b),
+								OSCAR_STATUS_ID_MOBILE, NULL);
+					}
+
+					g_free(gname_utf8);
+					g_free(alias);
+					g_free(alias_utf8);
+				}
+			} break;
+
+			case AIM_SSI_TYPE_GROUP: { /* Group */
+				if (curitem->name != NULL && purple_find_group(curitem->name) == NULL) {
+					g = purple_group_new(curitem->name);
+					purple_blist_add_group(g, NULL);
+				}
+			} break;
+
+			case AIM_SSI_TYPE_PERMIT: { /* Permit buddy (unless we're on ICQ) */
+				if (!od->icq && curitem->name) {
+					for (cur = account->permit; (cur && oscar_util_name_compare(curitem->name, cur->data)); cur = cur->next);
+					if (!cur) {
+						purple_debug_info("oscar",
+								   "ssi: adding permit buddy %s to local list\n", curitem->name);
+						purple_privacy_permit_add(account, curitem->name, TRUE);
+					}
+				}
+			} break;
+
+			case AIM_SSI_TYPE_ICQDENY:
+			case AIM_SSI_TYPE_DENY: { /* Deny buddy */
+				if (curitem->type == deny_entry_type && curitem->name) {
+					for (cur = account->deny; (cur && oscar_util_name_compare(curitem->name, cur->data)); cur = cur->next);
+					if (!cur) {
+						purple_debug_info("oscar",
+								   "ssi: adding deny buddy %s to local list\n", curitem->name);
+						purple_privacy_deny_add(account, curitem->name, TRUE);
+					}
+				}
+			} break;
+
+			case AIM_SSI_TYPE_PDINFO: { /* Permit/deny setting */
+				/*
+				 * We don't inherit the permit/deny setting from the server
+				 * for ICQ because, for ICQ, this setting controls who can
+				 * see your online status when you are invisible.  Thus it is
+				 * a part of your status and not really related to blocking.
+				 */
+				if (!od->icq && curitem->data) {
+					guint8 perm_deny = aim_ssi_getpermdeny(od->ssi.local);
+					if (perm_deny != 0 && perm_deny != account->perm_deny)
+					{
+						purple_debug_info("oscar",
+								   "ssi: changing permdeny from %d to %hhu\n", account->perm_deny, perm_deny);
+						account->perm_deny = perm_deny;
+					}
+				}
+			} break;
+
+			case AIM_SSI_TYPE_PRESENCEPREFS: { /* Presence setting */
+				/* We don't want to change Purple's setting because it applies to all accounts */
+			} break;
+		} /* End of switch on curitem->type */
+	} /* End of for loop */
+
+	/*** End code for adding from server list to local list ***/
+
+	if (od->icq) {
+		oscar_set_icq_permdeny(account);
+	} else {
+		oscar_set_aim_permdeny(gc);
+	}
+
+	/* Activate SSI */
+	/* Sending the enable causes other people to be able to see you, and you to see them */
+	/* Make sure your privacy setting/invisibility is set how you want it before this! */
+	purple_debug_info("oscar",
+			   "ssi: activating server-stored buddy list\n");
+	aim_ssi_enable(od);
+
+	/*
+	 * Make sure our server-stored icon is updated correctly in
+	 * the event that the local user set a new icon while this
+	 * account was offline.
+	 */
+	img = purple_buddy_icons_find_account_icon(account);
+	oscar_set_icon(gc, img);
+	purple_imgstore_unref(img);
+
+	/*
+	 * If we've already received our bos rights then we're not waiting on
+	 * anything else, so send the server clientready.
+	 */
+	if (od->bos.have_rights) {
+		aim_srv_clientready(od, conn);
+
+		/* Request offline messages for AIM and ICQ */
+		aim_im_reqofflinemsgs(od);
+
+		purple_connection_set_state(gc, PURPLE_CONNECTED);
+	}
+
+	return 1;
+}
+
+static int purple_ssi_parseack(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	va_list ap;
+	struct aim_ssi_tmp *retval;
+
+	va_start(ap, fr);
+	retval = va_arg(ap, struct aim_ssi_tmp *);
+	va_end(ap);
+
+	while (retval) {
+		purple_debug_misc("oscar",
+				   "ssi: status is 0x%04hx for a 0x%04hx action with name %s\n", retval->ack,  retval->action, retval->item ? (retval->item->name ? retval->item->name : "no name") : "no item");
+
+		if (retval->ack != 0xffff)
+		switch (retval->ack) {
+			case 0x0000: { /* added successfully */
+			} break;
+
+			case 0x000c: { /* you are over the limit, the cheat is to the limit, come on fhqwhgads */
+				gchar *buf;
+				buf = g_strdup_printf(_("Unable to add the buddy %s because you have too many buddies in your buddy list.  Please remove one and try again."), (retval->name ? retval->name : _("(no name)")));
+				if ((retval->name != NULL) && !purple_conv_present_error(retval->name, purple_connection_get_account(gc), buf))
+					purple_notify_error(gc, NULL, _("Unable to Add"), buf);
+				g_free(buf);
+			} break;
+
+			case 0x000e: { /* buddy requires authorization */
+				if ((retval->action == SNAC_SUBTYPE_FEEDBAG_ADD) && (retval->name))
+					oscar_auth_sendrequest(gc, retval->name, NULL);
+			} break;
+
+			default: { /* La la la */
+				gchar *buf;
+				purple_debug_error("oscar", "ssi: Action 0x%04hx was unsuccessful with error 0x%04hx\n", retval->action, retval->ack);
+				buf = g_strdup_printf(_("Unable to add the buddy %s for an unknown reason."),
+						(retval->name ? retval->name : _("(no name)")));
+				if ((retval->name != NULL) && !purple_conv_present_error(retval->name, purple_connection_get_account(gc), buf))
+					purple_notify_error(gc, NULL, _("Unable to Add"), buf);
+				g_free(buf);
+			} break;
+		}
+
+		retval = retval->next;
+	}
+
+	return 1;
+}
+
+static int
+purple_ssi_parseaddmod(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	char *gname, *gname_utf8, *alias, *alias_utf8;
+	PurpleBuddy *b;
+	PurpleGroup *g;
+	struct aim_ssi_item *ssi_item;
+	va_list ap;
+	guint16 snac_subtype, type;
+	const char *name;
+
+	gc = od->gc;
+	account = purple_connection_get_account(gc);
+
+	va_start(ap, fr);
+	snac_subtype = (guint16)va_arg(ap, int);
+	type = (guint16)va_arg(ap, int);
+	name = va_arg(ap, char *);
+	va_end(ap);
+
+	if ((type != 0x0000) || (name == NULL))
+		return 1;
+
+	gname = aim_ssi_itemlist_findparentname(od->ssi.local, name);
+	gname_utf8 = gname ? oscar_utf8_try_convert(account, od, gname) : NULL;
+
+	alias = aim_ssi_getalias(od->ssi.local, gname, name);
+	alias_utf8 = oscar_utf8_try_convert(account, od, alias);
+	g_free(alias);
+
+	b = purple_find_buddy(account, name);
+	if (b) {
+		/*
+		 * You're logged in somewhere else and you aliased one
+		 * of your buddies, so update our local buddy list with
+		 * the person's new alias.
+		 */
+		purple_blist_alias_buddy(b, alias_utf8);
+	} else if (snac_subtype == 0x0008) {
+		/*
+		 * You're logged in somewhere else and you added a buddy to
+		 * your server list, so add them to your local buddy list.
+		 */
+		b = purple_buddy_new(account, name, alias_utf8);
+
+		if (!(g = purple_find_group(gname_utf8 ? gname_utf8 : _("Orphans")))) {
+			g = purple_group_new(gname_utf8 ? gname_utf8 : _("Orphans"));
+			purple_blist_add_group(g, NULL);
+		}
+
+		purple_debug_info("oscar",
+				   "ssi: adding buddy %s to group %s to local list\n", name, gname_utf8 ? gname_utf8 : _("Orphans"));
+		purple_blist_add_buddy(b, NULL, g, NULL);
+
+		/* Mobile users should always be online */
+		if (name[0] == '+') {
+			purple_prpl_got_user_status(account,
+					name, OSCAR_STATUS_ID_AVAILABLE, NULL);
+			purple_prpl_got_user_status(account,
+					name, OSCAR_STATUS_ID_MOBILE, NULL);
+		}
+
+	}
+
+	ssi_item = aim_ssi_itemlist_finditem(od->ssi.local,
+			gname, name, AIM_SSI_TYPE_BUDDY);
+	if (ssi_item == NULL)
+	{
+		purple_debug_error("oscar", "purple_ssi_parseaddmod: "
+				"Could not find ssi item for oncoming buddy %s, "
+				"group %s\n", name, gname);
+	}
+
+	g_free(gname_utf8);
+	g_free(alias_utf8);
+
+	return 1;
+}
+
+static int purple_ssi_authgiven(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	va_list ap;
+	char *bn;
+	gchar *dialog_msg, *nombre;
+	struct name_data *data;
+	PurpleBuddy *buddy;
+
+	va_start(ap, fr);
+	bn = va_arg(ap, char *);
+	va_arg(ap, char *); /* msg */
+	va_end(ap);
+
+	purple_debug_info("oscar",
+			   "ssi: %s has given you permission to add him to your buddy list\n", bn);
+
+	buddy = purple_find_buddy(purple_connection_get_account(gc), bn);
+	if (buddy && (purple_buddy_get_alias_only(buddy)))
+		nombre = g_strdup_printf("%s (%s)", bn, purple_buddy_get_alias_only(buddy));
+	else
+		nombre = g_strdup(bn);
+
+	dialog_msg = g_strdup_printf(_("The user %s has given you permission to add him or her to your buddy list.  Do you want to add this user?"), nombre);
+	g_free(nombre);
+
+	data = g_new(struct name_data, 1);
+	data->gc = gc;
+	data->name = g_strdup(bn);
+	data->nick = (buddy ? g_strdup(purple_buddy_get_alias_only(buddy)) : NULL);
+
+	purple_request_yes_no(gc, NULL, _("Authorization Given"), dialog_msg,
+						PURPLE_DEFAULT_ACTION_NONE,
+						purple_connection_get_account(gc), bn, NULL,
+						data,
+						G_CALLBACK(purple_icq_buddyadd),
+						G_CALLBACK(oscar_free_name_data));
+	g_free(dialog_msg);
+
+	return 1;
+}
+
+static int purple_ssi_authrequest(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...)
+{
+	va_list ap;
+	const char *bn;
+	char *msg;
+
+	va_start(ap, fr);
+	bn = va_arg(ap, const char *);
+	msg = va_arg(ap, char *);
+	va_end(ap);
+
+	purple_debug_info("oscar",
+			"ssi: received authorization request from %s\n", bn);
+
+	if (!msg) {
+		purple_debug_warning("oscar", "Received auth request from %s with "
+				"empty message\n", bn);
+	} else if (!g_utf8_validate(msg, -1, NULL)) {
+		purple_debug_warning("oscar", "Received auth request from %s with "
+				"invalid UTF-8 message\n", bn);
+		msg = NULL;
+	}
+
+	aim_icq_getalias(od, bn, TRUE, msg);
+	return 1;
+}
+
+static int purple_ssi_authreply(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	va_list ap;
+	char *bn, *msg;
+	gchar *dialog_msg, *nombre;
+	guint8 reply;
+	PurpleBuddy *buddy;
+
+	va_start(ap, fr);
+	bn = va_arg(ap, char *);
+	reply = (guint8)va_arg(ap, int);
+	msg = va_arg(ap, char *);
+	va_end(ap);
+
+	purple_debug_info("oscar",
+			   "ssi: received authorization reply from %s.  Reply is 0x%04hhx\n", bn, reply);
+
+	buddy = purple_find_buddy(purple_connection_get_account(gc), bn);
+	if (buddy && (purple_buddy_get_alias_only(buddy)))
+		nombre = g_strdup_printf("%s (%s)", bn, purple_buddy_get_alias_only(buddy));
+	else
+		nombre = g_strdup(bn);
+
+	if (reply) {
+		/* Granted */
+		dialog_msg = g_strdup_printf(_("The user %s has granted your request to add them to your buddy list."), nombre);
+		purple_notify_info(gc, NULL, _("Authorization Granted"), dialog_msg);
+	} else {
+		/* Denied */
+		dialog_msg = g_strdup_printf(_("The user %s has denied your request to add them to your buddy list for the following reason:\n%s"), nombre, msg ? msg : _("No reason given."));
+		purple_notify_info(gc, NULL, _("Authorization Denied"), dialog_msg);
+	}
+	g_free(dialog_msg);
+	g_free(nombre);
+
+	return 1;
+}
+
+static int purple_ssi_gotadded(OscarData *od, FlapConnection *conn, FlapFrame *fr, ...) {
+	PurpleConnection *gc = od->gc;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	va_list ap;
+	char *bn;
+	PurpleBuddy *buddy;
+
+	va_start(ap, fr);
+	bn = va_arg(ap, char *);
+	va_end(ap);
+
+	buddy = purple_find_buddy(account, bn);
+	purple_debug_info("oscar", "ssi: %s added you to their buddy list\n", bn);
+	purple_account_notify_added(account, bn, NULL,
+			(buddy ? purple_buddy_get_alias_only(buddy) : NULL), NULL);
+
+	return 1;
+}
+
+GList *oscar_chat_info(PurpleConnection *gc) {
+	GList *m = NULL;
+	struct proto_chat_entry *pce;
+
+	pce = g_new0(struct proto_chat_entry, 1);
+	pce->label = _("_Room:");
+	pce->identifier = "room";
+	pce->required = TRUE;
+	m = g_list_append(m, pce);
+
+	pce = g_new0(struct proto_chat_entry, 1);
+	pce->label = _("_Exchange:");
+	pce->identifier = "exchange";
+	pce->required = TRUE;
+	pce->is_int = TRUE;
+	pce->min = 4;
+	pce->max = 20;
+	m = g_list_append(m, pce);
+
+	return m;
+}
+
+GHashTable *oscar_chat_info_defaults(PurpleConnection *gc, const char *chat_name)
+{
+	GHashTable *defaults;
+
+	defaults = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_free);
+
+	if (chat_name != NULL)
+		g_hash_table_insert(defaults, "room", g_strdup(chat_name));
+	g_hash_table_insert(defaults, "exchange", g_strdup("4"));
+
+	return defaults;
+}
+
+char *
+oscar_get_chat_name(GHashTable *data)
+{
+	return g_strdup(g_hash_table_lookup(data, "room"));
+}
+
+void
+oscar_join_chat(PurpleConnection *gc, GHashTable *data)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	FlapConnection *conn;
+	char *name, *exchange;
+	int exchange_int;
+
+	name = g_hash_table_lookup(data, "room");
+	exchange = g_hash_table_lookup(data, "exchange");
+
+	g_return_if_fail(name != NULL && *name != '\0');
+	g_return_if_fail(exchange != NULL);
+
+	errno = 0;
+	exchange_int = strtol(exchange, NULL, 10);
+	g_return_if_fail(errno == 0);
+
+	purple_debug_info("oscar", "Attempting to join chat room %s.\n", name);
+
+	if ((conn = flap_connection_getbytype(od, SNAC_FAMILY_CHATNAV)))
+	{
+		purple_debug_info("oscar", "chatnav exists, creating room\n");
+		aim_chatnav_createroom(od, conn, name, exchange_int);
+	} else {
+		/* this gets tricky */
+		struct create_room *cr = g_new0(struct create_room, 1);
+		purple_debug_info("oscar", "chatnav does not exist, opening chatnav\n");
+		cr->exchange = exchange_int;
+		cr->name = g_strdup(name);
+		od->create_rooms = g_slist_prepend(od->create_rooms, cr);
+		aim_srv_requestnew(od, SNAC_FAMILY_CHATNAV);
+	}
+}
+
+void
+oscar_chat_invite(PurpleConnection *gc, int id, const char *message, const char *name)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	struct chat_connection *ccon = find_oscar_chat(gc, id);
+
+	if (ccon == NULL)
+		return;
+
+	aim_im_sendch2_chatinvite(od, name, message ? message : "",
+			ccon->exchange, ccon->name, 0x0);
+}
+
+void
+oscar_chat_leave(PurpleConnection *gc, int id)
+{
+	PurpleConversation *conv;
+	struct chat_connection *cc;
+
+	conv = purple_find_chat(gc, id);
+
+	g_return_if_fail(conv != NULL);
+
+	purple_debug_info("oscar", "Leaving chat room %s\n",
+			purple_conversation_get_name(conv));
+
+	cc = find_oscar_chat(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(conv)));
+	flap_connection_schedule_destroy(cc->conn, OSCAR_DISCONNECT_DONE, NULL);
+	oscar_chat_kill(gc, cc);
+}
+
+int oscar_send_chat(PurpleConnection *gc, int id, const char *message, PurpleMessageFlags flags)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	PurpleConversation *conv = NULL;
+	struct chat_connection *c = NULL;
+	char *buf, *buf2, *buf3;
+	guint16 charset;
+	char *charsetstr;
+	gsize len;
+
+	if (!(conv = purple_find_chat(gc, id)))
+		return -EINVAL;
+
+	if (!(c = find_oscar_chat_by_conv(gc, conv)))
+		return -EINVAL;
+
+	buf = purple_strdup_withhtml(message);
+
+	if (strstr(buf, "<IMG "))
+		purple_conversation_write(conv, "",
+			_("Your IM Image was not sent. "
+			  "You cannot send IM Images in AIM chats."),
+			PURPLE_MESSAGE_ERROR, time(NULL));
+
+	buf2 = oscar_encode_im(buf, &len, &charset, &charsetstr);
+	/*
+	 * Evan S. suggested that maxvis really does mean "number of
+	 * visible characters" and not "number of bytes"
+	 */
+	if ((len > c->maxlen) || (len > c->maxvis)) {
+		/* If the length was too long, try stripping the HTML and then running it back through
+		 * purple_strdup_withhtml() and the encoding process. The result may be shorter. */
+		g_free(buf2);
+
+		buf3 = purple_markup_strip_html(buf);
+		g_free(buf);
+
+		buf = purple_strdup_withhtml(buf3);
+		g_free(buf3);
+
+		buf2 = oscar_encode_im(buf, &len, &charset, &charsetstr);
+
+		if ((len > c->maxlen) || (len > c->maxvis)) {
+			purple_debug_warning("oscar",
+					"Could not send %s because (%" G_GSIZE_FORMAT " > maxlen %i) or (%" G_GSIZE_FORMAT " > maxvis %i)\n",
+					buf2, len, c->maxlen, len, c->maxvis);
+			g_free(buf);
+			g_free(buf2);
+			return -E2BIG;
+		}
+
+		purple_debug_info("oscar", "Sending %s as %s because the original was too long.\n",
+				message, buf2);
+	}
+
+	aim_chat_send_im(od, c->conn, 0, buf2, len, charsetstr, "en");
+	g_free(buf2);
+	g_free(buf);
+
+	return 0;
+}
+
+PurpleMood* oscar_get_purple_moods(PurpleAccount *account)
+{
+	return icq_get_purple_moods(account);
+}
+
+const char *oscar_list_icon_icq(PurpleAccount *a, PurpleBuddy *b)
+{
+	const char *name = b ? purple_buddy_get_name(b) : NULL;
+	if (name && !oscar_util_valid_name_sms(name) && oscar_util_valid_name_icq(name))
+		return "icq";
+
+	return "icq";
+}
+
+const char *oscar_list_icon_aim(PurpleAccount *a, PurpleBuddy *b)
+{
+	const char *name = b ? purple_buddy_get_name(b) : NULL;
+	if (name && !oscar_util_valid_name_sms(name) && oscar_util_valid_name_icq(name))
+		return "icq";
+
+	return "aim";
+}
+
+const char *oscar_list_emblem(PurpleBuddy *b)
+{
+	PurpleConnection *gc = NULL;
+	OscarData *od = NULL;
+	PurpleAccount *account = NULL;
+	PurplePresence *presence;
+	aim_userinfo_t *userinfo = NULL;
+	const char *name;
+
+	account = purple_buddy_get_account(b);
+	name = purple_buddy_get_name(b);
+	if (account != NULL)
+		gc = purple_account_get_connection(account);
+	if (gc != NULL)
+		od = purple_connection_get_protocol_data(gc);
+	if (od != NULL)
+		userinfo = aim_locate_finduserinfo(od, name);
+
+	presence = purple_buddy_get_presence(b);
+
+	if (purple_presence_is_online(presence) == FALSE) {
+		char *gname;
+		if ((name) && (od) && (od->ssi.received_data) &&
+			(gname = aim_ssi_itemlist_findparentname(od->ssi.local, name)) &&
+			(aim_ssi_waitingforauth(od->ssi.local, gname, name))) {
+			return "not-authorized";
+		}
+	}
+
+	if (userinfo != NULL ) {
+		if (userinfo->flags & AIM_FLAG_ADMINISTRATOR)
+			return "admin";
+		if (userinfo->flags & AIM_FLAG_ACTIVEBUDDY)
+			return "bot";
+		if (userinfo->capabilities & OSCAR_CAPABILITY_SECUREIM)
+			return "secure";
+		if (userinfo->icqinfo.status & AIM_ICQ_STATE_BIRTHDAY)
+			return "birthday";
+
+		/* Make the mood icon override anything below this. */
+		if (purple_presence_is_status_primitive_active(presence, PURPLE_STATUS_MOOD))
+			return NULL;
+
+		if (userinfo->capabilities & OSCAR_CAPABILITY_HIPTOP)
+			return "hiptop";
+	}
+	return NULL;
+}
+
+void oscar_tooltip_text(PurpleBuddy *b, PurpleNotifyUserInfo *user_info, gboolean full)
+{
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	OscarData *od;
+	aim_userinfo_t *userinfo;
+
+	if (!PURPLE_BUDDY_IS_ONLINE(b))
+		return;
+
+	account = purple_buddy_get_account(b);
+	gc = purple_account_get_connection(account);
+	od = purple_connection_get_protocol_data(gc);
+	userinfo = aim_locate_finduserinfo(od, purple_buddy_get_name(b));
+
+	oscar_user_info_append_status(gc, user_info, b, userinfo, /* use_html_status */ FALSE);
+
+	if (full)
+		oscar_user_info_append_extra_info(gc, user_info, b, userinfo);
+}
+
+char *oscar_status_text(PurpleBuddy *b)
+{
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	OscarData *od;
+	const PurplePresence *presence;
+	const PurpleStatus *status;
+	const char *message;
+	gchar *ret = NULL;
+
+	gc = purple_account_get_connection(purple_buddy_get_account(b));
+	account = purple_connection_get_account(gc);
+	od = purple_connection_get_protocol_data(gc);
+	presence = purple_buddy_get_presence(b);
+	status = purple_presence_get_active_status(presence);
+
+	if ((od != NULL) && !purple_presence_is_online(presence))
+	{
+		const char *name = purple_buddy_get_name(b);
+		char *gname = aim_ssi_itemlist_findparentname(od->ssi.local, name);
+		if (aim_ssi_waitingforauth(od->ssi.local, gname, name))
+			ret = g_strdup(_("Not Authorized"));
+		else
+			ret = g_strdup(_("Offline"));
+	}
+	else
+	{
+		message = purple_status_get_attr_string(status, "message");
+		if (message != NULL)
+		{
+			gchar *tmp = oscar_util_format_string(message, purple_account_get_username(account));
+			ret = purple_markup_escape_text(tmp, -1);
+			g_free(tmp);
+		}
+		else if (purple_status_is_available(status))
+		{
+			/* Don't show "Available" as status message in case buddy doesn't have a status message */
+		}
+		else
+		{
+			ret = g_strdup(purple_status_get_name(status));
+		}
+	}
+
+	return ret;
+}
+
+void oscar_set_aim_permdeny(PurpleConnection *gc) {
+	PurpleAccount *account = purple_connection_get_account(gc);
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	/*
+	 * Conveniently there is a one-to-one mapping between the
+	 * values of libpurple's PurplePrivacyType and the values used
+	 * by the oscar protocol.
+	 */
+	aim_ssi_setpermdeny(od, account->perm_deny);
+}
+
+void oscar_add_permit(PurpleConnection *gc, const char *who) {
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	purple_debug_info("oscar", "ssi: About to add a permit\n");
+	aim_ssi_add_to_private_list(od, who, AIM_SSI_TYPE_PERMIT);
+}
+
+void oscar_add_deny(PurpleConnection *gc, const char *who) {
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	purple_debug_info("oscar", "ssi: About to add a deny\n");
+	aim_ssi_add_to_private_list(od, who, aim_ssi_getdenyentrytype(od));
+}
+
+void oscar_rem_permit(PurpleConnection *gc, const char *who) {
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	purple_debug_info("oscar", "ssi: About to delete a permit\n");
+	aim_ssi_del_from_private_list(od, who, AIM_SSI_TYPE_PERMIT);
+}
+
+void oscar_rem_deny(PurpleConnection *gc, const char *who) {
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	purple_debug_info("oscar", "ssi: About to delete a deny\n");
+	aim_ssi_del_from_private_list(od, who, aim_ssi_getdenyentrytype(od));
+}
+
+GList *
+oscar_status_types(PurpleAccount *account)
+{
+	gboolean is_icq;
+	GList *status_types = NULL;
+	PurpleStatusType *type;
+
+	g_return_val_if_fail(account != NULL, NULL);
+
+	/* Used to flag some statuses as "user settable" or not */
+	is_icq = oscar_util_valid_name_icq(purple_account_get_username(account));
+
+	/* Common status types */
+	/* Really the available message should only be settable for AIM accounts */
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
+										   OSCAR_STATUS_ID_AVAILABLE,
+										   NULL, TRUE, TRUE, FALSE,
+										   "message", _("Message"),
+										   purple_value_new(PURPLE_TYPE_STRING),
+										   "itmsurl", _("iTunes Music Store Link"),
+										   purple_value_new(PURPLE_TYPE_STRING), NULL);
+	status_types = g_list_prepend(status_types, type);
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
+									 OSCAR_STATUS_ID_FREE4CHAT,
+									 _("Free For Chat"), TRUE, is_icq, FALSE,
+									 "message", _("Message"),
+				purple_value_new(PURPLE_TYPE_STRING), NULL);
+
+	status_types = g_list_prepend(status_types, type);
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
+									 OSCAR_STATUS_ID_EVIL,
+									 _("Evil"), TRUE, is_icq, FALSE,
+				 "message", _("Message"),
+				purple_value_new(PURPLE_TYPE_STRING), NULL);
+	status_types = g_list_prepend(status_types, type);
+
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
+									 OSCAR_STATUS_ID_DEPRESSION,
+									 _("Depression"), TRUE, is_icq, FALSE,
+				 "message", _("Message"),
+				purple_value_new(PURPLE_TYPE_STRING), NULL);
+	status_types = g_list_prepend(status_types, type);
+
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
+									 OSCAR_STATUS_ID_ATHOME,
+									 _("At home"), TRUE, is_icq, FALSE,
+				"message", _("Message"),
+				purple_value_new(PURPLE_TYPE_STRING), NULL);
+	status_types = g_list_prepend(status_types, type);
+
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
+									 OSCAR_STATUS_ID_ATWORK,
+									 _("At work"), TRUE, is_icq, FALSE,
+				"message", _("Message"),
+				purple_value_new(PURPLE_TYPE_STRING), NULL);
+
+	status_types = g_list_prepend(status_types, type);
+
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
+									 OSCAR_STATUS_ID_LUNCH,
+									 _("Lunch"), TRUE, is_icq, FALSE,
+				"message", _("Message"),
+				purple_value_new(PURPLE_TYPE_STRING), NULL);
+
+	status_types = g_list_prepend(status_types, type);
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AWAY,
+										   OSCAR_STATUS_ID_AWAY,
+										   NULL, TRUE, TRUE, FALSE,
+										   "message", _("Message"),
+										   purple_value_new(PURPLE_TYPE_STRING), NULL);
+	status_types = g_list_prepend(status_types, type);
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_INVISIBLE,
+									 OSCAR_STATUS_ID_INVISIBLE,
+									 NULL, TRUE, TRUE, FALSE,
+									 "message", _("Message"),
+									  purple_value_new(PURPLE_TYPE_STRING), NULL);
+
+	status_types = g_list_prepend(status_types, type);
+
+	type = purple_status_type_new_full(PURPLE_STATUS_MOBILE, OSCAR_STATUS_ID_MOBILE, NULL, FALSE, FALSE, TRUE);
+	status_types = g_list_prepend(status_types, type);
+
+	/* ICQ-specific status types */
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_UNAVAILABLE,
+				OSCAR_STATUS_ID_OCCUPIED,
+				_("Occupied"), TRUE, is_icq, FALSE,
+				"message", _("Message"),
+				purple_value_new(PURPLE_TYPE_STRING), NULL);
+	status_types = g_list_prepend(status_types, type);
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_UNAVAILABLE,
+				OSCAR_STATUS_ID_DND,
+				_("Do Not Disturb"), TRUE, is_icq, FALSE,
+				"message", _("Message"),
+				purple_value_new(PURPLE_TYPE_STRING), NULL);
+	status_types = g_list_prepend(status_types, type);
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_EXTENDED_AWAY,
+				OSCAR_STATUS_ID_NA,
+				_("Not Available"), TRUE, is_icq, FALSE,
+				"message", _("Message"),
+				purple_value_new(PURPLE_TYPE_STRING), NULL);
+	status_types = g_list_prepend(status_types, type);
+
+	type = purple_status_type_new_full(PURPLE_STATUS_OFFLINE,
+									 OSCAR_STATUS_ID_OFFLINE,
+									 NULL, TRUE, TRUE, FALSE);
+	status_types = g_list_prepend(status_types, type);
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_MOOD,
+			"mood", NULL, TRUE, is_icq, TRUE,
+			PURPLE_MOOD_NAME, _("Mood Name"), purple_value_new(PURPLE_TYPE_STRING),
+			PURPLE_MOOD_COMMENT, _("Mood Comment"), purple_value_new(PURPLE_TYPE_STRING),
+			NULL);
+	status_types = g_list_prepend(status_types, type);
+
+	return g_list_reverse(status_types);
+}
+
+static void oscar_ssi_editcomment(struct name_data *data, const char *text) {
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	OscarData *od;
+	PurpleBuddy *b;
+	PurpleGroup *g;
+
+	gc = data->gc;
+	od = purple_connection_get_protocol_data(gc);
+	account = purple_connection_get_account(gc);
+
+	b = purple_find_buddy(account, data->name);
+	if (b == NULL) {
+		oscar_free_name_data(data);
+		return;
+	}
+
+	g = purple_buddy_get_group(b);
+	if (g == NULL) {
+		oscar_free_name_data(data);
+		return;
+	}
+
+	aim_ssi_editcomment(od, purple_group_get_name(g), data->name, text);
+	oscar_free_name_data(data);
+}
+
+static void oscar_buddycb_edit_comment(PurpleBlistNode *node, gpointer ignore) {
+
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+	OscarData *od;
+	struct name_data *data;
+	PurpleGroup *g;
+	char *comment;
+	gchar *comment_utf8;
+	gchar *title;
+	PurpleAccount *account;
+	const char *name;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy *) node;
+	name = purple_buddy_get_name(buddy);
+	account = purple_buddy_get_account(buddy);
+	gc = purple_account_get_connection(account);
+	od = purple_connection_get_protocol_data(gc);
+
+	if (!(g = purple_buddy_get_group(buddy)))
+		return;
+
+	data = g_new(struct name_data, 1);
+
+	comment = aim_ssi_getcomment(od->ssi.local, purple_group_get_name(g), name);
+	comment_utf8 = comment ? oscar_utf8_try_convert(account, od, comment) : NULL;
+
+	data->gc = gc;
+	data->name = g_strdup(name);
+	data->nick = g_strdup(purple_buddy_get_alias_only(buddy));
+
+	title = g_strdup_printf(_("Buddy Comment for %s"), data->name);
+	purple_request_input(gc, title, _("Buddy Comment:"), NULL,
+					   comment_utf8, TRUE, FALSE, NULL,
+					   _("_OK"), G_CALLBACK(oscar_ssi_editcomment),
+					   _("_Cancel"), G_CALLBACK(oscar_free_name_data),
+					   account, data->name, NULL,
+					   data);
+	g_free(title);
+
+	g_free(comment);
+	g_free(comment_utf8);
+}
+
+static void
+oscar_ask_directim_yes_cb(struct oscar_ask_directim_data *data)
+{
+	peer_connection_propose(data->od, OSCAR_CAPABILITY_DIRECTIM, data->who);
+	g_free(data->who);
+	g_free(data);
+}
+
+static void
+oscar_ask_directim_no_cb(struct oscar_ask_directim_data *data)
+{
+	g_free(data->who);
+	g_free(data);
+}
+
+/* This is called from right-click menu on a buddy node. */
+static void
+oscar_ask_directim(gpointer object, gpointer ignored)
+{
+	PurpleBlistNode *node;
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+	gchar *buf;
+	struct oscar_ask_directim_data *data;
+	PurpleAccount *account;
+
+	node = object;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy *)node;
+	account = purple_buddy_get_account(buddy);
+	gc = purple_account_get_connection(account);
+
+	data = g_new0(struct oscar_ask_directim_data, 1);
+	data->who = g_strdup(purple_buddy_get_name(buddy));
+	data->od = purple_connection_get_protocol_data(gc);
+	buf = g_strdup_printf(_("You have selected to open a Direct IM connection with %s."),
+			data->who);
+
+	purple_request_action(gc, NULL, buf,
+			_("Because this reveals your IP address, it "
+			  "may be considered a security risk.  Do you "
+			  "wish to continue?"),
+			0, /* Default action is "connect" */
+			account, data->who, NULL,
+			data, 2,
+			_("C_onnect"), G_CALLBACK(oscar_ask_directim_yes_cb),
+			_("_Cancel"), G_CALLBACK(oscar_ask_directim_no_cb));
+	g_free(buf);
+}
+
+static void
+oscar_close_directim(gpointer object, gpointer ignored)
+{
+	PurpleBlistNode *node;
+	PurpleBuddy *buddy;
+	PurpleAccount *account;
+	PurpleConnection *gc;
+	PurpleConversation *conv;
+	OscarData *od;
+	PeerConnection *conn;
+	const char *name;
+
+	node = object;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy*)node;
+	name = purple_buddy_get_name(buddy);
+	account = purple_buddy_get_account(buddy);
+	gc = purple_account_get_connection(account);
+	od = gc->proto_data;
+	conn = peer_connection_find_by_type(od, name, OSCAR_CAPABILITY_DIRECTIM);
+
+	if (conn != NULL)
+	{
+		if (!conn->ready)
+			aim_im_sendch2_cancel(conn);
+
+		peer_connection_destroy(conn, OSCAR_DISCONNECT_LOCAL_CLOSED, NULL);
+
+		/* OSCAR_DISCONNECT_LOCAL_CLOSED doesn't write anything to the convo
+		 * window. Let the user know that we cancelled the Direct IM. */
+		conv = purple_conversation_new(PURPLE_CONV_TYPE_IM, account, name);
+		purple_conversation_write(conv, NULL, _("You closed the connection."),
+				PURPLE_MESSAGE_SYSTEM, time(NULL));
+	}
+}
+
+static void oscar_get_icqxstatusmsg(PurpleBlistNode *node, gpointer ignore)
+{
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+	OscarData *od;
+	PurpleAccount *account;
+	const char *bname;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy *)node;
+	bname = purple_buddy_get_name(buddy);
+
+	account = purple_buddy_get_account(buddy);
+	gc = purple_account_get_connection(account);
+	od = purple_connection_get_protocol_data(gc);
+
+	purple_debug_info("oscar", "Manual X-Status Get From %s to %s:\n", bname, purple_account_get_username(account));
+
+	icq_im_xstatus_request(od, bname);
+}
+
+static void
+oscar_get_aim_info_cb(PurpleBlistNode *node, gpointer ignore)
+{
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy *)node;
+	gc = purple_account_get_connection(purple_buddy_get_account(buddy));
+
+	aim_locate_getinfoshort(purple_connection_get_protocol_data(gc),
+			purple_buddy_get_name(buddy), 0x00000003);
+}
+
+static GList *
+oscar_buddy_menu(PurpleBuddy *buddy) {
+	PurpleConnection *gc;
+	OscarData *od;
+	GList *menu;
+	PurpleMenuAction *act;
+	aim_userinfo_t *userinfo;
+	PurpleAccount *account;
+	const char *bname = purple_buddy_get_name(buddy);
+
+	account = purple_buddy_get_account(buddy);
+	gc = purple_account_get_connection(account);
+	od = purple_connection_get_protocol_data(gc);
+	userinfo = aim_locate_finduserinfo(od, bname);
+	menu = NULL;
+
+	if (od->icq && oscar_util_valid_name_icq(bname))
+	{
+		act = purple_menu_action_new(_("Get AIM Info"),
+								   PURPLE_CALLBACK(oscar_get_aim_info_cb),
+								   NULL, NULL);
+		menu = g_list_prepend(menu, act);
+	}
+
+	if (purple_buddy_get_group(buddy) != NULL)
+	{
+		/* We only do this if the user is in our buddy list */
+		act = purple_menu_action_new(_("Edit Buddy Comment"),
+		                           PURPLE_CALLBACK(oscar_buddycb_edit_comment),
+		                           NULL, NULL);
+		menu = g_list_prepend(menu, act);
+	}
+
+	if (od->icq)
+	{
+		act = purple_menu_action_new(_("Get X-Status Msg"),
+		                           PURPLE_CALLBACK(oscar_get_icqxstatusmsg),
+		                           NULL, NULL);
+		menu = g_list_prepend(menu, act);
+		menu = g_list_prepend(menu, create_visibility_menu_item(od, bname));
+	}
+
+	if (userinfo &&
+		oscar_util_name_compare(purple_account_get_username(account), bname) &&
+		PURPLE_BUDDY_IS_ONLINE(buddy))
+	{
+		PeerConnection *conn;
+		conn = peer_connection_find_by_type(od, bname, OSCAR_CAPABILITY_DIRECTIM);
+
+		if (userinfo->capabilities & OSCAR_CAPABILITY_DIRECTIM)
+		{
+			if (conn)
+			{
+				act = purple_menu_action_new(_("End Direct IM Session"),
+				                          PURPLE_CALLBACK(oscar_close_directim),
+				                          NULL, NULL);
+			}
+			else
+			{
+				act = purple_menu_action_new(_("Direct IM"),
+				                          PURPLE_CALLBACK(oscar_ask_directim),
+				                          NULL, NULL);
+			}
+			menu = g_list_prepend(menu, act);
+		}
+	}
+
+	if (od->ssi.received_data && purple_buddy_get_group(buddy) != NULL)
+	{
+		/*
+		 * We only do this if the user is in our buddy list and we're
+		 * waiting for authorization.
+		 */
+		char *gname;
+		gname = aim_ssi_itemlist_findparentname(od->ssi.local, bname);
+		if (gname && aim_ssi_waitingforauth(od->ssi.local, gname, bname))
+		{
+			act = purple_menu_action_new(_("Re-request Authorization"),
+			                           PURPLE_CALLBACK(oscar_auth_sendrequest_menu),
+			                           NULL, NULL);
+			menu = g_list_prepend(menu, act);
+		}
+	}
+
+	menu = g_list_reverse(menu);
+
+	return menu;
+}
+
+
+GList *oscar_blist_node_menu(PurpleBlistNode *node) {
+	if(PURPLE_BLIST_NODE_IS_BUDDY(node)) {
+		return oscar_buddy_menu((PurpleBuddy *) node);
+	} else {
+		return NULL;
+	}
+}
+
+static void
+oscar_icq_privacy_opts(PurpleConnection *gc, PurpleRequestFields *fields)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	PurpleAccount *account = purple_connection_get_account(gc);
+	PurpleRequestField *f;
+	gboolean auth, web_aware;
+
+	f = purple_request_fields_get_field(fields, "authorization");
+	auth = purple_request_field_bool_get_value(f);
+
+	f = purple_request_fields_get_field(fields, "web_aware");
+	web_aware = purple_request_field_bool_get_value(f);
+
+	purple_account_set_bool(account, "authorization", auth);
+	purple_account_set_bool(account, "web_aware", web_aware);
+
+	oscar_set_extended_status(gc);
+	aim_icq_setsecurity(od, auth, web_aware);
+}
+
+static void
+oscar_show_icq_privacy_opts(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *g;
+	PurpleRequestField *f;
+	gboolean auth, web_aware;
+
+	auth = purple_account_get_bool(account, "authorization", OSCAR_DEFAULT_AUTHORIZATION);
+	web_aware = purple_account_get_bool(account, "web_aware", OSCAR_DEFAULT_WEB_AWARE);
+
+	fields = purple_request_fields_new();
+
+	g = purple_request_field_group_new(NULL);
+
+	f = purple_request_field_bool_new("authorization", _("Require authorization"), auth);
+	purple_request_field_group_add_field(g, f);
+
+	f = purple_request_field_bool_new("web_aware", _("Web aware (enabling this will cause you to receive SPAM!)"), web_aware);
+	purple_request_field_group_add_field(g, f);
+
+	purple_request_fields_add_group(fields, g);
+
+	purple_request_fields(gc, _("ICQ Privacy Options"), _("ICQ Privacy Options"),
+						NULL, fields,
+						_("OK"), G_CALLBACK(oscar_icq_privacy_opts),
+						_("Cancel"), NULL,
+						purple_connection_get_account(gc), NULL, NULL,
+						gc);
+}
+
+static void oscar_confirm_account(PurplePluginAction *action)
+{
+	PurpleConnection *gc;
+	OscarData *od;
+	FlapConnection *conn;
+
+	gc = (PurpleConnection *)action->context;
+	od = purple_connection_get_protocol_data(gc);
+
+	conn = flap_connection_getbytype(od, SNAC_FAMILY_ADMIN);
+	if (conn != NULL) {
+		aim_admin_reqconfirm(od, conn);
+	} else {
+		od->conf = TRUE;
+		aim_srv_requestnew(od, SNAC_FAMILY_ADMIN);
+	}
+}
+
+static void oscar_show_email(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	FlapConnection *conn = flap_connection_getbytype(od, SNAC_FAMILY_ADMIN);
+
+	if (conn) {
+		aim_admin_getinfo(od, conn, 0x11);
+	} else {
+		od->reqemail = TRUE;
+		aim_srv_requestnew(od, SNAC_FAMILY_ADMIN);
+	}
+}
+
+static void oscar_change_email(PurpleConnection *gc, const char *email)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	FlapConnection *conn = flap_connection_getbytype(od, SNAC_FAMILY_ADMIN);
+
+	if (conn) {
+		aim_admin_setemail(od, conn, email);
+	} else {
+		od->setemail = TRUE;
+		od->email = g_strdup(email);
+		aim_srv_requestnew(od, SNAC_FAMILY_ADMIN);
+	}
+}
+
+static void oscar_show_change_email(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	purple_request_input(gc, NULL, _("Change Address To:"), NULL, NULL,
+					   FALSE, FALSE, NULL,
+					   _("_OK"), G_CALLBACK(oscar_change_email),
+					   _("_Cancel"), NULL,
+					   purple_connection_get_account(gc), NULL, NULL,
+					   gc);
+}
+
+static void oscar_show_awaitingauth(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	PurpleAccount *account = purple_connection_get_account(gc);
+	GSList *buddies, *filtered_buddies, *cur;
+	gchar *text;
+
+	buddies = purple_find_buddies(account, NULL);
+	filtered_buddies = NULL;
+	for (cur = buddies; cur != NULL; cur = cur->next) {
+		PurpleBuddy *buddy;
+		const gchar *bname, *gname;
+
+		buddy = cur->data;
+		bname = purple_buddy_get_name(buddy);
+		gname = purple_group_get_name(purple_buddy_get_group(buddy));
+		if (aim_ssi_waitingforauth(od->ssi.local, gname, bname)) {
+			filtered_buddies = g_slist_prepend(filtered_buddies, buddy);
+		}
+	}
+
+	g_slist_free(buddies);
+
+	filtered_buddies = g_slist_reverse(filtered_buddies);
+	text = oscar_format_buddies(filtered_buddies, _("you are not waiting for authorization"));
+	g_slist_free(filtered_buddies);
+
+	purple_notify_formatted(gc, NULL, _("You are awaiting authorization from "
+						  "the following buddies"),	_("You can re-request "
+						  "authorization from these buddies by "
+						  "right-clicking on them and selecting "
+						  "\"Re-request Authorization.\""), text, NULL, NULL);
+	g_free(text);
+}
+
+static void search_by_email_cb(PurpleConnection *gc, const char *email)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	aim_search_address(od, email);
+}
+
+static void oscar_show_find_email(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	purple_request_input(gc, _("Find Buddy by Email"),
+					   _("Search for a buddy by email address"),
+					   _("Type the email address of the buddy you are "
+						 "searching for."),
+					   NULL, FALSE, FALSE, NULL,
+					   _("_Search"), G_CALLBACK(search_by_email_cb),
+					   _("_Cancel"), NULL,
+					   purple_connection_get_account(gc), NULL, NULL,
+					   gc);
+}
+
+static void oscar_show_set_info(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	purple_account_request_change_user_info(purple_connection_get_account(gc));
+}
+
+static void oscar_show_set_info_icqurl(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	purple_notify_uri(gc, "http://www.icq.com/whitepages/user_details.php");
+}
+
+static void oscar_change_pass(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	purple_account_request_change_password(purple_connection_get_account(gc));
+}
+
+/**
+ * Only used when connecting with the old-style BUCP login.
+ */
+static void oscar_show_chpassurl(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	gchar *substituted = purple_strreplace(od->authinfo->chpassurl, "%s", purple_account_get_username(purple_connection_get_account(gc)));
+	purple_notify_uri(gc, substituted);
+	g_free(substituted);
+}
+
+static void oscar_show_imforwardingurl(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	purple_notify_uri(gc, "http://mymobile.aol.com/dbreg/register?action=imf&clientID=1");
+}
+
+void oscar_set_icon(PurpleConnection *gc, PurpleStoredImage *img)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	if (img == NULL) {
+		aim_ssi_delicon(od);
+	} else {
+		PurpleCipherContext *context;
+		guchar md5[16];
+		gconstpointer data = purple_imgstore_get_data(img);
+		size_t len = purple_imgstore_get_size(img);
+
+		context = purple_cipher_context_new_by_name("md5", NULL);
+		purple_cipher_context_append(context, data, len);
+		purple_cipher_context_digest(context, 16, md5, NULL);
+		purple_cipher_context_destroy(context);
+
+		aim_ssi_seticon(od, md5, 16);
+	}
+}
+
+/**
+ * Called by the Purple core to determine whether or not we're
+ * allowed to send a file to this user.
+ */
+gboolean
+oscar_can_receive_file(PurpleConnection *gc, const char *who)
+{
+	OscarData *od;
+	PurpleAccount *account;
+
+	od = purple_connection_get_protocol_data(gc);
+	account = purple_connection_get_account(gc);
+
+	if (od != NULL)
+	{
+		aim_userinfo_t *userinfo;
+		userinfo = aim_locate_finduserinfo(od, who);
+
+		/*
+		 * Don't allowing sending a file to a user that does not support
+		 * file transfer, and don't allow sending to ourselves.
+		 */
+		if (((userinfo == NULL) ||
+			(userinfo->capabilities & OSCAR_CAPABILITY_SENDFILE)) &&
+			oscar_util_name_compare(who, purple_account_get_username(account)))
+		{
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+PurpleXfer *
+oscar_new_xfer(PurpleConnection *gc, const char *who)
+{
+	PurpleXfer *xfer;
+	OscarData *od;
+	PurpleAccount *account;
+	PeerConnection *conn;
+
+	od = purple_connection_get_protocol_data(gc);
+	account = purple_connection_get_account(gc);
+
+	xfer = purple_xfer_new(account, PURPLE_XFER_SEND, who);
+	if (xfer)
+	{
+		purple_xfer_ref(xfer);
+		purple_xfer_set_init_fnc(xfer, peer_oft_sendcb_init);
+		purple_xfer_set_cancel_send_fnc(xfer, peer_oft_cb_generic_cancel);
+		purple_xfer_set_request_denied_fnc(xfer, peer_oft_cb_generic_cancel);
+		purple_xfer_set_ack_fnc(xfer, peer_oft_sendcb_ack);
+
+		conn = peer_connection_new(od, OSCAR_CAPABILITY_SENDFILE, who);
+		conn->flags |= PEER_CONNECTION_FLAG_INITIATED_BY_ME;
+		conn->flags |= PEER_CONNECTION_FLAG_APPROVED;
+		aim_icbm_makecookie(conn->cookie);
+		conn->xfer = xfer;
+		xfer->data = conn;
+	}
+
+	return xfer;
+}
+
+/*
+ * Called by the Purple core when the user indicates that a
+ * file is to be sent to a special someone.
+ */
+void
+oscar_send_file(PurpleConnection *gc, const char *who, const char *file)
+{
+	PurpleXfer *xfer;
+
+	xfer = oscar_new_xfer(gc, who);
+
+	if (file != NULL)
+		purple_xfer_request_accepted(xfer, file);
+	else
+		purple_xfer_request(xfer);
+}
+
+GList *
+oscar_actions(PurplePlugin *plugin, gpointer context)
+{
+	PurpleConnection *gc = (PurpleConnection *) context;
+	OscarData *od = purple_connection_get_protocol_data(gc);
+	GList *menu = NULL;
+	PurplePluginAction *act;
+
+	act = purple_plugin_action_new(_("Set User Info..."),
+			oscar_show_set_info);
+	menu = g_list_prepend(menu, act);
+
+	if (od->icq)
+	{
+		act = purple_plugin_action_new(_("Set User Info (web)..."),
+				oscar_show_set_info_icqurl);
+		menu = g_list_prepend(menu, act);
+	}
+
+	act = purple_plugin_action_new(_("Change Password..."),
+			oscar_change_pass);
+	menu = g_list_prepend(menu, act);
+
+	if (od->authinfo != NULL && od->authinfo->chpassurl != NULL)
+	{
+		/* This only happens when connecting with the old-style BUCP login */
+		act = purple_plugin_action_new(_("Change Password (web)"),
+				oscar_show_chpassurl);
+		menu = g_list_prepend(menu, act);
+	}
+
+	if (!od->icq)
+	{
+		act = purple_plugin_action_new(_("Configure IM Forwarding (web)"),
+				oscar_show_imforwardingurl);
+		menu = g_list_prepend(menu, act);
+	}
+
+	menu = g_list_prepend(menu, NULL);
+
+	if (od->icq)
+	{
+		/* ICQ actions */
+		act = purple_plugin_action_new(_("Set Privacy Options..."),
+				oscar_show_icq_privacy_opts);
+		menu = g_list_prepend(menu, act);
+
+		act = purple_plugin_action_new(_("Show Visible List"), oscar_show_visible_list);
+		menu = g_list_prepend(menu, act);
+
+		act = purple_plugin_action_new(_("Show Invisible List"), oscar_show_invisible_list);
+		menu = g_list_prepend(menu, act);
+	}
+	else
+	{
+		/* AIM actions */
+		act = purple_plugin_action_new(_("Confirm Account"),
+				oscar_confirm_account);
+		menu = g_list_prepend(menu, act);
+
+		act = purple_plugin_action_new(_("Display Currently Registered Email Address"),
+				oscar_show_email);
+		menu = g_list_prepend(menu, act);
+
+		act = purple_plugin_action_new(_("Change Currently Registered Email Address..."),
+				oscar_show_change_email);
+		menu = g_list_prepend(menu, act);
+	}
+
+	menu = g_list_prepend(menu, NULL);
+
+	act = purple_plugin_action_new(_("Show Buddies Awaiting Authorization"),
+			oscar_show_awaitingauth);
+	menu = g_list_prepend(menu, act);
+
+	menu = g_list_prepend(menu, NULL);
+
+	act = purple_plugin_action_new(_("Search for Buddy by Email Address..."),
+			oscar_show_find_email);
+	menu = g_list_prepend(menu, act);
+
+	menu = g_list_reverse(menu);
+
+	return menu;
+}
+
+void oscar_change_passwd(PurpleConnection *gc, const char *old, const char *new)
+{
+	OscarData *od = purple_connection_get_protocol_data(gc);
+
+	if (od->icq) {
+		aim_icq_changepasswd(od, new);
+	} else {
+		FlapConnection *conn;
+		conn = flap_connection_getbytype(od, SNAC_FAMILY_ADMIN);
+		if (conn) {
+			aim_admin_changepasswd(od, conn, new, old);
+		} else {
+			od->chpass = TRUE;
+			od->oldp = g_strdup(old);
+			od->newp = g_strdup(new);
+			aim_srv_requestnew(od, SNAC_FAMILY_ADMIN);
+		}
+	}
+}
+
+void
+oscar_convo_closed(PurpleConnection *gc, const char *who)
+{
+	OscarData *od;
+	PeerConnection *conn;
+
+	od = purple_connection_get_protocol_data(gc);
+	conn = peer_connection_find_by_type(od, who, OSCAR_CAPABILITY_DIRECTIM);
+
+	if (conn != NULL)
+	{
+		if (!conn->ready)
+			aim_im_sendch2_cancel(conn);
+
+		peer_connection_destroy(conn, OSCAR_DISCONNECT_LOCAL_CLOSED, NULL);
+	}
+}
+
+const char *
+oscar_normalize(const PurpleAccount *account, const char *str)
+{
+	static char buf[BUF_LEN];
+	char *tmp1, *tmp2;
+	int i, j;
+
+	g_return_val_if_fail(str != NULL, NULL);
+
+	/* copy str to buf and skip all blanks */
+	i = 0;
+	for (j = 0; str[j]; j++) {
+		if (str[j] != ' ') {
+			buf[i++] = str[j];
+			if (i >= BUF_LEN - 1)
+				break;
+		}
+	}
+	buf[i] = '\0';
+
+	tmp1 = g_utf8_strdown(buf, -1);
+	tmp2 = g_utf8_normalize(tmp1, -1, G_NORMALIZE_DEFAULT);
+	if (strlen(tmp2) > sizeof(buf) - 1) {
+		purple_debug_error("oscar", "normalized string exceeds buffer length!\n");
+	}
+	g_strlcpy(buf, tmp2, sizeof(buf));
+	g_free(tmp2);
+	g_free(tmp1);
+
+	return buf;
+}
+
+gboolean
+oscar_offline_message(const PurpleBuddy *buddy)
+{
+	return TRUE;
+}
+
+/* TODO: Find somewhere to put this instead of including it in a bunch of places.
+ * Maybe just change purple_accounts_find() to return anything for the prpl if there is no acct_id.
+ */
+static PurpleAccount *find_acct(const char *prpl, const char *acct_id)
+{
+	PurpleAccount *acct = NULL;
+
+	/* If we have a specific acct, use it */
+	if (acct_id) {
+		acct = purple_accounts_find(acct_id, prpl);
+		if (acct && !purple_account_is_connected(acct))
+			acct = NULL;
+	} else { /* Otherwise find an active account for the protocol */
+		GList *l = purple_accounts_get_all();
+		while (l) {
+			if (!strcmp(prpl, purple_account_get_protocol_id(l->data))
+					&& purple_account_is_connected(l->data)) {
+				acct = l->data;
+				break;
+			}
+			l = l->next;
+		}
+	}
+
+	return acct;
+}
+
+
+static gboolean oscar_uri_handler(const char *proto, const char *cmd, GHashTable *params)
+{
+	char *acct_id = g_hash_table_lookup(params, "account");
+	char prpl[11];
+	PurpleAccount *acct;
+
+	if (g_ascii_strcasecmp(proto, "aim") && g_ascii_strcasecmp(proto, "icq"))
+		return FALSE;
+
+	g_snprintf(prpl, sizeof(prpl), "prpl-%s", proto);
+
+	acct = find_acct(prpl, acct_id);
+
+	if (!acct)
+		return FALSE;
+
+	/* aim:GoIM?screenname=SCREENNAME&message=MESSAGE */
+	if (!g_ascii_strcasecmp(cmd, "GoIM")) {
+		char *bname = g_hash_table_lookup(params, "screenname");
+		if (bname) {
+			char *message = g_hash_table_lookup(params, "message");
+
+			PurpleConversation *conv = purple_find_conversation_with_account(
+				PURPLE_CONV_TYPE_IM, bname, acct);
+			if (conv == NULL)
+				conv = purple_conversation_new(PURPLE_CONV_TYPE_IM, acct, bname);
+			purple_conversation_present(conv);
+
+			if (message) {
+				/* Spaces are encoded as '+' */
+				g_strdelimit(message, "+", ' ');
+				purple_conv_send_confirm(conv, message);
+			}
+		}
+		/*else
+			**If pidgindialogs_im() was in the core, we could use it here.
+			 * It is all purple_request_* based, but I'm not sure it really belongs in the core
+			pidgindialogs_im();*/
+
+		return TRUE;
+	}
+	/* aim:GoChat?roomname=CHATROOMNAME&exchange=4 */
+	else if (!g_ascii_strcasecmp(cmd, "GoChat")) {
+		char *rname = g_hash_table_lookup(params, "roomname");
+		if (rname) {
+			/* This is somewhat hacky, but the params aren't useful after this command */
+			g_hash_table_insert(params, g_strdup("exchange"), g_strdup("4"));
+			g_hash_table_insert(params, g_strdup("room"), g_strdup(rname));
+			serv_join_chat(purple_account_get_connection(acct), params);
+		}
+		/*else
+			** Same as above (except that this would have to be re-written using purple_request_*)
+			pidgin_blist_joinchat_show(); */
+
+		return TRUE;
+	}
+	/* aim:AddBuddy?screenname=SCREENNAME&groupname=GROUPNAME*/
+	else if (!g_ascii_strcasecmp(cmd, "AddBuddy")) {
+		char *bname = g_hash_table_lookup(params, "screenname");
+		char *gname = g_hash_table_lookup(params, "groupname");
+		purple_blist_request_add_buddy(acct, bname, gname, NULL);
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+void oscar_init(PurplePlugin *plugin, gboolean is_icq)
+{
+	PurplePluginProtocolInfo *prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(plugin);
+	PurpleAccountOption *option;
+	static gboolean init = FALSE;
+	static const gchar *encryption_keys[] = {
+		N_("Use encryption if available"),
+		N_("Require encryption"),
+		N_("Don't use encryption"),
+		NULL
+	};
+	static const gchar *encryption_values[] = {
+		OSCAR_OPPORTUNISTIC_ENCRYPTION,
+		OSCAR_REQUIRE_ENCRYPTION,
+		OSCAR_NO_ENCRYPTION,
+		NULL
+	};
+	GList *encryption_options = NULL;
+	int i;
+
+	option = purple_account_option_string_new(_("Server"), "server", get_login_server(is_icq, TRUE));
+	prpl_info->protocol_options = g_list_append(prpl_info->protocol_options, option);
+
+	option = purple_account_option_int_new(_("Port"), "port", OSCAR_DEFAULT_LOGIN_PORT);
+	prpl_info->protocol_options = g_list_append(prpl_info->protocol_options, option);
+
+	for (i = 0; encryption_keys[i]; i++) {
+		PurpleKeyValuePair *kvp = g_new0(PurpleKeyValuePair, 1);
+		kvp->key = g_strdup(_(encryption_keys[i]));
+		kvp->value = g_strdup(encryption_values[i]);
+		encryption_options = g_list_append(encryption_options, kvp);
+	}
+	option = purple_account_option_list_new(_("Connection security"), "encryption", encryption_options);
+	prpl_info->protocol_options = g_list_append(prpl_info->protocol_options, option);
+
+	option = purple_account_option_bool_new(_("Use clientLogin"), "use_clientlogin",
+			OSCAR_DEFAULT_USE_CLIENTLOGIN);
+	prpl_info->protocol_options = g_list_append(prpl_info->protocol_options, option);
+
+	option = purple_account_option_bool_new(
+		_("Always use AIM/ICQ proxy server for\nfile transfers and direct IM (slower,\nbut does not reveal your IP address)"), "always_use_rv_proxy",
+		OSCAR_DEFAULT_ALWAYS_USE_RV_PROXY);
+	prpl_info->protocol_options = g_list_append(prpl_info->protocol_options, option);
+
+	if (g_str_equal(purple_plugin_get_id(plugin), "prpl-aim")) {
+		option = purple_account_option_bool_new(_("Allow multiple simultaneous logins"), "allow_multiple_logins",
+												OSCAR_DEFAULT_ALLOW_MULTIPLE_LOGINS);
+		prpl_info->protocol_options = g_list_append(prpl_info->protocol_options, option);
+	}
+
+	if (init)
+		return;
+	init = TRUE;
+
+	/* Preferences */
+	purple_prefs_add_none("/plugins/prpl/oscar");
+	purple_prefs_add_bool("/plugins/prpl/oscar/recent_buddies", FALSE);
+
+	purple_prefs_remove("/plugins/prpl/oscar/show_idle");
+	purple_prefs_remove("/plugins/prpl/oscar/always_use_rv_proxy");
+
+	/* protocol handler */
+	/* TODO: figure out a good instance to use here */
+	purple_signal_connect(purple_get_core(), "uri-handler", &init,
+		PURPLE_CALLBACK(oscar_uri_handler), NULL);
+}
+
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/oscar/oscar.h pidgin-2.10.11/libpurple/protocols/oscar/oscar.h
--- pidgin-2.10.11.orig/libpurple/protocols/oscar/oscar.h	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/oscar/oscar.h	2015-02-10 14:28:16.394018882 +0900
@@ -616,6 +616,7 @@
 #define AIM_CHARSET_ASCII   0x0000 /* ISO 646 */
 #define AIM_CHARSET_UNICODE 0x0002 /* ISO 10646 (UTF-16/UCS-2BE) */
 #define AIM_CHARSET_LATIN_1 0x0003 /* ISO 8859-1 */
+#define AIM_CHARSET_QUIRKUTF8	0x000d /* iChat and AIM6 use this in the meaning of UTF-8 in ODC. --yaz */
 
 /*
  * Arguments to aim_send_im_ext().
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/libyahoo.c pidgin-2.10.11/libpurple/protocols/yahoo/libyahoo.c
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/libyahoo.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/libyahoo.c	2015-02-10 14:28:16.394018882 +0900
@@ -32,6 +32,7 @@
 #include "yahoo_doodle.h"
 #include "yahoo_filexfer.h"
 #include "yahoo_picture.h"
+#include "ycht.h"
 
 static PurplePlugin *my_protocol = NULL;
 
@@ -332,10 +333,14 @@
 	option = purple_account_option_bool_new(_("Use account proxy for HTTP and HTTPS connections"), "proxy_ssl", FALSE);
 	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
 
-#if 0
 	option = purple_account_option_string_new(_("Chat room list URL"), "room_list", YAHOO_ROOMLIST_URL);
 	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
-#endif
+
+	option = purple_account_option_string_new(_("Yahoo Chat server"), "ycht-server", YAHOO_YCHT_HOST);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+	option = purple_account_option_int_new(_("Yahoo Chat port"), "ycht-port", YAHOO_YCHT_PORT);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
 
 	my_protocol = plugin;
 	yahoo_register_commands();
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/libyahoojp.c pidgin-2.10.11/libpurple/protocols/yahoo/libyahoojp.c
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/libyahoojp.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/libyahoojp.c	2015-02-10 14:28:16.394018882 +0900
@@ -31,6 +31,7 @@
 #include "yahoo_doodle.h"
 #include "yahoo_filexfer.h"
 #include "yahoo_picture.h"
+#include "ycht.h"
 
 static void yahoojp_register_commands(void)
 {
@@ -228,8 +229,14 @@
 	option = purple_account_option_bool_new(_("Use account proxy for HTTP and HTTPS connections"), "proxy_ssl", FALSE);
 	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
 
-#if 0
-	option = purple_account_option_string_new(_("Chat room list URL"), "room_list", YAHOO_ROOMLIST_URL);
+#if 1
+	option = purple_account_option_string_new(_("Chat room list URL"), "room_list", YAHOOJP_ROOMLIST_URL);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+	option = purple_account_option_string_new(_("Yahoo Chat server"), "ycht-server", YAHOOJP_YCHT_HOST);
+	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
+
+	option = purple_account_option_int_new(_("Yahoo Chat port"), "ycht-port", YAHOOJP_YCHT_PORT);
 	prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);
 #endif
 
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/libymsg.c pidgin-2.10.11/libpurple/protocols/yahoo/libymsg.c
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/libymsg.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/libymsg.c	2015-02-10 14:28:16.394018882 +0900
@@ -1695,8 +1695,9 @@
 
 #define OUT_CHARSET "utf-8"
 
-static char *yahoo_decode(const char *text)
+static char *yahoo_decode(PurpleConnection *gc, const char *text)
 {
+	YahooData *yd = gc->proto_data;
 	char *converted = NULL;
 	char *n, *new;
 	const char *end, *p;
@@ -1737,11 +1738,16 @@
 
 	*n = '\0';
 
-	if (strstr(text, "\033$B"))
-		converted = g_convert(new, n - new, OUT_CHARSET, "iso-2022-jp", NULL, NULL, NULL);
-	if (!converted)
-		converted = g_convert(new, n - new, OUT_CHARSET, "iso-8859-1", NULL, NULL, NULL);
-	g_free(new);
+	if (yd->jp) {
+		converted = g_convert(new, n - new, OUT_CHARSET, "UTF-8", NULL, NULL, NULL);
+	}
+	if (!yd->jp || !converted) {
+		if (strstr(text, "\033$B"))
+			converted = g_convert(new, n - new, OUT_CHARSET, "iso-2022-jp", NULL, NULL, NULL);
+		if (!converted)
+			converted = g_convert(new, n - new, OUT_CHARSET, "iso-8859-1", NULL, NULL, NULL);
+		g_free(new);
+	}
 
 	return converted;
 }
@@ -1790,8 +1796,8 @@
 	}
 
 	if (who && subj && email && *email) {
-		char *dec_who = yahoo_decode(who);
-		char *dec_subj = yahoo_decode(subj);
+		char *dec_who = yahoo_decode(gc, who);
+		char *dec_subj = yahoo_decode(gc, subj);
 		char *from = g_strdup_printf("%s (%s)", dec_who, email);
 
 		purple_notify_email(gc, dec_subj, from, purple_account_get_username(account),
@@ -1883,7 +1889,7 @@
 					2, name,
 					2, "1",
 					59, yd->cookie_b,
-					98, purple_account_get_string(account, "room_list_locale", yd->jp ? "jp" : "us"),
+					98, yd->jp ? "jp" : purple_account_get_string(account, "room_list_locale", "us"),
 					135, yd->jp ? YAHOOJP_CLIENT_VERSION : YAHOO_CLIENT_VERSION);
 	} else { /* don't try to send an empty B cookie - the server will be mad */
 		yahoo_packet_hash(pkt, "sssssssss",
@@ -1895,7 +1901,7 @@
 					244, yd->jp ? YAHOOJP_CLIENT_VERSION_ID : YAHOO_CLIENT_VERSION_ID,
 					2, name,
 					2, "1",
-					98, purple_account_get_string(account, "room_list_locale", yd->jp ? "jp" : "us"),
+					98, yd->jp ? "jp" : purple_account_get_string(account, "room_list_locale", "us"),
 					135, yd->jp ? YAHOOJP_CLIENT_VERSION : YAHOO_CLIENT_VERSION);
 	}
 
@@ -5024,6 +5030,7 @@
 	char *msg = NULL, *msg2 = NULL;
 	PurpleStatus *status = NULL;
 	gboolean invisible = FALSE;
+	gboolean utf8 = TRUE;
 
 	if (idle && yd->current_status != YAHOO_STATUS_CUSTOM)
 		yd->current_status = YAHOO_STATUS_IDLE;
@@ -5047,7 +5054,6 @@
 			status = purple_presence_get_active_status(purple_account_get_presence(purple_connection_get_account(gc)));
 		tmp = purple_status_get_attr_string(status, "message");
 		if (tmp != NULL) {
-			gboolean utf8 = TRUE;
 			msg = yahoo_string_encode(gc, tmp, &utf8);
 			msg2 = purple_markup_strip_html(msg);
 			yahoo_packet_hash_str(pkt, 97, utf8 ? "1" : 0);
@@ -5055,6 +5061,7 @@
 		} else {
 			/* get_yahoo_status_from_purple_status() returns YAHOO_STATUS_CUSTOM for
 			 * the generic away state (YAHOO_STATUS_TYPE_AWAY) with no message */
+			yahoo_packet_hash_str(pkt, 97, utf8 ? "1" : 0);
 			yahoo_packet_hash_str(pkt, 19, _("Away"));
 		}
 	} else {
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/libymsg.c.orig pidgin-2.10.11/libpurple/protocols/yahoo/libymsg.c.orig
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/libymsg.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/libymsg.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,5513 @@
+/*
+ * purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+
+/*
+ * Note: When handling the list of struct yahoo_pair's from an incoming
+ * packet the value might not be UTF-8. You should either validate that
+ * it is UTF-8 using g_utf8_validate() or use yahoo_string_decode().
+ */
+
+#include "internal.h"
+
+#include "account.h"
+#include "accountopt.h"
+#include "blist.h"
+#include "cipher.h"
+#include "cmds.h"
+#include "core.h"
+#include "debug.h"
+#include "network.h"
+#include "notify.h"
+#include "privacy.h"
+#include "prpl.h"
+#include "proxy.h"
+#include "request.h"
+#include "server.h"
+#include "util.h"
+#include "version.h"
+#include "xmlnode.h"
+
+#include "libymsg.h"
+#include "yahoochat.h"
+#include "yahoo_aliases.h"
+#include "yahoo_doodle.h"
+#include "yahoo_filexfer.h"
+#include "yahoo_friend.h"
+#include "yahoo_packet.h"
+#include "yahoo_picture.h"
+#include "ycht.h"
+
+/* #define YAHOO_DEBUG */
+
+/* #define TRY_WEBMESSENGER_LOGIN 0 */
+
+/* One hour */
+#define PING_TIMEOUT 3600
+
+/* One minute */
+#define KEEPALIVE_TIMEOUT 60
+
+#ifdef TRY_WEBMESSENGER_LOGIN
+static void yahoo_login_page_cb(PurpleUtilFetchUrlData *url_data, gpointer user_data, const gchar *url_text, size_t len, const gchar *error_message);
+#endif /* TRY_WEBMESSENGER_LOGIN */
+
+static gboolean yahoo_is_japan(PurpleAccount *account)
+{
+	return purple_strequal(purple_account_get_protocol_id(account), "prpl-yahoojp");
+}
+
+static void yahoo_update_status(PurpleConnection *gc, const char *name, YahooFriend *f)
+{
+	char *status = NULL;
+
+	if (!gc || !name || !f || !purple_find_buddy(purple_connection_get_account(gc), name))
+		return;
+
+	switch (f->status) {
+	case YAHOO_STATUS_OFFLINE:
+		status = YAHOO_STATUS_TYPE_OFFLINE;
+		break;
+	case YAHOO_STATUS_AVAILABLE:
+		status = YAHOO_STATUS_TYPE_AVAILABLE;
+		break;
+	case YAHOO_STATUS_BRB:
+		status = YAHOO_STATUS_TYPE_BRB;
+		break;
+	case YAHOO_STATUS_BUSY:
+		status = YAHOO_STATUS_TYPE_BUSY;
+		break;
+	case YAHOO_STATUS_NOTATHOME:
+		status = YAHOO_STATUS_TYPE_NOTATHOME;
+		break;
+	case YAHOO_STATUS_NOTATDESK:
+		status = YAHOO_STATUS_TYPE_NOTATDESK;
+		break;
+	case YAHOO_STATUS_NOTINOFFICE:
+		status = YAHOO_STATUS_TYPE_NOTINOFFICE;
+		break;
+	case YAHOO_STATUS_ONPHONE:
+		status = YAHOO_STATUS_TYPE_ONPHONE;
+		break;
+	case YAHOO_STATUS_ONVACATION:
+		status = YAHOO_STATUS_TYPE_ONVACATION;
+		break;
+	case YAHOO_STATUS_OUTTOLUNCH:
+		status = YAHOO_STATUS_TYPE_OUTTOLUNCH;
+		break;
+	case YAHOO_STATUS_STEPPEDOUT:
+		status = YAHOO_STATUS_TYPE_STEPPEDOUT;
+		break;
+	case YAHOO_STATUS_INVISIBLE: /* this should never happen? */
+		status = YAHOO_STATUS_TYPE_INVISIBLE;
+		break;
+	case YAHOO_STATUS_CUSTOM:
+	case YAHOO_STATUS_IDLE:
+		if (!f->away)
+			status = YAHOO_STATUS_TYPE_AVAILABLE;
+		else
+			status = YAHOO_STATUS_TYPE_AWAY;
+		break;
+	default:
+		purple_debug_warning("yahoo", "Warning, unknown status %d\n", f->status);
+		break;
+	}
+
+	if (status) {
+		if (f->status == YAHOO_STATUS_CUSTOM)
+			purple_prpl_got_user_status(purple_connection_get_account(gc), name, status, "message",
+			                          yahoo_friend_get_status_message(f), NULL);
+		else
+			purple_prpl_got_user_status(purple_connection_get_account(gc), name, status, NULL);
+	}
+
+	if (f->idle != 0)
+		purple_prpl_got_user_idle(purple_connection_get_account(gc), name, TRUE, f->idle);
+	else
+		purple_prpl_got_user_idle(purple_connection_get_account(gc), name, FALSE, 0);
+
+	if (f->sms)
+		purple_prpl_got_user_status(purple_connection_get_account(gc), name, YAHOO_STATUS_TYPE_MOBILE, NULL);
+	else
+		purple_prpl_got_user_status_deactive(purple_connection_get_account(gc), name, YAHOO_STATUS_TYPE_MOBILE);
+}
+
+static void yahoo_process_status(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	PurpleAccount *account = purple_connection_get_account(gc);
+	GSList *l = pkt->hash;
+	YahooFriend *f = NULL;
+	char *name = NULL;
+	gboolean unicode = FALSE;
+	char *message = NULL;
+	YahooFederation fed = YAHOO_FEDERATION_NONE;
+	char *fedname = NULL;
+
+	if (pkt->service == YAHOO_SERVICE_LOGOFF && pkt->status == -1) {
+		if (!purple_account_get_remember_password(account))
+			purple_account_set_password(account, NULL);
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NAME_IN_USE,
+			_("You have signed on from another location"));
+		return;
+	}
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 0: /* we won't actually do anything with this */
+		case 1: /* we won't actually do anything with this */
+			break;
+		case 8: /* how many online buddies we have */
+			break;
+		case 7: /* the current buddy */
+			/* update the previous buddy before changing the variables */
+			if (f) {
+				if (message)
+					yahoo_friend_set_status_message(f, yahoo_string_decode(gc, message, unicode));
+				if (name)
+					yahoo_update_status(gc, name, f);
+			}
+			name = message = NULL;
+			f = NULL;
+			if (pair->value && g_utf8_validate(pair->value, -1, NULL)) {
+				GSList *tmplist;
+
+				name = pair->value;
+
+				/* Look ahead to see if we have the federation info about the buddy */
+				for (tmplist = l->next; tmplist; tmplist = tmplist->next) {
+					struct yahoo_pair *p = tmplist->data;
+					if (p->key == 7)
+						break;
+					if (p->key == 241) {
+						fed = strtol(p->value, NULL, 10);
+						g_free(fedname);
+						switch (fed) {
+							case YAHOO_FEDERATION_MSN:
+								name = fedname = g_strconcat("msn/", name, NULL);
+								break;
+							case YAHOO_FEDERATION_OCS:
+								name = fedname = g_strconcat("ocs/", name, NULL);
+								break;
+							case YAHOO_FEDERATION_IBM:
+								name = fedname = g_strconcat("ibm/", name, NULL);
+								break;
+							case YAHOO_FEDERATION_NONE:
+							default:
+								fedname = NULL;
+								break;
+						}
+						break;
+					}
+				}
+				f = yahoo_friend_find_or_new(gc, name);
+				f->fed = fed;
+			}
+			break;
+		case 10: /* state */
+			if (!f)
+				break;
+
+			f->status = strtol(pair->value, NULL, 10);
+			if ((f->status >= YAHOO_STATUS_BRB) && (f->status <= YAHOO_STATUS_STEPPEDOUT))
+				f->away = 1;
+			else
+				f->away = 0;
+
+			if (f->status == YAHOO_STATUS_IDLE) {
+				/* Idle may have already been set in a more precise way in case 137 */
+				if (f->idle == 0)
+				{
+					if(pkt->service == YAHOO_SERVICE_STATUS_15)
+						f->idle = -1;
+					else
+						f->idle = time(NULL);
+				}
+			} else
+				f->idle = 0;
+
+			if (f->status != YAHOO_STATUS_CUSTOM)
+				yahoo_friend_set_status_message(f, NULL);
+
+			f->sms = 0;
+			break;
+		case 19: /* custom message */
+			if (f)
+				message = pair->value;
+			break;
+		case 11: /* this is the buddy's session id */
+			if (f)
+				f->session_id = strtol(pair->value, NULL, 10);
+			break;
+		case 17: /* in chat? */
+			break;
+		case 47: /* is custom status away or not? 2=idle*/
+			if (!f)
+				break;
+
+			/* I have no idea what it means when this is
+			 * set when someone's available, but it doesn't
+			 * mean idle. */
+			if (f->status == YAHOO_STATUS_AVAILABLE)
+				break;
+
+			f->away = strtol(pair->value, NULL, 10);
+			if (f->away == 2) {
+				/* Idle may have already been set in a more precise way in case 137 */
+				if (f->idle == 0)
+				{
+					if(pkt->service == YAHOO_SERVICE_STATUS_15)
+						f->idle = -1;
+					else
+						f->idle = time(NULL);
+				}
+			}
+
+			break;
+		case 138: /* when value is 1, either we're not idle, or we are but won't say how long */
+			if (!f)
+				break;
+
+			if( (strtol(pair->value, NULL, 10) == 1) && (f->idle) )
+				f->idle = -1;
+			break;
+		case 137: /* usually idle time in seconds, sometimes login time */
+			if (!f)
+				break;
+
+			if (f->status != YAHOO_STATUS_AVAILABLE)
+				f->idle = time(NULL) - strtol(pair->value, NULL, 10);
+			break;
+		case 13: /* bitmask, bit 0 = pager, bit 1 = chat, bit 2 = game */
+			if (strtol(pair->value, NULL, 10) == 0) {
+				if (f)
+					f->status = YAHOO_STATUS_OFFLINE;
+				if (name) {
+					purple_prpl_got_user_status(account, name, "offline", NULL);
+					purple_prpl_got_user_status_deactive(account, name, YAHOO_STATUS_TYPE_MOBILE);
+				}
+				break;
+			}
+			break;
+		case 60: /* SMS */
+			if (f) {
+				f->sms = strtol(pair->value, NULL, 10);
+				yahoo_update_status(gc, name, f);
+			}
+			break;
+		case 197: /* Avatars */
+		{
+			guchar *decoded;
+			char *tmp;
+			gsize len;
+
+			if (pair->value) {
+				decoded = purple_base64_decode(pair->value, &len);
+				if (decoded && len > 0) {
+					tmp = purple_str_binary_to_ascii(decoded, len);
+					purple_debug_info("yahoo", "Got key 197, value = %s\n", tmp);
+					g_free(tmp);
+				}
+				g_free(decoded);
+			}
+			break;
+		}
+		case 192: /* Pictures, aka Buddy Icons, checksum */
+		{
+			/* FIXME: Please, if you know this protocol,
+			 * FIXME: fix up the strtol() stuff if possible. */
+			int cksum = strtol(pair->value, NULL, 10);
+			const char *locksum = NULL;
+			PurpleBuddy *b;
+
+			if (!name)
+				break;
+
+			b = purple_find_buddy(gc->account, name);
+
+			if (!cksum || (cksum == -1)) {
+				if (f)
+					yahoo_friend_set_buddy_icon_need_request(f, TRUE);
+				purple_buddy_icons_set_for_user(gc->account, name, NULL, 0, NULL);
+				break;
+			}
+
+			if (!f)
+				break;
+
+			yahoo_friend_set_buddy_icon_need_request(f, FALSE);
+			if (b) {
+				locksum = purple_buddy_icons_get_checksum_for_user(b);
+				if (!locksum || (cksum != strtol(locksum, NULL, 10)))
+					yahoo_send_picture_request(gc, name);
+			}
+
+			break;
+		}
+		case 16: /* Custom error message */
+			{
+				char *tmp = yahoo_string_decode(gc, pair->value, TRUE);
+				purple_notify_error(gc, NULL, tmp, NULL);
+				g_free(tmp);
+			}
+			break;
+		case 97: /* Unicode status message */
+			unicode = !strcmp(pair->value, "1");
+			break;
+		case 244: /* client version number. Yahoo Client Detection */
+			if(f && strtol(pair->value, NULL, 10))
+				f->version_id = strtol(pair->value, NULL, 10);
+			break;
+		case 241: /* Federated network buddy belongs to */
+			break;  /* We process this when get '7' */
+		default:
+			purple_debug_warning("yahoo",
+					   "Unknown status key %d\n", pair->key);
+			break;
+		}
+
+		l = l->next;
+	}
+
+	if (f) {
+		if (pkt->service == YAHOO_SERVICE_LOGOFF)
+			f->status = YAHOO_STATUS_OFFLINE;
+		if (message)
+			yahoo_friend_set_status_message(f, yahoo_string_decode(gc, message, unicode));
+
+		if (name) /* update the last buddy */
+			yahoo_update_status(gc, name, f);
+	}
+
+	g_free(fedname);
+}
+
+static void yahoo_do_group_check(PurpleAccount *account, GHashTable *ht, const char *name, const char *group)
+{
+	PurpleBuddy *b;
+	PurpleGroup *g;
+	GSList *list, *i;
+	gboolean onlist = FALSE;
+	char *oname = NULL;
+
+	if (g_hash_table_lookup_extended(ht, name, (gpointer *)&oname, (gpointer *)&list))
+		g_hash_table_steal(ht, oname);
+	else
+		list = purple_find_buddies(account, name);
+
+	for (i = list; i; i = i->next) {
+		b = i->data;
+		g = purple_buddy_get_group(b);
+		if (!purple_utf8_strcasecmp(group, purple_group_get_name(g))) {
+			purple_debug_misc("yahoo",
+				"Oh good, %s is in the right group (%s).\n", name, group);
+			list = g_slist_delete_link(list, i);
+			onlist = TRUE;
+			break;
+		}
+	}
+
+	if (!onlist) {
+		purple_debug_misc("yahoo",
+			"Uhoh, %s isn't on the list (or not in this group), adding him to group %s.\n", name, group);
+		if (!(g = purple_find_group(group))) {
+			g = purple_group_new(group);
+			purple_blist_add_group(g, NULL);
+		}
+		b = purple_buddy_new(account, name, NULL);
+		purple_blist_add_buddy(b, NULL, g, NULL);
+	}
+
+	if (list) {
+		if (!oname)
+			oname = g_strdup(name);
+		g_hash_table_insert(ht, oname, list);
+	} else
+		g_free(oname);
+}
+
+static void yahoo_do_group_cleanup(gpointer key, gpointer value, gpointer user_data)
+{
+	char *name = key;
+	GSList *list = value, *i;
+	PurpleBuddy *b;
+	PurpleGroup *g;
+
+	for (i = list; i; i = i->next) {
+		b = i->data;
+		g = purple_buddy_get_group(b);
+		purple_debug_misc("yahoo", "Deleting Buddy %s from group %s.\n", name,
+				purple_group_get_name(g));
+		purple_blist_remove_buddy(b);
+	}
+}
+
+static char *_getcookie(char *rawcookie)
+{
+	char *cookie = NULL;
+	char *tmpcookie;
+	char *cookieend;
+
+	if (strlen(rawcookie) < 2)
+		return NULL;
+	tmpcookie = g_strdup(rawcookie+2);
+	cookieend = strchr(tmpcookie, ';');
+
+	if (cookieend)
+		*cookieend = '\0';
+
+	cookie = g_strdup(tmpcookie);
+	g_free(tmpcookie);
+
+	return cookie;
+}
+
+static void yahoo_process_cookie(YahooData *yd, char *c)
+{
+	if (c[0] == 'Y') {
+		if (yd->cookie_y)
+			g_free(yd->cookie_y);
+		yd->cookie_y = _getcookie(c);
+	} else if (c[0] == 'T') {
+		if (yd->cookie_t)
+			g_free(yd->cookie_t);
+		yd->cookie_t = _getcookie(c);
+	} else
+		purple_debug_info("yahoo", "Unrecognized cookie '%c'\n", c[0]);
+	yd->cookies = g_slist_prepend(yd->cookies, g_strdup(c));
+}
+
+static void yahoo_process_list_15(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	GSList *l = pkt->hash;
+
+	PurpleAccount *account = purple_connection_get_account(gc);
+	YahooData *yd = gc->proto_data;
+	GHashTable *ht;
+	char *norm_bud = NULL;
+	char *temp = NULL;
+	YahooFriend *f = NULL; /* It's your friends. They're going to want you to share your StarBursts. */
+	                       /* But what if you had no friends? */
+	YahooFederation fed = YAHOO_FEDERATION_NONE;
+	int stealth = 0;
+
+	ht = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_slist_free);
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+		l = l->next;
+
+		switch (pair->key) {
+		case 302:
+			/* This is always 318 before a group, 319 before the first s/n in a group, 320 before any ignored s/n.
+			 * It is not sent for s/n's in a group after the first.
+			 * All ignored s/n's are listed last, so when we see a 320 we clear the group and begin marking the
+			 * s/n's as ignored.  It is always followed by an identical 300 key.
+			 */
+			if (pair->value && !strcmp(pair->value, "320")) {
+				/* No longer in any group; this indicates the start of the ignore list. */
+				g_free(yd->current_list15_grp);
+				yd->current_list15_grp = NULL;
+			}
+
+			break;
+		case 301: /* This is 319 before all s/n's in a group after the first. It is followed by an identical 300. */
+			if(temp != NULL) {
+				switch (fed) {
+					case YAHOO_FEDERATION_MSN:
+						norm_bud = g_strconcat("msn/", temp, NULL);
+						break;
+					case YAHOO_FEDERATION_OCS:
+						norm_bud = g_strconcat("ocs/", temp, NULL);
+						break;
+					case YAHOO_FEDERATION_IBM:
+						norm_bud = g_strconcat("ibm/", temp, NULL);
+						break;
+					case YAHOO_FEDERATION_PBX:
+						norm_bud = g_strconcat("pbx/", temp, NULL);
+						break;
+					case YAHOO_FEDERATION_NONE:
+						norm_bud = g_strdup(temp);
+						break;
+				}
+				if (yd->current_list15_grp) {
+					/* This buddy is in a group */
+					f = yahoo_friend_find_or_new(gc, norm_bud);
+					if (!purple_find_buddy(account, norm_bud)) {
+						PurpleBuddy *b;
+						PurpleGroup *g;
+						if (!(g = purple_find_group(yd->current_list15_grp))) {
+							g = purple_group_new(yd->current_list15_grp);
+							purple_blist_add_group(g, NULL);
+						}
+						b = purple_buddy_new(account, norm_bud, NULL);
+						purple_blist_add_buddy(b, NULL, g, NULL);
+					}
+					yahoo_do_group_check(account, ht, norm_bud, yd->current_list15_grp);
+					if(fed) {
+						f->fed = fed;
+						purple_debug_info("yahoo", "Setting federation to %d\n", f->fed);
+					}
+					if(stealth == 2)
+						f->presence = YAHOO_PRESENCE_PERM_OFFLINE;
+
+					/* set p2p status not connected and no p2p packet sent */
+					if(fed == YAHOO_FEDERATION_NONE) {
+						yahoo_friend_set_p2p_status(f, YAHOO_P2PSTATUS_NOT_CONNECTED);
+						f->p2p_packet_sent = 0;
+					} else
+						yahoo_friend_set_p2p_status(f, YAHOO_P2PSTATUS_DO_NOT_CONNECT);
+				} else {
+					/* This buddy is on the ignore list (and therefore in no group) */
+					purple_debug_info("yahoo", "%s adding %s to the deny list because of the ignore list / no group was found\n",account->username, norm_bud);
+					purple_privacy_deny_add(account, norm_bud, 1);
+				}
+
+				g_free(norm_bud);
+				norm_bud=NULL;
+				fed = YAHOO_FEDERATION_NONE;
+				stealth = 0;
+				g_free(temp);
+				temp = NULL;
+			}
+			break;
+		case 300: /* This is 318 before a group, 319 before any s/n in a group, and 320 before any ignored s/n. */
+			break;
+		case 65: /* This is the group */
+			g_free(yd->current_list15_grp);
+			yd->current_list15_grp = yahoo_string_decode(gc, pair->value, FALSE);
+			break;
+		case 7: /* buddy's s/n */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				g_free(temp);
+				temp = g_strdup(purple_normalize(account, pair->value));
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_list_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 241: /* user on federated network */
+			fed = strtol(pair->value, NULL, 10);
+			break;
+		case 59: /* somebody told cookies come here too, but im not sure */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				yahoo_process_cookie(yd, pair->value);
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_list_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 317: /* Stealth Setting */
+			stealth = strtol(pair->value, NULL, 10);
+			break;
+		/* case 242: */ /* this seems related to 241 */
+			/* break; */
+		}
+	}
+
+	g_hash_table_foreach(ht, yahoo_do_group_cleanup, NULL);
+
+	/* The reporter of ticket #9745 determined that we weren't retrieving the
+	 * aliases during buddy list retrieval, so we never updated aliases that
+	 * changed while we were signed off. */
+	yahoo_fetch_aliases(gc);
+
+	/* Now that we have processed the buddy list, we can say yahoo has connected */
+	purple_connection_set_display_name(gc, purple_normalize(account, purple_account_get_username(account)));
+	yd->logged_in = TRUE;
+	purple_debug_info("yahoo","Authentication: Connection established\n");
+	purple_connection_set_state(gc, PURPLE_CONNECTED);
+	if (yd->picture_upload_todo) {
+		yahoo_buddy_icon_upload(gc, yd->picture_upload_todo);
+		yd->picture_upload_todo = NULL;
+	}
+	yahoo_set_status(account, purple_account_get_active_status(account));
+
+	g_hash_table_destroy(ht);
+	g_free(temp);
+}
+
+static void yahoo_process_list(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	GSList *l = pkt->hash;
+	gboolean got_serv_list = FALSE;
+	YahooFriend *f = NULL;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	YahooData *yd = gc->proto_data;
+	GHashTable *ht;
+
+	char **lines;
+	char **split;
+	char **buddies;
+	char **tmp, **bud, *norm_bud;
+	char *grp = NULL;
+
+	if (pkt->id)
+		yd->session_id = pkt->id;
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+		l = l->next;
+
+		switch (pair->key) {
+		case 87:
+			if (!yd->tmp_serv_blist)
+				yd->tmp_serv_blist = g_string_new(pair->value);
+			else
+				g_string_append(yd->tmp_serv_blist, pair->value);
+			break;
+		case 88:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				if (!yd->tmp_serv_ilist)
+					yd->tmp_serv_ilist = g_string_new(pair->value);
+				else
+					g_string_append(yd->tmp_serv_ilist, pair->value);
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_list "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 89:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				yd->profiles = g_strsplit(pair->value, ",", -1);
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_list "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 59: /* cookies, yum */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				yahoo_process_cookie(yd, pair->value);
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_list "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case YAHOO_SERVICE_PRESENCE_PERM:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				if (!yd->tmp_serv_plist)
+					yd->tmp_serv_plist = g_string_new(pair->value);
+				else
+					g_string_append(yd->tmp_serv_plist, pair->value);
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_list "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		}
+	}
+
+	if (pkt->status != 0)
+		return;
+
+	if (yd->tmp_serv_blist) {
+		ht = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_slist_free);
+
+		lines = g_strsplit(yd->tmp_serv_blist->str, "\n", -1);
+		for (tmp = lines; *tmp; tmp++) {
+			split = g_strsplit(*tmp, ":", 2);
+			if (!split)
+				continue;
+			if (!split[0] || !split[1]) {
+				g_strfreev(split);
+				continue;
+			}
+			grp = yahoo_string_decode(gc, split[0], FALSE);
+			buddies = g_strsplit(split[1], ",", -1);
+			for (bud = buddies; bud && *bud; bud++) {
+				if (!g_utf8_validate(*bud, -1, NULL)) {
+					purple_debug_warning("yahoo", "yahoo_process_list "
+							"got non-UTF-8 string for bud\n");
+					continue;
+				}
+
+				norm_bud = g_strdup(purple_normalize(account, *bud));
+				f = yahoo_friend_find_or_new(gc, norm_bud);
+
+				if (!purple_find_buddy(account, norm_bud)) {
+					PurpleBuddy *b;
+					PurpleGroup *g;
+					if (!(g = purple_find_group(grp))) {
+						g = purple_group_new(grp);
+						purple_blist_add_group(g, NULL);
+					}
+					b = purple_buddy_new(account, norm_bud, NULL);
+					purple_blist_add_buddy(b, NULL, g, NULL);
+				}
+
+				yahoo_do_group_check(account, ht, norm_bud, grp);
+				/* set p2p status not connected and no p2p packet sent */
+				yahoo_friend_set_p2p_status(f, YAHOO_P2PSTATUS_NOT_CONNECTED);
+				f->p2p_packet_sent = 0;
+
+				g_free(norm_bud);
+			}
+			g_strfreev(buddies);
+			g_strfreev(split);
+			g_free(grp);
+		}
+		g_strfreev(lines);
+
+		g_string_free(yd->tmp_serv_blist, TRUE);
+		yd->tmp_serv_blist = NULL;
+		g_hash_table_foreach(ht, yahoo_do_group_cleanup, NULL);
+		g_hash_table_destroy(ht);
+	}
+
+	if (yd->tmp_serv_ilist) {
+		buddies = g_strsplit(yd->tmp_serv_ilist->str, ",", -1);
+		for (bud = buddies; bud && *bud; bud++) {
+			/* The server is already ignoring the user */
+			got_serv_list = TRUE;
+			purple_privacy_deny_add(account, *bud, 1);
+		}
+		g_strfreev(buddies);
+
+		g_string_free(yd->tmp_serv_ilist, TRUE);
+		yd->tmp_serv_ilist = NULL;
+	}
+
+	if (got_serv_list &&
+		((account->perm_deny != PURPLE_PRIVACY_ALLOW_BUDDYLIST) &&
+		(account->perm_deny != PURPLE_PRIVACY_DENY_ALL) &&
+		(account->perm_deny != PURPLE_PRIVACY_ALLOW_USERS)))
+	{
+		account->perm_deny = PURPLE_PRIVACY_DENY_USERS;
+		purple_debug_info("yahoo", "%s privacy defaulting to PURPLE_PRIVACY_DENY_USERS.\n",
+				account->username);
+	}
+
+	if (yd->tmp_serv_plist) {
+		buddies = g_strsplit(yd->tmp_serv_plist->str, ",", -1);
+		for (bud = buddies; bud && *bud; bud++) {
+			f = yahoo_friend_find(gc, *bud);
+			if (f) {
+				purple_debug_info("yahoo", "%s setting presence for %s to PERM_OFFLINE\n",
+						account->username, *bud);
+				f->presence = YAHOO_PRESENCE_PERM_OFFLINE;
+			}
+		}
+		g_strfreev(buddies);
+		g_string_free(yd->tmp_serv_plist, TRUE);
+		yd->tmp_serv_plist = NULL;
+
+	}
+	/* Now that we've got the list, request aliases */
+	yahoo_fetch_aliases(gc);
+}
+
+/* pkt_type is YAHOO_PKT_TYPE_SERVER if pkt arrives from yahoo server, YAHOO_PKT_TYPE_P2P if pkt arrives through p2p */
+static void yahoo_process_notify(PurpleConnection *gc, struct yahoo_packet *pkt, yahoo_pkt_type pkt_type)
+{
+	PurpleAccount *account;
+	char *msg = NULL;
+	char *from = NULL;
+	char *stat = NULL;
+	char *game = NULL;
+	YahooFriend *f = NULL;
+	GSList *l = pkt->hash;
+	gint val_11 = 0;
+	YahooData *yd = gc->proto_data;
+	YahooFederation fed = YAHOO_FEDERATION_NONE;
+
+	account = purple_connection_get_account(gc);
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+		if (pair->key == 4 || pair->key == 1) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				from = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_notify "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		}
+		if (pair->key == 49)
+			msg = pair->value;
+		if (pair->key == 13)
+			stat = pair->value;
+		if (pair->key == 14) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				game = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_notify "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		}
+		if (pair->key == 11)
+			val_11 = strtol(pair->value, NULL, 10);
+		if (pair->key == 241)
+			fed = strtol(pair->value, NULL, 10);
+		l = l->next;
+	}
+
+	if (!from || !msg)
+		return;
+
+	/* disconnect the peer if connected through p2p and sends wrong value for session id */
+	if( (pkt_type == YAHOO_PKT_TYPE_P2P) && (val_11 != yd->session_id) ) {
+		purple_debug_warning("yahoo","p2p: %s sent us notify with wrong session id. Disconnecting p2p connection to peer\n", from);
+		/* remove from p2p connection lists, also calls yahoo_p2p_disconnect_destroy_data */
+		g_hash_table_remove(yd->peers, from);
+		return;
+	}
+
+	if (!g_ascii_strncasecmp(msg, "TYPING", strlen("TYPING"))
+		&& (purple_privacy_check(account, from)))
+	{
+		char *fed_from = from;
+		switch (fed) {
+			case YAHOO_FEDERATION_MSN:
+				fed_from = g_strconcat("msn/", from, NULL);
+				break;
+			case YAHOO_FEDERATION_OCS:
+				fed_from = g_strconcat("ocs/", from, NULL);
+				break;
+			case YAHOO_FEDERATION_IBM:
+				fed_from = g_strconcat("ibm/", from, NULL);
+				break;
+			case YAHOO_FEDERATION_PBX:
+				fed_from = g_strconcat("pbx/", from, NULL);
+				break;
+			case YAHOO_FEDERATION_NONE:
+			default:
+				break;
+		}
+
+		if (stat && *stat == '1')
+			serv_got_typing(gc, fed_from, 0, PURPLE_TYPING);
+		else
+			serv_got_typing_stopped(gc, fed_from);
+
+		if (fed_from != from)
+			g_free(fed_from);
+
+	} else if (!g_ascii_strncasecmp(msg, "GAME", strlen("GAME"))) {
+		PurpleBuddy *bud = purple_find_buddy(account, from);
+
+		if (!bud) {
+			purple_debug_warning("yahoo",
+					   "%s is playing a game, and doesn't want you to know.\n", from);
+		}
+
+		f = yahoo_friend_find(gc, from);
+		if (!f)
+			return; /* if they're not on the list, don't bother */
+
+		yahoo_friend_set_game(f, NULL);
+
+		if (stat && *stat == '1') {
+			yahoo_friend_set_game(f, game);
+			if (bud)
+				yahoo_update_status(gc, from, f);
+		}
+	} else if (!g_ascii_strncasecmp(msg, "WEBCAMINVITE", strlen("WEBCAMINVITE"))) {
+		PurpleConversation *conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, from, account);
+		char *buf = g_strdup_printf(_("%s has sent you a webcam invite, which is not yet supported."), from);
+		purple_conversation_write(conv, NULL, buf, PURPLE_MESSAGE_SYSTEM|PURPLE_MESSAGE_NOTIFY, time(NULL));
+		g_free(buf);
+	}
+}
+
+
+struct _yahoo_im {
+	char *from;
+	char *active_id;
+	int time;
+	int utf8;
+	int buddy_icon;
+	char *id;
+	char *msg;
+	YahooFederation fed;
+	char *fed_from;
+};
+
+static void yahoo_process_sms_message(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	PurpleAccount *account;
+	GSList *l = pkt->hash;
+	struct _yahoo_im *sms = NULL;
+	YahooData *yd;
+	char *server_msg = NULL;
+	char *m;
+
+	yd = gc->proto_data;
+	account = purple_connection_get_account(gc);
+
+	while (l != NULL) {
+		struct yahoo_pair *pair = l->data;
+		if (pair->key == 4) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				sms = g_new0(struct _yahoo_im, 1);
+				sms->from = g_strdup_printf("+%s", pair->value);
+				sms->time = time(NULL);
+				sms->utf8 = TRUE;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_sms_message "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		}
+		if (pair->key == 14) {
+			if (sms)
+				sms->msg = pair->value;
+		}
+		if (pair->key == 68)
+			if(sms)
+				g_hash_table_insert(yd->sms_carrier, g_strdup(sms->from), g_strdup(pair->value));
+		if (pair->key == 16) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				server_msg = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_sms_message "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		}
+		l = l->next;
+	}
+
+	if(!sms) {
+		purple_debug_info("yahoo", "Received a malformed SMS packet!\n");
+		return;
+	}
+
+	if ((int)pkt->status < 0)
+		pkt->status = YAHOO_STATUS_DISCONNECTED;
+	if (pkt->status == YAHOO_STATUS_DISCONNECTED) {
+		if (server_msg) {
+			PurpleConversation *c;
+			c = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, sms->from, account);
+			if (c == NULL)
+				c = purple_conversation_new(PURPLE_CONV_TYPE_IM, account, sms->from);
+			purple_conversation_write(c, NULL, server_msg, PURPLE_MESSAGE_SYSTEM, time(NULL));
+		}
+		else
+			purple_notify_error(gc, NULL, _("Your SMS was not delivered"), NULL);
+
+		g_free(sms->from);
+		g_free(sms);
+		return ;
+	}
+
+	if (!sms->from || !sms->msg) {
+		g_free(sms);
+		return;
+	}
+
+	m = yahoo_string_decode(gc, sms->msg, sms->utf8);
+	serv_got_im(gc, sms->from, m, 0, sms->time);
+
+	g_free(m);
+	g_free(sms->from);
+	g_free(sms);
+}
+
+/* pkt_type is YAHOO_PKT_TYPE_SERVER if pkt arrives from yahoo server, YAHOO_PKT_TYPE_P2P if pkt arrives through p2p */
+static void yahoo_process_message(PurpleConnection *gc, struct yahoo_packet *pkt, yahoo_pkt_type pkt_type)
+{
+	PurpleAccount *account;
+	YahooData *yd = gc->proto_data;
+	GSList *l = pkt->hash;
+	GSList *list = NULL;
+	struct _yahoo_im *im = NULL;
+
+	account = purple_connection_get_account(gc);
+
+	if (pkt->status <= 1 || pkt->status == 5 || pkt->status == YAHOO_STATUS_OFFLINE) {
+	/* messages are received with status YAHOO_STATUS_OFFLINE in case of p2p */
+		while (l != NULL) {
+			struct yahoo_pair *pair = l->data;
+			if (pair->key == 4 || pair->key == 1) {
+				if (g_utf8_validate(pair->value, -1, NULL)) {
+					im = g_new0(struct _yahoo_im, 1);
+					list = g_slist_append(list, im);
+					im->from = pair->value;
+					im->time = time(NULL);
+					im->utf8 = TRUE;
+					im->fed = YAHOO_FEDERATION_NONE;
+					im->fed_from = g_strdup(im->from);
+				} else {
+					purple_debug_warning("yahoo", "yahoo_process_message "
+							"got non-UTF-8 string for key %d\n", pair->key);
+				}
+			}
+			if (im && pair->key == 5)
+				im->active_id = pair->value;
+			if (pair->key == 97)
+				if (im)
+					im->utf8 = strtol(pair->value, NULL, 10);
+			if (pair->key == 15)
+				if (im)
+					im->time = strtol(pair->value, NULL, 10);
+			if (pair->key == 206)
+				if (im)
+					im->buddy_icon = strtol(pair->value, NULL, 10);
+			if (pair->key == 14) {
+				if (im)
+					im->msg = pair->value;
+			}
+			if (im && pair->key == 241) {
+				im->fed = strtol(pair->value, NULL, 10);
+				g_free(im->fed_from);
+				switch (im->fed) {
+					case YAHOO_FEDERATION_MSN:
+						im->fed_from = g_strconcat("msn/",im->from, NULL);
+						break;
+					case YAHOO_FEDERATION_OCS:
+						im->fed_from = g_strconcat("ocs/",im->from, NULL);
+						break;
+					case YAHOO_FEDERATION_IBM:
+						im->fed_from = g_strconcat("ibm/",im->from, NULL);
+						break;
+					case YAHOO_FEDERATION_PBX:
+						im->fed_from = g_strconcat("pbx/",im->from, NULL);
+						break;
+					case YAHOO_FEDERATION_NONE:
+					default:
+						im->fed_from = g_strdup(im->from);
+						break;
+				}
+				purple_debug_info("yahoo", "Message from federated (%d) buddy %s.\n", im->fed, im->fed_from);
+
+			}
+			/* peer session id */
+			if (im && (pair->key == 11)) {
+				/* disconnect the peer if connected through p2p and sends wrong value for session id */
+				if( (im->fed == YAHOO_FEDERATION_NONE) && (pkt_type == YAHOO_PKT_TYPE_P2P)
+						&& (yd->session_id != strtol(pair->value, NULL, 10)) )
+				{
+					purple_debug_warning("yahoo","p2p: %s sent us message with wrong session id. Disconnecting p2p connection to peer\n", im->fed_from);
+					/* remove from p2p connection lists, also calls yahoo_p2p_disconnect_destroy_data */
+					g_hash_table_remove(yd->peers, im->fed_from);
+					g_free(im->fed_from);
+					g_free(im);
+					return; /* Not sure whether we should process remaining IMs in this packet */
+				}
+			}
+			/* IMV key */
+			if (im && pair->key == 63 && g_utf8_validate(pair->value, -1, NULL))
+			{
+				/* Check for the Doodle IMV, no IMvironment for federated buddies */
+				if (im->from != NULL && im->fed == YAHOO_FEDERATION_NONE)
+				{
+					g_hash_table_replace(yd->imvironments, g_strdup(im->from), g_strdup(pair->value));
+
+					if (strstr(pair->value, "doodle;") != NULL)
+					{
+						PurpleWhiteboard *wb;
+
+						if (!purple_privacy_check(account, im->from)) {
+							purple_debug_info("yahoo", "Doodle request from %s dropped.\n",
+												im->from);
+							g_free(im->fed_from);
+							g_free(im);
+							return;
+						}
+						/* I'm not sure the following ever happens -DAA */
+						wb = purple_whiteboard_get_session(account, im->from);
+
+						/* If a Doodle session doesn't exist between this user */
+						if(wb == NULL)
+						{
+							doodle_session *ds;
+							wb = purple_whiteboard_create(account, im->from,
+											DOODLE_STATE_REQUESTED);
+							ds = wb->proto_data;
+							ds->imv_key = g_strdup(pair->value);
+
+							yahoo_doodle_command_send_request(gc, im->from, pair->value);
+							yahoo_doodle_command_send_ready(gc, im->from, pair->value);
+						}
+					}
+				}
+			}
+			if (pair->key == 429)
+				if (im)
+					im->id = pair->value;
+			l = l->next;
+		}
+	} else if (pkt->status == 2) {
+		purple_notify_error(gc, NULL,
+		                  _("Your Yahoo! message did not get sent."), NULL);
+	}
+
+	for (l = list; l; l = l->next) {
+		YahooFriend *f;
+		char *m, *m2;
+		im = l->data;
+
+		if (!im->fed_from || !im->msg) {
+			g_free(im->fed_from);
+			g_free(im);
+			continue;
+		}
+
+		if (!purple_privacy_check(account, im->fed_from)) {
+			purple_debug_info("yahoo", "Message from %s dropped.\n", im->fed_from);
+			return;
+		}
+
+		/*
+		 * TODO: Is there anything else we should check when determining whether
+		 *       we should send an acknowledgement?
+		 */
+		if (im->id != NULL) {
+			/* Send acknowledgement.  If we don't do this then the official
+			 * Yahoo Messenger client for Windows will send us the same
+			 * message 7 seconds later as an offline message.  This is true
+			 * for at least version 9.0.0.2162 on Windows XP. */
+			struct yahoo_packet *pkt2;
+			pkt2 = yahoo_packet_new(YAHOO_SERVICE_MESSAGE_ACK,
+					YAHOO_STATUS_AVAILABLE, pkt->id);
+			yahoo_packet_hash(pkt2, "ssisii",
+					1, im->active_id,  /* May not always be the connection's display name */
+					5, im->from,
+					302, 430,
+					430, im->id,
+					303, 430,
+					450, 0);
+			yahoo_packet_send_and_free(pkt2, yd);
+		}
+
+		m = yahoo_string_decode(gc, im->msg, im->utf8);
+		/* This may actually not be necessary, but it appears
+		 * that at least at one point some clients were sending
+		 * "\r\n" as line delimiters, so we want to avoid double
+		 * lines. */
+		m2 = purple_strreplace(m, "\r\n", "\n");
+		g_free(m);
+		m = m2;
+		purple_util_chrreplace(m, '\r', '\n');
+		if (!strcmp(m, "<ding>")) {
+			char *username;
+
+			username = g_markup_escape_text(im->fed_from, -1);
+			purple_prpl_got_attention(gc, username, YAHOO_BUZZ);
+			g_free(username);
+			g_free(m);
+			g_free(im->fed_from);
+			g_free(im);
+			continue;
+		}
+
+		m2 = yahoo_codes_to_html(m);
+		g_free(m);
+
+		serv_got_im(gc, im->fed_from, m2, 0, im->time);
+		g_free(m2);
+
+		/* Official clients don't share buddy images with federated buddies */
+		if (im->fed == YAHOO_FEDERATION_NONE) {
+			if ((f = yahoo_friend_find(gc, im->from)) && im->buddy_icon == 2) {
+				if (yahoo_friend_get_buddy_icon_need_request(f)) {
+					yahoo_send_picture_request(gc, im->from);
+					yahoo_friend_set_buddy_icon_need_request(f, FALSE);
+				}
+			}
+		}
+
+		g_free(im->fed_from);
+		g_free(im);
+	}
+
+	g_slist_free(list);
+}
+
+static void yahoo_process_sysmessage(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	GSList *l = pkt->hash;
+	char *prim, *me = NULL, *msg = NULL;
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+
+		if (pair->key == 5) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				me = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_sysmessage "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		}
+		if (pair->key == 14) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				msg = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_sysmessage "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		}
+
+		l = l->next;
+	}
+
+	if (!msg || !g_utf8_validate(msg, -1, NULL))
+		return;
+
+	prim = g_strdup_printf(_("Yahoo! system message for %s:"),
+	                       me?me:purple_connection_get_display_name(gc));
+	purple_notify_info(NULL, NULL, prim, msg);
+	g_free(prim);
+}
+
+struct yahoo_add_request {
+	PurpleConnection *gc;
+	char *id;
+	char *who;
+	YahooFederation fed;
+};
+
+static void
+yahoo_buddy_add_authorize_cb(gpointer data)
+{
+	struct yahoo_add_request *add_req = data;
+	struct yahoo_packet *pkt;
+	YahooData *yd = add_req->gc->proto_data;
+	const char *who = add_req->who;
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_AUTH_REQ_15, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	if (add_req->fed) {
+		who += 4;
+		yahoo_packet_hash(pkt, "ssiii",
+						  1, add_req->id,
+						  5, who,
+						  241, add_req->fed,
+						  13, 1,
+						  334, 0);
+	}
+	else {
+		yahoo_packet_hash(pkt, "ssii",
+						  1, add_req->id,
+						  5, who,
+						  13, 1,
+						  334, 0);
+	}
+
+	yahoo_packet_send_and_free(pkt, yd);
+
+	g_free(add_req->id);
+	g_free(add_req->who);
+	g_free(add_req);
+}
+
+static void
+yahoo_buddy_add_deny_cb(struct yahoo_add_request *add_req, const char *msg)
+{
+	YahooData *yd = add_req->gc->proto_data;
+	struct yahoo_packet *pkt;
+	char *encoded_msg = NULL;
+	const char *who = add_req->who;
+
+	if (msg && *msg)
+		encoded_msg = yahoo_string_encode(add_req->gc, msg, NULL);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_AUTH_REQ_15,
+			YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	if (add_req->fed) {
+		who += 4; /* Skip fed identifier (msn|ocs|ibm)/' */
+		yahoo_packet_hash(pkt, "ssiiiis",
+						  1, add_req->id,
+						  5, who,
+						  241, add_req->fed,
+						  13, 2,
+						  334, 0,
+						  97, 1,
+						  14, encoded_msg ? encoded_msg : "");
+	}
+	else {
+		yahoo_packet_hash(pkt, "ssiiis",
+						  1, add_req->id,
+						  5, who,
+						  13, 2,
+						  334, 0,
+						  97, 1,
+						  14, encoded_msg ? encoded_msg : "");
+	}
+
+
+	yahoo_packet_send_and_free(pkt, yd);
+
+	g_free(encoded_msg);
+
+	g_free(add_req->id);
+	g_free(add_req->who);
+	g_free(add_req);
+}
+
+static void
+yahoo_buddy_add_deny_noreason_cb(struct yahoo_add_request *add_req, const char*msg)
+{
+	yahoo_buddy_add_deny_cb(add_req, NULL);
+}
+
+static void
+yahoo_buddy_add_deny_reason_cb(gpointer data) {
+	struct yahoo_add_request *add_req = data;
+	purple_request_input(add_req->gc, NULL, _("Authorization denied message:"),
+			NULL, _("No reason given."), TRUE, FALSE, NULL,
+			_("OK"), G_CALLBACK(yahoo_buddy_add_deny_cb),
+			_("Cancel"), G_CALLBACK(yahoo_buddy_add_deny_noreason_cb),
+			purple_connection_get_account(add_req->gc), add_req->who, NULL,
+			add_req);
+}
+
+static void yahoo_buddy_denied_our_add(PurpleConnection *gc, const char *who, const char *reason)
+{
+	char *notify_msg;
+	YahooData *yd = gc->proto_data;
+
+	if (who == NULL)
+		return;
+
+	if (reason != NULL) {
+		char *msg2 = yahoo_string_decode(gc, reason, FALSE);
+		notify_msg = g_strdup_printf(_("%s has (retroactively) denied your request to add them to your list for the following reason: %s."), who, msg2);
+		g_free(msg2);
+	} else
+		notify_msg = g_strdup_printf(_("%s has (retroactively) denied your request to add them to your list."), who);
+
+	purple_notify_info(gc, NULL, _("Add buddy rejected"), notify_msg);
+	g_free(notify_msg);
+
+	g_hash_table_remove(yd->friends, who);
+	purple_prpl_got_user_status(purple_connection_get_account(gc), who, "offline", NULL); /* FIXME: make this set not on list status instead */
+	/* TODO: Shouldn't we remove the buddy from our local list? */
+}
+
+static void yahoo_buddy_auth_req_15(PurpleConnection *gc, struct yahoo_packet *pkt) {
+	PurpleAccount *account;
+	GSList *l = pkt->hash;
+	const char *msg = NULL;
+
+	account = purple_connection_get_account(gc);
+
+	/* Buddy authorized/declined our addition */
+	if (pkt->status == 1) {
+		char *temp = NULL;
+		char *who = NULL;
+		int response = 0;
+		YahooFederation fed = YAHOO_FEDERATION_NONE;
+
+		while (l) {
+			struct yahoo_pair *pair = l->data;
+
+			switch (pair->key) {
+			case 4:
+				if (g_utf8_validate(pair->value, -1, NULL)) {
+					temp = pair->value;
+				} else {
+					purple_debug_warning("yahoo", "yahoo_buddy_auth_req_15 "
+							"got non-UTF-8 string for key %d\n", pair->key);
+				}
+				break;
+			case 13:
+				response = strtol(pair->value, NULL, 10);
+				break;
+			case 14:
+				msg = pair->value;
+				break;
+			case 241:
+				fed = strtol(pair->value, NULL, 10);
+				break;
+			}
+			l = l->next;
+		}
+
+		switch (fed) {
+			case YAHOO_FEDERATION_MSN:
+				who = g_strconcat("msn/", temp, NULL);
+				break;
+			case YAHOO_FEDERATION_OCS:
+				who = g_strconcat("ocs/", temp, NULL);
+				break;
+			case YAHOO_FEDERATION_IBM:
+				who = g_strconcat("ibm/", temp, NULL);
+				break;
+			case YAHOO_FEDERATION_NONE:
+			default:
+				who = g_strdup(temp);
+				break;
+		}
+
+		if (response == 1) /* Authorized */
+			purple_debug_info("yahoo", "Received authorization from buddy '%s'.\n", who ? who : "(Unknown Buddy)");
+		else if (response == 2) { /* Declined */
+			purple_debug_info("yahoo", "Received authorization decline from buddy '%s'.\n", who ? who : "(Unknown Buddy)");
+			yahoo_buddy_denied_our_add(gc, who, msg);
+		} else
+			purple_debug_error("yahoo", "Received unknown authorization response of %d from buddy '%s'.\n", response, who ? who : "(Unknown Buddy)");
+	g_free(who);
+	}
+	/* Buddy requested authorization to add us. */
+	else if (pkt->status == 3) {
+		struct yahoo_add_request *add_req;
+		const char *firstname = NULL, *lastname = NULL;
+		char *temp = NULL;
+
+		add_req = g_new0(struct yahoo_add_request, 1);
+		add_req->gc = gc;
+		add_req->fed = YAHOO_FEDERATION_NONE;
+
+		while (l) {
+			struct yahoo_pair *pair = l->data;
+
+			switch (pair->key) {
+			case 4:
+				if (g_utf8_validate(pair->value, -1, NULL)) {
+					temp = pair->value;
+				} else {
+					purple_debug_warning("yahoo", "yahoo_buddy_auth_req_15 "
+							"got non-UTF-8 string for key %d\n", pair->key);
+				}
+				break;
+			case 5:
+				if (g_utf8_validate(pair->value, -1, NULL)) {
+					add_req->id = g_strdup(pair->value);
+				} else {
+					purple_debug_warning("yahoo", "yahoo_buddy_auth_req_15 "
+							"got non-UTF-8 string for key %d\n", pair->key);
+				}
+				break;
+			case 14:
+				msg = pair->value;
+				break;
+			case 216:
+				if (g_utf8_validate(pair->value, -1, NULL)) {
+					firstname = pair->value;
+				} else {
+					purple_debug_warning("yahoo", "yahoo_buddy_auth_req_15 "
+							"got non-UTF-8 string for key %d\n", pair->key);
+				}
+				break;
+			case 241:
+				add_req->fed = strtol(pair->value, NULL, 10);
+				break;
+			case 254:
+				if (g_utf8_validate(pair->value, -1, NULL)) {
+					lastname = pair->value;
+				} else {
+					purple_debug_warning("yahoo", "yahoo_buddy_auth_req_15 "
+							"got non-UTF-8 string for key %d\n", pair->key);
+				}
+				break;
+
+			}
+			l = l->next;
+		}
+		switch (add_req->fed) {
+			case YAHOO_FEDERATION_MSN:
+				add_req->who = g_strconcat("msn/", temp, NULL);
+				break;
+			case YAHOO_FEDERATION_OCS:
+				add_req->who = g_strconcat("ocs/", temp, NULL);
+				break;
+			case YAHOO_FEDERATION_IBM:
+				add_req->who = g_strconcat("ibm/", temp, NULL);
+				break;
+			case YAHOO_FEDERATION_NONE:
+			default:
+				add_req->who = g_strdup(temp);
+				break;
+		}
+
+		if (add_req->id && add_req->who) {
+			char *alias = NULL, *dec_msg = NULL;
+
+			if (!purple_privacy_check(account, add_req->who))
+			{
+				purple_debug_misc("yahoo", "Auth. request from %s dropped and automatically denied due to privacy settings!\n",
+						  add_req->who);
+				yahoo_buddy_add_deny_cb(add_req, NULL);
+				return;
+			}
+
+			if (msg)
+				dec_msg = yahoo_string_decode(gc, msg, FALSE);
+
+			if (firstname && lastname)
+				alias = g_strdup_printf("%s %s", firstname, lastname);
+			else if (firstname)
+				alias = g_strdup(firstname);
+			else if (lastname)
+				alias = g_strdup(lastname);
+
+			/* DONE! this is almost exactly the same as what MSN does,
+			 * this should probably be moved to the core.
+			 */
+			 purple_account_request_authorization(account, add_req->who, add_req->id,
+					alias, dec_msg,
+					purple_find_buddy(account, add_req->who) != NULL,
+					yahoo_buddy_add_authorize_cb,
+					yahoo_buddy_add_deny_reason_cb,
+					add_req);
+			g_free(alias);
+			g_free(dec_msg);
+		} else {
+			g_free(add_req->id);
+			g_free(add_req->who);
+			g_free(add_req);
+		}
+	} else {
+		purple_debug_error("yahoo", "Received authorization of unknown status (%d).\n", pkt->status);
+	}
+}
+
+/* I don't think this happens anymore in Version 15 */
+static void yahoo_buddy_added_us(PurpleConnection *gc, struct yahoo_packet *pkt) {
+	PurpleAccount *account;
+	struct yahoo_add_request *add_req;
+	char *msg = NULL;
+	GSList *l = pkt->hash;
+
+	account = purple_connection_get_account(gc);
+
+	add_req = g_new0(struct yahoo_add_request, 1);
+	add_req->gc = gc;
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 1:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				add_req->id = g_strdup(pair->value);
+			} else {
+					purple_debug_warning("yahoo", "yahoo_buddy_added_us "
+							"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 3:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				add_req->who = g_strdup(pair->value);
+			} else {
+					purple_debug_warning("yahoo", "yahoo_buddy_added_us "
+							"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 15: /* time, for when they add us and we're offline */
+			break;
+		case 14:
+			msg = pair->value;
+			break;
+		}
+		l = l->next;
+	}
+
+	if (add_req->id && add_req->who) {
+		char *dec_msg = NULL;
+
+		if (!purple_privacy_check(account, add_req->who)) {
+			purple_debug_misc("yahoo", "Auth. request from %s dropped and automatically denied due to privacy settings!\n",
+					  add_req->who);
+			yahoo_buddy_add_deny_cb(add_req, NULL);
+			return;
+		}
+
+		if (msg)
+			dec_msg = yahoo_string_decode(gc, msg, FALSE);
+
+		/* DONE! this is almost exactly the same as what MSN does,
+		 * this should probably be moved to the core.
+		 */
+		 purple_account_request_authorization(account, add_req->who, add_req->id,
+				NULL, dec_msg,
+				purple_find_buddy(account,add_req->who) != NULL,
+						yahoo_buddy_add_authorize_cb,
+						yahoo_buddy_add_deny_reason_cb, add_req);
+		g_free(dec_msg);
+	} else {
+		g_free(add_req->id);
+		g_free(add_req->who);
+		g_free(add_req);
+	}
+}
+
+/* I have no idea if this every gets called in version 15 */
+static void yahoo_buddy_denied_our_add_old(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	char *who = NULL;
+	char *msg = NULL;
+	GSList *l = pkt->hash;
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 3:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_buddy_denied_our_add_old "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 14:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				msg = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_buddy_denied_our_add_old "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		}
+		l = l->next;
+	}
+
+	yahoo_buddy_denied_our_add(gc, who, msg);
+}
+
+static void yahoo_process_contact(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	switch (pkt->status) {
+	case 1:
+		yahoo_process_status(gc, pkt);
+		return;
+	case 3:
+		yahoo_buddy_added_us(gc, pkt);
+		break;
+	case 7:
+		yahoo_buddy_denied_our_add_old(gc, pkt);
+		break;
+	default:
+		break;
+	}
+}
+
+#define OUT_CHARSET "utf-8"
+
+static char *yahoo_decode(const char *text)
+{
+	char *converted = NULL;
+	char *n, *new;
+	const char *end, *p;
+	int i, k;
+
+	n = new = g_malloc(strlen (text) + 1);
+	end = text + strlen(text);
+
+	for (p = text; p < end; p++, n++) {
+		if (*p == '\\') {
+			if (p[1] >= '0' && p[1] <= '7') {
+				p += 1;
+				for (i = 0, k = 0; k < 3; k += 1) {
+					char c = p[k];
+					if (c < '0' || c > '7') break;
+					i *= 8;
+					i += c - '0';
+				}
+				*n = i;
+				p += k - 1;
+			} else { /* bug 959248 */
+				/* If we see a \ not followed by an octal number,
+				 * it means that it is actually a \\ with one \
+				 * already eaten by some unknown function.
+				 * This is arguably broken.
+				 *
+				 * I think wing is wrong here, there is no function
+				 * called that I see that could have done it. I guess
+				 * it is just really sending single \'s. That's yahoo
+				 * for you.
+				 */
+				*n = *p;
+			}
+		}
+		else
+			*n = *p;
+	}
+
+	*n = '\0';
+
+	if (strstr(text, "\033$B"))
+		converted = g_convert(new, n - new, OUT_CHARSET, "iso-2022-jp", NULL, NULL, NULL);
+	if (!converted)
+		converted = g_convert(new, n - new, OUT_CHARSET, "iso-8859-1", NULL, NULL, NULL);
+	g_free(new);
+
+	return converted;
+}
+
+static void yahoo_process_mail(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	PurpleAccount *account = purple_connection_get_account(gc);
+	YahooData *yd = gc->proto_data;
+	const char *who = NULL;
+	const char *email = NULL;
+	const char *subj = NULL;
+	const char *yahoo_mail_url = (yd->jp? YAHOOJP_MAIL_URL: YAHOO_MAIL_URL);
+	int count = 0;
+	GSList *l = pkt->hash;
+
+	if (!purple_account_get_check_mail(account))
+		return;
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+		if (pair->key == 9)
+			count = strtol(pair->value, NULL, 10);
+		else if (pair->key == 43) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_mail "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		} else if (pair->key == 42) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				email = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_mail "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		} else if (pair->key == 18) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				subj = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_mail "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		}
+		l = l->next;
+	}
+
+	if (who && subj && email && *email) {
+		char *dec_who = yahoo_decode(who);
+		char *dec_subj = yahoo_decode(subj);
+		char *from = g_strdup_printf("%s (%s)", dec_who, email);
+
+		purple_notify_email(gc, dec_subj, from, purple_account_get_username(account),
+						  yahoo_mail_url, NULL, NULL);
+
+		g_free(dec_who);
+		g_free(dec_subj);
+		g_free(from);
+	} else if (count > 0) {
+		const char *tos[2] = { purple_account_get_username(account) };
+		const char *urls[2] = { yahoo_mail_url };
+
+		purple_notify_emails(gc, count, FALSE, NULL, NULL, tos, urls,
+						   NULL, NULL);
+	}
+}
+
+/* We use this structure once while we authenticate */
+struct yahoo_auth_data
+{
+	PurpleConnection *gc;
+	char *seed;
+};
+
+/* This is the y64 alphabet... it's like base64, but has a . and a _ */
+static const char base64digits[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._";
+
+/* This is taken from Sylpheed by Hiroyuki Yamamoto. We have our own tobase64 function
+ * in util.c, but it is different from the one yahoo uses */
+static void to_y64(char *out, const unsigned char *in, gsize inlen)
+     /* raw bytes in quasi-big-endian order to base 64 string (NUL-terminated) */
+{
+	for (; inlen >= 3; inlen -= 3)
+		{
+			*out++ = base64digits[in[0] >> 2];
+			*out++ = base64digits[((in[0] << 4) & 0x30) | (in[1] >> 4)];
+			*out++ = base64digits[((in[1] << 2) & 0x3c) | (in[2] >> 6)];
+			*out++ = base64digits[in[2] & 0x3f];
+			in += 3;
+		}
+	if (inlen > 0)
+		{
+			unsigned char fragment;
+
+			*out++ = base64digits[in[0] >> 2];
+			fragment = (in[0] << 4) & 0x30;
+			if (inlen > 1)
+				fragment |= in[1] >> 4;
+			*out++ = base64digits[fragment];
+			*out++ = (inlen < 2) ? '-' : base64digits[(in[1] << 2) & 0x3c];
+			*out++ = '-';
+		}
+	*out = '\0';
+}
+
+static void yahoo_auth16_stage3(PurpleConnection *gc, const char *crypt)
+{
+	YahooData *yd = gc->proto_data;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	const char *name = purple_normalize(account, purple_account_get_username(account));
+	PurpleCipher *md5_cipher;
+	PurpleCipherContext *md5_ctx;
+	guchar md5_digest[16];
+	gchar base64_string[25];
+	struct yahoo_packet *pkt;
+
+	purple_debug_info("yahoo","Authentication: In yahoo_auth16_stage3\n");
+
+	g_return_if_fail(crypt != NULL);
+
+	md5_cipher = purple_ciphers_find_cipher("md5");
+	md5_ctx = purple_cipher_context_new(md5_cipher, NULL);
+	purple_cipher_context_append(md5_ctx, (guchar *)crypt, strlen(crypt));
+	purple_cipher_context_digest(md5_ctx, sizeof(md5_digest), md5_digest, NULL);
+
+	to_y64(base64_string, md5_digest, 16);
+
+	purple_debug_info("yahoo", "yahoo status: %d\n", yd->current_status);
+	pkt = yahoo_packet_new(YAHOO_SERVICE_AUTHRESP, yd->current_status, yd->session_id);
+
+	if(yd->cookie_b) { /* send B cookie if we have it */
+		yahoo_packet_hash(pkt, "ssssssssss",
+					1, name,
+					0, name,
+					277, yd->cookie_y,
+					278, yd->cookie_t,
+					307, base64_string,
+					244, yd->jp ? YAHOOJP_CLIENT_VERSION_ID : YAHOO_CLIENT_VERSION_ID,
+					2, name,
+					2, "1",
+					59, yd->cookie_b,
+					98, purple_account_get_string(account, "room_list_locale", yd->jp ? "jp" : "us"),
+					135, yd->jp ? YAHOOJP_CLIENT_VERSION : YAHOO_CLIENT_VERSION);
+	} else { /* don't try to send an empty B cookie - the server will be mad */
+		yahoo_packet_hash(pkt, "sssssssss",
+					1, name,
+					0, name,
+					277, yd->cookie_y,
+					278, yd->cookie_t,
+					307, base64_string,
+					244, yd->jp ? YAHOOJP_CLIENT_VERSION_ID : YAHOO_CLIENT_VERSION_ID,
+					2, name,
+					2, "1",
+					98, purple_account_get_string(account, "room_list_locale", yd->jp ? "jp" : "us"),
+					135, yd->jp ? YAHOOJP_CLIENT_VERSION : YAHOO_CLIENT_VERSION);
+	}
+
+	if (yd->picture_checksum)
+		yahoo_packet_hash_int(pkt, 192, yd->picture_checksum);
+	yahoo_packet_send_and_free(pkt, yd);
+
+	purple_cipher_context_destroy(md5_ctx);
+}
+
+static gchar *yahoo_auth16_get_cookie_b(gchar *headers)
+{
+	gchar **splits = g_strsplit(headers, "\r\n", -1);
+	gchar *tmp = NULL, *tmp2 = NULL, *sem = NULL;
+	int elements = g_strv_length(splits), i;
+
+	if(elements > 1) {
+		for(i = 0; i < elements; i++) {
+			if(g_ascii_strncasecmp(splits[i], "Set-Cookie: B=", 14) == 0) {
+				tmp = &splits[i][14];
+				sem = strchr(tmp, ';');
+
+				if (sem != NULL) {
+					tmp2 = g_strndup(tmp, sem - tmp);
+					purple_debug_info("yahoo", "Got needed part of B cookie: %s\n",
+							tmp2 ? tmp2 : "(null)");
+					break;
+				}
+			}
+		}
+	}
+
+	g_strfreev(splits);
+	return tmp2;
+}
+
+static void yahoo_auth16_stage2(PurpleUtilFetchUrlData *url_data, gpointer user_data, const gchar *ret_data, size_t len, const gchar *error_message)
+{
+	struct yahoo_auth_data *auth_data = user_data;
+	PurpleConnection *gc = auth_data->gc;
+	YahooData *yd = purple_connection_get_protocol_data(gc);
+
+	purple_debug_info("yahoo","Authentication: In yahoo_auth16_stage2\n");
+
+	yd->url_datas = g_slist_remove(yd->url_datas, url_data);
+
+	if (error_message != NULL) {
+		purple_debug_error("yahoo", "Login Failed, unable to retrieve stage 2 url: %s\n", error_message);
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, error_message);
+		g_free(auth_data->seed);
+		g_free(auth_data);
+		return;
+	}
+	else if (len > 0 && ret_data && *ret_data) {
+		gchar **splits = g_strsplit(ret_data, "\r\n\r\n", -1), **split_data = NULL;
+		int totalelements = 0;
+		int response_no = -1;
+		char *crumb = NULL;
+		char *crypt = NULL;
+
+		if(g_strv_length(splits) > 1) {
+			yd->cookie_b = yahoo_auth16_get_cookie_b(splits[0]);
+			split_data = g_strsplit(splits[1], "\r\n", -1);
+			totalelements = g_strv_length(split_data);
+		}
+
+		if (totalelements >= 4) {
+			int i;
+
+			for(i = 0; i < totalelements; i++) {
+				/* I'm not exactly a fan of the magic numbers, but it's obvious,
+				 * so no sense in wasting a bajillion vars or calls to strlen */
+
+				if(g_ascii_isdigit(split_data[i][0])) {
+					/* if the current line and the next line both start with numbers,
+					 * the current line is the length of the body, so skip.  If not,
+					 * then the current line is the response code from the login process. */
+					if(!g_ascii_isdigit(split_data[i + 1][0])) {
+						response_no = strtol(split_data[i], NULL, 10);
+						purple_debug_info("yahoo", "Got auth16 stage 2 response code: %d\n",
+								response_no);
+					}
+				} else if(strncmp(split_data[i], "crumb=", 6) == 0) {
+					crumb = g_strdup(&split_data[i][6]);
+
+					if(purple_debug_is_unsafe())
+						purple_debug_info("yahoo", "Got crumb: %s\n", crumb);
+
+				} else if(strncmp(split_data[i], "Y=", 2) == 0) {
+					yd->cookie_y = g_strdup(&split_data[i][2]);
+
+					if(purple_debug_is_unsafe())
+						purple_debug_info("yahoo", "Got Y cookie: %s\n", yd->cookie_y);
+
+				} else if(strncmp(split_data[i], "T=", 2) == 0) {
+					yd->cookie_t = g_strdup(&split_data[i][2]);
+
+					if(purple_debug_is_unsafe())
+						purple_debug_info("yahoo", "Got T cookie: %s\n", yd->cookie_t);
+				}
+			}
+		}
+
+		g_strfreev(splits);
+		g_strfreev(split_data);
+
+		if (crumb == NULL)
+			response_no = -1;
+
+		if(response_no != 0) {
+			/* Some error in the login process */
+			PurpleConnectionError error;
+			char *error_reason = NULL;
+
+			switch(response_no) {
+				case -1:
+					/* Some error in the received stream */
+					error_reason = g_strdup(_("Received invalid data"));
+					error = PURPLE_CONNECTION_ERROR_NETWORK_ERROR;
+					break;
+				case 100:
+					/* Unknown error */
+					error_reason = g_strdup(_("Unknown error"));
+					error = PURPLE_CONNECTION_ERROR_OTHER_ERROR;
+					break;
+				default:
+					/* if we have everything we need, why not try to login irrespective of response */
+					if((crumb != NULL) && (yd->cookie_y != NULL) && (yd->cookie_t != NULL)) {
+#if 0
+						try_login_on_error = TRUE;
+#endif
+						break;
+					}
+					error_reason = g_strdup(_("Unknown error"));
+					error = PURPLE_CONNECTION_ERROR_OTHER_ERROR;
+					break;
+			}
+			if(error_reason) {
+				purple_debug_error("yahoo", "Authentication error: %s. "
+				                   "Code %d\n", error_reason, response_no);
+				purple_connection_error_reason(gc, error, error_reason);
+				g_free(error_reason);
+				g_free(auth_data->seed);
+				g_free(auth_data);
+				return;
+			}
+		}
+
+		crypt = g_strconcat(crumb, auth_data->seed, NULL);
+		yahoo_auth16_stage3(gc, crypt);
+		g_free(crypt);
+		g_free(crumb);
+	}
+	g_free(auth_data->seed);
+	g_free(auth_data);
+}
+
+static void yahoo_auth16_stage1_cb(PurpleUtilFetchUrlData *url_data, gpointer user_data, const gchar *ret_data, size_t len, const gchar *error_message)
+{
+	struct yahoo_auth_data *auth_data = user_data;
+	PurpleConnection *gc = auth_data->gc;
+	YahooData *yd = purple_connection_get_protocol_data(gc);
+
+	purple_debug_info("yahoo","Authentication: In yahoo_auth16_stage1_cb\n");
+
+	yd->url_datas = g_slist_remove(yd->url_datas, url_data);
+
+	if (error_message != NULL) {
+		purple_debug_error("yahoo", "Login Failed, unable to retrieve login url: %s\n", error_message);
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, error_message);
+		g_free(auth_data->seed);
+		g_free(auth_data);
+		return;
+	}
+	else if (len > 0 && ret_data && *ret_data) {
+		PurpleAccount *account = purple_connection_get_account(gc);
+		gchar **split_data = g_strsplit(ret_data, "\r\n", -1);
+		int totalelements = 0;
+		int response_no = -1;
+		char *token = NULL;
+
+		totalelements = g_strv_length(split_data);
+
+		if(totalelements == 1) { /* Received an error code */
+			response_no = strtol(split_data[0], NULL, 10);
+		} else if(totalelements == 2 || totalelements == 3 ) { /* received valid data */
+			response_no = strtol(split_data[0], NULL, 10);
+			token = g_strdup(split_data[1] + strlen("ymsgr="));
+		} else { /* It looks like a transparent proxy has returned a document we don't want */
+			response_no = -1;
+		}
+
+		g_strfreev(split_data);
+
+		if(response_no != 0) {
+			/* Some error in the login process */
+			PurpleConnectionError error;
+			char *error_reason;
+
+			switch(response_no) {
+				case -1:
+					/* Some error in the received stream */
+					error_reason = g_strdup(_("Received invalid data"));
+					error = PURPLE_CONNECTION_ERROR_NETWORK_ERROR;
+					break;
+				case 1212:
+					/* Password incorrect */
+					/* Set password to NULL. Avoids account locking. Brings dialog to enter password if clicked on Re-enable account */
+					if (!purple_account_get_remember_password(account))
+						purple_account_set_password(account, NULL);
+					error_reason = g_strdup(_("Incorrect password"));
+					error = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;
+					break;
+				case 1213:
+					/* security lock from too many failed login attempts */
+					error_reason = g_strdup(_("Account locked: Too many failed login "
+								"attempts.  Logging into the Yahoo! website may fix this."));
+					error = PURPLE_CONNECTION_ERROR_OTHER_ERROR;
+					break;
+				case 1235:
+					/* the username does not exist */
+					error_reason = g_strdup(_("Username does not exist"));
+					error = PURPLE_CONNECTION_ERROR_INVALID_USERNAME;
+					break;
+				case 1214:
+					/* indicates a lock of some description */
+					error_reason = g_strdup(_("Account locked: Unknown reason.  Logging "
+								"into the Yahoo! website may fix this."));
+					error = PURPLE_CONNECTION_ERROR_OTHER_ERROR;
+					break;
+				case 1236:
+					/* indicates a lock due to logging in too frequently */
+					error_reason = g_strdup(_("Account locked: You have been logging in too "
+								"frequently.  Wait a few minutes before trying to connect "
+								"again.  Logging into the Yahoo! website may help."));
+					error = PURPLE_CONNECTION_ERROR_OTHER_ERROR;
+					break;
+				case 100:
+					/* username or password missing */
+					error_reason = g_strdup(_("Username or password missing"));
+					error = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;
+					break;
+				default:
+					/* Unknown error! */
+					error_reason = g_strdup_printf(_("Unknown error (%d)"), response_no);
+					error = PURPLE_CONNECTION_ERROR_OTHER_ERROR;
+					break;
+			}
+			purple_debug_error("yahoo", "Authentication error: %s. Code %d\n",
+			                   error_reason, response_no);
+			purple_connection_error_reason(gc, error, error_reason);
+			g_free(error_reason);
+			g_free(auth_data->seed);
+			g_free(auth_data);
+			g_free(token);
+		}
+		else {
+			/* OK to login, correct information provided */
+			PurpleUtilFetchUrlData *url_data = NULL;
+			char *url = NULL;
+			gboolean yahoojp = yahoo_is_japan(account);
+			gboolean proxy_ssl = purple_account_get_bool(account, "proxy_ssl", FALSE);
+
+			url = g_strdup_printf(yahoojp ? YAHOOJP_LOGIN_URL : YAHOO_LOGIN_URL, token);
+			url_data = purple_util_fetch_url_request_len_with_account(
+					proxy_ssl ? account : NULL, url, TRUE, YAHOO_CLIENT_USERAGENT,
+					TRUE, NULL, TRUE, -1, yahoo_auth16_stage2, auth_data);
+			if (url_data)
+				yd->url_datas = g_slist_prepend(yd->url_datas, url_data);
+			g_free(url);
+			g_free(token);
+		}
+	}
+}
+
+static void yahoo_auth16_stage1(PurpleConnection *gc, const char *seed)
+{
+	YahooData *yd = purple_connection_get_protocol_data(gc);
+	PurpleAccount *account = purple_connection_get_account(gc);
+	PurpleUtilFetchUrlData *url_data = NULL;
+	struct yahoo_auth_data *auth_data = NULL;
+	char *url = NULL;
+	char *encoded_username;
+	char *encoded_password;
+	gboolean yahoojp = yahoo_is_japan(account);
+	gboolean proxy_ssl = purple_account_get_bool(account, "proxy_ssl", FALSE);
+
+	purple_debug_info("yahoo", "Authentication: In yahoo_auth16_stage1\n");
+
+	if(!purple_ssl_is_supported()) {
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT, _("SSL support unavailable"));
+		return;
+	}
+
+	auth_data = g_new0(struct yahoo_auth_data, 1);
+	auth_data->gc = gc;
+	auth_data->seed = g_strdup(seed);
+
+	encoded_username = g_strdup(purple_url_encode(purple_account_get_username(purple_connection_get_account(gc))));
+	encoded_password = g_strdup(purple_url_encode(purple_connection_get_password(gc)));
+	url = g_strdup_printf(yahoojp ? YAHOOJP_TOKEN_URL : YAHOO_TOKEN_URL,
+			encoded_username, encoded_password, purple_url_encode(seed));
+	g_free(encoded_password);
+	g_free(encoded_username);
+
+	url_data = purple_util_fetch_url_request_len_with_account(
+			proxy_ssl ? account : NULL, url, TRUE,
+			YAHOO_CLIENT_USERAGENT, TRUE, NULL, FALSE, -1,
+			yahoo_auth16_stage1_cb, auth_data);
+	if (url_data)
+		yd->url_datas = g_slist_prepend(yd->url_datas, url_data);
+
+	g_free(url);
+}
+
+static void yahoo_process_auth(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	char *seed = NULL;
+	GSList *l = pkt->hash;
+	int m = 0;
+	gchar *buf;
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+		/* (pair->key == 1) -> sn */
+		if (pair->key == 94) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				seed = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_auth "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		} else if (pair->key == 13) {
+			m = atoi(pair->value);
+		}
+		l = l->next;
+	}
+
+	if (seed) {
+		switch (m) {
+		case 0:
+			/* used to be for really old auth routine, dont support now */
+		case 1:
+		case 2: /* Yahoo ver 16 authentication */
+			yahoo_auth16_stage1(gc, seed);
+			break;
+		default:
+			{
+				GHashTable *ui_info = purple_core_get_ui_info();
+
+				buf = g_strdup_printf(_("The Yahoo server has requested the use of an unrecognized "
+							"authentication method.  You will probably not be able "
+							"to successfully sign on to Yahoo.  Check %s for updates."),
+							((ui_info && g_hash_table_lookup(ui_info, "website")) ? (char *)g_hash_table_lookup(ui_info, "website") : PURPLE_WEBSITE));
+				purple_notify_error(gc, "", _("Failed Yahoo! Authentication"),
+							buf);
+				g_free(buf);
+				yahoo_auth16_stage1(gc, seed); /* Can't hurt to try it anyway. */
+				break;
+			}
+		}
+	}
+}
+
+static void ignore_buddy(PurpleBuddy *buddy) {
+	PurpleGroup *group;
+	PurpleAccount *account;
+	gchar *name;
+
+	if (!buddy)
+		return;
+
+	group = purple_buddy_get_group(buddy);
+	name = g_strdup(purple_buddy_get_name(buddy));
+	account = purple_buddy_get_account(buddy);
+
+	purple_debug_info("yahoo", "blist: Removing '%s' from buddy list.\n", name);
+	purple_account_remove_buddy(account, buddy, group);
+	purple_blist_remove_buddy(buddy);
+
+	serv_add_deny(purple_account_get_connection(account), name);
+
+	g_free(name);
+}
+
+static void keep_buddy(PurpleBuddy *b)
+{
+	purple_privacy_deny_remove(purple_buddy_get_account(b),
+			purple_buddy_get_name(b), 1);
+}
+
+static void yahoo_process_ignore(PurpleConnection *gc, struct yahoo_packet *pkt) {
+	PurpleBuddy *b;
+	GSList *l;
+	gchar *who = NULL;
+	gchar buf[BUF_LONG];
+	gboolean ignore = TRUE;
+	gint status = 0;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+		switch (pair->key) {
+		case 0:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_ignore "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		/* 1 -> me */
+		case 13:
+			/* 1 == ignore, 2 == unignore */
+			ignore = (strtol(pair->value, NULL, 10) == 1);
+			break;
+		case 66:
+			status = strtol(pair->value, NULL, 10);
+			break;
+		default:
+			break;
+		}
+	}
+
+	/*
+	 * status
+	 * 0  - ok
+	 * 2  - already in ignore list, could not add
+	 * 3  - not in ignore list, could not delete
+	 * 12 - is a buddy, could not add (and possibly also a not-in-ignore list condition?)
+	 */
+	switch (status) {
+		case 12:
+			purple_debug_info("yahoo", "Server reported \"is a buddy\" for %s while %s",
+							  who, (ignore ? "ignoring" : "unignoring"));
+
+			if (ignore) {
+				b = purple_find_buddy(gc->account, who);
+				g_snprintf(buf, sizeof(buf), _("You have tried to ignore %s, but the "
+											   "user is on your buddy list.  Clicking \"Yes\" "
+											   "will remove and ignore the buddy."), who);
+				purple_request_yes_no(gc, NULL, _("Ignore buddy?"), buf, 0,
+									  gc->account, who, NULL,
+									  b,
+									  G_CALLBACK(ignore_buddy),
+									  G_CALLBACK(keep_buddy));
+				break;
+			}
+		case 2:
+			purple_debug_info("yahoo", "Server reported that %s is already in the ignore list.\n",
+							  who);
+			break;
+		case 3:
+			purple_debug_info("yahoo", "Server reported that %s is not in the ignore list; could not delete\n",
+							  who);
+		case 0:
+		default:
+			break;
+	}
+}
+
+static void yahoo_process_authresp(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+#ifdef TRY_WEBMESSENGER_LOGIN
+	YahooData *yd = gc->proto_data;
+#endif /* TRY_WEBMESSENGER_LOGIN */
+	GSList *l = pkt->hash;
+	int err = 0;
+	char *msg;
+	char *url = NULL;
+	char *fullmsg;
+	PurpleAccount *account = gc->account;
+	PurpleConnectionError reason = PURPLE_CONNECTION_ERROR_OTHER_ERROR;
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+
+		if (pair->key == 66)
+			err = strtol(pair->value, NULL, 10);
+		else if (pair->key == 20) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				url = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_authresp "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		}
+
+		l = l->next;
+	}
+
+	switch (err) {
+	case 0:
+		msg = g_strdup(_("Unknown error"));
+		reason = PURPLE_CONNECTION_ERROR_NETWORK_ERROR;
+		break;
+	case 3:
+		msg = g_strdup(_("Username does not exist"));
+		reason = PURPLE_CONNECTION_ERROR_INVALID_USERNAME;
+		break;
+	case 13:
+#ifdef TRY_WEBMESSENGER_LOGIN
+		if (!yd->wm) {
+			PurpleUtilFetchUrlData *url_data;
+			yd->wm = TRUE;
+			if (yd->fd >= 0)
+				close(yd->fd);
+			if (gc->inpa)
+				purple_input_remove(gc->inpa);
+			url_data = purple_util_fetch_url(WEBMESSENGER_URL, TRUE,
+					"Purple/" VERSION, FALSE, yahoo_login_page_cb, gc);
+			if (url_data != NULL)
+				yd->url_datas = g_slist_prepend(yd->url_datas, url_data);
+			return;
+		}
+#endif /* TRY_WEBMESSENGER_LOGIN */
+		if (!purple_account_get_remember_password(account))
+			purple_account_set_password(account, NULL);
+
+		msg = g_strdup(_("Invalid username or password"));
+		reason = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;
+		break;
+	case 14:
+		msg = g_strdup(_("Your account has been locked due to too many failed login attempts."
+					"  Please try logging into the Yahoo! website."));
+		reason = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;
+		break;
+	case 52:
+		/* See #9660. As much as we know, reconnecting shouldn't hurt */
+		purple_debug_info("yahoo", "Got error 52, Set to autoreconnect\n");
+		msg = g_strdup(_("Unknown error 52.  Reconnecting should fix this."));
+		reason = PURPLE_CONNECTION_ERROR_NETWORK_ERROR;
+		break;
+	case 1013:
+		msg = g_strdup(_("Error 1013: The username you have entered is invalid."
+					"  The most common cause of this error is entering your email"
+					" address instead of your Yahoo! ID."));
+		reason = PURPLE_CONNECTION_ERROR_INVALID_USERNAME;
+		break;
+	default:
+		msg = g_strdup_printf(_("Unknown error number %d. Logging into the Yahoo! website may fix this."), err);
+	}
+
+	if (url)
+		fullmsg = g_strdup_printf("%s\n%s", msg, url);
+	else
+		fullmsg = g_strdup(msg);
+
+	purple_connection_error_reason(gc, reason, fullmsg);
+	g_free(msg);
+	g_free(fullmsg);
+}
+
+static void yahoo_process_addbuddy(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	int err = 0;
+	char *who = NULL;
+	char *temp = NULL;
+	char *group = NULL;
+	char *decoded_group;
+	char *buf;
+	YahooFriend *f;
+	GSList *l = pkt->hash;
+	YahooData *yd = gc->proto_data;
+	YahooFederation fed = YAHOO_FEDERATION_NONE;
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 66:
+			err = strtol(pair->value, NULL, 10);
+			break;
+		case 7:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				temp = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_addbuddy "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 65:
+			group = pair->value;
+			break;
+		case 241:
+			fed = strtol(pair->value, NULL, 10);
+			break;
+		}
+
+		l = l->next;
+	}
+
+	if (!temp)
+		return;
+	if (!group)
+		group = "";
+
+	switch (fed) {
+		case YAHOO_FEDERATION_MSN:
+			who = g_strconcat("msn/", temp, NULL);
+			break;
+		case YAHOO_FEDERATION_OCS:
+			who = g_strconcat("ocs/", temp, NULL);
+			break;
+		case YAHOO_FEDERATION_IBM:
+			who = g_strconcat("ibm/", temp, NULL);
+			break;
+		case YAHOO_FEDERATION_NONE:
+		default:
+			who = g_strdup(temp);
+			break;
+	}
+
+	if (!err || (err == 2)) { /* 0 = ok, 2 = already on serv list */
+		f = yahoo_friend_find_or_new(gc, who);
+		yahoo_update_status(gc, who, f);
+		f->fed = fed;
+
+		if( !g_hash_table_lookup(yd->peers, who) ) {
+			/* we are not connected as client, so set friend to not connected */
+			if(fed)
+				yahoo_friend_set_p2p_status(f, YAHOO_P2PSTATUS_DO_NOT_CONNECT);
+			else	{
+				yahoo_friend_set_p2p_status(f, YAHOO_P2PSTATUS_NOT_CONNECTED);
+				f->p2p_packet_sent = 0;
+			}
+		}
+		else	/* we are already connected. set friend to YAHOO_P2PSTATUS_WE_ARE_CLIENT */
+			yahoo_friend_set_p2p_status(f, YAHOO_P2PSTATUS_WE_ARE_CLIENT);
+		g_free(who);
+		return;
+	}
+
+	decoded_group = yahoo_string_decode(gc, group, FALSE);
+	buf = g_strdup_printf(_("Unable to add buddy %s to group %s to the server list on account %s."),
+				who, decoded_group, purple_connection_get_display_name(gc));
+	if (!purple_conv_present_error(who, purple_connection_get_account(gc), buf))
+		purple_notify_error(gc, NULL, _("Unable to add buddy to server list"), buf);
+	g_free(buf);
+	g_free(decoded_group);
+	g_free(who);
+}
+
+/* write pkt to the source */
+static void yahoo_p2p_write_pkt(gint source, struct yahoo_packet *pkt)
+{
+	size_t pkt_len;
+	gssize written;
+	guchar *raw_packet;
+
+	/*build the raw packet and send it to the host*/
+	pkt_len = yahoo_packet_build(pkt, 0, 0, 0, &raw_packet);
+	written = write(source, raw_packet, pkt_len);
+	if (written < 0 || (gsize)written != pkt_len)
+		purple_debug_warning("yahoo","p2p: couldn't write to the source\n");
+	g_free(raw_packet);
+}
+
+static void yahoo_p2p_keepalive_cb(gpointer key, gpointer value, gpointer user_data)
+{
+	struct yahoo_p2p_data *p2p_data = value;
+	PurpleConnection *gc = user_data;
+	struct yahoo_packet *pkt_to_send;
+	PurpleAccount *account;
+	YahooData *yd = gc->proto_data;
+
+	account = purple_connection_get_account(gc);
+
+	pkt_to_send = yahoo_packet_new(YAHOO_SERVICE_P2PFILEXFER, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash(pkt_to_send, "ssisi",
+		4, purple_normalize(account, purple_account_get_username(account)),
+		5, p2p_data->host_username,
+		241, 0,		/* Protocol identifier */
+		49, "PEERTOPEER",
+		13, 7);
+	yahoo_p2p_write_pkt(p2p_data->source, pkt_to_send);
+
+	yahoo_packet_free(pkt_to_send);
+}
+
+static gboolean yahoo_p2p_keepalive(gpointer data)
+{
+	PurpleConnection *gc = data;
+	YahooData *yd = gc->proto_data;
+
+	g_hash_table_foreach(yd->peers, yahoo_p2p_keepalive_cb, gc);
+
+	return TRUE;
+}
+
+/* destroy p2p_data associated with a peer and close p2p connection.
+ * g_hash_table_remove() calls this function to destroy p2p_data associated with the peer,
+ * call g_hash_table_remove() instead of this fucntion if peer has an entry in the table */
+static void yahoo_p2p_disconnect_destroy_data(gpointer data)
+{
+	struct yahoo_p2p_data *p2p_data;
+	YahooFriend *f;
+
+	if(!(p2p_data = data))
+		return ;
+
+	/* If friend, set him not connected */
+	f = yahoo_friend_find(p2p_data->gc, p2p_data->host_username);
+	if (f)
+		yahoo_friend_set_p2p_status(f, YAHOO_P2PSTATUS_NOT_CONNECTED);
+
+	if(p2p_data->source >= 0)
+		close(p2p_data->source);
+	if (p2p_data->input_event > 0)
+		purple_input_remove(p2p_data->input_event);
+	g_free(p2p_data->host_ip);
+	g_free(p2p_data->host_username);
+	g_free(p2p_data);
+}
+
+/* exchange of initial p2pfilexfer packets, service type YAHOO_SERVICE_P2PFILEXFER */
+static void yahoo_p2p_process_p2pfilexfer(gpointer data, gint source, struct yahoo_packet *pkt)
+{
+	struct yahoo_p2p_data *p2p_data;
+	char *who = NULL;
+	GSList *l = pkt->hash;
+	struct yahoo_packet *pkt_to_send;
+	PurpleAccount *account;
+	int val_13_to_send = 0;
+	YahooData *yd;
+	YahooFriend *f;
+
+	if(!(p2p_data = data))
+		return ;
+
+	yd = p2p_data->gc->proto_data;
+
+	/* lets see whats in the packet */
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 4:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+				if(strncmp(who, p2p_data->host_username, strlen(p2p_data->host_username)) != 0) {
+					/* from whom are we receiving the packets ?? */
+					purple_debug_warning("yahoo","p2p: received data from wrong user\n");
+					return;
+				}
+			} else {
+				purple_debug_warning("yahoo", "yahoo_p2p_process_p2pfilexfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 13:
+			p2p_data->val_13 = strtol(pair->value, NULL, 10);	/* Value should be 5-7 */
+			break;
+		/* case 5, 49 look laters, no use right now */
+		}
+		l = l->next;
+	}
+
+	account = purple_connection_get_account(p2p_data->gc);
+
+	/* key_13: sort of a counter.
+	 * WHEN WE ARE CLIENT: yahoo server sends val_13 = 0, we send to peer val_13 = 1, receive back val_13 = 5,
+	 * we send val_13=6, receive val_13=7, we send val_13=7, HALT. Keep sending val_13 = 7 as keep alive.
+	 * WHEN WE ARE SERVER: we send val_13 = 0 to yahoo server, peer sends us val_13 = 1, we send val_13 = 5,
+	 * receive val_13 = 6, send val_13 = 7, receive val_13 = 7. HALT. Keep sending val_13 = 7 as keep alive. */
+
+	switch(p2p_data->val_13) {
+		case 1 : val_13_to_send = 5; break;
+		case 5 : val_13_to_send = 6; break;
+		case 6 : val_13_to_send = 7; break;
+		case 7 : if( g_hash_table_lookup(yd->peers, p2p_data->host_username) )
+				return;
+			 val_13_to_send = 7; break;
+		default: purple_debug_warning("yahoo","p2p:Unknown value for key 13\n");
+			 return;
+		}
+
+	/* Build the yahoo packet */
+	pkt_to_send = yahoo_packet_new(YAHOO_SERVICE_P2PFILEXFER, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash(pkt_to_send, "ssisi",
+		4, purple_normalize(account, purple_account_get_username(account)),
+		5, p2p_data->host_username,
+		241, 0,		/* Protocol identifier */
+		49, "PEERTOPEER",
+		13, val_13_to_send);
+
+	/* build the raw packet and send it to the host */
+	yahoo_p2p_write_pkt(source, pkt_to_send);
+	yahoo_packet_free(pkt_to_send);
+
+	if( val_13_to_send == 7 )
+		if( !g_hash_table_lookup(yd->peers, p2p_data->host_username) ) {
+			g_hash_table_insert(yd->peers, g_strdup(p2p_data->host_username), p2p_data);
+			/* If the peer is a friend, set him connected */
+			f = yahoo_friend_find(p2p_data->gc, p2p_data->host_username);
+			if (f) {
+				if(p2p_data->connection_type == YAHOO_P2P_WE_ARE_SERVER) {
+					p2p_data->session_id = f->session_id;
+					yahoo_friend_set_p2p_status(f, YAHOO_P2PSTATUS_WE_ARE_SERVER);
+				}
+				else
+					yahoo_friend_set_p2p_status(f, YAHOO_P2PSTATUS_WE_ARE_CLIENT);
+			}
+		}
+}
+
+/* callback function associated with receiving of data, not considering receipt of multiple YMSG packets in a single TCP packet */
+static void yahoo_p2p_read_pkt_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	guchar buf[1024];	/* is it safe to assume a fixed array length of 1024 ?? */
+	int len;
+	int pos = 0;
+	int pktlen;
+	struct yahoo_packet *pkt;
+	guchar *start;
+	struct yahoo_p2p_data *p2p_data;
+	YahooData *yd;
+
+	if(!(p2p_data = data))
+		return ;
+	yd = p2p_data->gc->proto_data;
+
+	len = read(source, buf, sizeof(buf));
+	if ((len < 0) && ((errno == EAGAIN) || (errno == EWOULDBLOCK)))
+		return ; /* No Worries*/
+	else if (len <= 0)
+	{
+		purple_debug_warning("yahoo","p2p: Error in connection, or host disconnected\n");
+		/* remove from p2p connection lists, also calls yahoo_p2p_disconnect_destroy_data */
+		if( g_hash_table_lookup(yd->peers, p2p_data->host_username) )
+			g_hash_table_remove(yd->peers,p2p_data->host_username);
+		else
+			yahoo_p2p_disconnect_destroy_data(data);
+		return;
+	}
+
+	/* TODO: It looks like there's a bug here (and above) where an incorrect
+	 * assumtion is being made that the buffer will be added to when this
+	 * is next called, but that's not really the case! */
+	if(len < YAHOO_PACKET_HDRLEN)
+		return;
+
+	if(strncmp((char *)buf, "YMSG", 4) != 0) {
+		/* Not a YMSG packet */
+		purple_debug_warning("yahoo", "p2p: Got something other than YMSG packet\n");
+
+		start = (guchar *) g_strstr_len((char *) buf + 1, len - 1 ,"YMSG");
+		if (start == NULL) {
+			/* remove from p2p connection lists, also calls yahoo_p2p_disconnect_destroy_data */
+			if (g_hash_table_lookup(yd->peers, p2p_data->host_username))
+				g_hash_table_remove(yd->peers, p2p_data->host_username);
+			else
+				yahoo_p2p_disconnect_destroy_data(data);
+			return;
+		}
+		purple_debug_warning("yahoo","p2p: Got something other than YMSG packet\n");
+
+		len -= (start - buf);
+		g_memmove(buf, start, len);
+	}
+
+	pos += 4;	/* YMSG */
+	pos += 2;
+	pos += 2;
+
+	pktlen = yahoo_get16(buf + pos); pos += 2;
+	if (len < (YAHOO_PACKET_HDRLEN + pktlen)) {
+		purple_debug_error("yahoo", "p2p: packet length(%d) > buffer length(%d)\n",
+				pktlen, (len - pos)); 
+		/* remove from p2p connection lists, also calls yahoo_p2p_disconnect_destroy_data */
+		if (g_hash_table_lookup(yd->peers, p2p_data->host_username))
+			g_hash_table_remove(yd->peers, p2p_data->host_username);
+		else
+			yahoo_p2p_disconnect_destroy_data(data);
+		return;
+	} else
+		purple_debug_misc("yahoo", "p2p: %d bytes to read\n", pktlen);
+
+	pkt = yahoo_packet_new(0, 0, 0);
+	pkt->service = yahoo_get16(buf + pos); pos += 2;
+	pkt->status = yahoo_get32(buf + pos); pos += 4;
+	pkt->id = yahoo_get32(buf + pos); pos += 4;
+
+	purple_debug_misc("yahoo", "p2p: Yahoo Service: 0x%02x Status: %d\n",pkt->service, pkt->status);
+	yahoo_packet_read(pkt, buf + pos, pktlen);
+
+	/* packet processing */
+	switch(pkt->service) {
+		case YAHOO_SERVICE_P2PFILEXFER:
+			yahoo_p2p_process_p2pfilexfer(data, source, pkt);
+			break;
+		case YAHOO_SERVICE_MESSAGE:
+			yahoo_process_message(p2p_data->gc, pkt, YAHOO_PKT_TYPE_P2P);
+			break;
+		case YAHOO_SERVICE_NOTIFY:
+			yahoo_process_notify(p2p_data->gc, pkt, YAHOO_PKT_TYPE_P2P);
+			break;
+		default:
+			purple_debug_warning("yahoo","p2p: p2p service %d Unhandled\n",pkt->service);
+	}
+
+	yahoo_packet_free(pkt);
+}
+
+static void yahoo_p2p_server_send_connected_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	int acceptfd;
+	struct yahoo_p2p_data *p2p_data;
+	YahooData *yd;
+
+	if(!(p2p_data = data))
+		return ;
+	yd = p2p_data->gc->proto_data;
+
+	acceptfd = accept(source, NULL, 0);
+	if(acceptfd == -1 && (errno == EAGAIN || errno == EWOULDBLOCK))
+		return;
+	else if(acceptfd == -1) {
+		purple_debug_warning("yahoo","yahoo_p2p_server_send_connected_cb: accept: %s\n", g_strerror(errno));
+		yahoo_p2p_disconnect_destroy_data(data);
+		return;
+	}
+
+	/* remove timeout */
+	if (yd->yahoo_p2p_server_timeout_handle) {
+		purple_timeout_remove(yd->yahoo_p2p_server_timeout_handle);
+		yd->yahoo_p2p_server_timeout_handle = 0;
+	}
+
+	/* remove watcher and close p2p server */
+	if (yd->yahoo_p2p_server_watcher) {
+		purple_input_remove(yd->yahoo_p2p_server_watcher);
+		yd->yahoo_p2p_server_watcher = 0;
+	}
+	if (yd->yahoo_local_p2p_server_fd >= 0) {
+		close(yd->yahoo_local_p2p_server_fd);
+		yd->yahoo_local_p2p_server_fd = -1;
+	}
+
+	/* Add an Input Read event to the file descriptor */
+	p2p_data->input_event = purple_input_add(acceptfd, PURPLE_INPUT_READ, yahoo_p2p_read_pkt_cb, data);
+	p2p_data->source = acceptfd;
+}
+
+static gboolean yahoo_cancel_p2p_server_listen_cb(gpointer data)
+{
+	struct yahoo_p2p_data *p2p_data;
+	YahooData *yd;
+
+	if(!(p2p_data = data))
+		return FALSE;
+
+	yd = p2p_data->gc->proto_data;
+
+	purple_debug_warning("yahoo","yahoo p2p server timeout, peer failed to connect\n");
+	yahoo_p2p_disconnect_destroy_data(data);
+	purple_input_remove(yd->yahoo_p2p_server_watcher);
+	yd->yahoo_p2p_server_watcher = 0;
+	close(yd->yahoo_local_p2p_server_fd);
+	yd->yahoo_local_p2p_server_fd = -1;
+	yd->yahoo_p2p_server_timeout_handle = 0;
+
+	return FALSE;
+}
+
+static void yahoo_p2p_server_listen_cb(int listenfd, gpointer data)
+{
+	struct yahoo_p2p_data *p2p_data;
+	YahooData *yd;
+
+	if(!(p2p_data = data))
+		return ;
+
+	yd = p2p_data->gc->proto_data;
+	yd->listen_data = NULL;
+
+	if(listenfd == -1) {
+		purple_debug_warning("yahoo","p2p: error starting p2p server\n");
+		yahoo_p2p_disconnect_destroy_data(data);
+		return;
+	}
+
+	/* Add an Input Read event to the file descriptor */
+	yd->yahoo_local_p2p_server_fd = listenfd;
+	yd->yahoo_p2p_server_watcher = purple_input_add(listenfd, PURPLE_INPUT_READ, yahoo_p2p_server_send_connected_cb,data);
+
+	/* add timeout */
+	yd->yahoo_p2p_server_timeout_handle = purple_timeout_add_seconds(YAHOO_P2P_SERVER_TIMEOUT, yahoo_cancel_p2p_server_listen_cb, data);
+}
+
+/* send p2p pkt containing our encoded ip, asking peer to connect to us */
+void yahoo_send_p2p_pkt(PurpleConnection *gc, const char *who, int val_13)
+{
+	const char *public_ip;
+	guint32 temp[4];
+	guint32 ip;
+	char temp_str[100];
+	gchar *base64_ip = NULL;
+	YahooFriend *f;
+	struct yahoo_packet *pkt;
+	PurpleAccount *account;
+	YahooData *yd = gc->proto_data;
+	struct yahoo_p2p_data *p2p_data;
+	const char *norm_username;
+
+	f = yahoo_friend_find(gc, who);
+	account = purple_connection_get_account(gc);
+
+	/* Do not send invitation if already listening for other connection */
+	if(yd->yahoo_local_p2p_server_fd >= 0)
+		return;
+
+	/* One shouldn't try to connect to self */
+	if( strcmp(purple_normalize(account, purple_account_get_username(account)), who) == 0)
+		return;
+
+	/* send packet to only those friends who arent p2p connected and to whom we havent already sent. Do not send if this condition doesn't hold good */
+	if( !( f && (yahoo_friend_get_p2p_status(f) == YAHOO_P2PSTATUS_NOT_CONNECTED) && (f->p2p_packet_sent == 0)) )
+		return;
+
+	/* Dont send p2p packet to buddies of other protocols */
+	if(f->fed)
+		return;
+
+	/* Finally, don't try to connect to buddies not online or on sms */
+	if( (f->status == YAHOO_STATUS_OFFLINE) || f->sms )
+		return;
+
+	public_ip = purple_network_get_public_ip();
+	if( (sscanf(public_ip, "%u.%u.%u.%u", &temp[0], &temp[1], &temp[2], &temp[3])) !=4 )
+		return ;
+
+	ip = (temp[3] << 24) | (temp[2] <<16) | (temp[1] << 8) | temp[0];
+	sprintf(temp_str, "%d", ip);
+	base64_ip = purple_base64_encode( (guchar *)temp_str, strlen(temp_str) );
+
+	norm_username = purple_normalize(account, purple_account_get_username(account));
+	pkt = yahoo_packet_new(YAHOO_SERVICE_PEERTOPEER, YAHOO_STATUS_AVAILABLE, 0);
+	yahoo_packet_hash(pkt, "sssissis",
+		1, norm_username,
+		4, norm_username,
+		12, base64_ip,	/* base64 encode ip */
+		61, 0,		/* To-do : figure out what is 61 for?? */
+		2, "",
+		5, who,
+		13, val_13,
+		49, "PEERTOPEER");
+	yahoo_packet_send_and_free(pkt, yd);
+
+	f->p2p_packet_sent = 1;	/* set p2p_packet_sent to sent */
+
+	p2p_data = g_new0(struct yahoo_p2p_data, 1);
+
+	p2p_data->gc = gc;
+	p2p_data->host_ip = NULL;
+	p2p_data->host_username = g_strdup(who);
+	p2p_data->val_13 = val_13;
+	p2p_data->connection_type = YAHOO_P2P_WE_ARE_SERVER;
+	p2p_data->source = -1;
+
+	/* FIXME: If the port is already used, purple_network_listener returns NULL and old listener won't be canceled
+	 * in yahoo_close function. */
+	if (yd->listen_data)
+		purple_debug_warning("yahoo","p2p: Failed to create p2p server - server already exists\n");
+	else {
+		yd->listen_data = purple_network_listen(YAHOO_PAGER_PORT_P2P, SOCK_STREAM, yahoo_p2p_server_listen_cb, p2p_data);
+		if (yd->listen_data == NULL)
+			purple_debug_warning("yahoo","p2p: Failed to created p2p server\n");
+	}
+
+	g_free(base64_ip);
+}
+
+/* function called when connection to p2p host is setup */
+static void yahoo_p2p_init_cb(gpointer data, gint source, const gchar *error_message)
+{
+	struct yahoo_p2p_data *p2p_data;
+	struct yahoo_packet *pkt_to_send;
+	PurpleAccount *account;
+	YahooData *yd;
+
+	p2p_data = data;
+	yd = p2p_data->gc->proto_data;
+
+	if(error_message != NULL) {
+		purple_debug_warning("yahoo","p2p: %s\n",error_message);
+		yahoo_send_p2p_pkt(p2p_data->gc, p2p_data->host_username, 2);/* send p2p init packet with val_13=2 */
+
+		yahoo_p2p_disconnect_destroy_data(p2p_data);
+		return;
+	}
+
+	/* Add an Input Read event to the file descriptor */
+	p2p_data->input_event = purple_input_add(source, PURPLE_INPUT_READ, yahoo_p2p_read_pkt_cb, data);
+	p2p_data->source = source;
+
+	account = purple_connection_get_account(p2p_data->gc);
+
+	/* Build the yahoo packet */
+	pkt_to_send = yahoo_packet_new(YAHOO_SERVICE_P2PFILEXFER, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash(pkt_to_send, "ssisi",
+		4, purple_normalize(account, purple_account_get_username(account)),
+		5, p2p_data->host_username,
+		241, 0,		/* Protocol identifier */
+		49, "PEERTOPEER",
+		13, 1);		/* we receive key13= 0 or 2, we send key13=1 */
+
+	yahoo_p2p_write_pkt(source, pkt_to_send);	/* build raw packet and send */
+	yahoo_packet_free(pkt_to_send);
+}
+
+static void yahoo_process_p2p(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	GSList *l = pkt->hash;
+	char *who = NULL;
+	char *base64 = NULL;
+	guchar *decoded;
+	gsize len;
+	gint val_13 = 0;
+	gint val_11 = 0;
+	PurpleAccount *account;
+	YahooFriend *f;
+
+	/* if status is not YAHOO_STATUS_BRB or YAHOO_STATUS_P2P, the packet bounced back,
+	 * so it contains our own ip */
+	if(pkt->status != YAHOO_STATUS_BRB && pkt->status != YAHOO_STATUS_P2P)
+		return ;
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 5:
+			/* our identity */
+			break;
+		case 4:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_p2p "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 1:
+			/* who again, the master identity this time? */
+			break;
+		case 12:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				base64 = pair->value;
+				/* so, this is an ip address. in base64. decoded it's in ascii.
+				   after strtol, it's in reversed byte order. Who thought this up?*/
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_p2p "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 13:
+			val_13 = strtol(pair->value, NULL, 10);
+			break;
+		case 11:
+			val_11 = strtol(pair->value, NULL, 10);		/* session id of peer */
+			if( (f = yahoo_friend_find(gc, who)) )
+				f->session_id = val_11;
+			break;
+		/*
+			TODO: figure these out
+			yahoo: Key: 61          Value: 0
+			yahoo: Key: 2   Value:
+			yahoo: Key: 13          Value: 0	packet count ??
+			yahoo: Key: 49          Value: PEERTOPEER
+			yahoo: Key: 140         Value: 1
+		*/
+
+		}
+
+		l = l->next;
+	}
+
+	if (base64) {
+		guint32 ip;
+		YahooFriend *f;
+		char *host_ip, *tmp;
+		struct yahoo_p2p_data *p2p_data;
+
+		decoded = purple_base64_decode(base64, &len);
+		if (decoded == NULL) {
+			purple_debug_info("yahoo","p2p: Unable to decode base64 IP (%s) \n", base64);
+			return;
+		}
+		tmp = purple_str_binary_to_ascii(decoded, len);
+		purple_debug_info("yahoo", "Got P2P service packet (from server): who = %s, ip = %s\n", who, tmp);
+		g_free(tmp);
+
+		ip = strtol((gchar *)decoded, NULL, 10);
+		g_free(decoded);
+		host_ip = g_strdup_printf("%u.%u.%u.%u", ip & 0xff, (ip >> 8) & 0xff, (ip >> 16) & 0xff,
+		                       (ip >> 24) & 0xff);
+		f = yahoo_friend_find(gc, who);
+		if (f)
+			yahoo_friend_set_ip(f, host_ip);
+		purple_debug_info("yahoo", "IP : %s\n", host_ip);
+
+		account = purple_connection_get_account(gc);
+
+		if(val_11==0) {
+			if(!f)
+				return;
+			else
+				val_11 = f->session_id;
+		}
+
+		p2p_data = g_new0(struct yahoo_p2p_data, 1);
+		p2p_data->host_username = g_strdup(who);
+		p2p_data->val_13 = val_13;
+		p2p_data->session_id = val_11;
+		p2p_data->host_ip = host_ip;
+		p2p_data->gc = gc;
+		p2p_data->connection_type = YAHOO_P2P_WE_ARE_CLIENT;
+		p2p_data->source = -1;
+
+		/* connect to host */
+		if((purple_proxy_connect(gc, account, host_ip, YAHOO_PAGER_PORT_P2P, yahoo_p2p_init_cb, p2p_data))==NULL) {
+			purple_debug_info("yahoo","p2p: Connection to %s failed\n", host_ip);
+			g_free(p2p_data->host_ip);
+			g_free(p2p_data->host_username);
+			g_free(p2p_data);
+		}
+	}
+}
+
+static void yahoo_process_audible(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	PurpleAccount *account;
+	char *who = NULL, *msg = NULL, *id = NULL;
+	GSList *l = pkt->hash;
+
+	account = purple_connection_get_account(gc);
+
+	while (l) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 4:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_audible "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 5:
+			/* us */
+			break;
+		case 230:
+			/* the audible, in foo.locale.bar.baz format
+			   eg: base.tw.smiley.smiley43 */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				id = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_audible "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 231:
+			/* the text of the audible */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				msg = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_audible "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 232:
+			/* SHA-1 hash of audible SWF file (eg: 4e8691499d9c0fb8374478ff9720f4a9ea4a4915) */
+			break;
+		}
+
+		l = l->next;
+	}
+
+	if (!msg)
+		msg = id;
+	if (!who || !msg)
+		return;
+	if (!g_utf8_validate(msg, -1, NULL)) {
+		purple_debug_misc("yahoo", "Warning, nonutf8 audible, ignoring!\n");
+		return;
+	}
+	if (!purple_privacy_check(account, who)) {
+		purple_debug_misc("yahoo", "Audible message from %s for %s dropped!\n",
+				purple_account_get_username(account), who);
+		return;
+	}
+	if (id) {
+		/* "http://l.yimg.com/pu/dl/aud/"+locale+"/"+id+".swf" */
+		char **audible_locale = g_strsplit(id, ".", 0);
+		char *buf = g_strdup_printf(_("[ Audible %s/%s/%s.swf ] %s"), YAHOO_AUDIBLE_URL, audible_locale[1], id, msg);
+		g_strfreev(audible_locale);
+
+		serv_got_im(gc, who, buf, 0, time(NULL));
+		g_free(buf);
+	} else
+		serv_got_im(gc, who, msg, 0, time(NULL));
+}
+
+static void yahoo_packet_process(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	switch (pkt->service) {
+	case YAHOO_SERVICE_LOGON:
+	case YAHOO_SERVICE_LOGOFF:
+	case YAHOO_SERVICE_ISAWAY:
+	case YAHOO_SERVICE_ISBACK:
+	case YAHOO_SERVICE_GAMELOGON:
+	case YAHOO_SERVICE_GAMELOGOFF:
+	case YAHOO_SERVICE_CHATLOGON:
+	case YAHOO_SERVICE_CHATLOGOFF:
+	case YAHOO_SERVICE_Y6_STATUS_UPDATE:
+	case YAHOO_SERVICE_STATUS_15:
+		yahoo_process_status(gc, pkt);
+		break;
+	case YAHOO_SERVICE_NOTIFY:
+		yahoo_process_notify(gc, pkt, YAHOO_PKT_TYPE_SERVER);
+		break;
+	case YAHOO_SERVICE_MESSAGE:
+	case YAHOO_SERVICE_GAMEMSG:
+	case YAHOO_SERVICE_CHATMSG:
+		yahoo_process_message(gc, pkt, YAHOO_PKT_TYPE_SERVER);
+		break;
+	case YAHOO_SERVICE_SYSMESSAGE:
+		yahoo_process_sysmessage(gc, pkt);
+			break;
+	case YAHOO_SERVICE_NEWMAIL:
+		yahoo_process_mail(gc, pkt);
+		break;
+	case YAHOO_SERVICE_NEWCONTACT:
+		yahoo_process_contact(gc, pkt);
+		break;
+	case YAHOO_SERVICE_AUTHRESP:
+		yahoo_process_authresp(gc, pkt);
+		break;
+	case YAHOO_SERVICE_LIST:
+		yahoo_process_list(gc, pkt);
+		break;
+	case YAHOO_SERVICE_LIST_15:
+		yahoo_process_list_15(gc, pkt);
+		break;
+	case YAHOO_SERVICE_AUTH:
+		yahoo_process_auth(gc, pkt);
+		break;
+	case YAHOO_SERVICE_AUTH_REQ_15:
+		yahoo_buddy_auth_req_15(gc, pkt);
+		break;
+	case YAHOO_SERVICE_ADDBUDDY:
+		yahoo_process_addbuddy(gc, pkt);
+		break;
+	case YAHOO_SERVICE_IGNORECONTACT:
+		yahoo_process_ignore(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CONFINVITE:
+	case YAHOO_SERVICE_CONFADDINVITE:
+		yahoo_process_conference_invite(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CONFDECLINE:
+		yahoo_process_conference_decline(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CONFLOGON:
+		yahoo_process_conference_logon(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CONFLOGOFF:
+		yahoo_process_conference_logoff(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CONFMSG:
+		yahoo_process_conference_message(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CHATONLINE:
+		yahoo_process_chat_online(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CHATLOGOUT:
+		yahoo_process_chat_logout(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CHATGOTO:
+		yahoo_process_chat_goto(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CHATJOIN:
+		yahoo_process_chat_join(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CHATLEAVE: /* XXX is this right? */
+	case YAHOO_SERVICE_CHATEXIT:
+		yahoo_process_chat_exit(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CHATINVITE: /* XXX never seen this one, might not do it right */
+	case YAHOO_SERVICE_CHATADDINVITE:
+		yahoo_process_chat_addinvite(gc, pkt);
+		break;
+	case YAHOO_SERVICE_COMMENT:
+		yahoo_process_chat_message(gc, pkt);
+		break;
+	case YAHOO_SERVICE_PRESENCE_PERM:
+	case YAHOO_SERVICE_PRESENCE_SESSION:
+		yahoo_process_presence(gc, pkt);
+		break;
+	case YAHOO_SERVICE_P2PFILEXFER:
+		/* This case had no break and continued; thus keeping it this way.*/
+		yahoo_process_p2p(gc, pkt);	/* P2PFILEXFER handled the same way as process_p2p */
+		yahoo_process_p2pfilexfer(gc, pkt);	/* redundant ??, need to have a break now */
+	case YAHOO_SERVICE_FILETRANSFER:
+		yahoo_process_filetransfer(gc, pkt);
+		break;
+	case YAHOO_SERVICE_PEERTOPEER:
+		yahoo_process_p2p(gc, pkt);
+		break;
+	case YAHOO_SERVICE_PICTURE:
+		yahoo_process_picture(gc, pkt);
+		break;
+	case YAHOO_SERVICE_PICTURE_CHECKSUM:
+		yahoo_process_picture_checksum(gc, pkt);
+		break;
+	case YAHOO_SERVICE_PICTURE_UPLOAD:
+		yahoo_process_picture_upload(gc, pkt);
+		break;
+	case YAHOO_SERVICE_PICTURE_UPDATE:
+	case YAHOO_SERVICE_AVATAR_UPDATE:
+		yahoo_process_avatar_update(gc, pkt);
+		break;
+	case YAHOO_SERVICE_AUDIBLE:
+		yahoo_process_audible(gc, pkt);
+		break;
+	case YAHOO_SERVICE_CONTACT_DETAILS:
+		yahoo_process_contact_details(gc, pkt);
+		break;
+	case YAHOO_SERVICE_FILETRANS_15:
+		yahoo_process_filetrans_15(gc, pkt);
+		break;
+	case YAHOO_SERVICE_FILETRANS_INFO_15:
+		yahoo_process_filetrans_info_15(gc, pkt);
+		break;
+	case YAHOO_SERVICE_FILETRANS_ACC_15:
+		yahoo_process_filetrans_acc_15(gc, pkt);
+		break;
+	case YAHOO_SERVICE_SMS_MSG:
+		yahoo_process_sms_message(gc, pkt);
+		break;
+
+	default:
+		purple_debug_error("yahoo", "Unhandled service 0x%02x\n", pkt->service);
+		break;
+	}
+}
+
+static void yahoo_pending(gpointer data, gint source, PurpleInputCondition cond)
+{
+	PurpleConnection *gc = data;
+	YahooData *yd = gc->proto_data;
+	char buf[1024];
+	int len;
+
+	len = read(yd->fd, buf, sizeof(buf));
+
+	if (len < 0) {
+		gchar *tmp;
+
+		if (errno == EAGAIN)
+			/* No worries */
+			return;
+
+		tmp = g_strdup_printf(_("Lost connection with server: %s"),
+				g_strerror(errno));
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	} else if (len == 0) {
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+				_("Server closed the connection"));
+		return;
+	}
+	gc->last_received = time(NULL);
+	yd->rxqueue = g_realloc(yd->rxqueue, len + yd->rxlen);
+	memcpy(yd->rxqueue + yd->rxlen, buf, len);
+	yd->rxlen += len;
+
+	while (1) {
+		struct yahoo_packet *pkt;
+		int pos = 0;
+		int pktlen;
+
+		if (yd->rxlen < YAHOO_PACKET_HDRLEN)
+			return;
+
+		if (strncmp((char *)yd->rxqueue, "YMSG", MIN(4, yd->rxlen)) != 0) {
+			/* HEY! This isn't even a YMSG packet. What
+			 * are you trying to pull? */
+			guchar *start;
+
+			purple_debug_warning("yahoo", "Error in YMSG stream, got something not a YMSG packet!\n");
+
+			start = memchr(yd->rxqueue + 1, 'Y', yd->rxlen - 1);
+			if (start) {
+				g_memmove(yd->rxqueue, start, yd->rxlen - (start - yd->rxqueue));
+				yd->rxlen -= start - yd->rxqueue;
+				continue;
+			} else {
+				g_free(yd->rxqueue);
+				yd->rxqueue = NULL;
+				yd->rxlen = 0;
+				return;
+			}
+		}
+
+		pos += 4; /* YMSG */
+		pos += 2;
+		pos += 2;
+
+		pktlen = yahoo_get16(yd->rxqueue + pos); pos += 2;
+		purple_debug_misc("yahoo", "%d bytes to read, rxlen is %d\n", pktlen, yd->rxlen);
+
+		if (yd->rxlen < (YAHOO_PACKET_HDRLEN + pktlen))
+			return;
+
+		yahoo_packet_dump(yd->rxqueue, YAHOO_PACKET_HDRLEN + pktlen);
+
+		pkt = yahoo_packet_new(0, 0, 0);
+
+		pkt->service = yahoo_get16(yd->rxqueue + pos); pos += 2;
+		pkt->status = yahoo_get32(yd->rxqueue + pos); pos += 4;
+		purple_debug_misc("yahoo", "Yahoo Service: 0x%02x Status: %d\n",
+				   pkt->service, pkt->status);
+		pkt->id = yahoo_get32(yd->rxqueue + pos); pos += 4;
+
+		yahoo_packet_read(pkt, yd->rxqueue + pos, pktlen);
+
+		yd->rxlen -= YAHOO_PACKET_HDRLEN + pktlen;
+		if (yd->rxlen) {
+			guchar *tmp = g_memdup(yd->rxqueue + YAHOO_PACKET_HDRLEN + pktlen, yd->rxlen);
+			g_free(yd->rxqueue);
+			yd->rxqueue = tmp;
+		} else {
+			g_free(yd->rxqueue);
+			yd->rxqueue = NULL;
+		}
+
+		yahoo_packet_process(gc, pkt);
+
+		yahoo_packet_free(pkt);
+	}
+}
+
+static void yahoo_got_connected(gpointer data, gint source, const gchar *error_message)
+{
+	PurpleConnection *gc = data;
+	YahooData *yd;
+	struct yahoo_packet *pkt;
+
+	if (source < 0) {
+		gchar *tmp;
+		tmp = g_strdup_printf(_("Unable to connect: %s"), error_message);
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	}
+
+	yd = gc->proto_data;
+	yd->fd = source;
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_AUTH, yd->current_status, yd->session_id);
+
+	yahoo_packet_hash_str(pkt, 1, purple_normalize(gc->account, purple_account_get_username(purple_connection_get_account(gc))));
+	yahoo_packet_send_and_free(pkt, yd);
+
+	gc->inpa = purple_input_add(yd->fd, PURPLE_INPUT_READ, yahoo_pending, gc);
+}
+
+#ifdef TRY_WEBMESSENGER_LOGIN
+static void yahoo_got_web_connected(gpointer data, gint source, const gchar *error_message)
+{
+	PurpleConnection *gc = data;
+	YahooData *yd;
+	struct yahoo_packet *pkt;
+
+	if (source < 0) {
+		gchar *tmp;
+		tmp = g_strdup_printf(_("Unable to connect: %s"), error_message);
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	}
+
+	yd = gc->proto_data;
+	yd->fd = source;
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_WEBLOGIN, YAHOO_STATUS_WEBLOGIN, yd->session_id);
+
+	yahoo_packet_hash(pkt, "sss", 0,
+	                  purple_normalize(gc->account, purple_account_get_username(purple_connection_get_account(gc))),
+	                  1, purple_normalize(gc->account, purple_account_get_username(purple_connection_get_account(gc))),
+	                  6, yd->auth);
+	yahoo_packet_send_and_free(pkt, yd);
+
+	g_free(yd->auth);
+	gc->inpa = purple_input_add(yd->fd, PURPLE_INPUT_READ, yahoo_pending, gc);
+}
+
+static void yahoo_web_pending(gpointer data, gint source, PurpleInputCondition cond)
+{
+	PurpleConnection *gc = data;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	YahooData *yd = gc->proto_data;
+	char bufread[2048], *i = bufread, *buf = bufread;
+	int len;
+	GString *s;
+
+	len = read(source, bufread, sizeof(bufread) - 1);
+
+	if (len < 0) {
+		gchar *tmp;
+
+		if (errno == EAGAIN)
+			/* No worries */
+			return;
+
+		tmp = g_strdup_printf(_("Lost connection with server: %s"),
+				g_strerror(errno));
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	} else if (len == 0) {
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+				_("Server closed the connection"));
+		return;
+	}
+
+	if (yd->rxlen > 0 || !g_strstr_len(buf, len, "\r\n\r\n")) {
+		yd->rxqueue = g_realloc(yd->rxqueue, yd->rxlen + len + 1);
+		memcpy(yd->rxqueue + yd->rxlen, buf, len);
+		yd->rxlen += len;
+		i = buf = (char *)yd->rxqueue;
+		len = yd->rxlen;
+	}
+	buf[len] = '\0';
+
+	if ((strncmp(buf, "HTTP/1.0 302", strlen("HTTP/1.0 302")) &&
+			  strncmp(buf, "HTTP/1.1 302", strlen("HTTP/1.1 302")))) {
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+			_("Received unexpected HTTP response from server"));
+		purple_debug_misc("yahoo", "Unexpected HTTP response: %s\n", buf);
+		return;
+	}
+
+	s = g_string_sized_new(len);
+
+	while ((i = strstr(i, "Set-Cookie: "))) {
+
+		i += strlen("Set-Cookie: ");
+		for (;*i != ';' && *i != '\0'; i++)
+			g_string_append_c(s, *i);
+
+		g_string_append(s, "; ");
+		/* Should these cookies be included too when trying for xfer?
+		 * It seems to work without these
+		 */
+	}
+
+	yd->auth = g_string_free(s, FALSE);
+	purple_input_remove(gc->inpa);
+	close(source);
+	g_free(yd->rxqueue);
+	yd->rxqueue = NULL;
+	yd->rxlen = 0;
+	/* Now we have our cookies to login with.  I'll go get the milk. */
+	if (purple_proxy_connect(gc, account, "wcs2.msg.dcn.yahoo.com",
+	                         purple_account_get_int(account, "port", YAHOO_PAGER_PORT),
+	                         yahoo_got_web_connected, gc) == NULL) {
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+		                               _("Unable to connect"));
+		return;
+	}
+}
+
+static void yahoo_got_cookies_send_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	PurpleConnection *gc;
+	YahooData *yd;
+	int written, remaining;
+
+	gc = data;
+	yd = gc->proto_data;
+
+	remaining = strlen(yd->auth) - yd->auth_written;
+	written = write(source, yd->auth + yd->auth_written, remaining);
+
+	if (written < 0 && errno == EAGAIN)
+		written = 0;
+	else if (written <= 0) {
+		gchar *tmp;
+		g_free(yd->auth);
+		yd->auth = NULL;
+		if (gc->inpa)
+			purple_input_remove(gc->inpa);
+		gc->inpa = 0;
+		tmp = g_strdup_printf(_("Lost connection with %s: %s"),
+				"login.yahoo.com:80", g_strerror(errno));
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	}
+
+	if (written < remaining) {
+		yd->auth_written += written;
+		return;
+	}
+
+	g_free(yd->auth);
+	yd->auth = NULL;
+	yd->auth_written = 0;
+	purple_input_remove(gc->inpa);
+	gc->inpa = purple_input_add(source, PURPLE_INPUT_READ, yahoo_web_pending, gc);
+}
+
+static void yahoo_got_cookies(gpointer data, gint source, const gchar *error_message)
+{
+	PurpleConnection *gc = data;
+
+	if (source < 0) {
+		gchar *tmp;
+		tmp = g_strdup_printf(_("Unable to establish a connection with %s: %s"),
+				"login.yahoo.com:80", error_message);
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
+		g_free(tmp);
+		return;
+	}
+
+	if (gc->inpa == 0)
+	{
+		gc->inpa = purple_input_add(source, PURPLE_INPUT_WRITE,
+			yahoo_got_cookies_send_cb, gc);
+		yahoo_got_cookies_send_cb(gc, source, PURPLE_INPUT_WRITE);
+	}
+}
+
+static void yahoo_login_page_hash_iter(const char *key, const char *val, GString *url)
+{
+	if (!strcmp(key, "passwd") || !strcmp(key, "login"))
+		return;
+	g_string_append_c(url, '&');
+	g_string_append(url, key);
+	g_string_append_c(url, '=');
+	if (!strcmp(key, ".save") || !strcmp(key, ".js"))
+		g_string_append_c(url, '1');
+	else if (!strcmp(key, ".challenge"))
+		g_string_append(url, val);
+	else
+		g_string_append(url, purple_url_encode(val));
+}
+
+static GHashTable *yahoo_login_page_hash(const char *buf, size_t len)
+{
+	GHashTable *hash = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+	const char *c = buf;
+	char *d;
+	char name[64], value[64];
+	int count;
+	int input_len = strlen("<input ");
+	int name_len = strlen("name=\"");
+	int value_len = strlen("value=\"");
+	while ((len > ((c - buf) + input_len))
+			&& (c = strstr(c, "<input "))) {
+		if (!(c = g_strstr_len(c, len - (c - buf), "name=\"")))
+			continue;
+		c += name_len;
+		count = sizeof(name)-1;
+		for (d = name; (len > ((c - buf) + 1)) && *c!='"'
+				&& count; c++, d++, count--)
+			*d = *c;
+		*d = '\0';
+		count = sizeof(value)-1;
+		if (!(d = g_strstr_len(c, len - (c - buf), "value=\"")))
+			continue;
+		d += value_len;
+		if (strchr(c, '>') < d)
+			break;
+		for (c = d, d = value; (len > ((c - buf) + 1))
+				&& *c!='"' && count; c++, d++, count--)
+			*d = *c;
+		*d = '\0';
+		g_hash_table_insert(hash, g_strdup(name), g_strdup(value));
+	}
+	return hash;
+}
+
+static void
+yahoo_login_page_cb(PurpleUtilFetchUrlData *url_data, gpointer user_data,
+		const gchar *url_text, size_t len, const gchar *error_message)
+{
+	PurpleConnection *gc = (PurpleConnection *)user_data;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	YahooData *yd = gc->proto_data;
+	const char *sn = purple_account_get_username(account);
+	const char *pass = purple_connection_get_password(gc);
+	GHashTable *hash = yahoo_login_page_hash(url_text, len);
+	GString *url = g_string_new("GET http://login.yahoo.com/config/login?login=");
+	char md5[33], *hashp = md5, *chal;
+	int i;
+	PurpleCipher *cipher;
+	PurpleCipherContext *context;
+	guchar digest[16];
+
+	yd->url_datas = g_slist_remove(yd->url_datas, url_data);
+
+	if (error_message != NULL)
+	{
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+		                               error_message);
+		return;
+	}
+
+	url = g_string_append(url, sn);
+	url = g_string_append(url, "&passwd=");
+
+	cipher = purple_ciphers_find_cipher("md5");
+	context = purple_cipher_context_new(cipher, NULL);
+
+	purple_cipher_context_append(context, (const guchar *)pass, strlen(pass));
+	purple_cipher_context_digest(context, sizeof(digest), digest, NULL);
+	for (i = 0; i < 16; ++i) {
+		g_snprintf(hashp, 3, "%02x", digest[i]);
+		hashp += 2;
+	}
+
+	chal = g_strconcat(md5, g_hash_table_lookup(hash, ".challenge"), NULL);
+	purple_cipher_context_reset(context, NULL);
+	purple_cipher_context_append(context, (const guchar *)chal, strlen(chal));
+	purple_cipher_context_digest(context, sizeof(digest), digest, NULL);
+	hashp = md5;
+	for (i = 0; i < 16; ++i) {
+		g_snprintf(hashp, 3, "%02x", digest[i]);
+		hashp += 2;
+	}
+	/*
+	 * I dunno why this is here and commented out.. but in case it's needed
+	 * I updated it..
+
+	purple_cipher_context_reset(context, NULL);
+	purple_cipher_context_append(context, md5, strlen(md5));
+	purple_cipher_context_digest(context, sizeof(digest), digest, NULL);
+	hashp = md5;
+	for (i = 0; i < 16; ++i) {
+		g_snprintf(hashp, 3, "%02x", digest[i]);
+		hashp += 2;
+	}
+	*/
+	g_free(chal);
+
+	url = g_string_append(url, md5);
+	g_hash_table_foreach(hash, (GHFunc)yahoo_login_page_hash_iter, url);
+
+	url = g_string_append(url, "&.hash=1&.md5=1 HTTP/1.1\r\n"
+			      "Host: login.yahoo.com\r\n\r\n");
+	g_hash_table_destroy(hash);
+	yd->auth = g_string_free(url, FALSE);
+	if (purple_proxy_connect(gc, account, "login.yahoo.com", 80, yahoo_got_cookies, gc) == NULL) {
+		purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+		                               _("Unable to connect"));
+		return;
+	}
+
+	purple_cipher_context_destroy(context);
+}
+#endif /* TRY_WEBMESSENGER_LOGIN */
+
+static void yahoo_picture_check(PurpleAccount *account)
+{
+	PurpleConnection *gc = purple_account_get_connection(account);
+	PurpleStoredImage *img = purple_buddy_icons_find_account_icon(account);
+
+	yahoo_set_buddy_icon(gc, img);
+	purple_imgstore_unref(img);
+}
+
+static int get_yahoo_status_from_purple_status(PurpleStatus *status)
+{
+	PurplePresence *presence;
+	const char *status_id;
+	const char *msg;
+
+	presence = purple_status_get_presence(status);
+	status_id = purple_status_get_id(status);
+	msg = purple_status_get_attr_string(status, "message");
+
+	if ((msg != NULL) && (*msg != '\0')) {
+		return YAHOO_STATUS_CUSTOM;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_AVAILABLE)) {
+		return YAHOO_STATUS_AVAILABLE;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_BRB)) {
+		return YAHOO_STATUS_BRB;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_BUSY)) {
+		return YAHOO_STATUS_BUSY;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_NOTATHOME)) {
+		return YAHOO_STATUS_NOTATHOME;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_NOTATDESK)) {
+		return YAHOO_STATUS_NOTATDESK;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_NOTINOFFICE)) {
+		return YAHOO_STATUS_NOTINOFFICE;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_ONPHONE)) {
+		return YAHOO_STATUS_ONPHONE;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_ONVACATION)) {
+		return YAHOO_STATUS_ONVACATION;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_OUTTOLUNCH)) {
+		return YAHOO_STATUS_OUTTOLUNCH;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_STEPPEDOUT)) {
+		return YAHOO_STATUS_STEPPEDOUT;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_INVISIBLE)) {
+		return YAHOO_STATUS_INVISIBLE;
+	} else if (!strcmp(status_id, YAHOO_STATUS_TYPE_AWAY)) {
+		return YAHOO_STATUS_CUSTOM;
+	} else if (purple_presence_is_idle(presence)) {
+		return YAHOO_STATUS_IDLE;
+	} else {
+		purple_debug_error("yahoo", "Unexpected PurpleStatus!\n");
+		return YAHOO_STATUS_AVAILABLE;
+	}
+}
+
+static void yahoo_got_pager_server(PurpleUtilFetchUrlData *url_data,
+		gpointer user_data, const gchar *url_text, gsize len, const gchar *error_message)
+{
+	YahooData *yd = user_data;
+	PurpleConnection *gc = yd->gc;
+	PurpleAccount *a = purple_connection_get_account(gc);
+	gchar **strings = NULL, *cs_server = NULL;
+	int port = purple_account_get_int(a, "port", YAHOO_PAGER_PORT);
+	int stringslen = 0;
+
+	yd->url_datas = g_slist_remove(yd->url_datas, url_data);
+
+	if(error_message != NULL || len == 0) {
+		purple_debug_error("yahoo", "Unable to retrieve server info. %"
+				G_GSIZE_FORMAT " bytes retrieved with error message: %s\n", len,
+				error_message ? error_message : "(null)");
+
+		if(yahoo_is_japan(a)) { /* We don't know fallback hosts for Yahoo Japan :( */
+			purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+					_("Unable to connect: The server returned an empty response."));
+		} else {
+				if(purple_proxy_connect(gc, a, YAHOO_PAGER_HOST_FALLBACK, port,
+							yahoo_got_connected, gc) == NULL) {
+					purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+							_("Unable to connect"));
+				}
+		}
+	} else {
+		strings = g_strsplit(url_text, "\r\n", -1);
+
+		if((stringslen = g_strv_length(strings)) > 1) {
+			int i;
+
+			for(i = 0; i < stringslen; i++) {
+				if(g_ascii_strncasecmp(strings[i], "COLO_CAPACITY=", 14) == 0) {
+					purple_debug_info("yahoo", "Got COLO Capacity: %s\n", &(strings[i][14]));
+				} else if(g_ascii_strncasecmp(strings[i], "CS_IP_ADDRESS=", 14) == 0) {
+					cs_server = g_strdup(&strings[i][14]);
+					purple_debug_info("yahoo", "Got CS IP address: %s\n", cs_server);
+				}
+			}
+		}
+
+		if(cs_server) { /* got an address; get on with connecting */
+			if(purple_proxy_connect(gc, a, cs_server, port, yahoo_got_connected, gc) == NULL)
+				purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+								_("Unable to connect"));
+		} else {
+			purple_debug_error("yahoo", "No CS address retrieved!  Server "
+					"response:\n%s\n", url_text ? url_text : "(null)");
+
+			if(yahoo_is_japan(a)) { /* We don't know fallback hosts for Yahoo Japan :( */
+				purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+						_("Unable to connect: The server's response did not contain "
+							"the necessary information"));
+			} else
+				if(purple_proxy_connect(gc, a, YAHOO_PAGER_HOST_FALLBACK, port,
+							yahoo_got_connected, gc) == NULL) {
+					purple_connection_error_reason(gc, PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+							_("Unable to connect"));
+				}
+		}
+	}
+
+	g_strfreev(strings);
+	g_free(cs_server);
+}
+
+void yahoo_login(PurpleAccount *account) {
+	PurpleConnection *gc = purple_account_get_connection(account);
+	YahooData *yd = gc->proto_data = g_new0(YahooData, 1);
+	PurpleStatus *status = purple_account_get_active_status(account);
+	gboolean use_whole_url = yahoo_account_use_http_proxy(gc);
+	gboolean proxy_ssl = purple_account_get_bool(account, "proxy_ssl", FALSE);
+	PurpleUtilFetchUrlData *url_data;
+
+	gc->flags |= PURPLE_CONNECTION_HTML | PURPLE_CONNECTION_NO_BGCOLOR | PURPLE_CONNECTION_NO_URLDESC;
+
+	purple_connection_update_progress(gc, _("Connecting"), 1, 2);
+
+	purple_connection_set_display_name(gc, purple_account_get_username(account));
+
+	yd->gc = gc;
+	yd->jp = yahoo_is_japan(account);
+	yd->yahoo_local_p2p_server_fd = -1;
+	yd->fd = -1;
+	yd->txhandler = 0;
+	/* TODO: Is there a good grow size for the buffer? */
+	yd->txbuf = purple_circ_buffer_new(0);
+	yd->friends = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, yahoo_friend_free);
+	yd->imvironments = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+	yd->xfer_peer_idstring_map = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	yd->peers = g_hash_table_new_full(g_str_hash, g_str_equal, g_free,
+					yahoo_p2p_disconnect_destroy_data);
+	yd->sms_carrier = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+	yd->yahoo_p2p_timer = purple_timeout_add_seconds(YAHOO_P2P_KEEPALIVE_SECS,
+					yahoo_p2p_keepalive, gc);
+	yd->confs = NULL;
+	yd->conf_id = 2;
+	yd->last_keepalive = yd->last_ping = time(NULL);
+
+	yd->current_status = get_yahoo_status_from_purple_status(status);
+
+	yahoo_picture_check(account);
+
+	/* Get the pager server.  Actually start connecting in the callback since we
+	 * must have the contents of the HTTP response to proceed. */
+	url_data = purple_util_fetch_url_request_len_with_account(
+			proxy_ssl ? purple_connection_get_account(gc) : NULL,
+			yd->jp ? YAHOOJP_PAGER_HOST_REQ_URL : YAHOO_PAGER_HOST_REQ_URL,
+			use_whole_url ? TRUE : FALSE,
+			YAHOO_CLIENT_USERAGENT, FALSE, NULL, FALSE, -1,
+			yahoo_got_pager_server, yd);
+	if (url_data)
+		yd->url_datas = g_slist_prepend(yd->url_datas, url_data);
+
+	return;
+}
+
+void yahoo_close(PurpleConnection *gc) {
+	YahooData *yd = (YahooData *)gc->proto_data;
+	GSList *l;
+
+	if (gc->inpa)
+		purple_input_remove(gc->inpa);
+
+	while (yd->url_datas) {
+		purple_util_fetch_url_cancel(yd->url_datas->data);
+		yd->url_datas = g_slist_delete_link(yd->url_datas, yd->url_datas);
+	}
+
+	for (l = yd->confs; l; l = l->next) {
+		PurpleConversation *conv = l->data;
+
+		yahoo_conf_leave(yd, purple_conversation_get_name(conv),
+		                 purple_connection_get_display_name(gc),
+				 purple_conv_chat_get_users(PURPLE_CONV_CHAT(conv)));
+	}
+	g_slist_free(yd->confs);
+
+	for (l = yd->cookies; l; l = l->next) {
+		g_free(l->data);
+		l->data=NULL;
+	}
+	g_slist_free(yd->cookies);
+
+	yd->chat_online = FALSE;
+	if (yd->in_chat)
+		yahoo_c_leave(gc, 1); /* 1 = YAHOO_CHAT_ID */
+
+	purple_timeout_remove(yd->yahoo_p2p_timer);
+	if(yd->yahoo_p2p_server_timeout_handle != 0) {
+		purple_timeout_remove(yd->yahoo_p2p_server_timeout_handle);
+		yd->yahoo_p2p_server_timeout_handle = 0;
+	}
+
+	/* close p2p server if it is waiting for a peer to connect */
+	if (yd->yahoo_p2p_server_watcher) {
+		purple_input_remove(yd->yahoo_p2p_server_watcher);
+		yd->yahoo_p2p_server_watcher = 0;
+	}
+	if (yd->yahoo_local_p2p_server_fd >= 0) {
+		close(yd->yahoo_local_p2p_server_fd);
+		yd->yahoo_local_p2p_server_fd = -1;
+	}
+
+	g_hash_table_destroy(yd->sms_carrier);
+	g_hash_table_destroy(yd->peers);
+	g_hash_table_destroy(yd->friends);
+	g_hash_table_destroy(yd->imvironments);
+	g_hash_table_destroy(yd->xfer_peer_idstring_map);
+	g_free(yd->chat_name);
+
+	g_free(yd->cookie_y);
+	g_free(yd->cookie_t);
+	g_free(yd->cookie_b);
+
+	if (yd->txhandler)
+		purple_input_remove(yd->txhandler);
+
+	purple_circ_buffer_destroy(yd->txbuf);
+
+	if (yd->fd >= 0)
+		close(yd->fd);
+
+	g_free(yd->rxqueue);
+	yd->rxlen = 0;
+	g_free(yd->picture_url);
+
+	if (yd->buddy_icon_connect_data)
+		purple_proxy_connect_cancel(yd->buddy_icon_connect_data);
+	if (yd->picture_upload_todo)
+		yahoo_buddy_icon_upload_data_free(yd->picture_upload_todo);
+	if (yd->ycht)
+		ycht_connection_close(yd->ycht);
+	if (yd->listen_data != NULL)
+		purple_network_listen_cancel(yd->listen_data);
+
+	g_free(yd->pending_chat_room);
+	g_free(yd->pending_chat_id);
+	g_free(yd->pending_chat_topic);
+	g_free(yd->pending_chat_goto);
+	g_strfreev(yd->profiles);
+
+	yahoo_personal_details_reset(&yd->ypd, TRUE);
+
+	g_free(yd->current_list15_grp);
+
+	g_free(yd);
+	gc->proto_data = NULL;
+}
+
+const char *yahoo_list_icon(PurpleAccount *a, PurpleBuddy *b)
+{
+	return "yahoo";
+}
+
+const char *yahoo_list_emblem(PurpleBuddy *b)
+{
+	PurpleAccount *account;
+	PurpleConnection *gc;
+	YahooFriend *f;
+	PurplePresence *presence;
+
+	if (!b || !(account = purple_buddy_get_account(b)) ||
+			!(gc = purple_account_get_connection(account)) ||
+			!gc->proto_data)
+		return NULL;
+
+	f = yahoo_friend_find(gc, purple_buddy_get_name(b));
+	if (!f) {
+		return "not-authorized";
+	}
+
+	presence = purple_buddy_get_presence(b);
+
+	if (purple_presence_is_online(presence)) {
+		if (yahoo_friend_get_game(f))
+			return "game";
+
+		if (f->fed)
+			return "external";
+	}
+	return NULL;
+}
+
+static const char *yahoo_get_status_string(enum yahoo_status a)
+{
+	switch (a) {
+	case YAHOO_STATUS_BRB:
+		return _("Be Right Back");
+	case YAHOO_STATUS_BUSY:
+		return _("Busy");
+	case YAHOO_STATUS_NOTATHOME:
+		return _("Not at Home");
+	case YAHOO_STATUS_NOTATDESK:
+		return _("Not at Desk");
+	case YAHOO_STATUS_NOTINOFFICE:
+		return _("Not in Office");
+	case YAHOO_STATUS_ONPHONE:
+		return _("On the Phone");
+	case YAHOO_STATUS_ONVACATION:
+		return _("On Vacation");
+	case YAHOO_STATUS_OUTTOLUNCH:
+		return _("Out to Lunch");
+	case YAHOO_STATUS_STEPPEDOUT:
+		return _("Stepped Out");
+	case YAHOO_STATUS_INVISIBLE:
+		return _("Invisible");
+	case YAHOO_STATUS_IDLE:
+		return _("Idle");
+	case YAHOO_STATUS_OFFLINE:
+		return _("Offline");
+	default:
+		return _("Available");
+	}
+}
+
+static void yahoo_initiate_conference(PurpleBlistNode *node, gpointer data) {
+
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+
+	GHashTable *components;
+	YahooData *yd;
+	int id;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy *) node;
+	gc = purple_account_get_connection(purple_buddy_get_account(buddy));
+	yd = gc->proto_data;
+	id = yd->conf_id;
+
+	components = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+	g_hash_table_replace(components, g_strdup("room"),
+		g_strdup_printf("%s-%d", purple_connection_get_display_name(gc), id));
+	g_hash_table_replace(components, g_strdup("topic"), g_strdup("Join my conference..."));
+	g_hash_table_replace(components, g_strdup("type"), g_strdup("Conference"));
+	yahoo_c_join(gc, components);
+	g_hash_table_destroy(components);
+
+	yahoo_c_invite(gc, id, "Join my conference...", purple_buddy_get_name(buddy));
+}
+
+static void yahoo_presence_settings(PurpleBlistNode *node, gpointer data) {
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+	int presence_val = GPOINTER_TO_INT(data);
+
+	buddy = (PurpleBuddy *) node;
+	gc = purple_account_get_connection(purple_buddy_get_account(buddy));
+
+	yahoo_friend_update_presence(gc, purple_buddy_get_name(buddy), presence_val);
+}
+
+static void yahoo_game(PurpleBlistNode *node, gpointer data) {
+
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+
+	const char *game;
+	char *game2;
+	char *t;
+	char url[256];
+	YahooFriend *f;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy *) node;
+	gc = purple_account_get_connection(purple_buddy_get_account(buddy));
+
+	f = yahoo_friend_find(gc, purple_buddy_get_name(buddy));
+	if (!f)
+		return;
+
+	game = yahoo_friend_get_game(f);
+	if (!game)
+		return;
+
+	t = game2 = g_strdup(strstr(game, "ante?room="));
+	while (*t && *t != '\t')
+		t++;
+	*t = 0;
+	g_snprintf(url, sizeof url, "http://games.yahoo.com/games/%s", game2);
+	purple_notify_uri(gc, url);
+	g_free(game2);
+}
+
+char *yahoo_status_text(PurpleBuddy *b)
+{
+	YahooFriend *f = NULL;
+	const char *msg;
+	char *msg2;
+	PurpleAccount *account;
+	PurpleConnection *gc;
+
+	account = purple_buddy_get_account(b);
+	gc = purple_account_get_connection(account);
+	if (!gc || !purple_connection_get_protocol_data(gc))
+		return NULL;
+
+	f = yahoo_friend_find(gc, purple_buddy_get_name(b));
+	if (!f)
+		return g_strdup(_("Not on server list"));
+
+	switch (f->status) {
+	case YAHOO_STATUS_AVAILABLE:
+		return NULL;
+	case YAHOO_STATUS_IDLE:
+		if (f->idle == -1)
+			return g_strdup(yahoo_get_status_string(f->status));
+		return NULL;
+	case YAHOO_STATUS_CUSTOM:
+		if (!(msg = yahoo_friend_get_status_message(f)))
+			return NULL;
+		msg2 = g_markup_escape_text(msg, strlen(msg));
+		purple_util_chrreplace(msg2, '\n', ' ');
+		return msg2;
+
+	default:
+		return g_strdup(yahoo_get_status_string(f->status));
+	}
+}
+
+void yahoo_tooltip_text(PurpleBuddy *b, PurpleNotifyUserInfo *user_info, gboolean full)
+{
+	YahooFriend *f;
+	char *status = NULL;
+	const char *presence = NULL;
+	PurpleAccount *account;
+
+	account = purple_buddy_get_account(b);
+	f = yahoo_friend_find(purple_account_get_connection(account), purple_buddy_get_name(b));
+	if (!f)
+		status = g_strdup_printf("\n%s", _("Not on server list"));
+	else {
+		switch (f->status) {
+		case YAHOO_STATUS_CUSTOM:
+			if (!yahoo_friend_get_status_message(f))
+				return;
+			status = g_strdup(yahoo_friend_get_status_message(f));
+			break;
+		case YAHOO_STATUS_OFFLINE:
+			break;
+		default:
+			status = g_strdup(yahoo_get_status_string(f->status));
+			break;
+		}
+
+		switch (f->presence) {
+			case YAHOO_PRESENCE_ONLINE:
+				presence = _("Appear Online");
+				break;
+			case YAHOO_PRESENCE_PERM_OFFLINE:
+				presence = _("Appear Permanently Offline");
+				break;
+			case YAHOO_PRESENCE_DEFAULT:
+				break;
+			default:
+				purple_debug_error("yahoo", "Unknown presence in yahoo_tooltip_text\n");
+				break;
+		}
+	}
+
+	if (status != NULL) {
+		purple_notify_user_info_add_pair_plaintext(user_info, _("Status"), status);
+		g_free(status);
+	}
+
+	if (presence != NULL)
+		purple_notify_user_info_add_pair_plaintext(user_info, _("Presence"), presence);
+
+	if (f && full) {
+		YahooPersonalDetails *ypd = &f->ypd;
+		int i;
+		struct {
+			char *id;
+			char *text;
+			char *value;
+		} yfields[] = {
+			{"hp", N_("Home Phone Number"), ypd->phone.home},
+			{"wp", N_("Work Phone Number"), ypd->phone.work},
+			{"mo", N_("Mobile Phone Number"), ypd->phone.mobile},
+			{NULL, NULL, NULL}
+		};
+		for (i = 0; yfields[i].id; i++) {
+			if (!yfields[i].value || !*yfields[i].value)
+				continue;
+			purple_notify_user_info_add_pair(user_info, _(yfields[i].text), yfields[i].value);
+		}
+	}
+}
+
+static void yahoo_addbuddyfrommenu_cb(PurpleBlistNode *node, gpointer data)
+{
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy *) node;
+	gc = purple_account_get_connection(purple_buddy_get_account(buddy));
+
+	yahoo_add_buddy(gc, buddy, NULL);
+}
+
+
+static void yahoo_chat_goto_menu(PurpleBlistNode *node, gpointer data)
+{
+	PurpleBuddy *buddy;
+	PurpleConnection *gc;
+
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY(node));
+
+	buddy = (PurpleBuddy *) node;
+	gc = purple_account_get_connection(purple_buddy_get_account(buddy));
+
+	yahoo_chat_goto(gc, purple_buddy_get_name(buddy));
+}
+
+static GList *build_presence_submenu(YahooFriend *f, PurpleConnection *gc) {
+	GList *m = NULL;
+	PurpleMenuAction *act;
+	YahooData *yd = (YahooData *) gc->proto_data;
+
+	if (yd->current_status == YAHOO_STATUS_INVISIBLE) {
+		if (f->presence != YAHOO_PRESENCE_ONLINE) {
+			act = purple_menu_action_new(_("Appear Online"),
+			                           PURPLE_CALLBACK(yahoo_presence_settings),
+			                           GINT_TO_POINTER(YAHOO_PRESENCE_ONLINE),
+			                           NULL);
+			m = g_list_append(m, act);
+		} else if (f->presence != YAHOO_PRESENCE_DEFAULT) {
+			act = purple_menu_action_new(_("Appear Offline"),
+			                           PURPLE_CALLBACK(yahoo_presence_settings),
+			                           GINT_TO_POINTER(YAHOO_PRESENCE_DEFAULT),
+			                           NULL);
+			m = g_list_append(m, act);
+		}
+	}
+
+	if (f->presence == YAHOO_PRESENCE_PERM_OFFLINE) {
+		act = purple_menu_action_new(_("Don't Appear Permanently Offline"),
+		                           PURPLE_CALLBACK(yahoo_presence_settings),
+		                           GINT_TO_POINTER(YAHOO_PRESENCE_DEFAULT),
+		                           NULL);
+		m = g_list_append(m, act);
+	} else {
+		act = purple_menu_action_new(_("Appear Permanently Offline"),
+		                           PURPLE_CALLBACK(yahoo_presence_settings),
+		                           GINT_TO_POINTER(YAHOO_PRESENCE_PERM_OFFLINE),
+		                           NULL);
+		m = g_list_append(m, act);
+	}
+
+	return m;
+}
+
+static void yahoo_doodle_blist_node(PurpleBlistNode *node, gpointer data)
+{
+	PurpleBuddy *b = (PurpleBuddy *)node;
+	PurpleAccount *account = purple_buddy_get_account(b);
+	PurpleConnection *gc = purple_account_get_connection(account);
+
+	yahoo_doodle_initiate(gc, purple_buddy_get_name(b));
+}
+
+static void
+yahoo_userinfo_blist_node(PurpleBlistNode *node, gpointer data)
+{
+	PurpleBuddy *b = (PurpleBuddy *)node;
+	PurpleAccount *account = purple_buddy_get_account(b);
+	PurpleConnection *gc = purple_account_get_connection(account);
+
+	yahoo_set_userinfo_for_buddy(gc, b);
+}
+
+static GList *yahoo_buddy_menu(PurpleBuddy *buddy)
+{
+	GList *m = NULL;
+	PurpleMenuAction *act;
+
+	PurpleConnection *gc = purple_account_get_connection(purple_buddy_get_account(buddy));
+	YahooData *yd = gc->proto_data;
+	static char buf2[1024];
+	YahooFriend *f;
+
+	f = yahoo_friend_find(gc, purple_buddy_get_name(buddy));
+
+	if (!f && !yd->wm) {
+		act = purple_menu_action_new(_("Add Buddy"),
+		                           PURPLE_CALLBACK(yahoo_addbuddyfrommenu_cb),
+		                           NULL, NULL);
+		m = g_list_append(m, act);
+
+		return m;
+
+	}
+
+	if (f && f->status != YAHOO_STATUS_OFFLINE && f->fed == YAHOO_FEDERATION_NONE) {
+		if (!yd->wm) {
+			act = purple_menu_action_new(_("Join in Chat"),
+			                           PURPLE_CALLBACK(yahoo_chat_goto_menu),
+			                           NULL, NULL);
+			m = g_list_append(m, act);
+		}
+
+		act = purple_menu_action_new(_("Initiate Conference"),
+		                           PURPLE_CALLBACK(yahoo_initiate_conference),
+		                           NULL, NULL);
+		m = g_list_append(m, act);
+
+		if (yahoo_friend_get_game(f)) {
+			const char *game = yahoo_friend_get_game(f);
+			char *room;
+			char *t;
+
+			if ((room = strstr(game, "&follow="))) {/* skip ahead to the url */
+				while (*room && *room != '\t')          /* skip to the tab */
+					room++;
+				t = room++;                             /* room as now at the name */
+				while (*t != '\n')
+					t++;                            /* replace the \n with a space */
+				*t = ' ';
+				g_snprintf(buf2, sizeof buf2, "%s", room);
+
+				act = purple_menu_action_new(buf2,
+				                           PURPLE_CALLBACK(yahoo_game),
+				                           NULL, NULL);
+				m = g_list_append(m, act);
+			}
+		}
+	}
+
+	if (f) {
+		act = purple_menu_action_new(_("Presence Settings"), NULL, NULL,
+		                           build_presence_submenu(f, gc));
+		m = g_list_append(m, act);
+
+		if (f->fed == YAHOO_FEDERATION_NONE) {
+			act = purple_menu_action_new(_("Start Doodling"),
+					PURPLE_CALLBACK(yahoo_doodle_blist_node),
+					NULL, NULL);
+			m = g_list_append(m, act);
+		}
+
+		act = purple_menu_action_new(_("Set User Info..."),
+		                           PURPLE_CALLBACK(yahoo_userinfo_blist_node),
+		                           NULL, NULL);
+		m = g_list_append(m, act);
+	}
+
+	return m;
+}
+
+GList *yahoo_blist_node_menu(PurpleBlistNode *node)
+{
+	if(PURPLE_BLIST_NODE_IS_BUDDY(node)) {
+		return yahoo_buddy_menu((PurpleBuddy *) node);
+	} else {
+		return NULL;
+	}
+}
+
+static void yahoo_act_id(PurpleConnection *gc, PurpleRequestFields *fields)
+{
+	YahooData *yd = gc->proto_data;
+	const char *name = yd->profiles[purple_request_fields_get_choice(fields, "id")];
+
+	struct yahoo_packet *pkt = yahoo_packet_new(YAHOO_SERVICE_IDACT, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash_str(pkt, 3, name);
+	yahoo_packet_send_and_free(pkt, yd);
+
+	purple_connection_set_display_name(gc, name);
+}
+
+static void
+yahoo_get_inbox_token_cb(PurpleUtilFetchUrlData *url_data, gpointer user_data,
+		const gchar *token, size_t len, const gchar *error_message)
+{
+	PurpleConnection *gc = user_data;
+	gboolean set_cookie = FALSE;
+	gchar *url;
+	YahooData *yd = gc->proto_data;
+
+	g_return_if_fail(PURPLE_CONNECTION_IS_VALID(gc));
+
+	yd->url_datas = g_slist_remove(yd->url_datas, url_data);
+
+	if (error_message != NULL)
+		purple_debug_error("yahoo", "Requesting mail login token failed: %s\n", error_message);
+	else if (len > 0 && token && *token) {
+	 	/* Should we not be hardcoding the rd url? */
+		url = g_strdup_printf(
+			"http://login.yahoo.com/config/reset_cookies_token?"
+			".token=%s"
+			"&.done=http://us.rd.yahoo.com/messenger/client/%%3fhttp://mail.yahoo.com/",
+			token);
+		set_cookie = TRUE;
+	}
+
+	if (!set_cookie) {
+		purple_debug_error("yahoo", "No mail login token; forwarding to login screen.\n");
+		url = g_strdup(yd->jp ? YAHOOJP_MAIL_URL : YAHOO_MAIL_URL);
+	}
+
+	/* Open the mailbox with the parsed url data */
+	purple_notify_uri(gc, url);
+
+	g_free(url);
+}
+
+
+static void yahoo_show_inbox(PurplePluginAction *action)
+{
+	/* Setup a cookie that can be used by the browser */
+	/* XXX I have no idea how this will work with Yahoo! Japan. */
+
+	PurpleConnection *gc = action->context;
+	YahooData *yd = gc->proto_data;
+
+	PurpleUtilFetchUrlData *url_data;
+	const char* base_url = "http://login.yahoo.com";
+	/* use whole URL if using HTTP Proxy */
+	gboolean use_whole_url = yahoo_account_use_http_proxy(gc);
+	gchar *request = g_strdup_printf(
+		"POST %s/config/cookie_token HTTP/1.0\r\n"
+		"Cookie: T=%s; path=/; domain=.yahoo.com; Y=%s;\r\n"
+		"User-Agent: " YAHOO_CLIENT_USERAGENT "\r\n"
+		"Host: login.yahoo.com\r\n"
+		"Content-Length: 0\r\n\r\n",
+		use_whole_url ? base_url : "",
+		yd->cookie_t, yd->cookie_y);
+
+	url_data = purple_util_fetch_url_request_len_with_account(
+			purple_connection_get_account(gc), base_url, use_whole_url,
+			YAHOO_CLIENT_USERAGENT, TRUE, request, FALSE, -1,
+			yahoo_get_inbox_token_cb, gc);
+
+	g_free(request);
+
+	if (url_data != NULL)
+		yd->url_datas = g_slist_prepend(yd->url_datas, url_data);
+	else {
+		const char *yahoo_mail_url = (yd->jp ? YAHOOJP_MAIL_URL : YAHOO_MAIL_URL);
+		purple_debug_error("yahoo",
+				   "Unable to request mail login token; forwarding to login screen.");
+		purple_notify_uri(gc, yahoo_mail_url);
+	}
+}
+
+static void
+yahoo_set_userinfo_fn(PurplePluginAction *action)
+{
+	yahoo_set_userinfo(action->context);
+}
+
+static void yahoo_show_act_id(PurplePluginAction *action)
+{
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *group;
+	PurpleRequestField *field;
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	YahooData *yd = purple_connection_get_protocol_data(gc);
+	const char *name = purple_connection_get_display_name(gc);
+	int iter;
+
+	fields = purple_request_fields_new();
+	group = purple_request_field_group_new(NULL);
+	purple_request_fields_add_group(fields, group);
+	field = purple_request_field_choice_new("id", _("Activate which ID?"), 0);
+	purple_request_field_group_add_field(group, field);
+
+	for (iter = 0; yd->profiles[iter]; iter++) {
+		purple_request_field_choice_add(field, yd->profiles[iter]);
+		if (purple_strequal(yd->profiles[iter], name))
+			purple_request_field_choice_set_default_value(field, iter);
+	}
+
+	purple_request_fields(gc, NULL, _("Select the ID you want to activate"), NULL,
+					   fields,
+					   _("OK"), G_CALLBACK(yahoo_act_id),
+					   _("Cancel"), NULL,
+					   purple_connection_get_account(gc), NULL, NULL,
+					   gc);
+}
+
+static void yahoo_show_chat_goto(PurplePluginAction *action)
+{
+	PurpleConnection *gc = (PurpleConnection *) action->context;
+	purple_request_input(gc, NULL, _("Join whom in chat?"), NULL,
+					   "", FALSE, FALSE, NULL,
+					   _("OK"), G_CALLBACK(yahoo_chat_goto),
+					   _("Cancel"), NULL,
+					   purple_connection_get_account(gc), NULL, NULL,
+					   gc);
+}
+
+GList *yahoo_actions(PurplePlugin *plugin, gpointer context) {
+	GList *m = NULL;
+	PurplePluginAction *act;
+
+	act = purple_plugin_action_new(_("Set User Info..."),
+			yahoo_set_userinfo_fn);
+	m = g_list_append(m, act);
+
+	act = purple_plugin_action_new(_("Activate ID..."),
+			yahoo_show_act_id);
+	m = g_list_append(m, act);
+
+	act = purple_plugin_action_new(_("Join User in Chat..."),
+			yahoo_show_chat_goto);
+	m = g_list_append(m, act);
+
+	m = g_list_append(m, NULL);
+	act = purple_plugin_action_new(_("Open Inbox"),
+			yahoo_show_inbox);
+	m = g_list_append(m, act);
+
+	return m;
+}
+
+struct yahoo_sms_carrier_cb_data	{
+	PurpleConnection *gc;
+	char *who;
+	char *what;
+};
+
+static void yahoo_get_sms_carrier_cb(PurpleUtilFetchUrlData *url_data, gpointer user_data,
+		const gchar *webdata, size_t len, const gchar *error_message)
+{
+	struct yahoo_sms_carrier_cb_data *sms_cb_data = user_data;
+	PurpleConnection *gc = sms_cb_data->gc;
+	YahooData *yd = gc->proto_data;
+	char *status = NULL;
+	char *carrier = NULL;
+	PurpleAccount *account = purple_connection_get_account(gc);
+	PurpleConversation *conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, sms_cb_data->who, account);
+
+	yd->url_datas = g_slist_remove(yd->url_datas, url_data);
+
+	if (error_message != NULL) {
+		purple_conversation_write(conv, NULL, _("Can't send SMS. Unable to obtain mobile carrier."), PURPLE_MESSAGE_SYSTEM, time(NULL));
+
+		g_free(sms_cb_data->who);
+		g_free(sms_cb_data->what);
+		g_free(sms_cb_data);
+		return ;
+	}
+	else if (len > 0 && webdata && *webdata) {
+		xmlnode *validate_data_root = xmlnode_from_str(webdata, -1);
+		xmlnode *validate_data_child = xmlnode_get_child(validate_data_root, "mobile_no");
+		const char *mobile_no = xmlnode_get_attrib(validate_data_child, "msisdn");
+
+		validate_data_root = xmlnode_copy(validate_data_child);
+		validate_data_child = xmlnode_get_child(validate_data_root, "status");
+		status = xmlnode_get_data(validate_data_child);
+
+		validate_data_child = xmlnode_get_child(validate_data_root, "carrier");
+		carrier = xmlnode_get_data(validate_data_child);
+
+		purple_debug_info("yahoo", "SMS validate data: %s\n", webdata);
+
+		if (status && g_str_equal(status, "Valid")) {
+			g_hash_table_insert(yd->sms_carrier,
+					g_strdup_printf("+%s", mobile_no), g_strdup(carrier));
+			yahoo_send_im(sms_cb_data->gc, sms_cb_data->who,
+					sms_cb_data->what, PURPLE_MESSAGE_SEND);
+		} else {
+			g_hash_table_insert(yd->sms_carrier,
+					g_strdup_printf("+%s", mobile_no), g_strdup("Unknown"));
+			purple_conversation_write(conv, NULL,
+					_("Can't send SMS. Unknown mobile carrier."),
+					PURPLE_MESSAGE_SYSTEM, time(NULL));
+		}
+
+		xmlnode_free(validate_data_child);
+		xmlnode_free(validate_data_root);
+		g_free(sms_cb_data->who);
+		g_free(sms_cb_data->what);
+		g_free(sms_cb_data);
+		g_free(status);
+		g_free(carrier);
+	}
+}
+
+static void yahoo_get_sms_carrier(PurpleConnection *gc, gpointer data)
+{
+	YahooData *yd = gc->proto_data;
+	PurpleUtilFetchUrlData *url_data;
+	struct yahoo_sms_carrier_cb_data *sms_cb_data;
+	char *validate_request_str = NULL;
+	char *request = NULL;
+	gboolean use_whole_url = FALSE;
+	xmlnode *validate_request_root = NULL;
+	xmlnode *validate_request_child = NULL;
+
+	if(!(sms_cb_data = data))
+		return;
+
+	validate_request_root = xmlnode_new("validate");
+	xmlnode_set_attrib(validate_request_root, "intl", "us");
+	xmlnode_set_attrib(validate_request_root, "version", YAHOO_CLIENT_VERSION);
+	xmlnode_set_attrib(validate_request_root, "qos", "0");
+
+	validate_request_child = xmlnode_new_child(validate_request_root, "mobile_no");
+	xmlnode_set_attrib(validate_request_child, "msisdn", sms_cb_data->who + 1);
+
+	validate_request_str = xmlnode_to_str(validate_request_root, NULL);
+
+	xmlnode_free(validate_request_child);
+	xmlnode_free(validate_request_root);
+
+	request = g_strdup_printf(
+		"POST /mobileno?intl=us&version=%s HTTP/1.1\r\n"
+		"Cookie: T=%s; path=/; domain=.yahoo.com; Y=%s; path=/; domain=.yahoo.com;\r\n"
+		"User-Agent: " YAHOO_CLIENT_USERAGENT "\r\n"
+		"Host: validate.msg.yahoo.com\r\n"
+		"Content-Length: %" G_GSIZE_FORMAT "\r\n"
+		"Cache-Control: no-cache\r\n\r\n%s",
+		YAHOO_CLIENT_VERSION, yd->cookie_t, yd->cookie_y, strlen(validate_request_str), validate_request_str);
+
+	/* use whole URL if using HTTP Proxy */
+	if ((gc->account->proxy_info) && (gc->account->proxy_info->type == PURPLE_PROXY_HTTP))
+	    use_whole_url = TRUE;
+
+	url_data = purple_util_fetch_url_request_len_with_account(
+			purple_connection_get_account(gc), YAHOO_SMS_CARRIER_URL, use_whole_url,
+			YAHOO_CLIENT_USERAGENT, TRUE, request, FALSE, -1,
+			yahoo_get_sms_carrier_cb, data);
+
+	g_free(request);
+	g_free(validate_request_str);
+
+	if (url_data)
+		yd->url_datas = g_slist_prepend(yd->url_datas, url_data);
+	else {
+		PurpleAccount *account = purple_connection_get_account(gc);
+		PurpleConversation *conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, sms_cb_data->who, account);
+		purple_conversation_write(conv, NULL, _("Can't send SMS. Unable to obtain mobile carrier."), PURPLE_MESSAGE_SYSTEM, time(NULL));
+		g_free(sms_cb_data->who);
+		g_free(sms_cb_data->what);
+		g_free(sms_cb_data);
+	}
+}
+
+int yahoo_send_im(PurpleConnection *gc, const char *who, const char *what, PurpleMessageFlags flags)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt = NULL;
+	char *msg = yahoo_html_to_codes(what);
+	char *msg2;
+	gboolean utf8 = TRUE;
+	PurpleWhiteboard *wb;
+	int ret = 1;
+	const char *fed_who;
+	gsize lenb = 0;
+	glong lenc = 0;
+	struct yahoo_p2p_data *p2p_data;
+	YahooFederation fed = YAHOO_FEDERATION_NONE;
+	msg2 = yahoo_string_encode(gc, msg, &utf8);
+
+	if(msg2) {
+		lenb = strlen(msg2);
+		lenc = g_utf8_strlen(msg2, -1);
+
+		if(lenb > YAHOO_MAX_MESSAGE_LENGTH_BYTES || lenc > YAHOO_MAX_MESSAGE_LENGTH_CHARS) {
+			purple_debug_info("yahoo", "Message too big.  Length is %" G_GSIZE_FORMAT
+					" bytes, %ld characters.  Max is %d bytes, %d chars."
+					"  Message is '%s'.\n", lenb, lenc, YAHOO_MAX_MESSAGE_LENGTH_BYTES,
+					YAHOO_MAX_MESSAGE_LENGTH_CHARS, msg2);
+			g_free(msg);
+			g_free(msg2);
+			return -E2BIG;
+		}
+	}
+
+	fed = yahoo_get_federation_from_name(who);
+
+	if (who[0] == '+') {
+		/* we have an sms to be sent */
+		gchar *carrier = NULL;
+		const char *alias = NULL;
+		PurpleAccount *account = purple_connection_get_account(gc);
+		PurpleConversation *conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, who, account);
+
+		carrier = g_hash_table_lookup(yd->sms_carrier, who);
+		if (!carrier) {
+			struct yahoo_sms_carrier_cb_data *sms_cb_data;
+			sms_cb_data = g_malloc(sizeof(struct yahoo_sms_carrier_cb_data));
+			sms_cb_data->gc = gc;
+			sms_cb_data->who = g_strdup(who);
+			sms_cb_data->what = g_strdup(what);
+
+			purple_conversation_write(conv, NULL, _("Getting mobile carrier to send the SMS."), PURPLE_MESSAGE_SYSTEM, time(NULL));
+
+			yahoo_get_sms_carrier(gc, sms_cb_data);
+
+			g_free(msg);
+			g_free(msg2);
+			return ret;
+		}
+		else if( strcmp(carrier,"Unknown") == 0 ) {
+			purple_conversation_write(conv, NULL, _("Can't send SMS. Unknown mobile carrier."), PURPLE_MESSAGE_SYSTEM, time(NULL));
+
+			g_free(msg);
+			g_free(msg2);
+			return -1;
+		}
+
+		alias = purple_account_get_alias(account);
+		pkt = yahoo_packet_new(YAHOO_SERVICE_SMS_MSG, YAHOO_STATUS_AVAILABLE, yd->session_id);
+		yahoo_packet_hash(pkt, "sssss",
+			1, purple_connection_get_display_name(gc),
+			69, alias,
+			5, who + 1,
+			68, carrier,
+			14, msg2);
+		yahoo_packet_send_and_free(pkt, yd);
+
+		g_free(msg);
+		g_free(msg2);
+
+		return ret;
+	}
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_MESSAGE, YAHOO_STATUS_OFFLINE, yd->session_id);
+	fed_who = who;
+	switch (fed) {
+		case YAHOO_FEDERATION_MSN:
+		case YAHOO_FEDERATION_OCS:
+		case YAHOO_FEDERATION_IBM:
+		case YAHOO_FEDERATION_PBX:
+			fed_who += 4;
+			break;
+		case YAHOO_FEDERATION_NONE:
+		default:
+			break;
+	}
+	yahoo_packet_hash(pkt, "ss", 1, purple_connection_get_display_name(gc), 5, fed_who);
+	if (fed)
+		yahoo_packet_hash_int(pkt, 241, fed);
+
+	if (utf8)
+		yahoo_packet_hash_str(pkt, 97, "1");
+	yahoo_packet_hash_str(pkt, 14, msg2);
+
+	/*
+	 * IMVironment.
+	 *
+	 * If this message is to a user who is also Doodling with the local user,
+	 * format the chat packet with the correct IMV information (thanks Yahoo!)
+	 *
+	 * Otherwise attempt to use the same IMVironment as the remote user,
+	 * just so that we don't inadvertantly reset their IMVironment back
+	 * to nothing.
+	 *
+	 * If they have not set an IMVironment, then use the default.
+	 */
+	wb = purple_whiteboard_get_session(gc->account, who);
+	if (wb)
+		yahoo_packet_hash_str(pkt, 63, DOODLE_IMV_KEY);
+	else
+	{
+		const char *imv;
+		imv = g_hash_table_lookup(yd->imvironments, who);
+		if (imv != NULL)
+			yahoo_packet_hash_str(pkt, 63, imv);
+		else
+			yahoo_packet_hash_str(pkt, 63, ";0");
+	}
+
+	yahoo_packet_hash_str(pkt,   64, "0"); /* no idea */
+	yahoo_packet_hash_str(pkt, 1002, "1"); /* no idea, Yahoo 6 or later only it seems */
+	if (!yd->picture_url)
+		yahoo_packet_hash_str(pkt, 206, "0"); /* 0 = no picture, 2 = picture, maybe 1 = avatar? */
+	else
+		yahoo_packet_hash_str(pkt, 206, "2");
+
+	/* We may need to not send any packets over 2000 bytes, but I'm not sure yet. */
+	if ((YAHOO_PACKET_HDRLEN + yahoo_packet_length(pkt)) <= 2000) {
+		/* if p2p link exists, send through it. To-do: key 15, time value to be sent in case of p2p */
+		if( (p2p_data = g_hash_table_lookup(yd->peers, who)) && !fed) {
+			yahoo_packet_hash_int(pkt, 11, p2p_data->session_id);
+			yahoo_p2p_write_pkt(p2p_data->source, pkt);
+		}
+		else	{
+			yahoo_packet_send(pkt, yd);
+			if(!fed)
+				yahoo_send_p2p_pkt(gc, who, 0);		/* send p2p packet, with val_13=0 */
+		}
+	}
+	else
+		ret = -E2BIG;
+
+	yahoo_packet_free(pkt);
+
+	g_free(msg);
+	g_free(msg2);
+
+	return ret;
+}
+
+unsigned int yahoo_send_typing(PurpleConnection *gc, const char *who, PurpleTypingState state)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_p2p_data *p2p_data;
+	YahooFederation fed = YAHOO_FEDERATION_NONE;
+	struct yahoo_packet *pkt = NULL;
+
+	fed = yahoo_get_federation_from_name(who);
+
+	/* Don't do anything if sms is being typed */
+	if( strncmp(who, "+", 1) == 0 )
+		return 0;
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_NOTIFY, YAHOO_STATUS_TYPING, yd->session_id);
+
+	/* check to see if p2p link exists, send through it */
+	if( (p2p_data = g_hash_table_lookup(yd->peers, who)) && !fed) {
+		yahoo_packet_hash(pkt, "sssssis", 49, "TYPING", 1, purple_connection_get_display_name(gc),
+	                  14, " ", 13, state == PURPLE_TYPING ? "1" : "0",
+	                  5, who, 11, p2p_data->session_id, 1002, "1");	/* To-do: key 15 to be sent in case of p2p */
+		yahoo_p2p_write_pkt(p2p_data->source, pkt);
+		yahoo_packet_free(pkt);
+	}
+	else	{	/* send through yahoo server */
+
+		const char *fed_who = who;
+		switch (fed) {
+			case YAHOO_FEDERATION_MSN:
+			case YAHOO_FEDERATION_OCS:
+			case YAHOO_FEDERATION_IBM:
+			case YAHOO_FEDERATION_PBX:
+				fed_who += 4;
+				break;
+			case YAHOO_FEDERATION_NONE:
+			default:
+				break;
+		}
+
+		yahoo_packet_hash(pkt, "ssssss", 49, "TYPING", 1, purple_connection_get_display_name(gc),
+                  14, " ", 13, state == PURPLE_TYPING ? "1" : "0",
+                  5, fed_who, 1002, "1");
+        if (fed)
+        	yahoo_packet_hash_int(pkt, 241, fed);
+		yahoo_packet_send_and_free(pkt, yd);
+	}
+
+	return 0;
+}
+
+static void yahoo_session_presence_remove(gpointer key, gpointer value, gpointer data)
+{
+	YahooFriend *f = value;
+	if (f && f->presence == YAHOO_PRESENCE_ONLINE)
+		f->presence = YAHOO_PRESENCE_DEFAULT;
+}
+
+void yahoo_set_status(PurpleAccount *account, PurpleStatus *status)
+{
+	PurpleConnection *gc;
+	PurplePresence *presence;
+	YahooData *yd;
+	struct yahoo_packet *pkt;
+	int old_status;
+	const char *msg = NULL;
+	char *tmp = NULL;
+	char *conv_msg = NULL;
+	gboolean utf8 = TRUE;
+
+	if (!purple_status_is_active(status))
+		return;
+
+	gc = purple_account_get_connection(account);
+	presence = purple_status_get_presence(status);
+	yd = (YahooData *)gc->proto_data;
+	old_status = yd->current_status;
+
+	yd->current_status = get_yahoo_status_from_purple_status(status);
+
+	if (yd->current_status == YAHOO_STATUS_CUSTOM)
+	{
+		msg = purple_status_get_attr_string(status, "message");
+
+		if (purple_status_is_available(status)) {
+			tmp = yahoo_string_encode(gc, msg, &utf8);
+			conv_msg = purple_markup_strip_html(tmp);
+			g_free(tmp);
+		} else {
+			if ((msg == NULL) || (*msg == '\0'))
+				msg = _("Away");
+			tmp = yahoo_string_encode(gc, msg, &utf8);
+			conv_msg = purple_markup_strip_html(tmp);
+			g_free(tmp);
+		}
+	}
+
+	if (yd->current_status == YAHOO_STATUS_INVISIBLE) {
+		pkt = yahoo_packet_new(YAHOO_SERVICE_Y6_VISIBLE_TOGGLE, YAHOO_STATUS_AVAILABLE, yd->session_id);
+		yahoo_packet_hash_str(pkt, 13, "2");
+		yahoo_packet_send_and_free(pkt, yd);
+
+		return;
+	}
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_Y6_STATUS_UPDATE, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash_int(pkt, 10, yd->current_status);
+
+	if (yd->current_status == YAHOO_STATUS_CUSTOM) {
+		yahoo_packet_hash_str(pkt, 97, utf8 ? "1" : 0);
+		yahoo_packet_hash_str(pkt, 19, conv_msg);
+	} else {
+		yahoo_packet_hash_str(pkt, 19, "");
+	}
+
+	g_free(conv_msg);
+
+	if (purple_presence_is_idle(presence))
+		yahoo_packet_hash_str(pkt, 47, "2");
+	else	{
+		if (!purple_status_is_available(status))
+			yahoo_packet_hash_str(pkt, 47, "1");
+		else
+			yahoo_packet_hash_str(pkt, 47, "0");
+	}
+
+	yahoo_packet_send_and_free(pkt, yd);
+
+	if (old_status == YAHOO_STATUS_INVISIBLE) {
+		pkt = yahoo_packet_new(YAHOO_SERVICE_Y6_VISIBLE_TOGGLE, YAHOO_STATUS_AVAILABLE, yd->session_id);
+		yahoo_packet_hash_str(pkt, 13, "1");
+		yahoo_packet_send_and_free(pkt, yd);
+
+		/* Any per-session presence settings are removed */
+		g_hash_table_foreach(yd->friends, yahoo_session_presence_remove, NULL);
+
+	}
+}
+
+void yahoo_set_idle(PurpleConnection *gc, int idle)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt = NULL;
+	char *msg = NULL, *msg2 = NULL;
+	PurpleStatus *status = NULL;
+	gboolean invisible = FALSE;
+
+	if (idle && yd->current_status != YAHOO_STATUS_CUSTOM)
+		yd->current_status = YAHOO_STATUS_IDLE;
+	else if (!idle && yd->current_status == YAHOO_STATUS_IDLE) {
+		status = purple_presence_get_active_status(purple_account_get_presence(purple_connection_get_account(gc)));
+		yd->current_status = get_yahoo_status_from_purple_status(status);
+	}
+
+	invisible = (yd->current_status == YAHOO_STATUS_INVISIBLE);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_Y6_STATUS_UPDATE, YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	if (!idle && invisible)
+		yahoo_packet_hash_int(pkt, 10, YAHOO_STATUS_AVAILABLE);
+	else
+		yahoo_packet_hash_int(pkt, 10, yd->current_status);
+
+	if (yd->current_status == YAHOO_STATUS_CUSTOM) {
+		const char *tmp;
+		if (status == NULL)
+			status = purple_presence_get_active_status(purple_account_get_presence(purple_connection_get_account(gc)));
+		tmp = purple_status_get_attr_string(status, "message");
+		if (tmp != NULL) {
+			gboolean utf8 = TRUE;
+			msg = yahoo_string_encode(gc, tmp, &utf8);
+			msg2 = purple_markup_strip_html(msg);
+			yahoo_packet_hash_str(pkt, 97, utf8 ? "1" : 0);
+			yahoo_packet_hash_str(pkt, 19, msg2);
+		} else {
+			/* get_yahoo_status_from_purple_status() returns YAHOO_STATUS_CUSTOM for
+			 * the generic away state (YAHOO_STATUS_TYPE_AWAY) with no message */
+			yahoo_packet_hash_str(pkt, 19, _("Away"));
+		}
+	} else {
+		yahoo_packet_hash_str(pkt, 19, "");
+	}
+
+	if (idle)
+		yahoo_packet_hash_str(pkt, 47, "2");
+	else if (yd->current_status == YAHOO_STATUS_CUSTOM &&
+			!purple_status_is_available(status))
+		/* We are still unavailable in this case.
+		 * Make sure Yahoo knows that */
+		yahoo_packet_hash_str(pkt, 47, "1");
+
+	yahoo_packet_send_and_free(pkt, yd);
+
+	g_free(msg);
+	g_free(msg2);
+}
+
+GList *yahoo_status_types(PurpleAccount *account)
+{
+	PurpleStatusType *type;
+	GList *types = NULL;
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE, YAHOO_STATUS_TYPE_AVAILABLE,
+	                                       NULL, TRUE, TRUE, FALSE,
+	                                       "message", _("Message"),
+	                                       purple_value_new(PURPLE_TYPE_STRING), NULL);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_AWAY, YAHOO_STATUS_TYPE_AWAY,
+	                                       NULL, TRUE, TRUE, FALSE,
+	                                       "message", _("Message"),
+	                                       purple_value_new(PURPLE_TYPE_STRING), NULL);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new(PURPLE_STATUS_AWAY, YAHOO_STATUS_TYPE_BRB, _("Be Right Back"), TRUE);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new_with_attrs(PURPLE_STATUS_UNAVAILABLE, YAHOO_STATUS_TYPE_BUSY,
+	                                       _("Busy"), TRUE, TRUE, FALSE,
+	                                       "message", _("Message"),
+	                                       purple_value_new(PURPLE_TYPE_STRING), NULL);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new(PURPLE_STATUS_AWAY, YAHOO_STATUS_TYPE_NOTATHOME, _("Not at Home"), TRUE);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new(PURPLE_STATUS_AWAY, YAHOO_STATUS_TYPE_NOTATDESK, _("Not at Desk"), TRUE);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new(PURPLE_STATUS_AWAY, YAHOO_STATUS_TYPE_NOTINOFFICE, _("Not in Office"), TRUE);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new(PURPLE_STATUS_UNAVAILABLE, YAHOO_STATUS_TYPE_ONPHONE, _("On the Phone"), TRUE);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new(PURPLE_STATUS_EXTENDED_AWAY, YAHOO_STATUS_TYPE_ONVACATION, _("On Vacation"), TRUE);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new(PURPLE_STATUS_AWAY, YAHOO_STATUS_TYPE_OUTTOLUNCH, _("Out to Lunch"), TRUE);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new(PURPLE_STATUS_AWAY, YAHOO_STATUS_TYPE_STEPPEDOUT, _("Stepped Out"), TRUE);
+	types = g_list_append(types, type);
+
+
+	type = purple_status_type_new(PURPLE_STATUS_INVISIBLE, YAHOO_STATUS_TYPE_INVISIBLE, NULL, TRUE);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new(PURPLE_STATUS_OFFLINE, YAHOO_STATUS_TYPE_OFFLINE, NULL, TRUE);
+	types = g_list_append(types, type);
+
+	type = purple_status_type_new_full(PURPLE_STATUS_MOBILE, YAHOO_STATUS_TYPE_MOBILE, NULL, FALSE, FALSE, TRUE);
+	types = g_list_append(types, type);
+
+	return types;
+}
+
+void yahoo_keepalive(PurpleConnection *gc)
+{
+	struct yahoo_packet *pkt;
+	YahooData *yd = gc->proto_data;
+	time_t now = time(NULL);
+
+	/* We're only allowed to send a ping once an hour or the servers will boot us */
+	if ((now - yd->last_ping) >= PING_TIMEOUT) {
+		yd->last_ping = now;
+
+		/* The native client will only send PING or CHATPING */
+		if (yd->chat_online) {
+			if (yd->wm) {
+				ycht_chat_send_keepalive(yd->ycht);
+			} else {
+				pkt = yahoo_packet_new(YAHOO_SERVICE_CHATPING, YAHOO_STATUS_AVAILABLE, yd->session_id);
+				yahoo_packet_hash_str(pkt, 109, purple_connection_get_display_name(gc));
+				yahoo_packet_send_and_free(pkt, yd);
+			}
+		} else {
+			pkt = yahoo_packet_new(YAHOO_SERVICE_PING, YAHOO_STATUS_AVAILABLE, yd->session_id);
+			yahoo_packet_send_and_free(pkt, yd);
+		}
+	}
+
+	if ((now - yd->last_keepalive) >= KEEPALIVE_TIMEOUT) {
+		yd->last_keepalive = now;
+		pkt = yahoo_packet_new(YAHOO_SERVICE_KEEPALIVE, YAHOO_STATUS_AVAILABLE, yd->session_id);
+		yahoo_packet_hash_str(pkt, 0, purple_connection_get_display_name(gc));
+		yahoo_packet_send_and_free(pkt, yd);
+	}
+
+}
+
+void yahoo_add_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *g)
+{
+	YahooData *yd = (YahooData *)gc->proto_data;
+	struct yahoo_packet *pkt;
+	const char *group = NULL;
+	char *group2;
+	const char *bname;
+	const char *fed_bname;
+	YahooFederation fed = YAHOO_FEDERATION_NONE;
+
+	if (!yd->logged_in)
+		return;
+
+	fed_bname = bname = purple_buddy_get_name(buddy);
+	if (!purple_privacy_check(purple_connection_get_account(gc), bname))
+		return;
+
+	fed = yahoo_get_federation_from_name(bname);
+	if (fed != YAHOO_FEDERATION_NONE)
+		fed_bname += 4;
+
+	g = purple_buddy_get_group(buddy);
+	if (g)
+		group = purple_group_get_name(g);
+	else
+		group = "Buddies";
+
+	group2 = yahoo_string_encode(gc, group, NULL);
+	pkt = yahoo_packet_new(YAHOO_SERVICE_ADDBUDDY, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	if (fed) {
+		yahoo_packet_hash(pkt, "sssssssisss",
+						  14, "",
+						  65, group2,
+						  97, "1",
+						  1, purple_connection_get_display_name(gc),
+						  302, "319",
+						  300, "319",
+						  7, fed_bname,
+						  241, fed,
+						  334, "0",
+						  301, "319",
+						  303, "319"
+		);
+	}
+	else {
+		yahoo_packet_hash(pkt, "ssssssssss",
+						  14, "",
+						  65, group2,
+						  97, "1",
+						  1, purple_connection_get_display_name(gc),
+						  302, "319",
+						  300, "319",
+						  7, fed_bname,
+						  334, "0",
+						  301, "319",
+						  303, "319"
+		);
+	}
+
+	yahoo_packet_send_and_free(pkt, yd);
+	g_free(group2);
+}
+
+void yahoo_remove_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group)
+{
+	YahooData *yd = (YahooData *)gc->proto_data;
+	struct yahoo_packet *pkt;
+	GSList *buddies, *l;
+	PurpleGroup *g;
+	gboolean remove = TRUE;
+	char *cg;
+	const char *bname, *gname;
+	YahooFriend *f = NULL;
+	YahooFederation fed = YAHOO_FEDERATION_NONE;
+
+	bname = purple_buddy_get_name(buddy);
+	f = yahoo_friend_find(gc, bname);
+	if (!f)
+		return;
+	fed = f->fed;
+
+	gname = purple_group_get_name(group);
+	buddies = purple_find_buddies(purple_connection_get_account(gc), bname);
+	for (l = buddies; l; l = l->next) {
+		g = purple_buddy_get_group(l->data);
+		if (purple_utf8_strcasecmp(gname, purple_group_get_name(g))) {
+			remove = FALSE;
+			break;
+		}
+	}
+
+	g_slist_free(buddies);
+
+	if (remove) {
+		g_hash_table_remove(yd->friends, bname);
+		f = NULL; /* f no longer valid - Just making it clear */
+	}
+
+	cg = yahoo_string_encode(gc, gname, NULL);
+	pkt = yahoo_packet_new(YAHOO_SERVICE_REMBUDDY, YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	switch (fed) {
+		case YAHOO_FEDERATION_MSN:
+		case YAHOO_FEDERATION_OCS:
+		case YAHOO_FEDERATION_IBM:
+			bname += 4;
+			break;
+		case YAHOO_FEDERATION_NONE:
+		default:
+			break;
+	}
+
+	yahoo_packet_hash(pkt, "sss", 1, purple_connection_get_display_name(gc),
+	                  7, bname, 65, cg);
+	if (fed)
+		yahoo_packet_hash_int(pkt, 241, fed);
+	yahoo_packet_send_and_free(pkt, yd);
+	g_free(cg);
+}
+
+void yahoo_add_deny(PurpleConnection *gc, const char *who) {
+	YahooData *yd = (YahooData *)gc->proto_data;
+	struct yahoo_packet *pkt;
+	YahooFederation fed = YAHOO_FEDERATION_NONE;
+
+	if (!yd->logged_in)
+		return;
+
+	if (!who || who[0] == '\0')
+		return;
+
+	fed = yahoo_get_federation_from_name(who);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_IGNORECONTACT, YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	if(fed)
+		yahoo_packet_hash(pkt, "ssis", 1, purple_connection_get_display_name(gc), 7, who+4, 241, fed, 13, "1");
+	else
+		yahoo_packet_hash(pkt, "sss", 1, purple_connection_get_display_name(gc), 7, who, 13, "1");
+
+	yahoo_packet_send_and_free(pkt, yd);
+}
+
+void yahoo_rem_deny(PurpleConnection *gc, const char *who) {
+	YahooData *yd = (YahooData *)gc->proto_data;
+	struct yahoo_packet *pkt;
+	YahooFederation fed = YAHOO_FEDERATION_NONE;
+
+	if (!yd->logged_in)
+		return;
+
+	if (!who || who[0] == '\0')
+		return;
+	fed = yahoo_get_federation_from_name(who);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_IGNORECONTACT, YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	if(fed)
+		yahoo_packet_hash(pkt, "ssis", 1, purple_connection_get_display_name(gc), 7, who+4, 241, fed, 13, "2");
+	else
+		yahoo_packet_hash(pkt, "sss", 1, purple_connection_get_display_name(gc), 7, who, 13, "2");
+
+	yahoo_packet_send_and_free(pkt, yd);
+}
+
+void yahoo_set_permit_deny(PurpleConnection *gc)
+{
+	PurpleAccount *account;
+	GSList *deny;
+
+	account = purple_connection_get_account(gc);
+
+	switch (account->perm_deny)
+	{
+		case PURPLE_PRIVACY_ALLOW_ALL:
+			for (deny = account->deny; deny; deny = deny->next)
+				yahoo_rem_deny(gc, deny->data);
+			break;
+
+		case PURPLE_PRIVACY_ALLOW_BUDDYLIST:
+		case PURPLE_PRIVACY_ALLOW_USERS:
+		case PURPLE_PRIVACY_DENY_USERS:
+		case PURPLE_PRIVACY_DENY_ALL:
+			for (deny = account->deny; deny; deny = deny->next)
+				yahoo_add_deny(gc, deny->data);
+			break;
+	}
+}
+
+void yahoo_change_buddys_group(PurpleConnection *gc, const char *who,
+				   const char *old_group, const char *new_group)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt;
+	char *gpn, *gpo;
+	YahooFriend *f = yahoo_friend_find(gc, who);
+	const char *temp = NULL;
+
+	/* Step 0:  If they aren't on the server list anyway,
+	 *          don't bother letting the server know.
+	 */
+	if (!f)
+		return;
+
+	if(f->fed) {
+		temp = who+4;
+	} else
+		temp = who;
+
+	/* If old and new are the same, we would probably
+	 * end up deleting the buddy, which would be bad.
+	 * This might happen because of the charset conversation.
+	 */
+	gpn = yahoo_string_encode(gc, new_group, NULL);
+	gpo = yahoo_string_encode(gc, old_group, NULL);
+	if (!strcmp(gpn, gpo)) {
+		g_free(gpn);
+		g_free(gpo);
+		return;
+	}
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CHGRP_15, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	if(f->fed)
+		yahoo_packet_hash(pkt, "ssssissss", 1, purple_connection_get_display_name(gc),
+	                  302, "240", 300, "240", 7, temp, 241, f->fed, 224, gpo, 264, gpn, 301,
+	                  "240", 303, "240");
+	else
+		yahoo_packet_hash(pkt, "ssssssss", 1, purple_connection_get_display_name(gc),
+	                  302, "240", 300, "240", 7, temp, 224, gpo, 264, gpn, 301,
+	                  "240", 303, "240");
+	yahoo_packet_send_and_free(pkt, yd);
+
+	g_free(gpn);
+	g_free(gpo);
+}
+
+void yahoo_rename_group(PurpleConnection *gc, const char *old_name,
+							   PurpleGroup *group, GList *moved_buddies)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt;
+	char *gpn, *gpo;
+
+	gpn = yahoo_string_encode(gc, purple_group_get_name(group), NULL);
+	gpo = yahoo_string_encode(gc, old_name, NULL);
+	if (!strcmp(gpn, gpo)) {
+		g_free(gpn);
+		g_free(gpo);
+		return;
+	}
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_GROUPRENAME, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash(pkt, "sss", 1, purple_connection_get_display_name(gc),
+	                  65, gpo, 67, gpn);
+	yahoo_packet_send_and_free(pkt, yd);
+	g_free(gpn);
+	g_free(gpo);
+}
+
+/********************************* Commands **********************************/
+
+PurpleCmdRet
+yahoopurple_cmd_buzz(PurpleConversation *c, const gchar *cmd, gchar **args, gchar **error, void *data) {
+	PurpleAccount *account = purple_conversation_get_account(c);
+
+	if (*args && args[0])
+		return PURPLE_CMD_RET_FAILED;
+
+	purple_prpl_send_attention(account->gc, c->name, YAHOO_BUZZ);
+
+	return PURPLE_CMD_RET_OK;
+}
+
+PurpleCmdRet
+yahoopurple_cmd_chat_join(PurpleConversation *conv, const char *cmd,
+                        char **args, char **error, void *data)
+{
+	GHashTable *comp;
+	PurpleConnection *gc;
+
+	if (!args || !args[0])
+		return PURPLE_CMD_RET_FAILED;
+
+	gc = purple_conversation_get_gc(conv);
+	purple_debug_info("yahoo", "Trying to join %s \n", args[0]);
+
+	comp = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+	g_hash_table_replace(comp, g_strdup("room"), g_ascii_strdown(args[0], -1));
+	g_hash_table_replace(comp, g_strdup("type"), g_strdup("Chat"));
+
+	yahoo_c_join(gc, comp);
+
+	g_hash_table_destroy(comp);
+	return PURPLE_CMD_RET_OK;
+}
+
+PurpleCmdRet
+yahoopurple_cmd_chat_list(PurpleConversation *conv, const char *cmd,
+                        char **args, char **error, void *data)
+{
+	PurpleAccount *account = purple_conversation_get_account(conv);
+	if (*args && args[0])
+		return PURPLE_CMD_RET_FAILED;
+	purple_roomlist_show_with_account(account);
+	return PURPLE_CMD_RET_OK;
+}
+
+gboolean yahoo_offline_message(const PurpleBuddy *buddy)
+{
+	return TRUE;
+}
+
+gboolean yahoo_send_attention(PurpleConnection *gc, const char *username, guint type)
+{
+	PurpleConversation *c;
+
+	c = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM,
+			username, gc->account);
+
+	g_return_val_if_fail(c != NULL, FALSE);
+
+	purple_debug_info("yahoo", "Sending <ding> on account %s to buddy %s.\n",
+			username, c->name);
+	purple_conv_im_send_with_flags(PURPLE_CONV_IM(c), "<ding>", PURPLE_MESSAGE_INVISIBLE);
+
+	return TRUE;
+}
+
+GList *yahoo_attention_types(PurpleAccount *account)
+{
+	static GList *list = NULL;
+
+	if (!list) {
+		/* Yahoo only supports one attention command: the 'buzz'. */
+		/* This is index number YAHOO_BUZZ. */
+		list = g_list_append(list, purple_attention_type_new("Buzz", _("Buzz"),
+				_("%s has buzzed you!"), _("Buzzing %s...")));
+	}
+
+	return list;
+}
+
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/libymsg.h pidgin-2.10.11/libpurple/protocols/yahoo/libymsg.h
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/libymsg.h	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/libymsg.h	2015-02-10 14:28:16.394018882 +0900
@@ -48,7 +48,7 @@
 #define YAHOO_ROOMLIST_LOCALE "us"
 
 /* Yahoo! JAPAN stuff */
-#define YAHOOJP_PAGER_HOST_REQ_URL "http://cs1.yahoo.co.jp/capacity"
+#define YAHOOJP_PAGER_HOST_REQ_URL "http://cs.yahoo.co.jp/capacity"
 #define YAHOOJP_TOKEN_URL "https://login.yahoo.co.jp/config/pwtoken_get?src=ymsgr&ts=&login=%s&passwd=%s&chal=%s"
 #define YAHOOJP_LOGIN_URL "https://login.yahoo.co.jp/config/pwtoken_login?src=ymsgr&ts=&token=%s"
 #define YAHOOJP_PROFILE_URL "http://profiles.yahoo.co.jp/"
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/util.c pidgin-2.10.11/libpurple/protocols/yahoo/util.c
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/util.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/util.c	2015-02-10 14:28:16.394018882 +0900
@@ -29,6 +29,7 @@
 #include "prpl.h"
 
 #include "libymsg.h"
+#include "util.h"
 
 #include <string.h>
 
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoo_filexfer.c pidgin-2.10.11/libpurple/protocols/yahoo/yahoo_filexfer.c
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoo_filexfer.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/yahoo_filexfer.c	2015-02-10 14:28:16.397352379 +0900
@@ -226,7 +226,7 @@
 	PurpleXfer *xfer;
 	struct yahoo_xfer_data *xd;
 	struct yahoo_packet *pkt;
-	gchar *size, *filename, *encoded_filename, *header;
+	gchar *size, *filename, *encoded_filename, *header, *tmp = NULL;
 	guchar *pkt_buf;
 	const char *host;
 	int port;
@@ -234,6 +234,7 @@
 	PurpleConnection *gc;
 	PurpleAccount *account;
 	YahooData *yd;
+	gsize dummy;
 
 	purple_debug_info("yahoo", "in yahoo_sendfile_connected\n");
 
@@ -260,8 +261,12 @@
 		YAHOO_STATUS_AVAILABLE, yd->session_id);
 
 	size = g_strdup_printf("%" G_GSIZE_FORMAT, purple_xfer_get_size(xfer));
-	filename = g_path_get_basename(purple_xfer_get_local_filename(xfer));
-	encoded_filename = yahoo_string_encode(gc, filename, NULL);
+
+	/* yaz */
+	tmp = g_filename_display_basename(purple_xfer_get_local_filename(xfer));
+	filename = botch_utf(tmp, strlen(tmp), &dummy);
+	g_free(tmp);
+	encoded_filename = yahoo_string_encode(gc, filename, NULL); // this takes utf8 as input. --yaz
 
 	yahoo_packet_hash(pkt, "sssss", 0, purple_connection_get_display_name(gc),
 	  5, xfer->who, 14, "", 27, encoded_filename, 28, size);
@@ -1033,7 +1038,7 @@
 	struct sockaddr_in *addr;
 	struct yahoo_packet *pkt;
 	unsigned long actaddr;
-	unsigned char a,b,c,d;
+	unsigned long a,b,c,d;
 	PurpleConnection *gc;
 	PurpleAccount *account;
 	YahooData *yd;
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoo_filexfer.c.orig pidgin-2.10.11/libpurple/protocols/yahoo/yahoo_filexfer.c.orig
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoo_filexfer.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/yahoo_filexfer.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,2048 @@
+/*
+ * @file yahoo_filexfer.c Yahoo Filetransfer
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#include "internal.h"
+#include "dnsquery.h"
+
+#include "prpl.h"
+#include "util.h"
+#include "debug.h"
+#include "network.h"
+#include "notify.h"
+#include "proxy.h"
+#include "ft.h"
+#include "libymsg.h"
+#include "yahoo_packet.h"
+#include "yahoo_filexfer.h"
+#include "yahoo_doodle.h"
+#include "yahoo_friend.h"
+
+struct yahoo_xfer_data {
+	gchar *host;
+	gchar *path;
+	int port;
+	PurpleConnection *gc;
+	long expires;
+	gboolean started;
+	gchar *txbuf;
+	gsize txbuflen;
+	gsize txbuf_written;
+	guint tx_handler;
+	gchar *rxqueue;
+	guint rxlen;
+	gchar *xfer_peer_idstring;
+	gchar *xfer_idstring_for_relay;
+	int version; /* 0 for old, 15 for Y7(YMSG 15) */
+	int info_val_249;
+
+	enum {
+		STARTED = 0,
+		HEAD_REQUESTED,
+		HEAD_REPLY_RECEIVED,
+		TRANSFER_PHASE,
+		ACCEPTED,
+		P2P_HEAD_REQUESTED,
+		P2P_HEAD_REPLIED,
+		P2P_GET_REQUESTED
+	} status_15;
+
+	/* contains all filenames, in case of multiple transfers, with the first
+	 * one in the list being the current file's name (ymsg15) */
+	GSList *filename_list;
+	GSList *size_list; /* corresponds to filename_list, with size as **STRING** */
+	gboolean firstoflist;
+	gchar *xfer_url;	/* url of the file, used when we are p2p server */
+	int yahoo_local_p2p_ft_server_fd;
+	int yahoo_local_p2p_ft_server_port;
+	int yahoo_p2p_ft_server_watcher;
+	int input_event;
+};
+
+static void yahoo_xfer_data_free(struct yahoo_xfer_data *xd)
+{
+	PurpleConnection *gc;
+	YahooData *yd;
+	PurpleXfer *xfer;
+	GSList *l;
+
+	gc = xd->gc;
+	yd = gc->proto_data;
+
+	/* remove entry from map */
+	if(xd->xfer_peer_idstring) {
+		xfer = g_hash_table_lookup(yd->xfer_peer_idstring_map, xd->xfer_peer_idstring);
+		if(xfer)
+			g_hash_table_remove(yd->xfer_peer_idstring_map, xd->xfer_peer_idstring);
+	}
+
+	/* empty file & filesize list */
+	for (l = xd->filename_list; l; l = l->next) {
+		g_free(l->data);
+		l->data=NULL;
+	}
+	for (l = xd->size_list; l; l = l->next) {
+		g_free(l->data);
+		l->data=NULL;
+	}
+	g_slist_free(xd->filename_list);
+	g_slist_free(xd->size_list);
+
+	g_free(xd->host);
+	g_free(xd->path);
+	g_free(xd->txbuf);
+	g_free(xd->xfer_peer_idstring);
+	g_free(xd->xfer_idstring_for_relay);
+	if (xd->tx_handler)
+		purple_input_remove(xd->tx_handler);
+	g_free(xd);
+}
+
+static void yahoo_receivefile_send_cb(gpointer data, gint source, PurpleInputCondition condition)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+	int remaining, written;
+
+	xfer = data;
+	xd = xfer->data;
+
+	remaining = xd->txbuflen - xd->txbuf_written;
+	written = write(xfer->fd, xd->txbuf + xd->txbuf_written, remaining);
+
+	if (written < 0 && errno == EAGAIN)
+		written = 0;
+	else if (written <= 0) {
+		purple_debug_error("yahoo", "Unable to write in order to start ft errno = %d\n", errno);
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	if (written < remaining) {
+		xd->txbuf_written += written;
+		return;
+	}
+
+	purple_input_remove(xd->tx_handler);
+	xd->tx_handler = 0;
+	g_free(xd->txbuf);
+	xd->txbuf = NULL;
+	xd->txbuflen = 0;
+
+	purple_xfer_start(xfer, source, NULL, 0);
+
+}
+
+static void yahoo_receivefile_connected(gpointer data, gint source, const gchar *error_message)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+
+	purple_debug_info("yahoo", "in yahoo_receivefile_connected\n");
+
+	if (!(xfer = data))
+		return;
+	if (!(xd = xfer->data))
+		return;
+	if ((source < 0) || (xd->path == NULL) || (xd->host == NULL)) {
+		purple_xfer_error(PURPLE_XFER_RECEIVE, purple_xfer_get_account(xfer),
+				xfer->who, _("Unable to connect."));
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	xfer->fd = source;
+
+	/* The first time we get here, assemble the tx buffer */
+	if (xd->txbuflen == 0) {
+		xd->txbuf = g_strdup_printf("GET /%s HTTP/1.0\r\nHost: %s\r\n\r\n",
+			      xd->path, xd->host);
+		xd->txbuflen = strlen(xd->txbuf);
+		xd->txbuf_written = 0;
+	}
+
+	if (!xd->tx_handler)
+	{
+		xd->tx_handler = purple_input_add(source, PURPLE_INPUT_WRITE,
+			yahoo_receivefile_send_cb, xfer);
+		yahoo_receivefile_send_cb(xfer, source, PURPLE_INPUT_WRITE);
+	}
+}
+
+static void yahoo_sendfile_send_cb(gpointer data, gint source, PurpleInputCondition condition)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+	int written, remaining;
+
+	xfer = data;
+	xd = xfer->data;
+
+	remaining = xd->txbuflen - xd->txbuf_written;
+	written = write(xfer->fd, xd->txbuf + xd->txbuf_written, remaining);
+
+	if (written < 0 && errno == EAGAIN)
+		written = 0;
+	else if (written <= 0) {
+		purple_debug_error("yahoo", "Unable to write in order to start ft errno = %d\n", errno);
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	if (written < remaining) {
+		xd->txbuf_written += written;
+		return;
+	}
+
+	purple_input_remove(xd->tx_handler);
+	xd->tx_handler = 0;
+	g_free(xd->txbuf);
+	xd->txbuf = NULL;
+	xd->txbuflen = 0;
+
+	purple_xfer_start(xfer, source, NULL, 0);
+}
+
+static void yahoo_sendfile_connected(gpointer data, gint source, const gchar *error_message)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+	struct yahoo_packet *pkt;
+	gchar *size, *filename, *encoded_filename, *header;
+	guchar *pkt_buf;
+	const char *host;
+	int port;
+	size_t content_length, header_len, pkt_buf_len;
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	YahooData *yd;
+
+	purple_debug_info("yahoo", "in yahoo_sendfile_connected\n");
+
+	if (!(xfer = data))
+		return;
+	if (!(xd = xfer->data))
+		return;
+
+	if (source < 0) {
+		purple_xfer_error(PURPLE_XFER_RECEIVE, purple_xfer_get_account(xfer),
+				xfer->who, _("Unable to connect."));
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	xfer->fd = source;
+
+	/* Assemble the tx buffer */
+	gc = xd->gc;
+	account = purple_connection_get_account(gc);
+	yd = gc->proto_data;
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANSFER,
+		YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	size = g_strdup_printf("%" G_GSIZE_FORMAT, purple_xfer_get_size(xfer));
+	filename = g_path_get_basename(purple_xfer_get_local_filename(xfer));
+	encoded_filename = yahoo_string_encode(gc, filename, NULL);
+
+	yahoo_packet_hash(pkt, "sssss", 0, purple_connection_get_display_name(gc),
+	  5, xfer->who, 14, "", 27, encoded_filename, 28, size);
+	g_free(size);
+	g_free(encoded_filename);
+	g_free(filename);
+
+	content_length = YAHOO_PACKET_HDRLEN + yahoo_packet_length(pkt);
+
+	pkt_buf_len = yahoo_packet_build(pkt, 4, FALSE, yd->jp, &pkt_buf);
+	yahoo_packet_free(pkt);
+
+	host = purple_account_get_string(account, "xfer_host", YAHOO_XFER_HOST);
+	port = purple_account_get_int(account, "xfer_port", YAHOO_XFER_PORT);
+	header = g_strdup_printf(
+		"POST http://%s:%d/notifyft HTTP/1.0\r\n"
+		"Content-length: %" G_GSIZE_FORMAT "\r\n"
+		"Host: %s:%d\r\n"
+		"Cookie: Y=%s; T=%s\r\n"
+		"\r\n",
+		host, port, content_length + 4 + purple_xfer_get_size(xfer),
+		host, port, yd->cookie_y, yd->cookie_t);
+
+	header_len = strlen(header);
+
+	xd->txbuflen = header_len + pkt_buf_len + 4;
+	xd->txbuf = g_malloc(xd->txbuflen);
+
+	memcpy(xd->txbuf, header, header_len);
+	g_free(header);
+	memcpy(xd->txbuf + header_len, pkt_buf, pkt_buf_len);
+	g_free(pkt_buf);
+	memcpy(xd->txbuf + header_len + pkt_buf_len, "29\xc0\x80", 4);
+
+	xd->txbuf_written = 0;
+
+	if (xd->tx_handler == 0)
+	{
+		xd->tx_handler = purple_input_add(source, PURPLE_INPUT_WRITE,
+										yahoo_sendfile_send_cb, xfer);
+		yahoo_sendfile_send_cb(xfer, source, PURPLE_INPUT_WRITE);
+	}
+}
+
+static void yahoo_xfer_init(PurpleXfer *xfer)
+{
+	struct yahoo_xfer_data *xfer_data;
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	YahooData *yd;
+
+	xfer_data = xfer->data;
+	gc = xfer_data->gc;
+	yd = gc->proto_data;
+	account = purple_connection_get_account(gc);
+
+	if (purple_xfer_get_type(xfer) == PURPLE_XFER_SEND) {
+		if (yd->jp) {
+			if (purple_proxy_connect(gc, account, purple_account_get_string(account, "xferjp_host",  YAHOOJP_XFER_HOST),
+			                       purple_account_get_int(account, "xfer_port", YAHOO_XFER_PORT),
+			                       yahoo_sendfile_connected, xfer) == NULL)
+			{
+				purple_notify_error(gc, NULL, _("File Transfer Failed"),
+				                _("Unable to establish file descriptor."));
+				purple_xfer_cancel_remote(xfer);
+			}
+		} else {
+			if (purple_proxy_connect(gc, account, purple_account_get_string(account, "xfer_host",  YAHOO_XFER_HOST),
+			                       purple_account_get_int(account, "xfer_port", YAHOO_XFER_PORT),
+			                       yahoo_sendfile_connected, xfer) == NULL)
+			{
+				purple_notify_error(gc, NULL, _("File Transfer Failed"),
+				                _("Unable to establish file descriptor."));
+				purple_xfer_cancel_remote(xfer);
+			}
+		}
+	} else {
+		xfer->fd = -1;
+		if (purple_proxy_connect(gc, account, xfer_data->host, xfer_data->port,
+		                              yahoo_receivefile_connected, xfer) == NULL) {
+			purple_notify_error(gc, NULL, _("File Transfer Failed"),
+			             _("Unable to establish file descriptor."));
+			purple_xfer_cancel_remote(xfer);
+		}
+	}
+}
+
+static void yahoo_xfer_init_15(PurpleXfer *xfer)
+{
+	struct yahoo_xfer_data *xfer_data;
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	YahooData *yd;
+	struct yahoo_packet *pkt;
+
+	xfer_data = xfer->data;
+	gc = xfer_data->gc;
+	yd = gc->proto_data;
+	account = purple_connection_get_account(gc);
+
+	if (purple_xfer_get_type(xfer) == PURPLE_XFER_SEND)	{
+		gchar *filename;
+		filename = g_path_get_basename(purple_xfer_get_local_filename(xfer));
+		pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_15,
+							   YAHOO_STATUS_AVAILABLE,
+							   yd->session_id);
+		yahoo_packet_hash(pkt, "sssiiiisiii",
+			1, purple_normalize(account, purple_account_get_username(account)),
+			5, xfer->who,
+			265, xfer_data->xfer_peer_idstring,
+			222, 1,
+			266, 1,
+			302, 268,
+			300, 268,
+			27,  filename,
+			28,  xfer->size,
+			301, 268,
+			303, 268);
+		g_free(filename);
+	} else {
+		if(xfer_data->firstoflist == TRUE) {
+			pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_15,
+				YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+			yahoo_packet_hash(pkt, "sssi",
+				1, purple_normalize(account, purple_account_get_username(account)),
+				5, xfer->who,
+				265, xfer_data->xfer_peer_idstring,
+				222, 3);
+		} else {
+			pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_ACC_15,
+				YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+			yahoo_packet_hash(pkt, "sssi",
+				1, purple_normalize(account, purple_account_get_username(account)),
+				5, xfer->who,
+				265, xfer_data->xfer_peer_idstring,
+				271, 1);
+		}
+	}
+	yahoo_packet_send_and_free(pkt, yd);
+}
+
+static void yahoo_xfer_start(PurpleXfer *xfer)
+{
+	/* We don't need to do anything here, do we? */
+}
+
+static guint calculate_length(const gchar *l, size_t len)
+{
+	size_t i;
+
+	for (i = 0; i < len; i++) {
+		if (!g_ascii_isdigit(l[i]))
+			continue;
+		return strtol(l + i, NULL, 10);
+	}
+	return 0;
+}
+
+static gssize yahoo_xfer_read(guchar **buffer, PurpleXfer *xfer)
+{
+	gchar buf[4096];
+	gssize len;
+	gchar *start = NULL;
+	gchar *length;
+	gchar *end;
+	int filelen;
+	struct yahoo_xfer_data *xd = xfer->data;
+
+	if (purple_xfer_get_type(xfer) != PURPLE_XFER_RECEIVE) {
+		return 0;
+	}
+
+	len = read(xfer->fd, buf, sizeof(buf));
+
+	if (len <= 0) {
+		if ((purple_xfer_get_size(xfer) > 0) &&
+		    (purple_xfer_get_bytes_sent(xfer) >= purple_xfer_get_size(xfer))) {
+			purple_xfer_set_completed(xfer, TRUE);
+			return 0;
+		} else
+			return -1;
+	}
+
+	if (!xd->started) {
+		xd->rxqueue = g_realloc(xd->rxqueue, len + xd->rxlen);
+		memcpy(xd->rxqueue + xd->rxlen, buf, len);
+		xd->rxlen += len;
+
+		length = g_strstr_len(xd->rxqueue, len, "Content-length:");
+		/* some proxies re-write this header, changing the capitalization :(
+		 * technically that's allowed since headers are case-insensitive
+		 * [RFC 2616, section 4.2] */
+		if (length == NULL)
+			length = g_strstr_len(xd->rxqueue, len, "Content-Length:");
+		if (length) {
+			end = g_strstr_len(length, length - xd->rxqueue, "\r\n");
+			if (!end)
+				return 0;
+			if ((filelen = calculate_length(length, len - (length - xd->rxqueue))))
+				purple_xfer_set_size(xfer, filelen);
+		}
+		start = g_strstr_len(xd->rxqueue, len, "\r\n\r\n");
+		if (start)
+			start += 4;
+		if (!start || start > (xd->rxqueue + len))
+			return 0;
+		xd->started = TRUE;
+
+		len -= (start - xd->rxqueue);
+
+		*buffer = g_malloc(len);
+		memcpy(*buffer, start, len);
+		g_free(xd->rxqueue);
+		xd->rxqueue = NULL;
+		xd->rxlen = 0;
+	} else {
+		*buffer = g_malloc(len);
+		memcpy(*buffer, buf, len);
+	}
+
+	return len;
+}
+
+static gssize yahoo_xfer_write(const guchar *buffer, size_t size, PurpleXfer *xfer)
+{
+	gssize len;
+	struct yahoo_xfer_data *xd = xfer->data;
+
+	if (!xd)
+		return -1;
+
+	if (purple_xfer_get_type(xfer) != PURPLE_XFER_SEND) {
+		return -1;
+	}
+
+	len = write(xfer->fd, buffer, size);
+
+	if (len == -1) {
+		if (purple_xfer_get_bytes_sent(xfer) >= purple_xfer_get_size(xfer))
+			purple_xfer_set_completed(xfer, TRUE);
+		if ((errno != EAGAIN) && (errno != EINTR))
+			return -1;
+		return 0;
+	}
+
+	return len;
+}
+
+static void yahoo_xfer_cancel_send(PurpleXfer *xfer)
+{
+	struct yahoo_xfer_data *xfer_data;
+
+	xfer_data = xfer->data;
+
+	if(purple_xfer_get_status(xfer) == PURPLE_XFER_STATUS_CANCEL_LOCAL && xfer_data->version == 15)
+	{
+		PurpleConnection *gc;
+		PurpleAccount *account;
+		YahooData *yd;
+		struct yahoo_packet *pkt;
+
+		gc = xfer_data->gc;
+		yd = gc->proto_data;
+		account = purple_connection_get_account(gc);
+		if(xfer_data->xfer_idstring_for_relay) /* hack to see if file trans acc/info packet has been received */
+		{
+			pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_INFO_15,
+								   YAHOO_STATUS_DISCONNECTED,
+								   yd->session_id);
+			yahoo_packet_hash(pkt, "sssi",
+				1, purple_normalize(account, purple_account_get_username(account)),
+				5, xfer->who,
+				265, xfer_data->xfer_peer_idstring,
+				66, -1);
+		}
+		else
+		{
+			pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_15,
+								   YAHOO_STATUS_AVAILABLE,
+								   yd->session_id);
+			yahoo_packet_hash(pkt, "sssi",
+				1, purple_normalize(account, purple_account_get_username(account)),
+				5, xfer->who,
+				265, xfer_data->xfer_peer_idstring,
+				222, 2);
+		}
+		yahoo_packet_send_and_free(pkt, yd);
+	}
+
+
+	if (xfer_data)
+		yahoo_xfer_data_free(xfer_data);
+	xfer->data = NULL;
+}
+
+static void yahoo_xfer_cancel_recv(PurpleXfer *xfer)
+{
+	struct yahoo_xfer_data *xfer_data;
+
+	xfer_data = xfer->data;
+
+	if(purple_xfer_get_status(xfer) == PURPLE_XFER_STATUS_CANCEL_LOCAL && xfer_data->version == 15)
+	{
+
+		PurpleConnection *gc;
+		PurpleAccount *account;
+		YahooData *yd;
+		struct yahoo_packet *pkt;
+
+		gc = xfer_data->gc;
+		yd = gc->proto_data;
+		account = purple_connection_get_account(gc);
+		if(!xfer_data->xfer_idstring_for_relay) /* hack to see if file trans acc/info packet has been received */
+		{
+			pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_15,
+								   YAHOO_STATUS_AVAILABLE,
+								   yd->session_id);
+			yahoo_packet_hash(pkt, "sssi",
+				1, purple_normalize(account, purple_account_get_username(account)),
+				5, xfer->who,
+				265, xfer_data->xfer_peer_idstring,
+				222, 4);
+		}
+		else
+		{
+			pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_15,
+								   YAHOO_STATUS_DISCONNECTED,
+								   yd->session_id);
+			yahoo_packet_hash(pkt, "sssi",
+				1, purple_normalize(account, purple_account_get_username(account)),
+				5, xfer->who,
+				265, xfer_data->xfer_peer_idstring,
+				66, -1);
+		}
+		yahoo_packet_send_and_free(pkt, yd);
+	}
+
+	if (xfer_data)
+		yahoo_xfer_data_free(xfer_data);
+	xfer->data = NULL;
+}
+
+/* Send HTTP OK after receiving file */
+static void yahoo_p2p_ft_server_send_OK(PurpleXfer *xfer)
+{
+	char *tx = NULL;
+	int written;
+
+	tx = g_strdup_printf("HTTP/1.1 200 OK\r\nContent-Length: 0\r\nContent-Type: application/octet-stream\r\nConnection: close\r\n\r\n");
+	written = write(xfer->fd, tx, strlen(tx));
+
+	if (written < 0 && errno == EAGAIN)
+		written = 0;
+	else if (written <= 0)
+		purple_debug_info("yahoo", "p2p filetransfer: Unable to write HTTP OK");
+
+	/* close connection */
+	close(xfer->fd);
+	xfer->fd = -1;
+	g_free(tx);
+}
+
+static void yahoo_xfer_end(PurpleXfer *xfer_old)
+{
+	struct yahoo_xfer_data *xfer_data;
+	PurpleXfer *xfer = NULL;
+	PurpleConnection *gc;
+	YahooData *yd;
+
+	xfer_data = xfer_old->data;
+	if(xfer_data && xfer_data->version == 15
+	   && purple_xfer_get_type(xfer_old) == PURPLE_XFER_RECEIVE
+	   && xfer_data->filename_list) {
+
+		/* Send HTTP OK in case of p2p transfer, when we act as server */
+		if((xfer_data->xfer_url != NULL) && (xfer_old->fd >=0) && (purple_xfer_get_status(xfer_old) == PURPLE_XFER_STATUS_DONE))
+			yahoo_p2p_ft_server_send_OK(xfer_old);
+
+		/* removing top of filename & size list completely */
+		g_free( xfer_data->filename_list->data );
+		g_free( xfer_data->size_list->data );
+
+		xfer_data->filename_list->data = NULL;
+		xfer_data->size_list->data = NULL;
+
+		xfer_data->filename_list = g_slist_delete_link(xfer_data->filename_list, xfer_data->filename_list);
+		xfer_data->size_list = g_slist_delete_link(xfer_data->size_list, xfer_data->size_list);
+
+		/* if there are still more files */
+		if(xfer_data->filename_list)
+		{
+			gchar* filename;
+			long filesize;
+
+			filename = xfer_data->filename_list->data;
+			filesize = atol( xfer_data->size_list->data );
+
+			gc = xfer_data->gc;
+			yd = gc->proto_data;
+
+			/* setting up xfer_data for next file's tranfer */
+			g_free(xfer_data->host);
+			g_free(xfer_data->path);
+			g_free(xfer_data->txbuf);
+			g_free(xfer_data->rxqueue);
+			g_free(xfer_data->xfer_idstring_for_relay);
+			if (xfer_data->tx_handler)
+				purple_input_remove(xfer_data->tx_handler);
+			xfer_data->host = NULL;
+			xfer_data->host = NULL;
+			xfer_data->port = 0;
+			xfer_data->expires = 0;
+			xfer_data->started = FALSE;
+			xfer_data->txbuf = NULL;
+			xfer_data->txbuflen = 0;
+			xfer_data->txbuf_written = 0;
+			xfer_data->tx_handler = 0;
+			xfer_data->rxqueue = NULL;
+			xfer_data->rxlen = 0;
+			xfer_data->xfer_idstring_for_relay = NULL;
+			xfer_data->info_val_249 = 0;
+			xfer_data->status_15 = STARTED;
+			xfer_data->firstoflist = FALSE;
+
+			/* Dereference xfer_data from old xfer */
+			xfer_old->data = NULL;
+
+			/* Build the file transfer handle. */
+			xfer = purple_xfer_new(gc->account, PURPLE_XFER_RECEIVE, xfer_old->who);
+
+
+			if (xfer) {
+				/* Set the info about the incoming file. */
+				char *utf8_filename = yahoo_string_decode(gc, filename, TRUE);
+				purple_xfer_set_filename(xfer, utf8_filename);
+				g_free(utf8_filename);
+				purple_xfer_set_size(xfer, filesize);
+
+				xfer->data = xfer_data;
+
+				/* Setup our I/O op functions */
+				purple_xfer_set_init_fnc(xfer,        yahoo_xfer_init_15);
+				purple_xfer_set_start_fnc(xfer,       yahoo_xfer_start);
+				purple_xfer_set_end_fnc(xfer,         yahoo_xfer_end);
+				purple_xfer_set_cancel_send_fnc(xfer, yahoo_xfer_cancel_send);
+				purple_xfer_set_cancel_recv_fnc(xfer, yahoo_xfer_cancel_recv);
+				purple_xfer_set_read_fnc(xfer,        yahoo_xfer_read);
+				purple_xfer_set_write_fnc(xfer,       yahoo_xfer_write);
+				purple_xfer_set_request_denied_fnc(xfer,yahoo_xfer_cancel_recv);
+
+				/* update map to current xfer */
+				g_hash_table_remove(yd->xfer_peer_idstring_map, xfer_data->xfer_peer_idstring);
+				g_hash_table_insert(yd->xfer_peer_idstring_map, xfer_data->xfer_peer_idstring, xfer);
+
+				/* Now perform the request */
+				purple_xfer_request(xfer);
+			}
+			return;
+		}
+	}
+	if (xfer_data)
+		yahoo_xfer_data_free(xfer_data);
+	xfer_old->data = NULL;
+
+}
+
+void yahoo_process_p2pfilexfer(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	GSList *l = pkt->hash;
+
+	char *me      = NULL;
+	char *from    = NULL;
+	char *service = NULL;
+	char *message = NULL;
+	char *command = NULL;
+	char *imv     = NULL;
+
+	/* Get all the necessary values from this new packet */
+	while(l != NULL)
+	{
+		struct yahoo_pair *pair = l->data;
+
+		switch(pair->key) {
+		case 5:         /* Get who the packet is for */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				me = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_p2pfilexfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 4:         /* Get who the packet is from */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				from = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_p2pfilexfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 49:        /* Get the type of service */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				service = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_p2pfilexfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 14:        /* Get the 'message' of the packet */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				message = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_p2pfilexfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 13:        /* Get the command associated with this packet */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				command = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_p2pfilexfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 63:        /* IMVironment name and version */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				imv = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_p2pfilexfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 64:        /* Not sure, but it does vary with initialization of Doodle */
+			break;
+		}
+
+		l = l->next;
+	}
+
+	/* If this packet is an IMVIRONMENT, handle it accordingly */
+	if(service != NULL && imv != NULL && !strcmp(service, "IMVIRONMENT"))
+	{
+		/* Check for a Doodle packet and handle it accordingly */
+		if(strstr(imv, "doodle;") != NULL)
+			yahoo_doodle_process(gc, me, from, command, message, imv);
+
+		/* If an IMVIRONMENT packet comes without a specific imviroment name */
+		if(!strcmp(imv, ";0"))
+		{
+			/* It is unfortunately time to close all IMVironments with the remote client */
+			yahoo_doodle_command_got_shutdown(gc, from);
+		}
+	}
+}
+
+void yahoo_process_filetransfer(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	char *from = NULL;
+	char *msg = NULL;
+	char *url = NULL;
+	char *imv = NULL;
+	PurpleXfer *xfer;
+	YahooData *yd;
+	struct yahoo_xfer_data *xfer_data;
+	char *service = NULL;
+	char *filename = NULL;
+	unsigned long filesize = 0L;
+	GSList *l;
+
+	yd = gc->proto_data;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 4:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				from = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetransfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 5: /* to */
+			break;
+		case 14:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				msg = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetransfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 20:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				url = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetransfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 38: /* expires */
+			break;
+		case 27:
+			filename = pair->value;
+			break;
+		case 28:
+			filesize = atol(pair->value);
+			break;
+		case 49:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				service = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetransfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 63:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				imv = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetransfer "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		}
+	}
+
+	/*
+	 * The remote user has changed their IMVironment.  We
+	 * record it for later use.
+	 */
+	if (from && imv && service && (strcmp("IMVIRONMENT", service) == 0)) {
+		g_hash_table_replace(yd->imvironments, g_strdup(from), g_strdup(imv));
+		return;
+	}
+
+	if (pkt->service == YAHOO_SERVICE_P2PFILEXFER) {
+		if (service && (strcmp("FILEXFER", service) != 0)) {
+			purple_debug_misc("yahoo", "unhandled service 0x%02x\n", pkt->service);
+			return;
+		}
+	}
+
+	if (msg) {
+		char *tmp;
+		tmp = strchr(msg, '\006');
+		if (tmp)
+			*tmp = '\0';
+	}
+
+	if (!url || !from)
+		return;
+
+	/* Setup the Yahoo-specific file transfer data */
+	xfer_data = g_new0(struct yahoo_xfer_data, 1);
+	xfer_data->gc = gc;
+	if (!purple_url_parse(url, &(xfer_data->host), &(xfer_data->port), &(xfer_data->path), NULL, NULL)) {
+		g_free(xfer_data);
+		return;
+	}
+
+	purple_debug_misc("yahoo_filexfer", "Host is %s, port is %d, path is %s, and the full url was %s.\n",
+	                xfer_data->host, xfer_data->port, xfer_data->path, url);
+
+	/* Build the file transfer handle. */
+	xfer = purple_xfer_new(gc->account, PURPLE_XFER_RECEIVE, from);
+	if (xfer == NULL) {
+		g_free(xfer_data);
+		g_return_if_reached();
+	}
+
+	xfer->data = xfer_data;
+
+	/* Set the info about the incoming file. */
+	if (filename) {
+		char *utf8_filename = yahoo_string_decode(gc, filename, TRUE);
+		purple_xfer_set_filename(xfer, utf8_filename);
+		g_free(utf8_filename);
+	} else {
+		gchar *start, *end;
+		start = g_strrstr(xfer_data->path, "/");
+		if (start)
+			start++;
+		end = g_strrstr(xfer_data->path, "?");
+		if (start && *start && end) {
+			char *utf8_filename;
+			filename = g_strndup(start, end - start);
+			utf8_filename = yahoo_string_decode(gc, filename, TRUE);
+			g_free(filename);
+			purple_xfer_set_filename(xfer, utf8_filename);
+			g_free(utf8_filename);
+			filename = NULL;
+		}
+	}
+
+	purple_xfer_set_size(xfer, filesize);
+
+	/* Setup our I/O op functions */
+	purple_xfer_set_init_fnc(xfer,        yahoo_xfer_init);
+	purple_xfer_set_start_fnc(xfer,       yahoo_xfer_start);
+	purple_xfer_set_end_fnc(xfer,         yahoo_xfer_end);
+	purple_xfer_set_cancel_send_fnc(xfer, yahoo_xfer_cancel_send);
+	purple_xfer_set_cancel_recv_fnc(xfer, yahoo_xfer_cancel_recv);
+	purple_xfer_set_read_fnc(xfer,        yahoo_xfer_read);
+	purple_xfer_set_write_fnc(xfer,       yahoo_xfer_write);
+
+	/* Now perform the request */
+	purple_xfer_request(xfer);
+}
+
+PurpleXfer *yahoo_new_xfer(PurpleConnection *gc, const char *who)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xfer_data;
+
+	g_return_val_if_fail(who != NULL, NULL);
+
+	xfer_data = g_new0(struct yahoo_xfer_data, 1);
+	xfer_data->gc = gc;
+
+	/* Build the file transfer handle. */
+	xfer = purple_xfer_new(gc->account, PURPLE_XFER_SEND, who);
+	if (xfer == NULL)
+	{
+		g_free(xfer_data);
+		g_return_val_if_reached(NULL);
+	}
+
+	xfer->data = xfer_data;
+
+	/* Setup our I/O op functions */
+	purple_xfer_set_init_fnc(xfer,        yahoo_xfer_init);
+	purple_xfer_set_start_fnc(xfer,       yahoo_xfer_start);
+	purple_xfer_set_end_fnc(xfer,         yahoo_xfer_end);
+	purple_xfer_set_cancel_send_fnc(xfer, yahoo_xfer_cancel_send);
+	purple_xfer_set_cancel_recv_fnc(xfer, yahoo_xfer_cancel_recv);
+	purple_xfer_set_read_fnc(xfer,        yahoo_xfer_read);
+	purple_xfer_set_write_fnc(xfer,       yahoo_xfer_write);
+
+	return xfer;
+}
+
+static gchar* yahoo_xfer_new_xfer_id(void)
+{
+	gchar *ans;
+	int i,j;
+	ans = g_strnfill(24, ' ');
+	ans[23] = '$';
+	ans[22] = '$';
+	for(i = 0; i < 22; i++)
+	{
+		j = g_random_int_range (0,61);
+		if(j < 26)
+			ans[i] = j + 'a';
+		else if(j < 52)
+			ans[i] = j - 26 + 'A';
+		else
+			ans[i] = j - 52 + '0';
+	}
+	return ans;
+}
+
+static void yahoo_xfer_dns_connected_15(GSList *hosts, gpointer data, const char *error_message)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+	struct sockaddr_in *addr;
+	struct yahoo_packet *pkt;
+	unsigned long actaddr;
+	unsigned char a,b,c,d;
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	YahooData *yd;
+	gchar *url;
+	gchar *filename;
+
+	if (!(xfer = data))
+		return;
+	if (!(xd = xfer->data))
+		return;
+	gc = xd->gc;
+	account = purple_connection_get_account(gc);
+	yd = gc->proto_data;
+
+	if(!hosts)
+	{
+		purple_debug_error("yahoo", "Unable to find an IP address for relay.msg.yahoo.com\n");
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	/* Discard the length... */
+	hosts = g_slist_remove(hosts, hosts->data);
+	if(!hosts)
+	{
+		purple_debug_error("yahoo", "Unable to find an IP address for relay.msg.yahoo.com\n");
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	/* TODO:actually, u must try with addr no.1 , if its not working addr no.2 ..... */
+	addr = hosts->data;
+	actaddr = addr->sin_addr.s_addr;
+	d = actaddr & 0xff;
+	actaddr >>= 8;
+	c = actaddr & 0xff;
+	actaddr >>= 8;
+	b = actaddr & 0xff;
+	actaddr >>= 8;
+	a = actaddr & 0xff;
+	if(yd->jp)
+		xd->port = YAHOOJP_XFER_RELAY_PORT;
+	else
+		xd->port = YAHOO_XFER_RELAY_PORT;
+
+	url = g_strdup_printf("%u.%u.%u.%u", d, c, b, a);
+
+	/* Free the address... */
+	g_free(hosts->data);
+	hosts = g_slist_remove(hosts, hosts->data);
+	addr = NULL;
+	while (hosts != NULL)
+	{
+		/* Discard the length... */
+		hosts = g_slist_remove(hosts, hosts->data);
+		/* Free the address... */
+		g_free(hosts->data);
+		hosts = g_slist_remove(hosts, hosts->data);
+	}
+
+	if (!purple_url_parse(url, &(xd->host), &(xd->port), &(xd->path), NULL, NULL)) {
+		purple_xfer_cancel_remote(xfer);
+		g_free(url);
+		return;
+	}
+	g_free(url);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_INFO_15, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	filename = g_path_get_basename(purple_xfer_get_local_filename(xfer));
+
+	yahoo_packet_hash(pkt, "ssssis",
+		1, purple_normalize(account, purple_account_get_username(account)),
+		5, xfer->who,
+		265, xd->xfer_peer_idstring,
+		27,  filename,
+		249, 3,
+		250, xd->host);
+
+	g_free(filename);
+	yahoo_packet_send_and_free(pkt, yd);
+}
+
+gboolean yahoo_can_receive_file(PurpleConnection *gc, const char *who)
+{
+	if (!who || yahoo_get_federation_from_name(who) != YAHOO_FEDERATION_NONE)
+		return FALSE;
+	return TRUE;
+}
+
+void yahoo_send_file(PurpleConnection *gc, const char *who, const char *file)
+{
+	struct yahoo_xfer_data *xfer_data;
+	YahooData *yd = gc->proto_data;
+	PurpleXfer *xfer = yahoo_new_xfer(gc, who);
+
+	g_return_if_fail(xfer != NULL);
+
+	/* if we don't have a p2p connection, try establishing it now */
+	if( !g_hash_table_lookup(yd->peers, who) )
+		yahoo_send_p2p_pkt(gc, who, 0);
+
+	xfer_data = xfer->data;
+	xfer_data->status_15 = STARTED;
+	purple_xfer_set_init_fnc(xfer, yahoo_xfer_init_15);
+	xfer_data->version = 15;
+	xfer_data->xfer_peer_idstring = yahoo_xfer_new_xfer_id();
+	g_hash_table_insert(yd->xfer_peer_idstring_map, xfer_data->xfer_peer_idstring, xfer);
+
+	/* Now perform the request */
+	if (file)
+		purple_xfer_request_accepted(xfer, file);
+	else
+		purple_xfer_request(xfer);
+}
+
+static void yahoo_p2p_ft_server_listen_cb(int listenfd, gpointer data);	/* using this in yahoo_xfer_send_cb_15 */
+static void yahoo_xfer_connected_15(gpointer data, gint source, const gchar *error_message);/* using this in recv_cb */
+
+static void yahoo_xfer_recv_cb_15(gpointer data, gint source, PurpleInputCondition condition)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+	int did;
+	gchar* buf;
+	gchar* t;
+	PurpleAccount *account;
+	PurpleConnection *gc;
+
+	xfer = data;
+	xd = xfer->data;
+	account = purple_connection_get_account(xd->gc);
+	gc = xd->gc;
+
+	buf=g_strnfill(1000, 0);
+	while((did = read(source, buf, 998)) > 0)
+	{
+		xd->txbuflen += did;
+		buf[did] = '\0';
+		t = xd->txbuf;
+		xd->txbuf = g_strconcat(t,buf,NULL);
+		g_free(t);
+	}
+	g_free(buf);
+
+	if (did < 0 && errno == EAGAIN)
+		return;
+	else if (did < 0) {
+		purple_debug_error("yahoo", "Unable to write in order to start ft errno = %d\n", errno);
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	purple_input_remove(xd->tx_handler);
+	xd->tx_handler = 0;
+	xd->txbuflen = 0;
+
+	if(xd->status_15 == HEAD_REQUESTED) {
+		xd->status_15 = HEAD_REPLY_RECEIVED;
+		close(source);/* Is this required? */
+		g_free(xd->txbuf);
+		xd->txbuf = NULL;
+		if (purple_proxy_connect(gc, account, xd->host, xd->port, yahoo_xfer_connected_15, xfer) == NULL)
+		{
+			purple_notify_error(gc, NULL, _("File Transfer Failed"),
+				_("Unable to establish file descriptor."));
+			purple_xfer_cancel_remote(xfer);
+		}
+	} else {
+		purple_debug_error("yahoo","Unrecognized yahoo file transfer mode and stage (ymsg15):%d,%d\n",
+						   purple_xfer_get_type(xfer),
+						   xd->status_15);
+		return;
+	}
+}
+
+static void yahoo_xfer_send_cb_15(gpointer data, gint source, PurpleInputCondition condition)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+	int remaining, written;
+
+	xfer = data;
+	xd = xfer->data;
+	remaining = xd->txbuflen - xd->txbuf_written;
+	written = write(source, xd->txbuf + xd->txbuf_written, remaining);
+
+	if (written < 0 && errno == EAGAIN)
+		written = 0;
+	else if (written <= 0) {
+		purple_debug_error("yahoo", "Unable to write in order to start ft errno = %d\n", errno);
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	if (written < remaining) {
+		xd->txbuf_written += written;
+		return;
+	}
+
+	purple_input_remove(xd->tx_handler);
+	xd->tx_handler = 0;
+	g_free(xd->txbuf);
+	xd->txbuf = NULL;
+	xd->txbuflen = 0;
+	xd->txbuf_written = 0;
+
+	if(purple_xfer_get_type(xfer) == PURPLE_XFER_RECEIVE && xd->status_15 == STARTED)
+	{
+		xd->status_15 = HEAD_REQUESTED;
+		xd->tx_handler = purple_input_add(source, PURPLE_INPUT_READ, yahoo_xfer_recv_cb_15, xfer);
+		yahoo_xfer_recv_cb_15(xfer, source, PURPLE_INPUT_READ);
+	}
+	else if(purple_xfer_get_type(xfer) == PURPLE_XFER_RECEIVE && xd->status_15 == HEAD_REPLY_RECEIVED)
+	{
+		xd->status_15 = TRANSFER_PHASE;
+		xfer->fd = source;
+		purple_xfer_start(xfer, source, NULL, 0);
+	}
+	else if(purple_xfer_get_type(xfer) == PURPLE_XFER_SEND && (xd->status_15 == ACCEPTED || xd->status_15 == P2P_GET_REQUESTED) )
+	{
+		xd->status_15 = TRANSFER_PHASE;
+		xfer->fd = source;
+		/* Remove Read event */
+		purple_input_remove(xd->input_event);
+		xd->input_event = 0;
+		purple_xfer_start(xfer, source, NULL, 0);
+	}
+	else if(purple_xfer_get_type(xfer) == PURPLE_XFER_SEND && xd->status_15 == P2P_HEAD_REQUESTED)
+	{
+		xd->status_15 = P2P_HEAD_REPLIED;
+		/* Remove Read event and close descriptor */
+		purple_input_remove(xd->input_event);
+		xd->input_event = 0;
+		close(source);
+		xfer->fd = -1;
+		/* start local server, listen for connections */
+		purple_network_listen(xd->yahoo_local_p2p_ft_server_port, SOCK_STREAM, yahoo_p2p_ft_server_listen_cb, xfer);
+	}
+	else
+	{
+		purple_debug_error("yahoo", "Unrecognized yahoo file transfer mode and stage (ymsg15):%d,%d\n", purple_xfer_get_type(xfer), xd->status_15);
+		return;
+	}
+}
+
+static void yahoo_xfer_connected_15(gpointer data, gint source, const gchar *error_message)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+	PurpleAccount *account;
+	PurpleConnection *gc;
+
+	if (!(xfer = data))
+		return;
+	if (!(xd = xfer->data))
+		return;
+	gc = xd->gc;
+	account = purple_connection_get_account(gc);
+	if ((source < 0) || (xd->path == NULL) || (xd->host == NULL)) {
+		purple_xfer_error(PURPLE_XFER_RECEIVE, purple_xfer_get_account(xfer),
+			xfer->who, _("Unable to connect."));
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+	/* The first time we get here, assemble the tx buffer */
+	if (xd->txbuflen == 0)
+	{
+		gchar* cookies;
+		YahooData *yd = gc->proto_data;
+
+		/* cookies = yahoo_get_cookies(gc);
+		 * This doesn't seem to be working. The function is returning NULL, which yahoo servers don't like
+		 * For now let us not use this function */
+
+		cookies = g_strdup_printf("Y=%s; T=%s", yd->cookie_y, yd->cookie_t);
+
+		if(purple_xfer_get_type(xfer) == PURPLE_XFER_SEND && xd->status_15 == ACCEPTED)
+		{
+			if(xd->info_val_249 == 2)
+				{
+				/* sending file via p2p, we are connected as client */
+				xd->txbuf = g_strdup_printf("POST /%s HTTP/1.1\r\n"
+						"User-Agent: " YAHOO_CLIENT_USERAGENT "\r\n"
+						"Host: %s\r\n"
+						"Content-Length: %ld\r\n"
+						"Cache-Control: no-cache\r\n\r\n",
+										xd->path,
+										xd->host,
+										(long int)xfer->size);	/* to do, add Referer */
+				}
+			else
+				{
+				/* sending file via relaying */
+				xd->txbuf = g_strdup_printf("POST /relay?token=%s&sender=%s&recver=%s HTTP/1.1\r\n"
+						"Cookie:%s\r\n"
+						"User-Agent: " YAHOO_CLIENT_USERAGENT "\r\n"
+						"Host: %s\r\n"
+						"Content-Length: %ld\r\n"
+						"Cache-Control: no-cache\r\n\r\n",
+										purple_url_encode(xd->xfer_idstring_for_relay),
+										purple_normalize(account, purple_account_get_username(account)),
+										xfer->who,
+										cookies,
+										xd->host,
+										(long int)xfer->size);
+				}
+		}
+		else if(purple_xfer_get_type(xfer) == PURPLE_XFER_RECEIVE && xd->status_15 == STARTED)
+		{
+			if(xd->info_val_249 == 1)
+				{
+				/* receiving file via p2p, connected as client */
+				xd->txbuf = g_strdup_printf("HEAD /%s HTTP/1.1\r\n"
+						"Accept: */*\r\n"
+						"User-Agent: " YAHOO_CLIENT_USERAGENT "\r\n"
+						"Host: %s\r\n"
+						"Content-Length: 0\r\n"
+						"Cache-Control: no-cache\r\n\r\n",
+						xd->path,xd->host);
+			}
+			else
+				{
+				/* receiving file via relaying */
+				xd->txbuf = g_strdup_printf("HEAD /relay?token=%s&sender=%s&recver=%s HTTP/1.1\r\n"
+						"Accept: */*\r\n"
+						"Cookie: %s\r\n"
+						"User-Agent: " YAHOO_CLIENT_USERAGENT "\r\n"
+						"Host: %s\r\n"
+						"Content-Length: 0\r\n"
+						"Cache-Control: no-cache\r\n\r\n",
+										purple_url_encode(xd->xfer_idstring_for_relay),
+										purple_normalize(account, purple_account_get_username(account)),
+										xfer->who,
+										cookies,
+										xd->host);
+			}
+		}
+		else if(purple_xfer_get_type(xfer) == PURPLE_XFER_RECEIVE && xd->status_15 == HEAD_REPLY_RECEIVED)
+		{
+			if(xd->info_val_249 == 1)
+				{
+				/* receiving file via p2p, connected as client */
+				xd->txbuf = g_strdup_printf("GET /%s HTTP/1.1\r\n"
+						"User-Agent: " YAHOO_CLIENT_USERAGENT "\r\n"
+						"Host: %s\r\n"
+						"Connection: Keep-Alive\r\n\r\n",
+						xd->path, xd->host);
+			}
+			else
+				{
+				/* receiving file via relaying */
+				xd->txbuf = g_strdup_printf("GET /relay?token=%s&sender=%s&recver=%s HTTP/1.1\r\n"
+						"Cookie: %s\r\n"
+						"User-Agent: " YAHOO_CLIENT_USERAGENT "\r\n"
+						"Host: %s\r\n"
+						"Connection: Keep-Alive\r\n\r\n",
+										purple_url_encode(xd->xfer_idstring_for_relay),
+										purple_normalize(account, purple_account_get_username(account)),
+										xfer->who,
+										cookies,
+										xd->host);
+			}
+		}
+		else
+		{
+			purple_debug_error("yahoo", "Unrecognized yahoo file transfer mode and stage (ymsg15):%d,%d\n", purple_xfer_get_type(xfer), xd->status_15);
+			g_free(cookies);
+			return;
+		}
+		xd->txbuflen = strlen(xd->txbuf);
+		xd->txbuf_written = 0;
+		g_free(cookies);
+	}
+
+	if (!xd->tx_handler)
+	{
+		xd->tx_handler = purple_input_add(source, PURPLE_INPUT_WRITE,
+			yahoo_xfer_send_cb_15, xfer);
+		yahoo_xfer_send_cb_15(xfer, source, PURPLE_INPUT_WRITE);
+	}
+}
+
+static void yahoo_p2p_ft_POST_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+
+	xfer = data;
+	if (!(xd = xfer->data))	{
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	purple_input_remove(xd->input_event);
+	xd->status_15 = TRANSFER_PHASE;
+	xfer->fd = source;
+	purple_xfer_start(xfer, source, NULL, 0);
+}
+
+static void yahoo_p2p_ft_HEAD_GET_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+	guchar buf[1024];
+	int len;
+	char *url_head;
+	char *url_get;
+	time_t unix_time;
+	char *time_str;
+
+	xfer = data;
+	if (!(xd = xfer->data))	{
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	len = read(source, buf, sizeof(buf));
+	if ((len < 0) && ((errno == EAGAIN) || (errno == EWOULDBLOCK)))
+		return ; /* No Worries*/
+	else if (len <= 0)	{
+		purple_debug_warning("yahoo","p2p-ft: Error in connection, or host disconnected\n");
+		purple_input_remove(xd->input_event);
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	url_head = g_strdup_printf("HEAD %s", xd->xfer_url);
+	url_get = g_strdup_printf("GET %s", xd->xfer_url);
+
+	if( strncmp(url_head, (char *)buf, strlen(url_head)) == 0 )
+		xd->status_15 = P2P_HEAD_REQUESTED;
+	else if( strncmp(url_get, (char *)buf, strlen(url_get)) == 0 )
+		xd->status_15 = P2P_GET_REQUESTED;
+	else	{
+		purple_debug_warning("yahoo","p2p-ft: Wrong HEAD/GET request from peer, disconnecting host\n");
+		purple_input_remove(xd->input_event);
+		purple_xfer_cancel_remote(xfer);
+		g_free(url_head);
+		return;
+	}
+
+	unix_time = time(NULL);
+	time_str = ctime(&unix_time);
+	time_str[strlen(time_str) - 1] = '\0';
+
+	if (xd->txbuflen == 0)	{
+		xd->txbuf = g_strdup_printf("HTTP/1.0 200 OK\r\n"
+		                            "Date: %s GMT\r\n"
+		                            "Server: Y!/1.0\r\n"
+		                            "MIME-version: 1.0\r\n"
+		                            "Last-modified: %s GMT\r\n"
+		                            "Content-length: %" G_GSIZE_FORMAT "\r\n\r\n",
+		                            time_str, time_str, xfer->size);
+		xd->txbuflen = strlen(xd->txbuf);
+		xd->txbuf_written = 0;
+	}
+
+	if (!xd->tx_handler)	{
+		xd->tx_handler = purple_input_add(source, PURPLE_INPUT_WRITE, yahoo_xfer_send_cb_15, xfer);
+		yahoo_xfer_send_cb_15(xfer, source, PURPLE_INPUT_WRITE);
+	}
+
+	g_free(url_head);
+	g_free(url_get);
+}
+
+static void yahoo_p2p_ft_server_send_connected_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	int acceptfd;
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+
+	xfer = data;
+	if (!(xd = xfer->data))	{
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	acceptfd = accept(source, NULL, 0);
+	if(acceptfd == -1 && (errno == EAGAIN || errno == EWOULDBLOCK))
+		return;
+	else if(acceptfd == -1) {
+		purple_debug_warning("yahoo","yahoo_p2p_server_send_connected_cb: accept: %s\n", g_strerror(errno));
+		purple_xfer_cancel_remote(xfer);
+		/* remove watcher and close p2p ft server */
+		purple_input_remove(xd->yahoo_p2p_ft_server_watcher);
+		close(xd->yahoo_local_p2p_ft_server_fd);
+		return;
+	}
+
+	/* remove watcher and close p2p ft server */
+	purple_input_remove(xd->yahoo_p2p_ft_server_watcher);
+	close(xd->yahoo_local_p2p_ft_server_fd);
+
+	/* Add an Input Read event to the file descriptor */
+	xfer->fd = acceptfd;
+	if(xfer->type == PURPLE_XFER_RECEIVE)
+		xd->input_event = purple_input_add(acceptfd, PURPLE_INPUT_READ, yahoo_p2p_ft_POST_cb, data);
+	else
+		xd->input_event = purple_input_add(acceptfd, PURPLE_INPUT_READ, yahoo_p2p_ft_HEAD_GET_cb, data);
+}
+
+static void yahoo_p2p_ft_server_listen_cb(int listenfd, gpointer data)
+{
+	PurpleXfer *xfer;
+	struct yahoo_xfer_data *xd;
+	struct yahoo_packet *pkt;
+	PurpleAccount *account;
+	YahooData *yd;
+	gchar *filename;
+	const char *local_ip;
+	gchar *url_to_send = NULL;
+	char *filename_without_spaces = NULL;
+
+	xfer = data;
+	if (!(xd = xfer->data) || (listenfd == -1))	{
+		purple_debug_warning("yahoo","p2p: error starting server for p2p file transfer\n");
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	if( (xfer->type == PURPLE_XFER_RECEIVE) || (xd->status_15 != P2P_HEAD_REPLIED) )	{
+		yd = xd->gc->proto_data;
+		account = purple_connection_get_account(xd->gc);
+		local_ip = purple_network_get_my_ip(listenfd);
+		xd->yahoo_local_p2p_ft_server_port = purple_network_get_port_from_fd(listenfd);
+
+		filename = g_path_get_basename(purple_xfer_get_local_filename(xfer));
+		filename_without_spaces = g_strdup(filename);
+		purple_util_chrreplace(filename_without_spaces, ' ', '+');
+		xd->xfer_url = g_strdup_printf("/Messenger.%s.%d000%s?AppID=Messenger&UserID=%s&K=lc9lu2u89gz1llmplwksajkjx", xfer->who, (int)time(NULL), filename_without_spaces, xfer->who);
+		url_to_send = g_strdup_printf("http://%s:%d%s", local_ip, xd->yahoo_local_p2p_ft_server_port, xd->xfer_url);
+
+		if(xfer->type == PURPLE_XFER_RECEIVE)	{
+			xd->info_val_249 = 2;	/* 249=2: we are p2p server, and receiving file */
+			pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_ACC_15,
+				YAHOO_STATUS_AVAILABLE, yd->session_id);
+			yahoo_packet_hash(pkt, "ssssis",
+				1, purple_normalize(account, purple_account_get_username(account)),
+				5, xfer->who,
+				265, xd->xfer_peer_idstring,
+				27, xfer->filename,
+				249, 2,
+				250, url_to_send);
+		}
+		else	{
+			xd->info_val_249 = 1;	/* 249=1: we are p2p server, and sending file */
+			pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_INFO_15, YAHOO_STATUS_AVAILABLE, yd->session_id);
+			yahoo_packet_hash(pkt, "ssssis",
+				1, purple_normalize(account, purple_account_get_username(account)),
+				5, xfer->who,
+				265, xd->xfer_peer_idstring,
+				27,  filename,
+				249, 1,
+				250, url_to_send);
+		}
+
+		yahoo_packet_send_and_free(pkt, yd);
+
+		g_free(filename);
+		g_free(url_to_send);
+		g_free(filename_without_spaces);
+	}
+
+	/* Add an Input Read event to the file descriptor */
+	xd->yahoo_local_p2p_ft_server_fd = listenfd;
+	xd->yahoo_p2p_ft_server_watcher = purple_input_add(listenfd, PURPLE_INPUT_READ, yahoo_p2p_ft_server_send_connected_cb, data);
+}
+
+/* send (p2p) file transfer information */
+static void yahoo_p2p_client_send_ft_info(PurpleConnection *gc, PurpleXfer *xfer)
+{
+	struct yahoo_xfer_data *xd;
+	struct yahoo_packet *pkt;
+	PurpleAccount *account;
+	YahooData *yd;
+	gchar *filename;
+	struct yahoo_p2p_data *p2p_data;
+
+	if (!(xd = xfer->data))
+		return;
+
+	account = purple_connection_get_account(gc);
+	yd = gc->proto_data;
+
+	p2p_data = g_hash_table_lookup(yd->peers, xfer->who);
+	if( p2p_data->connection_type == YAHOO_P2P_WE_ARE_SERVER )
+		if(purple_network_listen_range(0, 0, SOCK_STREAM, yahoo_p2p_ft_server_listen_cb, xfer))
+			return;
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_INFO_15, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	filename = g_path_get_basename(purple_xfer_get_local_filename(xfer));
+
+	yahoo_packet_hash(pkt, "ssssi",
+		1, purple_normalize(account, purple_account_get_username(account)),
+		5, xfer->who,
+		265, xd->xfer_peer_idstring,
+		27,  filename,
+		249, 2);	/* 249=2: we are p2p client */
+	xd->info_val_249 = 2;
+	yahoo_packet_send_and_free(pkt, yd);
+
+	g_free(filename);
+}
+
+void yahoo_process_filetrans_15(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	char *from = NULL;
+	char *imv = NULL;
+	long val_222 = 0L;
+	PurpleXfer *xfer;
+	YahooData *yd;
+	struct yahoo_xfer_data *xfer_data;
+	char *service = NULL;
+	char *filename = NULL;
+	char *xfer_peer_idstring = NULL;
+	char *utf8_filename;
+	unsigned long filesize = 0L;
+	GSList *l;
+	GSList *filename_list = NULL;
+	GSList *size_list = NULL;
+	int nooffiles = 0;
+
+	yd = gc->proto_data;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 4:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				from = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 5: /* to */
+			break;
+		case 265:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				xfer_peer_idstring = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 27:
+			filename_list = g_slist_prepend(filename_list, g_strdup(pair->value));
+			nooffiles++;
+			break;
+		case 28:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				size_list = g_slist_prepend(size_list, g_strdup(pair->value));
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 222:
+			val_222 = atol(pair->value);
+			/* 1=send, 2=cancel, 3=accept, 4=reject */
+			break;
+
+		/* check for p2p and imviron .... not sure it comes by this service packet. Since it was bundled with filexfer in old ymsg version, still keeping it. */
+		case 49:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				service = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 63:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				imv = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		/* end check */
+
+		}
+	}
+	if(!xfer_peer_idstring)
+		return;
+
+	if(val_222 == 2 || val_222 == 4)
+	{
+		xfer = g_hash_table_lookup(yd->xfer_peer_idstring_map,
+								   xfer_peer_idstring);
+		if(!xfer) return;
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+	if(val_222 == 3)
+	{
+		PurpleAccount *account;
+		xfer = g_hash_table_lookup(yd->xfer_peer_idstring_map,
+								   xfer_peer_idstring);
+		if(!xfer)
+			return;
+		/*
+		*	In the file trans info packet that we must reply with, we are
+		*	supposed to mention the ip address...
+		*	purple connect does not give me a way of finding the ip address...
+		*	so, purple dnsquery is used... but retries, trying with next ip
+		*	address etc. is not implemented..TODO
+		*/
+
+		/* To send through p2p */
+		if( g_hash_table_lookup(yd->peers, from) )	{
+			/* send p2p file transfer information */
+			yahoo_p2p_client_send_ft_info(gc, xfer);
+			return;
+		}
+
+		account = purple_connection_get_account(gc);
+		if (yd->jp)
+		{
+			purple_dnsquery_a_account(account, YAHOOJP_XFER_RELAY_HOST,
+							YAHOOJP_XFER_RELAY_PORT,
+							yahoo_xfer_dns_connected_15, xfer);
+		}
+		else
+		{
+			purple_dnsquery_a_account(account, YAHOO_XFER_RELAY_HOST,
+							YAHOO_XFER_RELAY_PORT,
+							yahoo_xfer_dns_connected_15, xfer);
+		}
+		return;
+	}
+
+	/* processing for p2p and imviron .... not sure it comes by this service packet. Since it was bundled with filexfer in old ymsg version, still keeping it. */
+	/*
+	* The remote user has changed their IMVironment.  We
+	* record it for later use.
+	*/
+	if (from && imv && service && (strcmp("IMVIRONMENT", service) == 0)) {
+		g_hash_table_replace(yd->imvironments, g_strdup(from), g_strdup(imv));
+		return;
+	}
+
+	if (pkt->service == YAHOO_SERVICE_P2PFILEXFER) {
+		if (service && (strcmp("FILEXFER", service) != 0)) {
+			purple_debug_misc("yahoo", "unhandled service 0x%02x\n", pkt->service);
+			return;
+		}
+	}
+	/* end processing */
+
+	if(!filename_list)
+		return;
+	/* have to change list into order in which client at other end sends */
+	filename_list = g_slist_reverse(filename_list);
+	size_list = g_slist_reverse(size_list);
+	filename = filename_list->data;
+	filesize = atol(size_list->data);
+
+	if(!from) return;
+	xfer_data = g_new0(struct yahoo_xfer_data, 1);
+	xfer_data->version = 15;
+	xfer_data->firstoflist = TRUE;
+	xfer_data->gc = gc;
+	xfer_data->xfer_peer_idstring = g_strdup(xfer_peer_idstring);
+	xfer_data->filename_list = filename_list;
+	xfer_data->size_list = size_list;
+
+	/* Build the file transfer handle. */
+	xfer = purple_xfer_new(gc->account, PURPLE_XFER_RECEIVE, from);
+	if (xfer == NULL)
+	{
+		g_free(xfer_data);
+		g_return_if_reached();
+	}
+
+	xfer->message = NULL;
+
+	/* Set the info about the incoming file. */
+	utf8_filename = yahoo_string_decode(gc, filename, TRUE);
+	purple_xfer_set_filename(xfer, utf8_filename);
+	g_free(utf8_filename);
+	purple_xfer_set_size(xfer, filesize);
+
+	xfer->data = xfer_data;
+
+	/* Setup our I/O op functions */
+	purple_xfer_set_init_fnc(xfer,        yahoo_xfer_init_15);
+	purple_xfer_set_start_fnc(xfer,       yahoo_xfer_start);
+	purple_xfer_set_end_fnc(xfer,         yahoo_xfer_end);
+	purple_xfer_set_cancel_send_fnc(xfer, yahoo_xfer_cancel_send);
+	purple_xfer_set_cancel_recv_fnc(xfer, yahoo_xfer_cancel_recv);
+	purple_xfer_set_read_fnc(xfer,        yahoo_xfer_read);
+	purple_xfer_set_write_fnc(xfer,       yahoo_xfer_write);
+	purple_xfer_set_request_denied_fnc(xfer,yahoo_xfer_cancel_recv);
+
+	g_hash_table_insert(yd->xfer_peer_idstring_map,
+						xfer_data->xfer_peer_idstring,
+						xfer);
+
+	if(nooffiles > 1) {
+		gchar* message;
+		message = g_strdup_printf(_("%s is trying to send you a group of %d files.\n"), xfer->who, nooffiles);
+		purple_xfer_conversation_write(xfer, message, FALSE);
+		g_free(message);
+	}
+	/* Now perform the request */
+	purple_xfer_request(xfer);
+}
+
+void yahoo_process_filetrans_info_15(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	char *url = NULL;
+	long val_249 = 0;
+	long val_66 = 0;
+	PurpleXfer *xfer;
+	YahooData *yd;
+	struct yahoo_xfer_data *xfer_data;
+	char *xfer_peer_idstring = NULL;
+	char *xfer_idstring_for_relay = NULL;
+	GSList *l;
+	struct yahoo_packet *pkt_to_send;
+	struct yahoo_p2p_data *p2p_data;
+
+	yd = gc->proto_data;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 4: /* from */
+			break;
+		case 5: /* to */
+			break;
+		case 265:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				xfer_peer_idstring = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_info_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 27: /* filename */
+			break;
+		case 66:
+			val_66 = strtol(pair->value, NULL, 10);
+			break;
+		case 249:
+			val_249 = strtol(pair->value, NULL, 10);
+			/* 249 has value 1 or 2 when doing p2p transfer and value 3 when relaying through yahoo server */
+			break;
+		case 250:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				url = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_info_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 251:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				xfer_idstring_for_relay = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_info_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		}
+	}
+
+	if(!xfer_peer_idstring)
+		return;
+
+	xfer = g_hash_table_lookup(yd->xfer_peer_idstring_map, xfer_peer_idstring);
+
+	if(!xfer) return;
+
+	if(val_66==-1)
+	{
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	xfer_data = xfer->data;
+
+	xfer_data->info_val_249 = val_249;
+	xfer_data->xfer_idstring_for_relay = g_strdup(xfer_idstring_for_relay);
+	if(val_249 == 1 || val_249 == 3) {
+		PurpleAccount *account;
+		if (!purple_url_parse(url, &(xfer_data->host), &(xfer_data->port), &(xfer_data->path), NULL, NULL)) {
+			purple_xfer_cancel_remote(xfer);
+			return;
+		}
+
+		account = purple_connection_get_account(xfer_data->gc);
+
+		pkt_to_send = yahoo_packet_new(YAHOO_SERVICE_FILETRANS_ACC_15,
+			YAHOO_STATUS_AVAILABLE, yd->session_id);
+		yahoo_packet_hash(pkt_to_send, "ssssis",
+			1, purple_normalize(account, purple_account_get_username(account)),
+			5, xfer->who,
+			265, xfer_data->xfer_peer_idstring,
+			27, xfer->filename,
+			249, xfer_data->info_val_249,
+			251, xfer_data->xfer_idstring_for_relay);
+
+		yahoo_packet_send_and_free(pkt_to_send, yd);
+
+		if (purple_proxy_connect(gc, account, xfer_data->host, xfer_data->port,
+			yahoo_xfer_connected_15, xfer) == NULL) {
+			purple_notify_error(gc, NULL, _("File Transfer Failed"),
+				_("Unable to establish file descriptor."));
+			purple_xfer_cancel_remote(xfer);
+		}
+	}
+	else if(val_249 == 2)	{
+		p2p_data = g_hash_table_lookup(yd->peers, xfer->who);
+		if( !( p2p_data && (p2p_data->connection_type == YAHOO_P2P_WE_ARE_SERVER) ) )	{
+			purple_xfer_cancel_remote(xfer);
+			return;
+		}
+		if(!purple_network_listen_range(0, 0, SOCK_STREAM, yahoo_p2p_ft_server_listen_cb, xfer)) {
+			purple_xfer_cancel_remote(xfer);
+			return;
+		}
+	}
+}
+
+/* TODO: Check filename etc. No probs till some hacker comes in the way */
+void yahoo_process_filetrans_acc_15(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	gchar *xfer_peer_idstring = NULL;
+	gchar *xfer_idstring_for_relay = NULL;
+	PurpleXfer *xfer;
+	YahooData *yd;
+	struct yahoo_xfer_data *xfer_data;
+	GSList *l;
+	PurpleAccount *account;
+	long val_66 = 0;
+	gchar *url = NULL;
+	int val_249 = 0;
+
+	yd = gc->proto_data;
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 251:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				xfer_idstring_for_relay = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_acc_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 265:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				xfer_peer_idstring = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_acc_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 66:
+			val_66 = atol(pair->value);
+			break;
+		case 249:
+			val_249 = atol(pair->value);
+			break;
+		case 250:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				/* we get a p2p url here when sending file, connected as client */
+				url = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_filetrans_acc_15 "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		}
+	}
+
+	xfer = g_hash_table_lookup(yd->xfer_peer_idstring_map, xfer_peer_idstring);
+	if(!xfer) return;
+
+	if(val_66 == -1 || ( (!(xfer_idstring_for_relay)) && (val_249 != 2) ))
+	{
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	if( (val_249 == 2) && (!(url)) )
+	{
+		purple_xfer_cancel_remote(xfer);
+		return;
+	}
+
+	xfer_data = xfer->data;
+	if(url)
+		purple_url_parse(url, &(xfer_data->host), &(xfer_data->port), &(xfer_data->path), NULL, NULL);
+
+	xfer_data->xfer_idstring_for_relay = g_strdup(xfer_idstring_for_relay);
+	xfer_data->status_15 = ACCEPTED;
+	account = purple_connection_get_account(gc);
+
+	if (purple_proxy_connect(gc, account, xfer_data->host, xfer_data->port,
+		yahoo_xfer_connected_15, xfer) == NULL)
+	{
+		purple_notify_error(gc, NULL, _("File Transfer Failed"),_("Unable to connect"));
+			purple_xfer_cancel_remote(xfer);
+	}
+}
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoo_packet.c pidgin-2.10.11/libpurple/protocols/yahoo/yahoo_packet.c
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoo_packet.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/yahoo_packet.c	2015-02-10 14:28:16.397352379 +0900
@@ -42,6 +42,7 @@
 {
 	struct yahoo_pair *pair;
 
+	g_return_if_fail(pkt != NULL);
 	g_return_if_fail(value != NULL);
 
 	pair = g_new0(struct yahoo_pair, 1);
@@ -54,6 +55,8 @@
 {
 	struct yahoo_pair *pair;
 
+	g_return_if_fail(pkt != NULL);
+
 	pair = g_new0(struct yahoo_pair, 1);
 	pair->key = key;
 	pair->value = g_strdup_printf("%d", value);
@@ -386,6 +389,9 @@
 {
 	int ret;
 
+	g_return_val_if_fail(pkt != NULL, 0);
+	g_return_val_if_fail(yd != NULL, 0);
+
 	ret = yahoo_packet_send(pkt, yd);
 	yahoo_packet_free(pkt);
 	return ret;
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoo_profile.c pidgin-2.10.11/libpurple/protocols/yahoo/yahoo_profile.c
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoo_profile.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/yahoo_profile.c	2015-02-10 14:28:16.397352379 +0900
@@ -22,6 +22,7 @@
  */
 
 #define PHOTO_SUPPORT 1
+//original is 1 --yaz
 
 #include "internal.h"
 #include "debug.h"
@@ -670,6 +671,7 @@
 	},
 };
 
+#if 0
 static char *yahoo_info_date_reformat(const char *field, size_t len)
 {
 	char *tmp = g_strndup(field, len);
@@ -678,6 +680,7 @@
 	g_free(tmp);
 	return g_strdup(purple_date_format_short(localtime(&t)));
 }
+#endif
 
 static char *yahoo_remove_nonbreaking_spaces(char *str)
 {
@@ -761,6 +764,7 @@
 
 #endif /* PHOTO_SUPPORT */
 
+#define PROF_LEN (1024 * 10)
 static void yahoo_got_info(PurpleUtilFetchUrlData *url_data, gpointer user_data,
 		const gchar *url_text, size_t len, const gchar *error_message)
 {
@@ -1009,6 +1013,9 @@
 			g_free(stripped);
 			stripped = purple_utf8_ncr_decode(p);
 			stripped_len = strlen(stripped);
+
+			purple_debug_misc("yahoo", "after utf8 conversion: stripped@1 = (%s)\n",
+                              stripped); //payload --yaz
 			g_free(p);
 		}
 	}
@@ -1020,7 +1027,7 @@
 				strings->charset, NULL, NULL, NULL);
 		yahoo_remove_nonbreaking_spaces(last_updated_utf8_string);
 
-		purple_debug_misc("yahoo", "after utf8 conversion: stripped = (%s)\n", stripped);
+		purple_debug_misc("yahoo", "after utf8 conversion: stripped = (%s)\n", stripped); //payload --yaz
 	}
 
 	if (strings && profile_state == PROFILE_STATE_DEFAULT) {
@@ -1053,16 +1060,17 @@
 		}
 	}
 #endif /* PHOTO_SUPPORT */
+	purple_debug_info("yahoo", "email = %s\n", strings->my_email_string);
 
 	/* extract their Email address and put it in */
 	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
 			strings->my_email_string, (yd->jp ? 4 : 1), " ", 0,
 			strings->private_string, _("Email"), 0, NULL, NULL);
-
+#if 0
 	/* extract the Nickname if it exists */
 	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
 			"Nickname:", 1, "\n", '\n',
-			NULL, _("Nickname"), 0, NULL, NULL);
+			 NULL, _("Nickname"), 0, NULL, NULL);
 
 	/* extract their RealName and put it in */
 	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
@@ -1093,7 +1101,7 @@
 	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
 			strings->occupation_string, 2, "\n", '\n',
 			NULL, _("Occupation"), 0, NULL, NULL);
-
+#endif
 	/* Hobbies, Latest News, and Favorite Quote are a bit different, since
 	 * the values can contain embedded newlines... but any or all of them
 	 * can also not appear.  The way we delimit them is to successively
@@ -1102,7 +1110,7 @@
 	 * next thing to follow this bunch.  (For Yahoo Japan, we check for
 	 * the "Description" ("Self PR") heading instead of "Links".)
 	 */
-
+#if 0
 	if (!purple_markup_extract_info_field(stripped, stripped_len, user_info,
 			strings->hobbies_string, (yd->jp ? 3 : 1), strings->latest_news_string,
 			'\n', "\n", _("Hobbies"), 0, NULL, NULL))
@@ -1188,6 +1196,7 @@
 				last_updated_utf8_string, (yd->jp ? 2 : 1), (yd->jp ? "\n" : " "), (yd->jp ? 0 : '\n'), NULL,
 				_("Last Update"), 0, NULL, (yd->jp ? NULL : yahoo_info_date_reformat));
 	}
+#endif
 	} /* if (profile_state == PROFILE_STATE_DEFAULT) */
 
 	if(!found)
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoo_profile.c.orig pidgin-2.10.11/libpurple/protocols/yahoo/yahoo_profile.c.orig
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoo_profile.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/yahoo_profile.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,1282 @@
+/*
+ * purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+
+#define PHOTO_SUPPORT 1
+
+#include "internal.h"
+#include "debug.h"
+#include "notify.h"
+#include "util.h"
+#if PHOTO_SUPPORT
+#include "imgstore.h"
+#endif /* PHOTO_SUPPORT */
+
+#include "libymsg.h"
+#include "yahoo_friend.h"
+
+typedef struct {
+	PurpleConnection *gc;
+	char *name;
+} YahooGetInfoData;
+
+typedef enum profile_lang_id {
+	XX, DA, DE, EL,
+	EN, EN_GB,
+	ES_AR, ES_ES, ES_MX, ES_US,
+	FR_CA, FR_FR,
+	IT, JA, KO, NO, PT, SV,
+	ZH_CN, ZH_HK, ZH_TW, ZH_US, PT_BR
+} profile_lang_id_t;
+
+typedef struct profile_lang_node {
+	profile_lang_id_t lang;
+	char *last_updated_string;
+	char *det;
+} profile_lang_node_t;
+
+typedef struct profile_strings_node {
+	profile_lang_id_t lang;
+	char *lang_string;                   /* Only to make debugging output saner */
+	char *charset;
+	char *yahoo_id_string;
+	char *private_string;
+	char *no_answer_string;
+	char *my_email_string;
+	char *realname_string;
+	char *location_string;
+	char *age_string;
+	char *maritalstatus_string;
+	char *gender_string;
+	char *occupation_string;
+	char *hobbies_string;
+	char *latest_news_string;
+	char *favorite_quote_string;
+	char *links_string;
+	char *no_home_page_specified_string;
+	char *home_page_string;
+	char *no_cool_link_specified_string;
+	char *cool_link_1_string;
+	char *cool_link_2_string;
+	char *cool_link_3_string;
+	char *dummy;
+} profile_strings_node_t;
+
+typedef enum profile_state {
+	PROFILE_STATE_DEFAULT,
+	PROFILE_STATE_NOT_FOUND,
+	PROFILE_STATE_UNKNOWN_LANGUAGE
+} profile_state_t;
+
+typedef struct {
+	YahooGetInfoData *info_data;
+	PurpleNotifyUserInfo *user_info;
+	char *url_buffer;
+	char *photo_url_text;
+	char *profile_url_text;
+	const profile_strings_node_t *strings;
+	const char *last_updated_string;
+	const char *title;
+	profile_state_t profile_state;
+} YahooGetInfoStepTwoData;
+
+/* Strings to determine the profile "language" (more accurately "locale").
+ * Strings in this list must be in the original charset in the profile.
+ * The "Last Updated" string is used, but sometimes is not sufficient to
+ * distinguish 2 locales with this (e.g., ES_ES from ES_US, or FR_CA from
+ * FR_FR, or EL from EN_GB), in which case a second string is added and
+ * such special cases must be placed before the more general case.
+ */
+static const profile_lang_node_t profile_langs[] = {
+	{ DA,    "Opdateret sidste gang&nbsp;",                          NULL },
+	{ DE,    "Letzter Update&nbsp;",                                 NULL },
+	{ EL,    "Last Updated:",              "http://gr.profiles.yahoo.com" },
+	{ EN_GB, "Last Update&nbsp;",                      "Favourite Quote" },
+	{ EN,    "Last Update:",                                        NULL },
+	{ EN,    "Last Update&nbsp;",                                   NULL },
+	{ ES_AR, "\332ltima actualizaci\363n&nbsp;",                     NULL },
+	{ ES_ES, "Actualizada el&nbsp;",       "http://es.profiles.yahoo.com" },
+	{ ES_MX, "Actualizada el &nbsp;",      "http://mx.profiles.yahoo.com" },
+	{ ES_US, "Actualizada el &nbsp;",                                NULL },
+	{ FR_CA, "Derni\xe8re mise \xe0 jour", "http://cf.profiles.yahoo.com" },
+	{ FR_FR, "Derni\xe8re mise \xe0 jour",                           NULL },
+	{ IT,    "Ultimo aggiornamento:",                                NULL },
+	{ JA,    "\xba\xc7\xbd\xaa\xb9\xb9\xbf\xb7\xc6\xfc\xa1\xa7",     NULL },
+	{ KO,    "\xb0\xbb\xbd\xc5\x20\xb3\xaf\xc2\xa5&nbsp;",           NULL },
+	{ NO,    "Sist oppdatert&nbsp;",                                 NULL },
+	{ PT,    "\332ltima atualiza\347\343o&nbsp;",                    NULL },
+	{ PT_BR, "\332ltima atualiza\347\343o:",                         NULL },
+	{ SV,    "Senast uppdaterad&nbsp;",                              NULL },
+	{ ZH_CN, "\xd7\xee\xba\xf3\xd0\xde\xb8\xc4\xc8\xd5\xc6\xda",     NULL },
+	{ ZH_HK, "\xb3\xcc\xaa\xf1\xa7\xf3\xb7\x73\xae\xc9\xb6\xa1",     NULL },
+	{ ZH_US, "\xb3\xcc\xab\xe1\xad\xd7\xa7\xef\xa4\xe9\xb4\xc1", "http://chinese.profiles.yahoo.com" },
+	{ ZH_TW, "\xb3\xcc\xab\xe1\xad\xd7\xa7\xef\xa4\xe9\xb4\xc1",     NULL },
+	{ XX,     NULL,                                                  NULL }
+};
+
+/* Strings in this list must be in UTF-8; &nbsp;'s should be specified as spaces. */
+static const profile_strings_node_t profile_strings[] = {
+	{ DA, "da", "ISO-8859-1",
+		"Yahoo! ID:",
+		"Privat",
+		"Intet svar",
+		"Min Email",
+		"Rigtige navn:",
+		"Opholdssted:",
+		"Alder:",
+		"Ægteskabelig status:",
+		"Køn:",
+		"Erhverv:",
+		"Hobbyer:",
+		"Sidste nyt:",
+		"Favoritcitat",
+		"Links",
+		"Ingen hjemmeside specificeret",
+		"Forside:",
+		"Intet cool link specificeret",
+		"Cool link 1:",
+		"Cool link 2:",
+		"Cool link 3:",
+		NULL
+	},
+	{ DE, "de", "ISO-8859-1",
+		"Yahoo!-ID:",
+		"Privat",
+		"Keine Antwort",
+		"Meine E-Mail",
+		"Realer Name:",
+		"Ort:",
+		"Alter:",
+		"Familienstand:",
+		"Geschlecht:",
+		"Beruf:",
+		"Hobbys:",
+		"Neuste Nachrichten:",
+		"Mein Lieblingsspruch",
+		"Links",
+		"Keine Homepage angegeben",
+		"Homepage:",
+		"Keinen coolen Link angegeben",
+		"Cooler Link 1:",
+		"Cooler Link 2:",
+		"Cooler Link 3:",
+		NULL
+	},
+	{ EL, "el", "ISO-8859-7", /* EL is identical to EN, except no_answer_string */
+		"Yahoo! ID:",
+		"Private",
+		"Καμία απάντηση",
+		"My Email",
+		"Real Name:",
+		"Location:",
+		"Age:",
+		"Marital Status:",
+		"Gender:",
+		"Occupation:",
+		"Hobbies:",
+		"Latest News",
+		"Favorite Quote",
+		"Links",
+		"No home page specified",
+		"Home Page:",
+		"No cool link specified",
+		"Cool Link 1:",
+		"Cool Link 2:",
+		"Cool Link 3:",
+		NULL
+	},
+	{ EN, "en", "ISO-8859-1",
+		"Yahoo! ID:",
+		"Private",
+		"No Answer",
+		"My Email:",
+		"Real Name:",
+		"Location:",
+		"Age:",
+		"Marital Status:",
+		"Sex:",
+		"Occupation:",
+		"Hobbies",
+		"Latest News",
+		"Favorite Quote",
+		"Links",
+		"No home page specified",
+		"Home Page:",
+		"No cool link specified",
+		"Cool Link 1",
+		"Cool Link 2",
+		"Cool Link 3",
+		NULL
+	},
+	{ EN_GB, "en_GB", "ISO-8859-1", /* Same as EN except spelling of "Favourite" */
+		"Yahoo! ID:",
+		"Private",
+		"No Answer",
+		"My Email:",
+		"Real Name:",
+		"Location:",
+		"Age:",
+		"Marital Status:",
+		"Sex:",
+		"Occupation:",
+		"Hobbies",
+		"Latest News",
+		"Favourite Quote",
+		"Links",
+		"No home page specified",
+		"Home Page:",
+		"No cool link specified",
+		"Cool Link 1",
+		"Cool Link 2",
+		"Cool Link 3",
+		NULL
+	},
+	{ ES_AR, "es_AR", "ISO-8859-1",
+		"Usuario de Yahoo!:",
+		"Privado",
+		"No introdujiste una respuesta",
+		"Mi dirección de correo electrónico",
+		"Nombre real:",
+		"Ubicación:",
+		"Edad:",
+		"Estado civil:",
+		"Sexo:",
+		"Ocupación:",
+		"Pasatiempos:",
+		"Últimas noticias:",
+		"Tu cita favorita",
+		"Enlaces",
+		"Ninguna página de inicio especificada",
+		"Página de inicio:",
+		"Ningún enlace preferido",
+		"Enlace genial 1:",
+		"Enlace genial 2:",
+		"Enlace genial 3:",
+		NULL
+	},
+	{ ES_ES, "es_ES", "ISO-8859-1",
+		"ID de Yahoo!:",
+		"Privado",
+		"Sin respuesta",
+		"Mi correo-e",
+		"Nombre verdadero:",
+		"Lugar:",
+		"Edad:",
+		"Estado civil:",
+		"Sexo:",
+		"Ocupación:",
+		"Aficiones:",
+		"Ultimas Noticias:",
+		"Tu cita Favorita",
+		"Enlace",
+		"Ninguna página personal especificada",
+		"Página de Inicio:",
+		"Ningún enlace preferido",
+		"Enlaces Preferidos 1:",
+		"Enlaces Preferidos 2:",
+		"Enlaces Preferidos 3:",
+		NULL
+	},
+	{ ES_MX, "es_MX", "ISO-8859-1",
+		"ID de Yahoo!:",
+		"Privado",
+		"Sin responder",
+		"Mi Dirección de correo-e",
+		"Nombre real:",
+		"Ubicación:",
+		"Edad:",
+		"Estado civil:",
+		"Sexo:",
+		"Ocupación:",
+		"Pasatiempos:",
+		"Ultimas Noticias:",
+		"Su cita favorita",
+		"Enlaces",
+		"Ninguna Página predefinida",
+		"Página web:",
+		"Ningún Enlace preferido",
+		"Enlaces Preferidos 1:",
+		"Enlaces Preferidos 2:",
+		"Enlaces Preferidos 3:",
+		NULL
+	},
+	{ ES_US, "es_US", "ISO-8859-1",
+		"ID de Yahoo!:",
+		"Privado",
+		"No introdujo una respuesta",
+		"Mi Dirección de correo-e",
+		"Nombre real:",
+		"Localidad:",
+		"Edad:",
+		"Estado civil:",
+		"Sexo:",
+		"Ocupación:",
+		"Pasatiempos:",
+		"Ultimas Noticias:",
+		"Su cita Favorita",
+		"Enlaces",
+		"Ninguna Página de inicio predefinida",
+		"Página de inicio:",
+		"Ningún Enlace preferido",
+		"Enlaces Preferidos 1:",
+		"Enlaces Preferidos 2:",
+		"Enlaces Preferidos 3:",
+		NULL
+	},
+	{ FR_CA, "fr_CA", "ISO-8859-1",
+		"Compte Yahoo!:",
+		"Privé",
+		"Sans réponse",
+		"Mon courriel",
+		"Nom réel:",
+		"Lieu:",
+		"Âge:",
+		"État civil:",
+		"Sexe:",
+		"Profession:",
+		"Passe-temps:",
+		"Actualités:",
+		"Citation préférée",
+		"Liens",
+		"Pas de mention d'une page personnelle",
+		"Page personnelle:",
+		"Pas de mention d'un lien favori",
+		"Lien préféré 1:",
+		"Lien préféré 2:",
+		"Lien préféré 3:",
+		NULL
+	},
+	{ FR_FR, "fr_FR", "ISO-8859-1",
+		"Compte Yahoo!:",
+		"Privé",
+		"Sans réponse",
+		"Mon E-mail",
+		"Nom réel:",
+		"Lieu:",
+		"Âge:",
+		"Situation de famille:",
+		"Sexe:",
+		"Profession:",
+		"Centres d'intérêts:",
+		"Actualités:",
+		"Citation préférée",
+		"Liens",
+		"Pas de mention d'une page perso",
+		"Page perso:",
+		"Pas de mention d'un lien favori",
+		"Lien préféré 1:",
+		"Lien préféré 2:",
+		"Lien préféré 3:",
+		NULL
+	},
+	{ IT, "it", "ISO-8859-1",
+		"Yahoo! ID:",
+		"Non pubblica",
+		"Nessuna risposta",
+		"La mia e-mail:",
+		"Nome vero:",
+		"Località:",
+		"Età:",
+		"Stato civile:",
+		"Sesso:",
+		"Occupazione:",
+		"Hobby",
+		"Ultime notizie",
+		"Citazione preferita",
+		"Link",
+		"Nessuna home page specificata",
+		"Inizio:",
+		"Nessun link specificato",
+		"Cool Link 1",
+		"Cool Link 2",
+		"Cool Link 3",
+		NULL
+	},
+	{ JA, "ja", "EUC-JP",
+		"Yahoo! JAPAN ID：",
+		"非公開",
+		"無回答",
+		"メール：",
+		"名前：",
+		"住所：",
+		"年齢：",
+		"未婚/既婚：",
+		"性別：",
+		"職業：",
+		"趣味：",
+		"最近の出来事：",
+		NULL,
+#if 0
+		"おすすめサイト",
+#else
+		"自己PR", /* "Self description" comes before "Links" for yahoo.co.jp */
+#endif
+		NULL,
+		NULL,
+		NULL,
+		"おすすめサイト1：",
+		"おすすめサイト2：",
+		"おすすめサイト3：",
+		NULL
+	},
+	{ KO, "ko", "EUC-KR",
+		"야후! ID:",
+		"비공개",
+		"비공개",
+		"My Email",
+		"실명:",
+		"거주지:",
+		"나이:",
+		"결혼 여부:",
+		"성별:",
+		"직업:",
+		"취미:",
+		"자기 소개:",
+		"좋아하는 명언",
+		"링크",
+		"홈페이지를 지정하지 않았습니다.",
+		"홈페이지:",
+		"추천 사이트가 없습니다.",
+		"추천 사이트 1:",
+		"추천 사이트 2:",
+		"추천 사이트 3:",
+		NULL
+	},
+	{ NO, "no", "ISO-8859-1",
+		"Yahoo! ID:",
+		"Privat",
+		"Ikke noe svar",
+		"Min e-post",
+		"Virkelig navn:",
+		"Sted:",
+		"Alder:",
+		"Sivilstatus:",
+		"Kjønn:",
+		"Yrke:",
+		"Hobbyer:",
+		"Siste nytt:",
+		"Yndlingssitat",
+		"Lenker",
+		"Ingen hjemmeside angitt",
+		"Hjemmeside:",
+		"No cool link specified",
+		"Bra lenke 1:",
+		"Bra lenke 2:",
+		"Bra lenke 3:",
+		NULL
+	},
+	{ PT, "pt", "ISO-8859-1",
+		"ID Yahoo!:",
+		"Particular",
+		"Sem resposta",
+		"Meu e-mail",
+		"Nome verdadeiro:",
+		"Local:",
+		"Idade:",
+		"Estado civil:",
+		"Sexo:",
+		"Ocupação:",
+		"Hobbies:",
+		"Últimas notícias:",
+		"Frase favorita",
+		"Links",
+		"Nenhuma página pessoal especificada",
+		"Página pessoal:",
+		"Nenhum site legal especificado",
+		"Site legal 1:",
+		"Site legal 2:",
+		"Site legal 3:",
+		NULL
+	},
+	{ PT_BR, "pt_br", "ISO-8859-1",
+		"ID Yahoo!:",
+		"Particular",
+		"Sem resposta",
+		"Meu e-mail",
+		"Nome verdadeiro:",
+		"Localização:",
+		"Idade:",
+		"Estado civil:",
+		"Sexo:",
+		"Ocupação:",
+		"Pasatiempos:",
+		"Últimas novidades:",
+		"Frase preferida:",
+		"Links",
+		"Nenhuma home page especificada",
+		"Página Web:",
+		"Nenhum site legal especificado",
+		"Link legal 1",
+		"Link legal 2",
+		"Link legal 3",
+		NULL
+	},
+	{ SV, "sv", "ISO-8859-1",
+		"Yahoo!-ID:",
+		"Privat",
+		"Inget svar",
+		"Min mail",
+		"Riktigt namn:",
+		"Plats:",
+		"Ålder:",
+		"Civilstånd:",
+		"Kön:",
+		"Yrke:",
+		"Hobby:",
+		"Senaste nytt:",
+		"Favoritcitat",
+		"Länkar",
+		"Ingen hemsida specificerad",
+		"Hemsida:",
+		"Ingen cool länk specificerad",
+		"Coola länkar 1:",
+		"Coola länkar 2:",
+		"Coola länkar 3:",
+		NULL
+	},
+	{ ZH_CN, "zh_CN", "GB2312",
+		"Yahoo! ID:",
+		"没有提供",
+		"没有回答",
+		"个人电邮地址",
+		"真实姓名:",
+		"所在地点:",
+		"年龄:",
+		"婚姻状况:",
+		"性别:",
+		"职业:",
+		"业余爱好:",
+		"个人近况:",
+		"喜欢的引言",
+		"链接",
+		"没有个人主页",
+		"个人主页:",
+		"没有推荐网站链接",
+		"推荐网站链接 1:",
+		"推荐网站链接 2:",
+		"推荐网站链接 3:",
+		NULL
+	},
+	{ ZH_HK, "zh_HK", "Big5",
+		"Yahoo! ID:",
+		"私人的",
+		"沒有回答",
+		"電子信箱",
+		"真實姓名:",
+		"地點:",
+		"年齡:",
+		"婚姻狀況:",
+		"性別:",
+		"職業:",
+		"嗜好:",
+		"最新消息:",
+		"最喜愛的股票叫價", /* [sic] Yahoo!'s translators don't check context */
+		"連結",
+		"沒有注明個人網頁", /* [sic] */
+		"個人網頁:",
+		"沒有注明 Cool 連結", /* [sic] */
+		"Cool 連結 1:", /* TODO */
+		"Cool 連結 2:", /* TODO */
+		"Cool 連結 3:", /* TODO */
+		NULL
+	},
+	{ ZH_TW, "zh_TW", "Big5",
+		"帳 號:",
+		"沒有提供",
+		"沒有回應",
+		"電子信箱",
+		"姓名:",
+		"地點:",
+		"年齡:",
+		"婚姻狀態:",
+		"性別:",
+		"職業:",
+		"興趣:",
+		"個人近況:",
+		"喜歡的名句",
+		"連結",
+		"沒有個人網頁",
+		"個人網頁:",
+		"沒有推薦網站連結",
+		"推薦網站連結 1:",
+		"推薦網站連結 2:",
+		"推薦網站連結 3:",
+		NULL
+	},
+	{ ZH_US, "zh_US", "Big5", /* ZH_US is like ZH_TW, but also a bit like ZH_HK */
+		"Yahoo! ID:",
+		"沒有提供",
+		"沒有回答",
+		"個人Email地址",
+		"真實姓名:",
+		"地點:",
+		"年齡:",
+		"婚姻狀態:",
+		"性別:",
+		"職業:",
+		"嗜好:",
+		"個人近況:",
+		"喜歡的名句",
+		"連結",
+		"沒有個人網頁",
+		"個人網頁:",
+		"沒有推薦網站連結",
+		"推薦網站連結 1:", /* TODO */
+		"推薦網站連結 2:", /* TODO */
+		"推薦網站連結 3:", /* TODO */
+		NULL
+	},
+	{ XX, NULL, NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL
+	},
+};
+
+static char *yahoo_info_date_reformat(const char *field, size_t len)
+{
+	char *tmp = g_strndup(field, len);
+	time_t t = purple_str_to_time(tmp, FALSE, NULL, NULL, NULL);
+
+	g_free(tmp);
+	return g_strdup(purple_date_format_short(localtime(&t)));
+}
+
+static char *yahoo_remove_nonbreaking_spaces(char *str)
+{
+	char *p;
+	while ((p = strstr(str, "&nbsp;")) != NULL) {
+		*p = ' '; /* Turn &nbsp;'s into ordinary blanks */
+		p += 1;
+		memmove(p, p + 5, strlen(p + 5));
+		str[strlen(str) - 5] = '\0';
+	}
+	return str;
+}
+
+static void yahoo_extract_user_info_text(PurpleNotifyUserInfo *user_info, YahooGetInfoData *info_data) {
+	PurpleBuddy *b;
+	YahooFriend *f;
+
+	b = purple_find_buddy(purple_connection_get_account(info_data->gc),
+			info_data->name);
+
+	if (b) {
+		const char *balias = purple_buddy_get_local_buddy_alias(b);
+		if(balias && balias[0]) {
+			purple_notify_user_info_add_pair_plaintext(user_info, _("Alias"), balias);
+		}
+		#if 0
+		if (b->idle > 0) {
+			char *idletime = purple_str_seconds_to_string(time(NULL) - b->idle);
+			purple_notify_user_info_add_pair_plaintext(user_info, _("Idle"), idletime);
+			g_free(idletime);
+		}
+		#endif
+
+		/* Add the normal tooltip pairs */
+		yahoo_tooltip_text(b, user_info, TRUE);
+
+		if ((f = yahoo_friend_find(info_data->gc, purple_buddy_get_name(b)))) {
+			const char *ip;
+			if ((ip = yahoo_friend_get_ip(f)))
+				purple_notify_user_info_add_pair_plaintext(user_info, _("IP Address"), ip);
+		}
+	}
+}
+
+#if PHOTO_SUPPORT
+
+static char *yahoo_get_photo_url(const char *url_text, const char *name) {
+	GString *s = g_string_sized_new(strlen(name) + 8);
+	char *p;
+	char *it = NULL;
+
+	/*g_string_printf(s, " alt=\"%s\">", name);*/
+	/* Y! newformat */
+	g_string_printf(s, " alt=%s>", name);
+	p = strstr(url_text, s->str);
+
+	if (p) {
+		/* Search backwards for "http://". This is stupid, but it works. */
+		for (; !it && p > url_text; p -= 1) {
+			/*if (strncmp(p, "\"http://", 8) == 0) {*/
+			/* Y! newformat*/
+			if (strncmp(p, "=http://", 8) == 0) {
+				char *q;
+				p += 1; /* skip only the ' ' */
+				q = strchr(p, ' ');
+				if (q) {
+					g_free(it);
+					it = g_strndup(p, q - p);
+				}
+			}
+		}
+	}
+
+	g_string_free(s, TRUE);
+	return it;
+}
+
+static void
+yahoo_got_photo(PurpleUtilFetchUrlData *url_data, gpointer data,
+		const gchar *url_text, size_t len, const gchar *error_message);
+
+#endif /* PHOTO_SUPPORT */
+
+static void yahoo_got_info(PurpleUtilFetchUrlData *url_data, gpointer user_data,
+		const gchar *url_text, size_t len, const gchar *error_message)
+{
+	YahooGetInfoData *info_data = (YahooGetInfoData *)user_data;
+	PurpleNotifyUserInfo *user_info;
+	char *p;
+#if PHOTO_SUPPORT
+	YahooGetInfoStepTwoData *info2_data;
+	char *photo_url_text = NULL;
+#else
+	gboolean found = FALSE;
+	char *stripped;
+	int stripped_len;
+	char *last_updated_utf8_string = NULL;
+#endif /* !PHOTO_SUPPORT */
+	const char *last_updated_string = NULL;
+	char *url_buffer;
+	GString *s;
+	char *tmp;
+	char *profile_url_text = NULL;
+	int lang, strid;
+	YahooData *yd;
+	const profile_strings_node_t *strings = NULL;
+	const char *title;
+	profile_state_t profile_state = PROFILE_STATE_DEFAULT;
+
+	purple_debug_info("yahoo", "In yahoo_got_info\n");
+
+	yd = info_data->gc->proto_data;
+	yd->url_datas = g_slist_remove(yd->url_datas, url_data);
+
+	user_info = purple_notify_user_info_new();
+
+	title = yd->jp ? _("Yahoo! Japan Profile") :
+					 _("Yahoo! Profile");
+
+	/* Get the tooltip info string */
+	yahoo_extract_user_info_text(user_info, info_data);
+
+	/* We failed to grab the profile URL.  This is not expected to actually
+	 * happen except under unusual error conditions, as Yahoo is observed
+	 * to send back HTML, with a 200 status code.
+	 */
+	if (error_message != NULL || url_text == NULL || strcmp(url_text, "") == 0) {
+		purple_notify_user_info_add_pair(user_info, _("Error retrieving profile"), NULL);
+		purple_notify_userinfo(info_data->gc, info_data->name,
+			user_info, NULL, NULL);
+		purple_notify_user_info_destroy(user_info);
+		g_free(profile_url_text);
+		g_free(info_data->name);
+		g_free(info_data);
+		return;
+	}
+
+	/* Construct the correct profile URL */
+	s = g_string_sized_new(80); /* wild guess */
+	g_string_printf(s, "%s%s", (yd->jp? YAHOOJP_PROFILE_URL: YAHOO_PROFILE_URL),
+		info_data->name);
+	profile_url_text = g_string_free(s, FALSE);
+	s = NULL;
+
+	/* We don't yet support the multiple link level of the warning page for
+	 * 'adult' profiles, not to mention the fact that yahoo wants you to be
+	 * logged in (on the website) to be able to view an 'adult' profile.  For
+	 * now, just tell them that we can't help them, and provide a link to the
+	 * profile if they want to do the web browser thing.
+	 */
+	p = strstr(url_text, "Adult Profiles Warning Message");
+	if (!p) {
+		p = strstr(url_text, "Adult Content Warning"); /* TITLE element */
+	}
+	if (p) {
+		tmp = g_strdup_printf("<b>%s</b><br><br>"
+							  "%s<br><a href=\"%s\">%s</a>",
+						_("Sorry, profiles marked as containing adult content "
+						"are not supported at this time."),
+						 _("If you wish to view this profile, "
+						"you will need to visit this link in your web browser:"),
+						 profile_url_text, profile_url_text);
+		purple_notify_user_info_add_pair(user_info, NULL, tmp);
+		g_free(tmp);
+
+		purple_notify_userinfo(info_data->gc, info_data->name,
+				user_info, NULL, NULL);
+
+		g_free(profile_url_text);
+		purple_notify_user_info_destroy(user_info);
+		g_free(info_data->name);
+		g_free(info_data);
+		return;
+	}
+
+	/* Check whether the profile is written in a supported language */
+	for (lang = 0;; lang += 1) {
+		last_updated_string = profile_langs[lang].last_updated_string;
+		if (!last_updated_string)
+			break;
+
+		p = strstr(url_text, last_updated_string);
+
+		if (p) {
+			if (profile_langs[lang].det && !strstr(url_text, profile_langs[lang].det))
+				p = NULL;
+			else
+				break;
+		}
+	}
+
+	if (p) {
+		for (strid = 0; profile_strings[strid].lang != XX; strid += 1) {
+			if (profile_strings[strid].lang == profile_langs[lang].lang) break;
+		}
+		strings = profile_strings + strid;
+		purple_debug_info("yahoo", "detected profile lang = %s (%d)\n", profile_strings[strid].lang_string, lang);
+	}
+
+	/* Every user may choose his/her own profile language, and this language
+	 * has nothing to do with the preferences of the user which looks at the
+	 * profile. We try to support all languages, but nothing is guaranteed.
+	 * If we cannot determine the language, it means either (1) the profile
+	 * is written in an unsupported language, (2) our language support is
+	 * out of date, or (3) the user is not found, or (4) Y! have changed their
+	 * webpage layout
+	 */
+	if (!p || strings->lang == XX) {
+		if (!strstr(url_text, "Yahoo! Member Directory - User not found")
+				&& !strstr(url_text, "was not found on this server.")
+				&& !strstr(url_text, "\xb8\xf8\xb3\xab\xa5\xd7\xa5\xed\xa5\xd5\xa5\xa3\xa1\xbc\xa5\xeb\xa4\xac\xb8\xab\xa4\xc4\xa4\xab\xa4\xea\xa4\xde\xa4\xbb\xa4\xf3")) {
+			profile_state = PROFILE_STATE_UNKNOWN_LANGUAGE;
+		} else {
+			profile_state = PROFILE_STATE_NOT_FOUND;
+		}
+	}
+
+#if PHOTO_SUPPORT
+	photo_url_text = yahoo_get_photo_url(url_text, info_data->name);
+#endif /* PHOTO_SUPPORT */
+
+	url_buffer = g_strdup(url_text);
+
+	/*
+	 * purple_markup_strip_html() doesn't strip out character entities like &nbsp;
+	 * and &#183;
+	*/
+	yahoo_remove_nonbreaking_spaces(url_buffer);
+#if 1
+	while ((p = strstr(url_buffer, "&#183;")) != NULL) {
+		memmove(p, p + 6, strlen(p + 6));
+		url_buffer[strlen(url_buffer) - 6] = '\0';
+	}
+#endif
+
+	/* nuke the nasty \r's */
+	purple_str_strip_char(url_buffer, '\r');
+
+#if PHOTO_SUPPORT
+	/* Marshall the existing state */
+	info2_data = g_malloc(sizeof(YahooGetInfoStepTwoData));
+	info2_data->info_data = info_data;
+	info2_data->url_buffer = url_buffer;
+	info2_data->photo_url_text = photo_url_text;
+	info2_data->profile_url_text = profile_url_text;
+	info2_data->strings = strings;
+	info2_data->last_updated_string = last_updated_string;
+	info2_data->title = title;
+	info2_data->profile_state = profile_state;
+	info2_data->user_info = user_info;
+
+	/* Try to put the photo in there too, if there's one */
+	if (photo_url_text) {
+		PurpleUtilFetchUrlData *url_data;
+		/* use whole URL if using HTTP Proxy */
+		gboolean use_whole_url = yahoo_account_use_http_proxy(info_data->gc);
+
+		/* User-uploaded photos use a different server that requires the Host
+		 * header, but Yahoo Japan will use the "chunked" content encoding if
+		 * we specify HTTP 1.1. So we have to specify 1.0 & fix purple_util_fetch_url
+		 */
+		url_data = purple_util_fetch_url(photo_url_text, use_whole_url, NULL,
+				FALSE, yahoo_got_photo, info2_data);
+		if (url_data != NULL)
+			yd->url_datas = g_slist_prepend(yd->url_datas, url_data);
+	} else {
+		/* Emulate a callback */
+		yahoo_got_photo(NULL, info2_data, NULL, 0, NULL);
+	}
+}
+
+static void
+yahoo_got_photo(PurpleUtilFetchUrlData *url_data, gpointer data,
+		const gchar *url_text, size_t len, const gchar *error_message)
+{
+	YahooGetInfoStepTwoData *info2_data = (YahooGetInfoStepTwoData *)data;
+	YahooData *yd;
+	gboolean found = FALSE;
+	int id = -1;
+
+	/* Temporary variables */
+	char *p = NULL;
+	char *stripped;
+	int stripped_len;
+	char *last_updated_utf8_string = NULL;
+	char *tmp;
+
+	/* Unmarshall the saved state */
+	YahooGetInfoData *info_data = info2_data->info_data;
+	char *url_buffer = info2_data->url_buffer;
+	PurpleNotifyUserInfo *user_info = info2_data->user_info;
+	char *photo_url_text = info2_data->photo_url_text;
+	char *profile_url_text = info2_data->profile_url_text;
+	const profile_strings_node_t *strings = info2_data->strings;
+	const char *last_updated_string = info2_data->last_updated_string;
+	profile_state_t profile_state = info2_data->profile_state;
+
+	/* We continue here from yahoo_got_info, as if nothing has happened */
+#endif /* PHOTO_SUPPORT */
+
+	/* Jun 29 05 Bleeter: Y! changed their profile pages. Terminators now seem to be */
+	/* </dd> and not \n. The prpl's need to be audited before it can be moved */
+	/* in to purple_markup_strip_html*/
+	char *fudged_buffer;
+
+	yd = info_data->gc->proto_data;
+	yd->url_datas = g_slist_remove(yd->url_datas, url_data);
+
+	fudged_buffer = purple_strcasereplace(url_buffer, "</dd>", "</dd><br>");
+	/* nuke the html, it's easier than trying to parse the horrid stuff */
+	stripped = purple_markup_strip_html(fudged_buffer);
+	stripped_len = strlen(stripped);
+
+	purple_debug_misc("yahoo", "stripped = %p\n", stripped);
+	purple_debug_misc("yahoo", "url_buffer = %p\n", url_buffer);
+
+	/* convert to utf8 */
+	if (strings && strings->charset) {
+		p = g_convert(stripped, -1, "utf-8", strings->charset,
+				NULL, NULL, NULL);
+		if (!p) {
+			p = g_locale_to_utf8(stripped, -1, NULL, NULL, NULL);
+			if (!p) {
+				p = g_convert(stripped, -1, "utf-8", "windows-1252",
+						NULL, NULL, NULL);
+			}
+		}
+		if (p) {
+			g_free(stripped);
+			stripped = purple_utf8_ncr_decode(p);
+			stripped_len = strlen(stripped);
+			g_free(p);
+		}
+	}
+	p = NULL;
+
+	/* "Last updated" should also be converted to utf8 and with &nbsp; killed */
+	if (strings && strings->charset) {
+		last_updated_utf8_string = g_convert(last_updated_string, -1, "utf-8",
+				strings->charset, NULL, NULL, NULL);
+		yahoo_remove_nonbreaking_spaces(last_updated_utf8_string);
+
+		purple_debug_misc("yahoo", "after utf8 conversion: stripped = (%s)\n", stripped);
+	}
+
+	if (strings && profile_state == PROFILE_STATE_DEFAULT) {
+#if 0
+	/* extract their Yahoo! ID and put it in. Don't bother marking has_info as
+	 * true, since the Yahoo! ID will always be there */
+	if (!purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->yahoo_id_string, (yd->jp ? 2 : 10), "\n", 0,
+			NULL, _("Yahoo! ID"), 0, NULL, NULL))
+		;
+#endif
+
+#if PHOTO_SUPPORT
+	/* Try to put the photo in there too, if there's one and is readable */
+	if (url_text && len != 0) {
+		if (strstr(url_text, "400 Bad Request")
+				|| strstr(url_text, "403 Forbidden")
+				|| strstr(url_text, "404 Not Found")) {
+
+			purple_debug_info("yahoo", "Error getting %s: %s\n",
+					photo_url_text, url_text);
+		} else {
+			purple_debug_info("yahoo", "%s is %" G_GSIZE_FORMAT
+					" bytes\n", photo_url_text, len);
+			id = purple_imgstore_add_with_id(g_memdup(url_text, len), len, NULL);
+
+			tmp = g_strdup_printf("<img id=\"%d\"><br>", id);
+			purple_notify_user_info_add_pair(user_info, NULL, tmp);
+			g_free(tmp);
+		}
+	}
+#endif /* PHOTO_SUPPORT */
+
+	/* extract their Email address and put it in */
+	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->my_email_string, (yd->jp ? 4 : 1), " ", 0,
+			strings->private_string, _("Email"), 0, NULL, NULL);
+
+	/* extract the Nickname if it exists */
+	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			"Nickname:", 1, "\n", '\n',
+			NULL, _("Nickname"), 0, NULL, NULL);
+
+	/* extract their RealName and put it in */
+	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->realname_string, (yd->jp ? 3 : 1), "\n", '\n',
+			NULL, _("Real Name"), 0, NULL, NULL);
+
+	/* extract their Location and put it in */
+	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->location_string, (yd->jp ? 4 : 2), "\n", '\n',
+			NULL, _("Location"), 0, NULL, NULL);
+
+	/* extract their Age and put it in */
+	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->age_string, (yd->jp ? 2 : 3), "\n", '\n',
+			NULL, _("Age"), 0, NULL, NULL);
+
+	/* extract their MaritalStatus and put it in */
+	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->maritalstatus_string, (yd->jp ? 2 : 3), "\n", '\n',
+			strings->no_answer_string, _("Marital Status"), 0, NULL, NULL);
+
+	/* extract their Gender and put it in */
+	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->gender_string, (yd->jp ? 2 : 3), "\n", '\n',
+			strings->no_answer_string, _("Gender"), 0, NULL, NULL);
+
+	/* extract their Occupation and put it in */
+	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->occupation_string, 2, "\n", '\n',
+			NULL, _("Occupation"), 0, NULL, NULL);
+
+	/* Hobbies, Latest News, and Favorite Quote are a bit different, since
+	 * the values can contain embedded newlines... but any or all of them
+	 * can also not appear.  The way we delimit them is to successively
+	 * look for the next one that _could_ appear, and if all else fails,
+	 * we end the section by looking for the 'Links' heading, which is the
+	 * next thing to follow this bunch.  (For Yahoo Japan, we check for
+	 * the "Description" ("Self PR") heading instead of "Links".)
+	 */
+
+	if (!purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->hobbies_string, (yd->jp ? 3 : 1), strings->latest_news_string,
+			'\n', "\n", _("Hobbies"), 0, NULL, NULL))
+	{
+		if (!purple_markup_extract_info_field(stripped, stripped_len, user_info,
+				strings->hobbies_string, 1, strings->favorite_quote_string,
+				'\n', "\n", _("Hobbies"), 0, NULL, NULL))
+		{
+			found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+					strings->hobbies_string, 1, strings->links_string,
+					'\n', "\n", _("Hobbies"), 0, NULL, NULL);
+		}
+		else
+			found = TRUE;
+	}
+	else
+		found = TRUE;
+
+	if (!purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->latest_news_string, 1, strings->favorite_quote_string,
+			'\n', "\n", _("Latest News"), 0, NULL, NULL))
+	{
+		found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+				strings->latest_news_string, (yd->jp ? 2 : 1), strings->links_string,
+				'\n', "\n", _("Latest News"), 0, NULL, NULL);
+	}
+	else
+		found = TRUE;
+
+	found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+			strings->favorite_quote_string, 1, strings->links_string,
+			'\n', "\n", _("Favorite Quote"), 0, NULL, NULL);
+
+	/* Home Page will either be "No home page specified",
+	 * or "Home Page: " and a link.
+	 * For Yahoo! Japan, if there is no home page specified,
+	 * neither "No home page specified" nor "Home Page:" is shown.
+	 */
+	if (strings->home_page_string) {
+		p = !strings->no_home_page_specified_string? NULL:
+			strstr(stripped, strings->no_home_page_specified_string);
+		if(!p)
+		{
+			found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+					strings->home_page_string, 1, "\n", 0, NULL,
+					_("Home Page"), 1, NULL, NULL);
+		}
+	}
+
+	/* Cool Link {1,2,3} is also different.  If "No cool link specified"
+	 * exists, then we have none.  If we have one however, we'll need to
+	 * check and see if we have a second one.  If we have a second one,
+	 * we have to check to see if we have a third one.
+	 */
+	p = !strings->no_cool_link_specified_string? NULL:
+		strstr(stripped,strings->no_cool_link_specified_string);
+	if (!p)
+	{
+		if (purple_markup_extract_info_field(stripped, stripped_len, user_info,
+				strings->cool_link_1_string, 1, "\n", 0, NULL,
+				_("Cool Link 1"), 1, NULL, NULL))
+		{
+			found = TRUE;
+			if (purple_markup_extract_info_field(stripped, stripped_len, user_info,
+					strings->cool_link_2_string, 1, "\n", 0, NULL,
+					_("Cool Link 2"), 1, NULL, NULL))
+			{
+				purple_markup_extract_info_field(stripped, stripped_len, user_info,
+						strings->cool_link_3_string, 1, "\n", 0, NULL,
+						_("Cool Link 3"), 1, NULL, NULL);
+			}
+		}
+	}
+
+	if (last_updated_utf8_string != NULL) {
+		/* see if Member Since is there, and if so, extract it. */
+		found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+				"Member Since:", 1, last_updated_utf8_string,
+				'\n', NULL, _("Member Since"), 0, NULL, yahoo_info_date_reformat);
+
+		/* extract the Last Updated date and put it in */
+		found |= purple_markup_extract_info_field(stripped, stripped_len, user_info,
+				last_updated_utf8_string, (yd->jp ? 2 : 1), (yd->jp ? "\n" : " "), (yd->jp ? 0 : '\n'), NULL,
+				_("Last Update"), 0, NULL, (yd->jp ? NULL : yahoo_info_date_reformat));
+	}
+	} /* if (profile_state == PROFILE_STATE_DEFAULT) */
+
+	if(!found)
+	{
+		const gchar *str;
+
+		purple_notify_user_info_add_section_break(user_info);
+		purple_notify_user_info_add_pair(user_info,
+				_("Error retrieving profile"), NULL);
+
+		if (profile_state == PROFILE_STATE_UNKNOWN_LANGUAGE) {
+			str = _("This profile is in a language "
+					  "or format that is not supported at this time.");
+
+		} else if (profile_state == PROFILE_STATE_NOT_FOUND) {
+			PurpleBuddy *b = purple_find_buddy
+					(purple_connection_get_account(info_data->gc),
+							info_data->name);
+			YahooFriend *f = NULL;
+			if (b) {
+				/* Someone on the buddy list can be "not on server list",
+				 * in which case the user may or may not actually exist.
+				 * Hence this extra step.
+				 */
+				PurpleAccount *account = purple_buddy_get_account(b);
+				f = yahoo_friend_find(purple_account_get_connection(account),
+						purple_buddy_get_name(b));
+			}
+			str = f ? _("Could not retrieve the user's profile. "
+					  "This most likely is a temporary server-side problem. "
+					  "Please try again later.") :
+					_("Could not retrieve the user's profile. "
+					  "This most likely means that the user does not exist; "
+					  "however, Yahoo! sometimes does fail to find a user's "
+					  "profile. If you know that the user exists, "
+					  "please try again later.");
+		} else {
+			str = _("The user's profile is empty.");
+		}
+
+		purple_notify_user_info_add_pair(user_info, NULL, str);
+	}
+
+	/* put a link to the actual profile URL */
+	purple_notify_user_info_add_section_break(user_info);
+	tmp = g_strdup_printf("<a href=\"%s\">%s</a>",
+			profile_url_text, _("View web profile"));
+	purple_notify_user_info_add_pair(user_info, NULL, tmp);
+	g_free(tmp);
+
+	g_free(stripped);
+
+	/* show it to the user */
+	purple_notify_userinfo(info_data->gc, info_data->name,
+						  user_info, NULL, NULL);
+	purple_notify_user_info_destroy(user_info);
+
+	g_free(last_updated_utf8_string);
+	g_free(url_buffer);
+	g_free(fudged_buffer);
+	g_free(profile_url_text);
+	g_free(info_data->name);
+	g_free(info_data);
+
+#if PHOTO_SUPPORT
+	g_free(photo_url_text);
+	g_free(info2_data);
+	if (id != -1)
+		purple_imgstore_unref_by_id(id);
+#endif /* PHOTO_SUPPORT */
+}
+
+void yahoo_get_info(PurpleConnection *gc, const char *name)
+{
+	YahooData *yd = gc->proto_data;
+	YahooGetInfoData *data;
+	char *url;
+	PurpleUtilFetchUrlData *url_data;
+
+	data       = g_new0(YahooGetInfoData, 1);
+	data->gc   = gc;
+	data->name = g_strdup(name);
+
+	url = g_strdup_printf("%s%s",
+			(yd->jp ? YAHOOJP_PROFILE_URL : YAHOO_PROFILE_URL), name);
+
+	url_data = purple_util_fetch_url(url, TRUE, NULL, FALSE, yahoo_got_info, data);
+	if (url_data != NULL)
+		yd->url_datas = g_slist_prepend(yd->url_datas, url_data);
+
+	g_free(url);
+}
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoochat.c pidgin-2.10.11/libpurple/protocols/yahoo/yahoochat.c
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoochat.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/yahoochat.c	2015-02-10 14:28:16.410686364 +0900
@@ -996,7 +996,7 @@
 	g_free(msg1);
 	msg1 = yahoo_string_encode(gc, msg2, &utf8);
 	g_free(msg2);
-	room2 = yahoo_string_encode(gc, room, NULL);
+	room2 = yahoo_string_encode(gc, room, &utf8);
 
 	pkt = yahoo_packet_new(YAHOO_SERVICE_COMMENT, YAHOO_STATUS_AVAILABLE, yd->session_id);
 
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoochat.c.orig pidgin-2.10.11/libpurple/protocols/yahoo/yahoochat.c.orig
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/yahoochat.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/yahoochat.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,1684 @@
+/*
+ * purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * Some code copyright 2003 Tim Ringenbach <omarvo@hotmail.com>
+ * (marv on irc.freenode.net)
+ * Some code borrowed from libyahoo2, copyright (C) 2002, Philip
+ * S Tellis <philip . tellis AT gmx . net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+
+#include "internal.h"
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif /* HAVE_CONFIG_H */
+
+#include "debug.h"
+#include "privacy.h"
+#include "prpl.h"
+
+#include "conversation.h"
+#include "notify.h"
+#include "util.h"
+
+#include "libymsg.h"
+#include "yahoo_packet.h"
+#include "yahoochat.h"
+#include "ycht.h"
+
+#define YAHOO_CHAT_ID (1)
+
+/* prototype(s) */
+static void yahoo_chat_leave(PurpleConnection *gc, const char *room, const char *dn, gboolean logout);
+
+/* special function to log us on to the yahoo chat service */
+static void yahoo_chat_online(PurpleConnection *gc)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt;
+	const char *rll;
+
+	if (yd->wm) {
+		ycht_connection_open(gc);
+		return;
+	}
+
+	rll = purple_account_get_string(purple_connection_get_account(gc),
+								  "room_list_locale", YAHOO_ROOMLIST_LOCALE);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CHATONLINE, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash(pkt, "sssss",
+					  109, purple_connection_get_display_name(gc),
+					  1, purple_connection_get_display_name(gc),
+					  6, "abcde",
+					/* I'm not sure this is the correct way to set this. */
+					  98, rll,
+					  135, yd->jp ? YAHOO_CLIENT_VERSION : YAHOOJP_CLIENT_VERSION);
+	yahoo_packet_send_and_free(pkt, yd);
+}
+
+/* this is slow, and different from the purple_* version in that it (hopefully) won't add a user twice */
+void yahoo_chat_add_users(PurpleConvChat *chat, GList *newusers)
+{
+	GList *i;
+
+	for (i = newusers; i; i = i->next) {
+		if (purple_conv_chat_find_user(chat, i->data))
+			continue;
+		purple_conv_chat_add_user(chat, i->data, NULL, PURPLE_CBFLAGS_NONE, TRUE);
+	}
+}
+
+void yahoo_chat_add_user(PurpleConvChat *chat, const char *user, const char *reason)
+{
+	if (purple_conv_chat_find_user(chat, user))
+		return;
+
+	purple_conv_chat_add_user(chat, user, reason, PURPLE_CBFLAGS_NONE, TRUE);
+}
+
+static PurpleConversation *yahoo_find_conference(PurpleConnection *gc, const char *name)
+{
+	YahooData *yd;
+	GSList *l;
+
+	yd = gc->proto_data;
+
+	for (l = yd->confs; l; l = l->next) {
+		PurpleConversation *c = l->data;
+		if (!purple_utf8_strcasecmp(purple_conversation_get_name(c), name))
+			return c;
+	}
+	return NULL;
+}
+
+
+void yahoo_process_conference_invite(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	PurpleAccount *account;
+	GSList *l;
+	char *room = NULL;
+	char *who = NULL;
+	char *msg = NULL;
+	GString *members = NULL;
+	GHashTable *components;
+
+	if ( (pkt->status == 2) || (pkt->status == 11) )
+		return; /* Status is 11 when we are being notified about invitation being sent to someone else */
+
+	account = purple_connection_get_account(gc);
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+		if (pair->key == 57)
+		{
+			room = yahoo_string_decode(gc, pair->value, FALSE);
+			if (yahoo_find_conference(gc, room) != NULL)
+			{
+				/* Looks like we got invited to an already open conference. */
+				/* Laters: Should we accept this conference rather than ignoring the invitation ? */
+				purple_debug_info("yahoo","Ignoring invitation for an already existing chat, room:%s\n",room);
+				g_free(room);
+				return;
+			}
+		}
+	}
+
+	members = g_string_sized_new(512);
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 1: /* us, but we already know who we are */
+			break;
+		case 57:
+			g_free(room);
+			room = yahoo_string_decode(gc, pair->value, FALSE);
+			break;
+		case 50: /* inviter */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+				g_string_append_printf(members, "%s\n", who);
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_conference_invite "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 51: /* This user is being invited to the conference. Comes with status = 11, so we wont reach here */
+			break;
+		case 52: /* Invited users. Assuming us invited, since we got this packet */
+			break; /* break needed, or else we add the users to the conference before they accept the invitation */
+		case 53: /* members who have already joined the conference */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				g_string_append_printf(members, "%s\n", pair->value);
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_conference_invite "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 58:
+			g_free(msg);
+			msg = yahoo_string_decode(gc, pair->value, FALSE);
+			break;
+		case 13: /* ? */
+			break;
+		}
+	}
+
+	if (!room) {
+		g_string_free(members, TRUE);
+		g_free(msg);
+		return;
+	}
+
+	if (!purple_privacy_check(account, who) ||
+			(purple_account_get_bool(account, "ignore_invites", FALSE)))
+	{
+		purple_debug_info("yahoo",
+		    "Invite to conference %s from %s has been dropped.\n", room, who);
+		g_free(room);
+		g_free(msg);
+		g_string_free(members, TRUE);
+		return;
+	}
+
+	components = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+	g_hash_table_replace(components, g_strdup("room"), room);
+	if (msg)
+		g_hash_table_replace(components, g_strdup("topic"), msg);
+	g_hash_table_replace(components, g_strdup("type"), g_strdup("Conference"));
+	g_hash_table_replace(components, g_strdup("members"), g_string_free(members, FALSE));
+	serv_got_chat_invite(gc, room, who, msg, components);
+
+}
+
+void yahoo_process_conference_decline(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	GSList *l;
+	char *room = NULL;
+	char *who = NULL;
+	char *msg = NULL;
+	PurpleConversation *c = NULL;
+	int utf8 = 0;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 57:
+			g_free(room);
+			room = yahoo_string_decode(gc, pair->value, FALSE);
+			break;
+		case 54:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_conference_decline "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 14:
+			g_free(msg);
+			msg = yahoo_string_decode(gc, pair->value, FALSE);
+			break;
+		case 97:
+			utf8 = strtol(pair->value, NULL, 10);
+			break;
+		}
+	}
+	if (!purple_privacy_check(purple_connection_get_account(gc), who))
+	{
+		g_free(room);
+		g_free(msg);
+		return;
+	}
+
+	if (who && room) {
+		/* make sure we're in the room before we process a decline message for it */
+		if((c = yahoo_find_conference(gc, room))) {
+			char *tmp = NULL, *msg_tmp = NULL;
+			if(msg)
+			{
+				msg_tmp = yahoo_string_decode(gc, msg, utf8);
+				msg = yahoo_codes_to_html(msg_tmp);
+				serv_got_chat_in(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(c)), who, 0, msg, time(NULL));
+				g_free(msg_tmp);
+				g_free(msg);
+			}
+
+			tmp = g_strdup_printf(_("%s has declined to join."), who);
+			purple_conversation_write(c, NULL, tmp, PURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_NO_LINKIFY, time(NULL));
+
+			g_free(tmp);
+		}
+
+		g_free(room);
+	}
+}
+
+void yahoo_process_conference_logon(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	GSList *l;
+	char *room = NULL;
+	char *who = NULL;
+	PurpleConversation *c;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 57:
+			g_free(room);
+			room = yahoo_string_decode(gc, pair->value, FALSE);
+			break;
+		case 53:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_conference_logon "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		}
+	}
+
+	if (who && room) {
+		c = yahoo_find_conference(gc, room);
+		if (c)
+		{	/* Prevent duplicate users in the chat */
+			if( !purple_conv_chat_find_user(PURPLE_CONV_CHAT(c), who) )
+				yahoo_chat_add_user(PURPLE_CONV_CHAT(c), who, NULL);
+		}
+		g_free(room);
+	}
+}
+
+void yahoo_process_conference_logoff(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	GSList *l;
+	char *room = NULL;
+	char *who = NULL;
+	PurpleConversation *c;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 57:
+			g_free(room);
+			room = yahoo_string_decode(gc, pair->value, FALSE);
+			break;
+		case 56:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_conference_logoff "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		}
+	}
+
+	if (who && room) {
+		c = yahoo_find_conference(gc, room);
+		if (c)
+			purple_conv_chat_remove_user(PURPLE_CONV_CHAT(c), who, NULL);
+		g_free(room);
+	}
+}
+
+void yahoo_process_conference_message(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	GSList *l;
+	char *room = NULL;
+	char *who = NULL;
+	char *msg = NULL;
+	int utf8 = 0;
+	PurpleConversation *c;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 57:
+			g_free(room);
+			room = yahoo_string_decode(gc, pair->value, FALSE);
+			break;
+		case 3:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_conference_message "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 14:
+			msg = pair->value;
+			break;
+		case 97:
+			utf8 = strtol(pair->value, NULL, 10);
+			break;
+		}
+	}
+
+	if (room && who && msg) {
+		char *msg2;
+
+		c = yahoo_find_conference(gc, room);
+		if (!c) {
+			g_free(room);
+			return;
+		}
+
+		msg2 = yahoo_string_decode(gc, msg, utf8);
+		msg = yahoo_codes_to_html(msg2);
+		serv_got_chat_in(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(c)), who, 0, msg, time(NULL));
+		g_free(msg);
+		g_free(msg2);
+	}
+
+	g_free(room);
+}
+
+static void yahoo_chat_join(PurpleConnection *gc, const char *dn, const char *room, const char *topic, const char *id)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt;
+	char *room2;
+	gboolean utf8 = TRUE;
+
+	if (yd->wm) {
+		g_return_if_fail(yd->ycht != NULL);
+		ycht_chat_join(yd->ycht, room);
+		return;
+	}
+
+	/* apparently room names are always utf8, or else always not utf8,
+	 * so we don't have to actually pass the flag in the packet. Or something. */
+	room2 = yahoo_string_encode(gc, room, &utf8);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CHATJOIN, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash(pkt, "ssss",
+						1, purple_connection_get_display_name(gc),
+						104, room2,
+						62, "2",
+						129, id ? id : "0");
+	yahoo_packet_send_and_free(pkt, yd);
+	g_free(room2);
+}
+
+/* this is a confirmation of yahoo_chat_online(); */
+void yahoo_process_chat_online(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	YahooData *yd = (YahooData *) gc->proto_data;
+
+	if (pkt->status == 1) {
+		yd->chat_online = TRUE;
+
+		/* We need to goto a user in chat */
+		if (yd->pending_chat_goto) {
+			struct yahoo_packet *pkt = yahoo_packet_new(YAHOO_SERVICE_CHATGOTO, YAHOO_STATUS_AVAILABLE, yd->session_id);
+			yahoo_packet_hash(pkt, "sss",
+				109, yd->pending_chat_goto,
+				1, purple_connection_get_display_name(gc),
+				62, "2");
+			yahoo_packet_send_and_free(pkt, yd);
+		} else if (yd->pending_chat_room) {
+			yahoo_chat_join(gc, purple_connection_get_display_name(gc), yd->pending_chat_room,
+				yd->pending_chat_topic, yd->pending_chat_id);
+		}
+
+		g_free(yd->pending_chat_room);
+		yd->pending_chat_room = NULL;
+		g_free(yd->pending_chat_id);
+		yd->pending_chat_id = NULL;
+		g_free(yd->pending_chat_topic);
+		yd->pending_chat_topic = NULL;
+		g_free(yd->pending_chat_goto);
+		yd->pending_chat_goto = NULL;
+	}
+}
+
+/* this is basicly the opposite of chat_online */
+void yahoo_process_chat_logout(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	YahooData *yd = (YahooData *) gc->proto_data;
+	GSList *l;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		if (pair->key == 1)
+			if (g_ascii_strcasecmp(pair->value,
+					purple_connection_get_display_name(gc)))
+				return;
+	}
+
+	if (pkt->status == 1) {
+		yd->chat_online = FALSE;
+		g_free(yd->pending_chat_room);
+		yd->pending_chat_room = NULL;
+		g_free(yd->pending_chat_id);
+		yd->pending_chat_id = NULL;
+		g_free(yd->pending_chat_topic);
+		yd->pending_chat_topic = NULL;
+		g_free(yd->pending_chat_goto);
+		yd->pending_chat_goto = NULL;
+		if (yd->in_chat)
+			yahoo_c_leave(gc, YAHOO_CHAT_ID);
+	}
+}
+
+void yahoo_process_chat_join(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	PurpleAccount *account = purple_connection_get_account(gc);
+	YahooData *yd = (YahooData *) gc->proto_data;
+	PurpleConversation *c = NULL;
+	GSList *l;
+	GList *members = NULL;
+	GList *roomies = NULL;
+	char *room = NULL;
+	char *topic = NULL;
+
+	if (pkt->status == -1) {
+		/* We can't join */
+		struct yahoo_pair *pair = pkt->hash->data;
+		gchar const *failed_to_join = _("Failed to join chat");
+		switch (atoi(pair->value)) {
+			case 0xFFFFFFFA: /* -6 */
+				purple_notify_error(gc, NULL, failed_to_join, _("Unknown room"));
+				break;
+			case 0xFFFFFFF1: /* -15 */
+				purple_notify_error(gc, NULL, failed_to_join, _("Maybe the room is full"));
+				break;
+			case 0xFFFFFFDD: /* -35 */
+				purple_notify_error(gc, NULL, failed_to_join, _("Not available"));
+				break;
+			default:
+				purple_notify_error(gc, NULL, failed_to_join,
+						_("Unknown error. You may need to logout and wait five minutes before being able to rejoin a chatroom"));
+		}
+		return;
+	}
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+
+		case 104:
+			g_free(room);
+			room = yahoo_string_decode(gc, pair->value, TRUE);
+			break;
+		case 105:
+			g_free(topic);
+			topic = yahoo_string_decode(gc, pair->value, TRUE);
+			break;
+		case 128: /* some id */
+			break;
+		case 108: /* number of joiners */
+			break;
+		case 129: /* some other id */
+			break;
+		case 130: /* some base64 or hash or something */
+			break;
+		case 126: /* some negative number */
+			break;
+		case 13: /* this is 1. maybe its the type of room? (normal, user created, private, etc?) */
+			break;
+		case 61: /*this looks similar to 130 */
+			break;
+
+		/* the previous section was just room info. this next section is
+		   info about individual room members, (including us) */
+
+		case 109: /* the yahoo id */
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				members = g_list_append(members, pair->value);
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_chat_join "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 110: /* age */
+			break;
+		case 141: /* nickname */
+			break;
+		case 142: /* location */
+			break;
+		case 113: /* bitmask */
+			break;
+		}
+	}
+
+	if (room && yd->chat_name && purple_utf8_strcasecmp(room, yd->chat_name))
+		yahoo_chat_leave(gc, room,
+				purple_connection_get_display_name(gc), FALSE);
+
+	c = purple_find_chat(gc, YAHOO_CHAT_ID);
+
+	if (room && (!c || purple_conv_chat_has_left(PURPLE_CONV_CHAT(c))) &&
+	    members && (members->next ||
+	     !g_ascii_strcasecmp(members->data, purple_connection_get_display_name(gc)))) {
+		GList *l;
+		GList *flags = NULL;
+		for (l = members; l; l = l->next)
+			flags = g_list_prepend(flags, GINT_TO_POINTER(PURPLE_CBFLAGS_NONE));
+		if (c && purple_conv_chat_has_left(PURPLE_CONV_CHAT(c))) {
+			/* this might be a hack, but oh well, it should nicely */
+			char *tmpmsg;
+
+			purple_conversation_set_name(c, room);
+
+			c = serv_got_joined_chat(gc, YAHOO_CHAT_ID, room);
+			if (topic) {
+				purple_conv_chat_set_topic(PURPLE_CONV_CHAT(c), NULL, topic);
+				/* Also print the topic to the backlog so that the captcha link is clickable */
+				purple_conv_chat_write(PURPLE_CONV_CHAT(c), "", topic, PURPLE_MESSAGE_SYSTEM, time(NULL));
+			}
+			yd->in_chat = 1;
+			yd->chat_name = g_strdup(room);
+			purple_conv_chat_add_users(PURPLE_CONV_CHAT(c), members, NULL, flags, FALSE);
+
+			tmpmsg = g_strdup_printf(_("You are now chatting in %s."), room);
+			purple_conv_chat_write(PURPLE_CONV_CHAT(c), "", tmpmsg, PURPLE_MESSAGE_SYSTEM, time(NULL));
+			g_free(tmpmsg);
+		} else {
+			c = serv_got_joined_chat(gc, YAHOO_CHAT_ID, room);
+			if (topic) {
+				purple_conv_chat_set_topic(PURPLE_CONV_CHAT(c), NULL, topic);
+				/* Also print the topic to the backlog so that the captcha link is clickable */
+				purple_conv_chat_write(PURPLE_CONV_CHAT(c), "", topic, PURPLE_MESSAGE_SYSTEM, time(NULL));
+			}
+			yd->in_chat = 1;
+			yd->chat_name = g_strdup(room);
+			purple_conv_chat_add_users(PURPLE_CONV_CHAT(c), members, NULL, flags, FALSE);
+		}
+		g_list_free(flags);
+	} else if (c) {
+		if (topic) {
+			const char *cur_topic = purple_conv_chat_get_topic(PURPLE_CONV_CHAT(c));
+			if (cur_topic == NULL || strcmp(cur_topic, topic) != 0)
+				purple_conv_chat_set_topic(PURPLE_CONV_CHAT(c), NULL, topic);
+		}
+		yahoo_chat_add_users(PURPLE_CONV_CHAT(c), members);
+	}
+
+	if (account->deny && c) {
+		PurpleConversationUiOps *ops = purple_conversation_get_ui_ops(c);
+		for (l = account->deny; l != NULL; l = l->next) {
+			for (roomies = members; roomies; roomies = roomies->next) {
+				if (!purple_utf8_strcasecmp((char *)l->data, roomies->data)) {
+					purple_debug_info("yahoo", "Ignoring room member %s in room %s\n" , (char *)roomies->data, room ? room : "");
+					purple_conv_chat_ignore(PURPLE_CONV_CHAT(c),roomies->data);
+					ops->chat_update_user(c, roomies->data);
+				}
+			}
+		}
+	}
+	g_list_free(roomies);
+	g_list_free(members);
+	g_free(room);
+	g_free(topic);
+}
+
+void yahoo_process_chat_exit(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	char *who = NULL;
+	char *room = NULL;
+	GSList *l;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		if (pair->key == 104) {
+			g_free(room);
+			room = yahoo_string_decode(gc, pair->value, TRUE);
+		}
+		if (pair->key == 109) {
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_chat_exit "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+		}
+	}
+
+	if (who && room) {
+		PurpleConversation *c = purple_find_chat(gc, YAHOO_CHAT_ID);
+		if (c && !purple_utf8_strcasecmp(purple_conversation_get_name(c), room))
+			purple_conv_chat_remove_user(PURPLE_CONV_CHAT(c), who, NULL);
+
+	}
+	g_free(room);
+}
+
+void yahoo_process_chat_message(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	char *room = NULL, *who = NULL, *msg = NULL, *msg2;
+	int msgtype = 1, utf8 = 1; /* default to utf8 */
+	PurpleConversation *c = NULL;
+	GSList *l;
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+
+		case 97:
+			utf8 = strtol(pair->value, NULL, 10);
+			break;
+		case 104:
+			g_free(room);
+			room = yahoo_string_decode(gc, pair->value, TRUE);
+			break;
+		case 109:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_chat_message "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 117:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				msg = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_chat_message "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 124:
+			msgtype = strtol(pair->value, NULL, 10);
+			break;
+		}
+	}
+
+	c = purple_find_chat(gc, YAHOO_CHAT_ID);
+	if (!who || !c) {
+		if (room)
+			g_free(room);
+		/* we still get messages after we part, funny that */
+		return;
+	}
+
+	if (!msg) {
+		purple_debug_misc("yahoo", "Got a message packet with no message.\nThis probably means something important, but we're ignoring it.\n");
+		return;
+	}
+	msg2 = yahoo_string_decode(gc, msg, utf8);
+	msg = yahoo_codes_to_html(msg2);
+	g_free(msg2);
+
+	if (msgtype == 2 || msgtype == 3) {
+		char *tmp;
+		tmp = g_strdup_printf("/me %s", msg);
+		g_free(msg);
+		msg = tmp;
+	}
+
+	serv_got_chat_in(gc, YAHOO_CHAT_ID, who, 0, msg, time(NULL));
+	g_free(msg);
+	g_free(room);
+}
+
+void yahoo_process_chat_addinvite(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	PurpleAccount *account;
+	GSList *l;
+	char *room = NULL;
+	char *msg = NULL;
+	char *who = NULL;
+
+	account = purple_connection_get_account(gc);
+
+	for (l = pkt->hash; l; l = l->next) {
+		struct yahoo_pair *pair = l->data;
+
+		switch (pair->key) {
+		case 104:
+			g_free(room);
+			room = yahoo_string_decode(gc, pair->value, TRUE);
+			break;
+		case 129: /* room id? */
+			break;
+		case 126: /* ??? */
+			break;
+		case 117:
+			g_free(msg);
+			msg = yahoo_string_decode(gc, pair->value, FALSE);
+			break;
+		case 119:
+			if (g_utf8_validate(pair->value, -1, NULL)) {
+				who = pair->value;
+			} else {
+				purple_debug_warning("yahoo", "yahoo_process_chat_addinvite "
+						"got non-UTF-8 string for key %d\n", pair->key);
+			}
+			break;
+		case 118: /* us */
+			break;
+		}
+	}
+
+	if (room && who) {
+		GHashTable *components;
+
+		if (!purple_privacy_check(account, who) ||
+				(purple_account_get_bool(account, "ignore_invites", FALSE)))
+		{
+			purple_debug_info("yahoo", "Invite to room %s from %s has been dropped.\n", room, who);
+			g_free(room);
+			g_free(msg);
+			return;
+		}
+
+		components = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+		g_hash_table_replace(components, g_strdup("room"), g_strdup(room));
+		serv_got_chat_invite(gc, room, who, msg, components);
+	}
+
+	g_free(room);
+	g_free(msg);
+}
+
+void yahoo_process_chat_goto(PurpleConnection *gc, struct yahoo_packet *pkt)
+{
+	if (pkt->status == -1)
+		purple_notify_error(gc, NULL, _("Failed to join buddy in chat"),
+						_("Maybe they're not in a chat?"));
+}
+
+/*
+ * Functions dealing with conferences
+ * I think conference names are always ascii.
+ */
+
+void yahoo_conf_leave(YahooData *yd, const char *room, const char *dn, GList *who)
+{
+	struct yahoo_packet *pkt;
+	GList *w;
+
+	purple_debug_misc("yahoo", "leaving conference %s\n", room);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CONFLOGOFF, YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	yahoo_packet_hash_str(pkt, 1, dn);
+	for (w = who; w; w = w->next) {
+		const char *name = purple_conv_chat_cb_get_name(w->data);
+		yahoo_packet_hash_str(pkt, 3, name);
+	}
+
+	yahoo_packet_hash_str(pkt, 57, room);
+	yahoo_packet_send_and_free(pkt, yd);
+}
+
+static int yahoo_conf_send(PurpleConnection *gc, const char *dn, const char *room,
+							GList *members, const char *what)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt;
+	GList *who;
+	char *msg, *msg2;
+	int utf8 = 1;
+
+	msg = yahoo_html_to_codes(what);
+	msg2 = yahoo_string_encode(gc, msg, &utf8);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CONFMSG, YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	yahoo_packet_hash_str(pkt, 1, dn);
+	for (who = members; who; who = who->next) {
+		const char *name = purple_conv_chat_cb_get_name(who->data);
+		yahoo_packet_hash_str(pkt, 53, name);
+	}
+	yahoo_packet_hash(pkt, "ss", 57, room, 14, msg2);
+	if (utf8)
+		yahoo_packet_hash_str(pkt, 97, "1"); /* utf-8 */
+
+	yahoo_packet_send_and_free(pkt, yd);
+	g_free(msg);
+	g_free(msg2);
+
+	return 0;
+}
+
+static void yahoo_conf_join(YahooData *yd, PurpleConversation *c, const char *dn, const char *room,
+						const char *topic, const char *members)
+{
+	struct yahoo_packet *pkt;
+	char **memarr = NULL;
+	int i;
+
+	if (members)
+		memarr = g_strsplit(members, "\n", 0);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CONFLOGON, YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	yahoo_packet_hash(pkt, "sss", 1, dn, 3, dn, 57, room);
+	if (memarr) {
+		for(i = 0 ; memarr[i]; i++) {
+			if (!strcmp(memarr[i], "") || !strcmp(memarr[i], dn))
+					continue;
+			yahoo_packet_hash_str(pkt, 3, memarr[i]);
+			purple_conv_chat_add_user(PURPLE_CONV_CHAT(c), memarr[i], NULL, PURPLE_CBFLAGS_NONE, TRUE);
+		}
+	}
+	yahoo_packet_send_and_free(pkt, yd);
+
+	if (memarr)
+		g_strfreev(memarr);
+}
+
+static void yahoo_conf_invite(PurpleConnection *gc, PurpleConversation *c,
+		const char *dn, const char *buddy, const char *room, const char *msg)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt;
+	GList *members;
+	char *msg2 = NULL;
+
+	if (msg)
+		msg2 = yahoo_string_encode(gc, msg, NULL);
+
+	members = purple_conv_chat_get_users(PURPLE_CONV_CHAT(c));
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CONFADDINVITE, YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	yahoo_packet_hash(pkt, "sssss", 1, dn, 51, buddy, 57, room, 58, msg?msg2:"", 13, "0");
+	for(; members; members = members->next) {
+		const char *name = purple_conv_chat_cb_get_name(members->data);
+		if (!strcmp(name, dn))
+			continue;
+		yahoo_packet_hash(pkt, "ss", 52, name, 53, name);
+	}
+
+	yahoo_packet_send_and_free(pkt, yd);
+	g_free(msg2);
+}
+
+/*
+ * Functions dealing with chats
+ */
+
+static void yahoo_chat_leave(PurpleConnection *gc, const char *room, const char *dn, gboolean logout)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt;
+
+	char *eroom;
+	gboolean utf8 = 1;
+
+	if (yd->wm) {
+		g_return_if_fail(yd->ycht != NULL);
+
+		ycht_chat_leave(yd->ycht, room, logout);
+		return;
+	}
+
+	eroom = yahoo_string_encode(gc, room, &utf8);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CHATEXIT, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash(pkt, "sss", 104, eroom, 109, dn, 108, "1");
+	yahoo_packet_hash_str(pkt, 112, "0"); /* what does this one mean? */
+	yahoo_packet_send_and_free(pkt, yd);
+
+	yd->in_chat = 0;
+	if (yd->chat_name) {
+		g_free(yd->chat_name);
+		yd->chat_name = NULL;
+	}
+
+	if (purple_find_chat(gc, YAHOO_CHAT_ID) != NULL)
+		serv_got_chat_left(gc, YAHOO_CHAT_ID);
+
+	if (!logout)
+		return;
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CHATLOGOUT,
+			YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash_str(pkt, 1, dn);
+	yahoo_packet_send_and_free(pkt, yd);
+
+	yd->chat_online = FALSE;
+	g_free(yd->pending_chat_room);
+	yd->pending_chat_room = NULL;
+	g_free(yd->pending_chat_id);
+	yd->pending_chat_id = NULL;
+	g_free(yd->pending_chat_topic);
+	yd->pending_chat_topic = NULL;
+	g_free(yd->pending_chat_goto);
+	yd->pending_chat_goto = NULL;
+	g_free(eroom);
+}
+
+static int yahoo_chat_send(PurpleConnection *gc, const char *dn, const char *room, const char *what, PurpleMessageFlags flags)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt;
+	int me = 0;
+	char *msg1, *msg2, *room2;
+	gboolean utf8 = TRUE;
+
+	if (yd->wm) {
+		g_return_val_if_fail(yd->ycht != NULL, 1);
+
+		return ycht_chat_send(yd->ycht, room, what);
+	}
+
+	msg1 = g_strdup(what);
+
+	if (purple_message_meify(msg1, -1))
+		me = 1;
+
+	msg2 = yahoo_html_to_codes(msg1);
+	g_free(msg1);
+	msg1 = yahoo_string_encode(gc, msg2, &utf8);
+	g_free(msg2);
+	room2 = yahoo_string_encode(gc, room, NULL);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_COMMENT, YAHOO_STATUS_AVAILABLE, yd->session_id);
+
+	yahoo_packet_hash(pkt, "sss", 1, dn, 104, room2, 117, msg1);
+	if (me)
+		yahoo_packet_hash_str(pkt, 124, "2");
+	else
+		yahoo_packet_hash_str(pkt, 124, "1");
+	/* fixme: what about /think? (124=3) */
+	if (utf8)
+		yahoo_packet_hash_str(pkt, 97, "1");
+
+	yahoo_packet_send_and_free(pkt, yd);
+	g_free(msg1);
+	g_free(room2);
+
+	return 0;
+}
+
+
+static void yahoo_chat_invite(PurpleConnection *gc, const char *dn, const char *buddy,
+							const char *room, const char *msg)
+{
+	YahooData *yd = gc->proto_data;
+	struct yahoo_packet *pkt;
+	char *room2, *msg2 = NULL;
+	gboolean utf8 = TRUE;
+
+	if (yd->wm) {
+		g_return_if_fail(yd->ycht != NULL);
+		ycht_chat_send_invite(yd->ycht, room, buddy, msg);
+		return;
+	}
+
+	room2 = yahoo_string_encode(gc, room, &utf8);
+	if (msg)
+		msg2 = yahoo_string_encode(gc, msg, NULL);
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CHATADDINVITE, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash(pkt, "sssss", 1, dn, 118, buddy, 104, room2, 117, (msg2?msg2:""), 129, "0");
+	yahoo_packet_send_and_free(pkt, yd);
+
+	g_free(room2);
+	g_free(msg2);
+}
+
+void yahoo_chat_goto(PurpleConnection *gc, const char *name)
+{
+	YahooData *yd;
+	struct yahoo_packet *pkt;
+
+	yd = gc->proto_data;
+
+	if (yd->wm) {
+		g_return_if_fail(yd->ycht != NULL);
+		ycht_chat_goto_user(yd->ycht, name);
+		return;
+	}
+
+	if (!yd->chat_online) {
+		yahoo_chat_online(gc);
+		g_free(yd->pending_chat_room);
+		yd->pending_chat_room = NULL;
+		g_free(yd->pending_chat_id);
+		yd->pending_chat_id = NULL;
+		g_free(yd->pending_chat_topic);
+		yd->pending_chat_topic = NULL;
+		g_free(yd->pending_chat_goto);
+		yd->pending_chat_goto = g_strdup(name);
+		return;
+	}
+
+	pkt = yahoo_packet_new(YAHOO_SERVICE_CHATGOTO, YAHOO_STATUS_AVAILABLE, yd->session_id);
+	yahoo_packet_hash(pkt, "sss", 109, name, 1, purple_connection_get_display_name(gc), 62, "2");
+	yahoo_packet_send_and_free(pkt, yd);
+}
+/*
+ * These are the functions registered with the core
+ * which get called for both chats and conferences.
+ */
+
+void yahoo_c_leave(PurpleConnection *gc, int id)
+{
+	YahooData *yd = (YahooData *) gc->proto_data;
+	PurpleConversation *c;
+
+	if (!yd)
+		return;
+
+	c = purple_find_chat(gc, id);
+	if (!c)
+		return;
+
+	if (id != YAHOO_CHAT_ID) {
+		yahoo_conf_leave(yd, purple_conversation_get_name(c),
+			purple_connection_get_display_name(gc), purple_conv_chat_get_users(PURPLE_CONV_CHAT(c)));
+			yd->confs = g_slist_remove(yd->confs, c);
+	} else {
+		yahoo_chat_leave(gc, purple_conversation_get_name(c), purple_connection_get_display_name(gc), TRUE);
+	}
+
+	serv_got_chat_left(gc, id);
+}
+
+int yahoo_c_send(PurpleConnection *gc, int id, const char *what, PurpleMessageFlags flags)
+{
+	PurpleConversation *c;
+	int ret;
+	YahooData *yd;
+
+	yd = (YahooData *) gc->proto_data;
+	if (!yd)
+		return -1;
+
+	c = purple_find_chat(gc, id);
+	if (!c)
+		return -1;
+
+	if (id != YAHOO_CHAT_ID) {
+		ret = yahoo_conf_send(gc, purple_connection_get_display_name(gc),
+				purple_conversation_get_name(c), purple_conv_chat_get_users(PURPLE_CONV_CHAT(c)), what);
+	} else {
+		ret = yahoo_chat_send(gc, purple_connection_get_display_name(gc),
+						purple_conversation_get_name(c), what, flags);
+		if (!ret)
+			serv_got_chat_in(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(c)),
+					purple_connection_get_display_name(gc), flags, what, time(NULL));
+	}
+	return ret;
+}
+
+GList *yahoo_c_info(PurpleConnection *gc)
+{
+	GList *m = NULL;
+	struct proto_chat_entry *pce;
+
+	pce = g_new0(struct proto_chat_entry, 1);
+	pce->label = _("_Room:");
+	pce->identifier = "room";
+	pce->required = TRUE;
+	m = g_list_append(m, pce);
+
+	return m;
+}
+
+GHashTable *yahoo_c_info_defaults(PurpleConnection *gc, const char *chat_name)
+{
+	GHashTable *defaults;
+
+	defaults = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_free);
+
+	if (chat_name != NULL)
+		g_hash_table_insert(defaults, "room", g_strdup(chat_name));
+
+	return defaults;
+}
+
+char *yahoo_get_chat_name(GHashTable *data)
+{
+	return g_strdup(g_hash_table_lookup(data, "room"));
+}
+
+void yahoo_c_join(PurpleConnection *gc, GHashTable *data)
+{
+	YahooData *yd;
+	char *room, *topic, *type;
+	PurpleConversation *c;
+
+	yd = (YahooData *) gc->proto_data;
+	if (!yd)
+		return;
+
+	room = g_hash_table_lookup(data, "room");
+	if (!room)
+		return;
+
+	topic = g_hash_table_lookup(data, "topic");
+	if (!topic)
+		topic = "";
+
+	if ((type = g_hash_table_lookup(data, "type")) && !strcmp(type, "Conference")) {
+		int id;
+		const char *members = g_hash_table_lookup(data, "members");
+		id = yd->conf_id++;
+		c = serv_got_joined_chat(gc, id, room);
+		yd->confs = g_slist_prepend(yd->confs, c);
+		purple_conv_chat_set_topic(PURPLE_CONV_CHAT(c), purple_connection_get_display_name(gc), topic);
+		yahoo_conf_join(yd, c, purple_connection_get_display_name(gc), room, topic, members);
+		return;
+	} else {
+		const char *id;
+		/*if (yd->in_chat)
+			yahoo_chat_leave(gc, room,
+					purple_connection_get_display_name(gc),
+					FALSE);*/
+
+		id = g_hash_table_lookup(data, "id");
+
+		if (!yd->chat_online) {
+			yahoo_chat_online(gc);
+			g_free(yd->pending_chat_room);
+			yd->pending_chat_room = g_strdup(room);
+			g_free(yd->pending_chat_id);
+			yd->pending_chat_id = g_strdup(id);
+			g_free(yd->pending_chat_topic);
+			yd->pending_chat_topic = g_strdup(topic);
+			g_free(yd->pending_chat_goto);
+			yd->pending_chat_goto = NULL;
+		} else {
+			yahoo_chat_join(gc, purple_connection_get_display_name(gc), room, topic, id);
+		}
+		return;
+	}
+}
+
+void yahoo_c_invite(PurpleConnection *gc, int id, const char *msg, const char *name)
+{
+	PurpleConversation *c;
+
+	c = purple_find_chat(gc, id);
+	if (!c || !c->name)
+		return;
+
+	if (id != YAHOO_CHAT_ID) {
+		yahoo_conf_invite(gc, c, purple_connection_get_display_name(gc), name,
+							purple_conversation_get_name(c), msg);
+	} else {
+		yahoo_chat_invite(gc, purple_connection_get_display_name(gc), name,
+							purple_conversation_get_name(c), msg);
+	}
+}
+
+struct yahoo_roomlist {
+	int fd;
+	int inpa;
+	gchar *txbuf;
+	gsize tx_written;
+	guchar *rxqueue;
+	int rxlen;
+	gboolean started;
+	char *path;
+	char *host;
+	PurpleRoomlist *list;
+	PurpleRoomlistRoom *cat;
+	PurpleRoomlistRoom *ucat;
+	GMarkupParseContext *parse;
+};
+
+static void yahoo_roomlist_destroy(struct yahoo_roomlist *yrl)
+{
+	if (yrl->inpa)
+		purple_input_remove(yrl->inpa);
+	g_free(yrl->txbuf);
+	g_free(yrl->rxqueue);
+	g_free(yrl->path);
+	g_free(yrl->host);
+	if (yrl->parse)
+		g_markup_parse_context_free(yrl->parse);
+	g_free(yrl);
+}
+
+enum yahoo_room_type {
+	yrt_yahoo,
+	yrt_user
+};
+
+struct yahoo_chatxml_state {
+	PurpleRoomlist *list;
+	struct yahoo_roomlist *yrl;
+	GQueue *q;
+	struct {
+		enum yahoo_room_type type;
+		char *name;
+		char *topic;
+		char *id;
+		int users, voices, webcams;
+	} room;
+};
+
+struct yahoo_lobby {
+	int count, users, voices, webcams;
+};
+
+static struct yahoo_chatxml_state *yahoo_chatxml_state_new(PurpleRoomlist *list, struct yahoo_roomlist *yrl)
+{
+	struct yahoo_chatxml_state *s;
+
+	s = g_new0(struct yahoo_chatxml_state, 1);
+	s->list = list;
+	s->yrl = yrl;
+	s->q = g_queue_new();
+
+	return s;
+}
+
+static void yahoo_chatxml_state_destroy(struct yahoo_chatxml_state *s)
+{
+	g_queue_free(s->q);
+	g_free(s->room.name);
+	g_free(s->room.topic);
+	g_free(s->room.id);
+	g_free(s);
+}
+
+static void yahoo_chatlist_start_element(GMarkupParseContext *context,
+                                  const gchar *ename, const gchar **anames,
+                                  const gchar **avalues, gpointer user_data,
+                                  GError **error)
+{
+	struct yahoo_chatxml_state *s = user_data;
+	PurpleRoomlist *list = s->list;
+	PurpleRoomlistRoom *r;
+	PurpleRoomlistRoom *parent;
+	int i;
+
+	if (!strcmp(ename, "category")) {
+		const gchar *name = NULL, *id = NULL;
+
+		for (i = 0; anames[i]; i++) {
+			if (!strcmp(anames[i], "id"))
+				id = avalues[i];
+			if (!strcmp(anames[i], "name"))
+				name = avalues[i];
+		}
+		if (!name || !id)
+			return;
+
+		parent = g_queue_peek_head(s->q);
+		r = purple_roomlist_room_new(PURPLE_ROOMLIST_ROOMTYPE_CATEGORY, name, parent);
+		purple_roomlist_room_add_field(list, r, (gpointer)name);
+		purple_roomlist_room_add_field(list, r, (gpointer)id);
+		purple_roomlist_room_add(list, r);
+		g_queue_push_head(s->q, r);
+	} else if (!strcmp(ename, "room")) {
+		s->room.users = s->room.voices = s->room.webcams = 0;
+
+		for (i = 0; anames[i]; i++) {
+			if (!strcmp(anames[i], "id")) {
+				g_free(s->room.id);
+				s->room.id = g_strdup(avalues[i]);
+			} else if (!strcmp(anames[i], "name")) {
+				g_free(s->room.name);
+				s->room.name = g_strdup(avalues[i]);
+			} else if (!strcmp(anames[i], "topic")) {
+				g_free(s->room.topic);
+				s->room.topic = g_strdup(avalues[i]);
+			} else if (!strcmp(anames[i], "type")) {
+				if (!strcmp("yahoo", avalues[i]))
+					s->room.type = yrt_yahoo;
+				else
+					s->room.type = yrt_user;
+			}
+		}
+
+	} else if (!strcmp(ename, "lobby")) {
+		struct yahoo_lobby *lob = g_new0(struct yahoo_lobby, 1);
+
+		for (i = 0; anames[i]; i++) {
+			if (!strcmp(anames[i], "count")) {
+				lob->count = strtol(avalues[i], NULL, 10);
+			} else if (!strcmp(anames[i], "users")) {
+				s->room.users += lob->users = strtol(avalues[i], NULL, 10);
+			} else if (!strcmp(anames[i], "voices")) {
+				s->room.voices += lob->voices = strtol(avalues[i], NULL, 10);
+			} else if (!strcmp(anames[i], "webcams")) {
+				s->room.webcams += lob->webcams = strtol(avalues[i], NULL, 10);
+			}
+		}
+		g_queue_push_head(s->q, lob);
+	}
+}
+
+static void yahoo_chatlist_end_element(GMarkupParseContext *context, const gchar *ename,
+                                       gpointer user_data, GError **error)
+{
+	struct yahoo_chatxml_state *s = user_data;
+
+	if (!strcmp(ename, "category")) {
+		g_queue_pop_head(s->q);
+	} else if (!strcmp(ename, "room")) {
+		struct yahoo_lobby *lob;
+		PurpleRoomlistRoom *r, *l;
+
+		if (s->room.type == yrt_yahoo)
+			r = purple_roomlist_room_new(PURPLE_ROOMLIST_ROOMTYPE_CATEGORY|PURPLE_ROOMLIST_ROOMTYPE_ROOM,
+		                                   s->room.name, s->yrl->cat);
+		else
+			r = purple_roomlist_room_new(PURPLE_ROOMLIST_ROOMTYPE_CATEGORY|PURPLE_ROOMLIST_ROOMTYPE_ROOM,
+		                                   s->room.name, s->yrl->ucat);
+
+		purple_roomlist_room_add_field(s->list, r, s->room.name);
+		purple_roomlist_room_add_field(s->list, r, s->room.id);
+		purple_roomlist_room_add_field(s->list, r, GINT_TO_POINTER(s->room.users));
+		purple_roomlist_room_add_field(s->list, r, GINT_TO_POINTER(s->room.voices));
+		purple_roomlist_room_add_field(s->list, r, GINT_TO_POINTER(s->room.webcams));
+		purple_roomlist_room_add_field(s->list, r, s->room.topic);
+		purple_roomlist_room_add(s->list, r);
+
+		while ((lob = g_queue_pop_head(s->q))) {
+			char *name = g_strdup_printf("%s:%d", s->room.name, lob->count);
+			l = purple_roomlist_room_new(PURPLE_ROOMLIST_ROOMTYPE_ROOM, name, r);
+
+			purple_roomlist_room_add_field(s->list, l, name);
+			purple_roomlist_room_add_field(s->list, l, s->room.id);
+			purple_roomlist_room_add_field(s->list, l, GINT_TO_POINTER(lob->users));
+			purple_roomlist_room_add_field(s->list, l, GINT_TO_POINTER(lob->voices));
+			purple_roomlist_room_add_field(s->list, l, GINT_TO_POINTER(lob->webcams));
+			purple_roomlist_room_add_field(s->list, l, s->room.topic);
+			purple_roomlist_room_add(s->list, l);
+
+			g_free(name);
+			g_free(lob);
+		}
+	}
+}
+
+static GMarkupParser parser = {
+	yahoo_chatlist_start_element,
+	yahoo_chatlist_end_element,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void yahoo_roomlist_cleanup(PurpleRoomlist *list, struct yahoo_roomlist *yrl)
+{
+	purple_roomlist_set_in_progress(list, FALSE);
+
+	if (yrl) {
+		list->proto_data = g_list_remove(list->proto_data, yrl);
+		yahoo_roomlist_destroy(yrl);
+	}
+
+	purple_roomlist_unref(list);
+}
+
+static void yahoo_roomlist_pending(gpointer data, gint source, PurpleInputCondition cond)
+{
+	struct yahoo_roomlist *yrl = data;
+	PurpleRoomlist *list = yrl->list;
+	char buf[1024];
+	int len;
+	guchar *start;
+	struct yahoo_chatxml_state *s;
+
+	len = read(yrl->fd, buf, sizeof(buf));
+
+	if (len < 0 && errno == EAGAIN)
+		return;
+
+	if (len <= 0) {
+		if (yrl->parse)
+			g_markup_parse_context_end_parse(yrl->parse, NULL);
+		yahoo_roomlist_cleanup(list, yrl);
+		return;
+	}
+
+	yrl->rxqueue = g_realloc(yrl->rxqueue, len + yrl->rxlen);
+	memcpy(yrl->rxqueue + yrl->rxlen, buf, len);
+	yrl->rxlen += len;
+
+	if (!yrl->started) {
+		yrl->started = TRUE;
+		start = (guchar *)g_strstr_len((char *)yrl->rxqueue, yrl->rxlen, "\r\n\r\n");
+		if (!start || (start - yrl->rxqueue + 4) >= yrl->rxlen)
+			return;
+		start += 4;
+	} else {
+		start = yrl->rxqueue;
+	}
+
+	if (yrl->parse == NULL) {
+		s = yahoo_chatxml_state_new(list, yrl);
+		yrl->parse = g_markup_parse_context_new(&parser, 0, s,
+		             (GDestroyNotify)yahoo_chatxml_state_destroy);
+	}
+
+	if (!g_markup_parse_context_parse(yrl->parse, (char *)start, (yrl->rxlen - (start - yrl->rxqueue)), NULL)) {
+
+		yahoo_roomlist_cleanup(list, yrl);
+		return;
+	}
+
+	yrl->rxlen = 0;
+}
+
+static void yahoo_roomlist_send_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	struct yahoo_roomlist *yrl;
+	PurpleRoomlist *list;
+	int written, remaining;
+
+	yrl = data;
+	list = yrl->list;
+
+	remaining = strlen(yrl->txbuf) - yrl->tx_written;
+	written = write(yrl->fd, yrl->txbuf + yrl->tx_written, remaining);
+
+	if (written < 0 && errno == EAGAIN)
+		written = 0;
+	else if (written <= 0) {
+		purple_input_remove(yrl->inpa);
+		yrl->inpa = 0;
+		g_free(yrl->txbuf);
+		yrl->txbuf = NULL;
+		purple_notify_error(purple_account_get_connection(list->account), NULL, _("Unable to connect"), _("Fetching the room list failed."));
+		yahoo_roomlist_cleanup(list, yrl);
+		return;
+	}
+
+	if (written < remaining) {
+		yrl->tx_written += written;
+		return;
+	}
+
+	g_free(yrl->txbuf);
+	yrl->txbuf = NULL;
+
+	purple_input_remove(yrl->inpa);
+	yrl->inpa = purple_input_add(yrl->fd, PURPLE_INPUT_READ,
+							   yahoo_roomlist_pending, yrl);
+
+}
+
+static void yahoo_roomlist_got_connected(gpointer data, gint source, const gchar *error_message)
+{
+	struct yahoo_roomlist *yrl = data;
+	PurpleRoomlist *list = yrl->list;
+	YahooData *yd = purple_account_get_connection(list->account)->proto_data;
+
+	if (source < 0) {
+		purple_notify_error(purple_account_get_connection(list->account), NULL, _("Unable to connect"), _("Fetching the room list failed."));
+		yahoo_roomlist_cleanup(list, yrl);
+		return;
+	}
+
+	yrl->fd = source;
+
+	yrl->txbuf = g_strdup_printf(
+		"GET http://%s/%s HTTP/1.0\r\n"
+		"Host: %s\r\n"
+		"Cookie: Y=%s; T=%s\r\n\r\n",
+		yrl->host, yrl->path, yrl->host, yd->cookie_y,
+		yd->cookie_t);
+
+
+	yrl->inpa = purple_input_add(yrl->fd, PURPLE_INPUT_WRITE,
+							   yahoo_roomlist_send_cb, yrl);
+	yahoo_roomlist_send_cb(yrl, yrl->fd, PURPLE_INPUT_WRITE);
+}
+
+PurpleRoomlist *yahoo_roomlist_get_list(PurpleConnection *gc)
+{
+	PurpleAccount *account;
+	PurpleRoomlist *rl;
+	PurpleRoomlistField *f;
+	GList *fields = NULL;
+	struct yahoo_roomlist *yrl;
+	const char *rll, *rlurl;
+	char *url;
+
+	account = purple_connection_get_account(gc);
+
+	/* for Yahoo Japan, it appears there is only one valid URL and locale */
+	if(purple_account_get_bool(account, "yahoojp", FALSE)) {
+		rll = YAHOOJP_ROOMLIST_LOCALE;
+		rlurl = YAHOOJP_ROOMLIST_URL;
+	}
+	else { /* but for the rest of the world that isn't the case */
+		rll = purple_account_get_string(account, "room_list_locale", YAHOO_ROOMLIST_LOCALE);
+		rlurl = purple_account_get_string(account, "room_list", YAHOO_ROOMLIST_URL);
+	}
+
+	url = g_strdup_printf("%s?chatcat=0&intl=%s", rlurl, rll);
+
+	yrl = g_new0(struct yahoo_roomlist, 1);
+	rl = purple_roomlist_new(account);
+	yrl->list = rl;
+
+	purple_url_parse(url, &(yrl->host), NULL, &(yrl->path), NULL, NULL);
+	g_free(url);
+
+	f = purple_roomlist_field_new(PURPLE_ROOMLIST_FIELD_STRING, "", "room", TRUE);
+	fields = g_list_append(fields, f);
+
+	f = purple_roomlist_field_new(PURPLE_ROOMLIST_FIELD_STRING, "", "id", TRUE);
+	fields = g_list_append(fields, f);
+
+	f = purple_roomlist_field_new(PURPLE_ROOMLIST_FIELD_INT, _("Users"), "users", FALSE);
+	fields = g_list_append(fields, f);
+
+	f = purple_roomlist_field_new(PURPLE_ROOMLIST_FIELD_INT, _("Voices"), "voices", FALSE);
+	fields = g_list_append(fields, f);
+
+	f = purple_roomlist_field_new(PURPLE_ROOMLIST_FIELD_INT, _("Webcams"), "webcams", FALSE);
+	fields = g_list_append(fields, f);
+
+	f = purple_roomlist_field_new(PURPLE_ROOMLIST_FIELD_STRING, _("Topic"), "topic", FALSE);
+	fields = g_list_append(fields, f);
+
+	purple_roomlist_set_fields(rl, fields);
+
+	if (purple_proxy_connect(gc, account, yrl->host, 80,
+	                       yahoo_roomlist_got_connected, yrl) == NULL)
+	{
+		purple_notify_error(gc, NULL, _("Connection problem"), _("Unable to fetch room list."));
+		yahoo_roomlist_cleanup(rl, yrl);
+		return NULL;
+	}
+
+	rl->proto_data = g_list_append(rl->proto_data, yrl);
+
+	purple_roomlist_set_in_progress(rl, TRUE);
+	return rl;
+}
+
+void yahoo_roomlist_cancel(PurpleRoomlist *list)
+{
+	GList *l, *k;
+
+	k = l = list->proto_data;
+	list->proto_data = NULL;
+
+	purple_roomlist_set_in_progress(list, FALSE);
+
+	for (; l; l = l->next) {
+		yahoo_roomlist_destroy(l->data);
+		purple_roomlist_unref(list);
+	}
+	g_list_free(k);
+}
+
+void yahoo_roomlist_expand_category(PurpleRoomlist *list, PurpleRoomlistRoom *category)
+{
+	struct yahoo_roomlist *yrl;
+	char *url;
+	char *id;
+	const char *rll;
+
+	if (category->type != PURPLE_ROOMLIST_ROOMTYPE_CATEGORY)
+		return;
+
+	if (!(id = g_list_nth_data(category->fields, 1))) {
+		purple_roomlist_set_in_progress(list, FALSE);
+		return;
+	}
+
+	rll = purple_account_get_string(list->account, "room_list_locale",
+								  YAHOO_ROOMLIST_LOCALE);
+
+	if (rll != NULL && *rll != '\0') {
+		url = g_strdup_printf("%s?chatroom_%s=0&intl=%s",
+	       purple_account_get_string(list->account,"room_list",
+	       YAHOO_ROOMLIST_URL), id, rll);
+	} else {
+		url = g_strdup_printf("%s?chatroom_%s=0",
+	       purple_account_get_string(list->account,"room_list",
+	       YAHOO_ROOMLIST_URL), id);
+	}
+
+	yrl = g_new0(struct yahoo_roomlist, 1);
+	yrl->list = list;
+	yrl->cat = category;
+	list->proto_data = g_list_append(list->proto_data, yrl);
+
+	purple_url_parse(url, &(yrl->host), NULL, &(yrl->path), NULL, NULL);
+	g_free(url);
+
+	yrl->ucat = purple_roomlist_room_new(PURPLE_ROOMLIST_ROOMTYPE_CATEGORY, _("User Rooms"), yrl->cat);
+	purple_roomlist_room_add(list, yrl->ucat);
+
+	if (purple_proxy_connect(purple_account_get_connection(list->account),
+			list->account, yrl->host, 80,
+			yahoo_roomlist_got_connected, yrl) == NULL)
+	{
+		purple_notify_error(purple_account_get_connection(list->account),
+		                  NULL, _("Connection problem"), _("Unable to fetch room list."));
+		purple_roomlist_ref(list);
+		yahoo_roomlist_cleanup(list, yrl);
+		return;
+	}
+
+	purple_roomlist_set_in_progress(list, TRUE);
+	purple_roomlist_ref(list);
+}
diff -uNr pidgin-2.10.11.orig/libpurple/protocols/yahoo/ycht.h pidgin-2.10.11/libpurple/protocols/yahoo/ycht.h
--- pidgin-2.10.11.orig/libpurple/protocols/yahoo/ycht.h	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/protocols/yahoo/ycht.h	2015-02-10 14:28:16.410686364 +0900
@@ -32,6 +32,10 @@
 #define YAHOO_YCHT_HOST "jcs3.chat.dcn.yahoo.com"
 #define YAHOO_YCHT_PORT 8002
 
+/* fix these --yaz */
+#define YAHOOJP_YCHT_HOST "chat.yahoo.co.jp"
+#define YAHOOJP_YCHT_PORT 8000
+
 #define YCHT_VERSION (0xae)
 #define YCHT_HEADER_LEN (0x10)
 
diff -uNr pidgin-2.10.11.orig/libpurple/server.c pidgin-2.10.11/libpurple/server.c
--- pidgin-2.10.11.orig/libpurple/server.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/server.c	2015-02-10 14:28:16.414019861 +0900
@@ -239,6 +239,8 @@
 	GSList *buddies;
 	PurpleBuddy *b;
 	PurpleConversation *conv;
+	gsize dummy;
+	gchar *alias2 = NULL;
 
 	account = purple_connection_get_account(gc);
 	buddies = purple_find_buddies(account, who);
@@ -255,13 +257,16 @@
 		if (purple_strequal(server_alias, alias))
 			continue;
 
-		purple_blist_server_alias_buddy(b, alias);
+		if(alias)
+			alias2 = sanitize_utf(alias, strlen(alias), &dummy);
+
+		purple_blist_server_alias_buddy(b, alias2);
 
 		conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, purple_buddy_get_name(b), account);
-		if (conv != NULL && alias != NULL && !purple_strequal(alias, who))
+		if (conv != NULL && alias2 != NULL && !purple_strequal(alias2, who))
 		{
 			char *escaped = g_markup_escape_text(who, -1);
-			char *escaped2 = g_markup_escape_text(alias, -1);
+			char *escaped2 = g_markup_escape_text(alias2, -1);
 			char *tmp = g_strdup_printf(_("%s is now known as %s.\n"),
 										escaped, escaped2);
 
@@ -273,6 +278,8 @@
 			g_free(escaped2);
 			g_free(escaped);
 		}
+		g_free(alias2);
+		alias2 = NULL;
 	}
 }
 
@@ -282,6 +289,8 @@
 	PurpleAccount *account = NULL;
 	GSList *buddies = NULL;
 	PurpleBuddy *b = NULL;
+	gsize dummy;
+	gchar *alias2 = NULL;
 
 	account = purple_connection_get_account(gc);
 	buddies = purple_find_buddies(account, who);
@@ -296,11 +305,13 @@
 		if (purple_strequal(balias, alias))
 			continue;
 
-		purple_blist_alias_buddy(b, alias);
+		alias2 = sanitize_utf(alias, strlen(alias), &dummy);
+		purple_blist_alias_buddy(b, alias2);
+		g_free(alias2);
+		alias2 = NULL;
 	}
 }
 
-
 PurpleAttentionType *purple_get_attention_type_from_code(PurpleAccount *account, guint type_code)
 {
 	PurplePlugin *prpl;
diff -uNr pidgin-2.10.11.orig/libpurple/util.c pidgin-2.10.11/libpurple/util.c
--- pidgin-2.10.11.orig/libpurple/util.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/util.c	2015-02-10 14:28:16.414019861 +0900
@@ -1277,6 +1277,8 @@
 		return FALSE;
 
 	q = strstr(p, end_token);
+	if(q == NULL) //yaz
+		return FALSE;
 
 	/* Trim leading blanks */
 	while (*p != '\n' && g_ascii_isspace(*p)) {
@@ -1289,7 +1291,7 @@
 	}
 
 	/* Don't bother with null strings */
-	if (p == q)
+	if (p >= q)
 		return FALSE;
 
 	if (q != NULL && (!no_value_token ||
@@ -2073,6 +2075,20 @@
 }
 
 static gboolean
+is_zenkaku_space(const char *c)
+{
+    gboolean rv = FALSE;
+    const guchar *u = (guchar *)c;
+
+    if(!c || !strcmp(c, "") || strlen(c) < 3)
+        rv = FALSE;
+    else if(*u == 0xe3 && *(u+1) == 0x80 && *(u+2) == 0x80)
+        rv = TRUE;
+
+    return rv;
+}
+
+static gboolean
 badchar(char c)
 {
 	switch (c) {
@@ -2112,7 +2128,7 @@
 	const char *t;
 
 	for (t = c;; t++) {
-		if (!badchar(*t) && !badentity(t))
+		if (!badchar(*t) && !badentity(t) && !is_zenkaku_space(t))
 			continue;
 
 		if (t - c == matchlen)
@@ -2148,6 +2164,7 @@
 	gunichar g;
 	gboolean inside_html = FALSE;
 	int inside_paren = 0;
+	int inside_bracket = 0;
 	GString *ret;
 
 	if (text == NULL)
@@ -2164,6 +2181,12 @@
 			c++;
 		}
 
+		if(*c == '[' && !inside_html) {
+			inside_bracket++;
+			ret = g_string_append_c(ret, *c);
+			c++;
+		}
+
 		if(inside_html) {
 			if(*c == '>') {
 				inside_html = FALSE;
@@ -2206,7 +2229,7 @@
 		} else if (!g_ascii_strncasecmp(c, "mailto:", 7)) {
 			t = c;
 			while (1) {
-				if (badchar(*t) || badentity(t)) {
+				if (badchar(*t) || badentity(t) || is_zenkaku_space(t)) {
 					char *d;
 					if (t - c == 7) {
 						break;
@@ -2307,6 +2330,11 @@
 			ret = g_string_append_c(ret, *c);
 			c++;
 		}
+		if(*c == ']' && !inside_html) {
+			inside_bracket--;
+			ret = g_string_append_c(ret, *c);
+			c++;
+		}
 
 		if (*c == 0)
 			break;
@@ -5164,3 +5192,296 @@
 			b,
 			(tmp >> 16) & 0xFFFF, g_random_int());
 }
+
+#ifdef _WIN32
+void botch_ucs(gchar *ucs_src, gsize len)
+{
+	/* no operation */
+}
+#else
+void botch_ucs(gchar *ucs_src, gsize len)
+{
+	gint i;
+	guchar *ucs = (guchar *)ucs_src;
+
+	g_return_if_fail(ucs_src != NULL);
+	g_return_if_fail(len > 0);
+
+ 	for(i=0;i<len;i+=2){
+ 		switch(*(ucs+i)){
+ 		case 0x00:
+ 			switch(*(ucs+i+1)){
+ 			case 0xa2:	// ¢
+ 				*(ucs+i) = 0xff;
+ 				*(ucs+i+1) = 0xe0;
+ 				break;
+ 			case 0xa3:	// £
+ 				*(ucs+i) = 0xff;
+				*(ucs+i+1) = 0xe1;
+ 				break;
+ 			case 0xac:	// ¬
+ 				*(ucs+i) = 0xff;
+ 				*(ucs+i+1) = 0xe2;
+ 				break;
+ 			}
+ 			break;
+ 		case 0x20:	// ‖
+ 			if(*(ucs+i+1) == 0x16){
+ 				*(ucs+i) = 0x22;
+				*(ucs+i+1) = 0x25;
+ 			}
+ 			break;
+ 		case 0x22:	// −
+ 			if(*(ucs+i+1) == 0x12){
+ 				*(ucs+i) = 0xff;
+ 				*(ucs+i+1) = 0x0d;
+ 			}
+ 			break;
+ 		case 0x30:	// 〜
+ 			if(*(ucs+i+1) == 0x1c){
+ 				*(ucs+i) = 0xff;
+ 				*(ucs+i+1) = 0x5e;
+ 			}
+ 			break;
+ 		}
+ 	}
+
+}
+#endif
+
+#ifdef _WIN32
+void sanitize_ucs(gchar *ucs, gsize len)
+{
+	/* no operation */
+}
+#else
+void sanitize_ucs(gchar *ucs_src, gsize len)
+{
+	gint i;
+	guchar *ucs = (guchar *)ucs_src;
+
+	g_return_if_fail(ucs_src != NULL);
+	g_return_if_fail(len > 0);
+
+	for(i=0;i<len;i+=2){
+		switch(*(ucs+i)){
+		case 0x22:
+			switch(*(ucs+i+1)){
+			case 0x25:	// ‖
+				*(ucs+i) = 0x20;
+				*(ucs+i+1) = 0x16;
+				break;
+			}
+			break;
+		case 0xff:
+			switch(*(ucs+i+1)){
+			case 0x0d:	// −
+				*(ucs+i) = 0x22;
+				*(ucs+i+1) = 0x12;
+				break;
+			case 0x5e:	// 〜
+				*(ucs+i) = 0x30;
+				*(ucs+i+1) = 0x1c;
+				break;
+			case 0xe0:	// ¢
+				*(ucs+i) = 0x00;
+				*(ucs+i+1) = 0xa2;
+				break;
+			case 0xe1:	// £
+				*(ucs+i) = 0x00;
+				*(ucs+i+1) = 0xa3;
+				break;
+			case 0xe2:	// ¬
+				*(ucs+i) = 0x00;
+				*(ucs+i+1) = 0xac;
+				break;
+			}
+			break;
+		}
+	}
+}
+#endif
+
+#ifdef _WIN32
+gchar *sanitize_utf(const gchar *msg, gsize len, gsize *newlen)
+{
+	g_return_val_if_fail(msg != NULL, NULL);
+	if(len == -1)
+		len = strlen(msg);
+	g_return_val_if_fail(len > 0, NULL);
+
+	if(newlen)
+		*newlen = len;
+
+	return g_strndup(msg, len);
+}
+#else
+gchar *sanitize_utf(const gchar *msg, gsize len, gsize *newlen)
+{
+	gint i;
+	size_t bytes;
+	guchar *utf;
+
+	g_return_val_if_fail(msg != NULL, NULL);
+	if(len == -1)
+		len = strlen(msg);
+	g_return_val_if_fail(len > 0, NULL);
+
+	utf = (guchar *)g_strndup(msg, len);
+
+	bytes = len;
+
+	for(i=0;i<len;i++){
+		switch(*(utf+i)){
+		case 0xe2:
+			if(*(utf+i+1) == 0x88) {
+				if(*(utf+i+2) == 0xa5) {	// ‖
+					*(utf+i) = 0xe2;
+					*(utf+i+1) = 0x80;
+					*(utf+i+2) = 0x96;
+				}
+			}
+			break;
+		case 0xef:
+			switch(*(utf+i+1)){
+			case 0xbc:
+				if(*(utf+i+2) == 0x8d) {	// −
+					*(utf+i) = 0xe2;
+					*(utf+i+1) = 0x88;
+					*(utf+i+2) = 0x92;
+				}
+				break;
+			case 0xbd:
+				if(*(utf+i+2) == 0x9e) {	// 〜
+					*(utf+i) = 0xe3;
+					*(utf+i+1) = 0x80;
+					*(utf+i+2) = 0x9c;
+				}
+				break;
+			case 0xbf:
+				switch(*(utf+i+2)){
+			       case 0xa0:	// ¢
+				       *(utf+i) = 0xc2;
+				       *(utf+i+1) = 0xa2;
+				       memmove(utf+i+2, utf+i+3,
+					       len-i-3); //shorten by 1byte
+				       bytes--;
+				       break;
+			       case 0xa1:	// £
+				       *(utf+i) = 0xc2;
+				       *(utf+i+1) = 0xa3;
+				       memmove(utf+i+2, utf+i+3,
+					       len-i-3); //shorten by 1byte
+				       bytes--;
+				       break;
+			       case 0xa2:	// ¬
+				       *(utf+i) = 0xc2;
+				       *(utf+i+1) = 0xac;
+				       memmove(utf+i+2, utf+i+3,
+					       len-i-3); //shorten by 1byte
+				       bytes--;
+				       break;
+			       }
+			       break;
+			}
+			break;
+		}
+	}
+	*(utf+bytes)= 0x00; //terminate
+	if(newlen)
+		*newlen = bytes;
+	return (gchar *)utf;
+}
+#endif
+
+#ifdef _WIN32
+gchar *botch_utf(const gchar *msg, gsize len, gsize *newlen)
+{
+	g_return_val_if_fail(msg != NULL, NULL);
+	if(len == -1)
+		len = strlen(msg);
+	g_return_val_if_fail(len > 0, NULL);
+
+	if(newlen)
+		*newlen = len;
+
+	return g_strndup(msg, len);
+}
+#else
+gchar *botch_utf(const gchar *msg, gsize len, gsize *newlen)
+{
+ 	int i,bytes;
+	unsigned char *utf;
+
+	g_return_val_if_fail(msg != NULL, NULL);
+	if(len == -1)
+		len = strlen(msg);
+	g_return_val_if_fail(len > 0, NULL);
+
+	bytes = len;
+
+	utf = g_malloc0(bytes*3/2+1); /* new length might be 3/2 in the worst case */
+	memcpy(utf, msg, bytes);
+
+ 	for(i=0;i<bytes;i++){
+ 		switch(*(utf+i)){
+ 		case 0xc2:
+ 			switch(*(utf+i+1)){
+ 			case 0xa2:	// ¢
+ 				*(utf+i) = 0xef;
+ 				*(utf+i+1) = 0xbf;
+				memmove(utf+i+3, utf+i+2, bytes-i-2);
+				*(utf+i+2) = 0xa0;
+				bytes++;
+ 				break;
+ 			case 0xa3:	// £
+ 				*(utf+i) = 0xef;
+ 				*(utf+i+1) = 0xbf;
+				memmove(utf+i+3, utf+i+2, bytes-i-2);
+				*(utf+i+2) = 0xa1;
+				bytes++;
+ 				break;
+ 			case 0xac:	// ¬
+ 				*(utf+i) = 0xef;
+ 				*(utf+i+1) = 0xbf;
+				memmove(utf+i+3, utf+i+2, bytes-i-2);
+				*(utf+i+2) = 0xa2;
+				bytes++;
+ 				break;
+ 			}
+ 			break;
+ 		case 0xe2:
+			switch(*(utf+i+1)){
+			case 0x80:	// ‖
+				if(*(utf+i+2) == 0x96){
+					*(utf+i) = 0xe2;
+					*(utf+i+1) = 0x88;
+					*(utf+i+2) = 0xa5;
+				}
+				break;
+			case 0x88:	// −
+				if(*(utf+i+1) == 0x92){
+					*(utf+i) = 0xef;
+					*(utf+i+1) = 0xbc;
+					*(utf+i+2) = 0x8d;
+				}
+				break;
+			}
+			break;
+ 		case 0xe3:	// 〜
+ 			if(*(utf+i+1) == 0x80){
+				if(*(utf+i+2) == 0x9c){
+					*(utf+i) = 0xef;
+					*(utf+i+1) = 0xbd;
+					*(utf+i+2) = 0x9e;
+				}
+ 			}
+ 			break;
+ 		} //switch
+ 	}
+	*(utf+bytes) = 0x00; //terminate
+	if(newlen)
+		*newlen = bytes;
+	return (gchar *)utf;
+}
+#endif
diff -uNr pidgin-2.10.11.orig/libpurple/util.c.orig pidgin-2.10.11/libpurple/util.c.orig
--- pidgin-2.10.11.orig/libpurple/util.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/libpurple/util.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,5166 @@
+/*
+ * @file util.h Utility Functions
+ * @ingroup core
+ */
+
+/* Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+#include "internal.h"
+
+#include "cipher.h"
+#include "conversation.h"
+#include "core.h"
+#include "debug.h"
+#include "notify.h"
+#include "ntlm.h"
+#include "prpl.h"
+#include "prefs.h"
+#include "util.h"
+
+/* 512KiB Default value for maximum HTTP download size (when the client hasn't
+   specified a length) */
+#define DEFAULT_MAX_HTTP_DOWNLOAD (512 * 1024)
+
+#define MAX_HTTP_CHUNK_SIZE (10 * 1024 * 1024)
+
+struct _PurpleUtilFetchUrlData
+{
+	PurpleUtilFetchUrlCallback callback;
+	void *user_data;
+
+	struct
+	{
+		char *user;
+		char *passwd;
+		char *address;
+		int port;
+		char *page;
+
+	} website;
+
+	char *url;
+	int num_times_redirected;
+	gboolean full;
+	char *user_agent;
+	gboolean http11;
+	char *request;
+	gsize request_written;
+	gboolean include_headers;
+
+	gboolean is_ssl;
+	PurpleSslConnection *ssl_connection;
+	PurpleProxyConnectData *connect_data;
+	int fd;
+	guint inpa;
+
+	gboolean got_headers;
+	gboolean has_explicit_data_len;
+	char *webdata;
+	gsize len;
+	unsigned long data_len;
+	gsize max_len;
+	gboolean chunked;
+	PurpleAccount *account;
+};
+
+static char *custom_user_dir = NULL;
+static char *user_dir = NULL;
+
+
+PurpleMenuAction *
+purple_menu_action_new(const char *label, PurpleCallback callback, gpointer data,
+                     GList *children)
+{
+	PurpleMenuAction *act = g_new0(PurpleMenuAction, 1);
+	act->label = g_strdup(label);
+	act->callback = callback;
+	act->data = data;
+	act->children = children;
+	return act;
+}
+
+void
+purple_menu_action_free(PurpleMenuAction *act)
+{
+	g_return_if_fail(act != NULL);
+
+	g_free(act->label);
+	g_free(act);
+}
+
+void
+purple_util_init(void)
+{
+	/* This does nothing right now.  It exists for symmetry with
+	 * purple_util_uninit() and forwards compatibility. */
+}
+
+void
+purple_util_uninit(void)
+{
+	/* Free these so we don't have leaks at shutdown. */
+
+	g_free(custom_user_dir);
+	custom_user_dir = NULL;
+
+	g_free(user_dir);
+	user_dir = NULL;
+}
+
+/**************************************************************************
+ * Base16 Functions
+ **************************************************************************/
+gchar *
+purple_base16_encode(const guchar *data, gsize len)
+{
+	gsize i;
+	gchar *ascii = NULL;
+
+	g_return_val_if_fail(data != NULL, NULL);
+	g_return_val_if_fail(len > 0,   NULL);
+
+	ascii = g_malloc(len * 2 + 1);
+
+	for (i = 0; i < len; i++)
+		g_snprintf(&ascii[i * 2], 3, "%02hhx", data[i]);
+
+	return ascii;
+}
+
+guchar *
+purple_base16_decode(const char *str, gsize *ret_len)
+{
+	gsize len, i, accumulator = 0;
+	guchar *data;
+
+	g_return_val_if_fail(str != NULL, NULL);
+
+	len = strlen(str);
+
+	g_return_val_if_fail(strlen(str) > 0, 0);
+	g_return_val_if_fail(len % 2 == 0,    0);
+
+	data = g_malloc(len / 2);
+
+	for (i = 0; i < len; i++)
+	{
+		if ((i % 2) == 0)
+			accumulator = 0;
+		else
+			accumulator <<= 4;
+
+		if (isdigit(str[i]))
+			accumulator |= str[i] - 48;
+		else
+		{
+			switch(tolower(str[i]))
+			{
+				case 'a':  accumulator |= 10;  break;
+				case 'b':  accumulator |= 11;  break;
+				case 'c':  accumulator |= 12;  break;
+				case 'd':  accumulator |= 13;  break;
+				case 'e':  accumulator |= 14;  break;
+				case 'f':  accumulator |= 15;  break;
+			}
+		}
+
+		if (i % 2)
+			data[(i - 1) / 2] = accumulator;
+	}
+
+	if (ret_len != NULL)
+		*ret_len = len / 2;
+
+	return data;
+}
+
+gchar *
+purple_base16_encode_chunked(const guchar *data, gsize len)
+{
+	gsize i;
+	gchar *ascii = NULL;
+
+	g_return_val_if_fail(data != NULL, NULL);
+	g_return_val_if_fail(len > 0,   NULL);
+
+	/* For each byte of input, we need 2 bytes for the hex representation
+	 * and 1 for the colon.
+	 * The final colon will be replaced by a terminating NULL
+	 */
+	ascii = g_malloc(len * 3 + 1);
+
+	for (i = 0; i < len; i++)
+		g_snprintf(&ascii[i * 3], 4, "%02hhx:", data[i]);
+
+	/* Replace the final colon with NULL */
+	ascii[len * 3 - 1] = 0;
+
+	return ascii;
+}
+
+
+/**************************************************************************
+ * Base64 Functions
+ **************************************************************************/
+static const char alphabet[] =
+	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
+	"0123456789+/";
+
+static const char xdigits[] =
+	"0123456789abcdef";
+
+gchar *
+purple_base64_encode(const guchar *data, gsize len)
+{
+	return g_base64_encode(data, len);
+}
+
+guchar *
+purple_base64_decode(const char *str, gsize *ret_len)
+{
+	/*
+	 * We want to allow ret_len to be NULL for backward compatibility,
+	 * but g_base64_decode() requires a valid length variable.  So if
+	 * ret_len is NULL then pass in a dummy variable.
+	 */
+	gsize unused;
+	return g_base64_decode(str, ret_len != NULL ? ret_len : &unused);
+}
+
+/**************************************************************************
+ * Quoted Printable Functions (see RFC 2045).
+ **************************************************************************/
+guchar *
+purple_quotedp_decode(const char *str, gsize *ret_len)
+{
+	char *n, *new;
+	const char *end, *p;
+
+	n = new = g_malloc(strlen (str) + 1);
+	end = str + strlen(str);
+
+	for (p = str; p < end; p++, n++) {
+		if (*p == '=') {
+			if (p[1] == '\r' && p[2] == '\n') { /* 5.1 #5 */
+				n -= 1;
+				p += 2;
+			} else if (p[1] == '\n') { /* fuzzy case for 5.1 #5 */
+				n -= 1;
+				p += 1;
+			} else if (p[1] && p[2]) {
+				char *nibble1 = strchr(xdigits, tolower(p[1]));
+				char *nibble2 = strchr(xdigits, tolower(p[2]));
+				if (nibble1 && nibble2) { /* 5.1 #1 */
+					*n = ((nibble1 - xdigits) << 4) | (nibble2 - xdigits);
+					p += 2;
+				} else { /* This should never happen */
+					*n = *p;
+				}
+			} else { /* This should never happen */
+				*n = *p;
+			}
+		}
+		else if (*p == '_')
+			*n = ' ';
+		else
+			*n = *p;
+	}
+
+	*n = '\0';
+
+	if (ret_len != NULL)
+		*ret_len = n - new;
+
+	/* Resize to take less space */
+	/* new = realloc(new, n - new); */
+
+	return (guchar *)new;
+}
+
+/**************************************************************************
+ * MIME Functions
+ **************************************************************************/
+char *
+purple_mime_decode_field(const char *str)
+{
+	/*
+	 * This is wing's version, partially based on revo/shx's version
+	 * See RFC2047 [which apparently obsoletes RFC1342]
+	 */
+	typedef enum {
+		state_start, state_equal1, state_question1,
+		state_charset, state_question2,
+		state_encoding, state_question3,
+		state_encoded_text, state_question4, state_equal2 = state_start
+	} encoded_word_state_t;
+	encoded_word_state_t state = state_start;
+	const char *cur, *mark;
+	const char *charset0 = NULL, *encoding0 = NULL, *encoded_text0 = NULL;
+	GString *new;
+
+	/* token can be any CHAR (supposedly ISO8859-1/ISO2022), not just ASCII */
+	#define token_char_p(c) \
+		(c != ' ' && !iscntrl(c) && !strchr("()<>@,;:\"/[]?.=", c))
+
+	/* But encoded-text must be ASCII; alas, isascii() may not exist */
+	#define encoded_text_char_p(c) \
+		((c & 0x80) == 0 && c != '?' && c != ' ' && isgraph(c))
+
+	g_return_val_if_fail(str != NULL, NULL);
+
+	new = g_string_new(NULL);
+
+	/* Here we will be looking for encoded words and if they seem to be
+	 * valid then decode them.
+	 * They are of this form: =?charset?encoding?text?=
+	 */
+
+	for (cur = str, mark = NULL; *cur; cur += 1) {
+		switch (state) {
+		case state_equal1:
+			if (*cur == '?') {
+				state = state_question1;
+			} else {
+				g_string_append_len(new, mark, cur - mark + 1);
+				state = state_start;
+			}
+			break;
+		case state_question1:
+			if (token_char_p(*cur)) {
+				charset0 = cur;
+				state = state_charset;
+			} else { /* This should never happen */
+				g_string_append_len(new, mark, cur - mark + 1);
+				state = state_start;
+			}
+			break;
+		case state_charset:
+			if (*cur == '?') {
+				state = state_question2;
+			} else if (!token_char_p(*cur)) { /* This should never happen */
+				g_string_append_len(new, mark, cur - mark + 1);
+				state = state_start;
+			}
+			break;
+		case state_question2:
+			if (token_char_p(*cur)) {
+				encoding0 = cur;
+				state = state_encoding;
+			} else { /* This should never happen */
+				g_string_append_len(new, mark, cur - mark + 1);
+				state = state_start;
+			}
+			break;
+		case state_encoding:
+			if (*cur == '?') {
+				state = state_question3;
+			} else if (!token_char_p(*cur)) { /* This should never happen */
+				g_string_append_len(new, mark, cur - mark + 1);
+				state = state_start;
+			}
+			break;
+		case state_question3:
+			if (encoded_text_char_p(*cur)) {
+				encoded_text0 = cur;
+				state = state_encoded_text;
+			} else if (*cur == '?') { /* empty string */
+				encoded_text0 = cur;
+				state = state_question4;
+			} else { /* This should never happen */
+				g_string_append_len(new, mark, cur - mark + 1);
+				state = state_start;
+			}
+			break;
+		case state_encoded_text:
+			if (*cur == '?') {
+				state = state_question4;
+			} else if (!encoded_text_char_p(*cur)) {
+				g_string_append_len(new, mark, cur - mark + 1);
+				state = state_start;
+			}
+			break;
+		case state_question4:
+			if (*cur == '=') { /* Got the whole encoded-word */
+				char *charset = g_strndup(charset0, encoding0 - charset0 - 1);
+				char *encoding = g_strndup(encoding0, encoded_text0 - encoding0 - 1);
+				char *encoded_text = g_strndup(encoded_text0, cur - encoded_text0 - 1);
+				guchar *decoded = NULL;
+				gsize dec_len;
+				if (g_ascii_strcasecmp(encoding, "Q") == 0)
+					decoded = purple_quotedp_decode(encoded_text, &dec_len);
+				else if (g_ascii_strcasecmp(encoding, "B") == 0)
+					decoded = purple_base64_decode(encoded_text, &dec_len);
+				else
+					decoded = NULL;
+				if (decoded) {
+					gsize len;
+					char *converted = g_convert((const gchar *)decoded, dec_len, "utf-8", charset, NULL, &len, NULL);
+
+					if (converted) {
+						g_string_append_len(new, converted, len);
+						g_free(converted);
+					}
+					g_free(decoded);
+				}
+				g_free(charset);
+				g_free(encoding);
+				g_free(encoded_text);
+				state = state_equal2; /* Restart the FSM */
+			} else { /* This should never happen */
+				g_string_append_len(new, mark, cur - mark + 1);
+				state = state_start;
+			}
+			break;
+		default:
+			if (*cur == '=') {
+				mark = cur;
+				state = state_equal1;
+			} else {
+				/* Some unencoded text. */
+				g_string_append_c(new, *cur);
+			}
+			break;
+		} /* switch */
+	} /* for */
+
+	if (state != state_start)
+		g_string_append_len(new, mark, cur - mark + 1);
+
+	return g_string_free(new, FALSE);;
+}
+
+
+/**************************************************************************
+ * Date/Time Functions
+ **************************************************************************/
+
+const char *purple_get_tzoff_str(const struct tm *tm, gboolean iso)
+{
+	static char buf[7];
+	long off;
+	gint8 min;
+	gint8 hrs;
+	struct tm new_tm = *tm;
+
+	mktime(&new_tm);
+
+	if (new_tm.tm_isdst < 0)
+		g_return_val_if_reached("");
+
+#ifdef _WIN32
+	if ((off = wpurple_get_tz_offset()) == -1)
+		return "";
+#else
+# ifdef HAVE_TM_GMTOFF
+	off = new_tm.tm_gmtoff;
+# else
+#  ifdef HAVE_TIMEZONE
+	tzset();
+	off = -1 * timezone;
+#  endif /* HAVE_TIMEZONE */
+# endif /* !HAVE_TM_GMTOFF */
+#endif /* _WIN32 */
+
+	min = (off / 60) % 60;
+	hrs = ((off / 60) - min) / 60;
+
+	if(iso) {
+		if (0 == off) {
+			strcpy(buf, "Z");
+		} else {
+			/* please leave the colons...they're optional for iso, but jabber
+			 * wants them */
+			if(g_snprintf(buf, sizeof(buf), "%+03d:%02d", hrs, ABS(min)) > 6)
+				g_return_val_if_reached("");
+		}
+	} else {
+		if (g_snprintf(buf, sizeof(buf), "%+03d%02d", hrs, ABS(min)) > 5)
+			g_return_val_if_reached("");
+	}
+
+	return buf;
+}
+
+/* Windows doesn't HAVE_STRFTIME_Z_FORMAT, but this seems clearer. -- rlaager */
+#if !defined(HAVE_STRFTIME_Z_FORMAT) || defined(_WIN32)
+static size_t purple_internal_strftime(char *s, size_t max, const char *format, const struct tm *tm)
+{
+	const char *start;
+	const char *c;
+	char *fmt = NULL;
+
+	/* Yes, this is checked in purple_utf8_strftime(),
+	 * but better safe than sorry. -- rlaager */
+	g_return_val_if_fail(format != NULL, 0);
+
+	/* This is fairly efficient, and it only gets
+	 * executed on Windows or if the underlying
+	 * system doesn't support the %z format string,
+	 * for strftime() so I think it's good enough.
+	 * -- rlaager */
+	for (c = start = format; *c ; c++)
+	{
+		if (*c != '%')
+			continue;
+
+		c++;
+
+#ifndef HAVE_STRFTIME_Z_FORMAT
+		if (*c == 'z')
+		{
+			char *tmp = g_strdup_printf("%s%.*s%s",
+			                            fmt ? fmt : "",
+			                            c - start - 1,
+			                            start,
+			                            purple_get_tzoff_str(tm, FALSE));
+			g_free(fmt);
+			fmt = tmp;
+			start = c + 1;
+		}
+#endif
+#ifdef _WIN32
+		if (*c == 'Z')
+		{
+			char *tmp = g_strdup_printf("%s%.*s%s",
+			                            fmt ? fmt : "",
+			                            c - start - 1,
+			                            start,
+			                            wpurple_get_timezone_abbreviation(tm));
+			g_free(fmt);
+			fmt = tmp;
+			start = c + 1;
+		}
+#endif
+	}
+
+	if (fmt != NULL)
+	{
+		size_t ret;
+
+		if (*start)
+		{
+			char *tmp = g_strconcat(fmt, start, NULL);
+			g_free(fmt);
+			fmt = tmp;
+		}
+
+		ret = strftime(s, max, fmt, tm);
+		g_free(fmt);
+
+		return ret;
+	}
+
+	return strftime(s, max, format, tm);
+}
+#else /* HAVE_STRFTIME_Z_FORMAT && !_WIN32 */
+#define purple_internal_strftime strftime
+#endif
+
+const char *
+purple_utf8_strftime(const char *format, const struct tm *tm)
+{
+	static char buf[128];
+	char *locale;
+	GError *err = NULL;
+	int len;
+	char *utf8;
+
+	g_return_val_if_fail(format != NULL, NULL);
+
+	if (tm == NULL)
+	{
+		time_t now = time(NULL);
+		tm = localtime(&now);
+	}
+
+	locale = g_locale_from_utf8(format, -1, NULL, NULL, &err);
+	if (err != NULL)
+	{
+		purple_debug_error("util", "Format conversion failed in purple_utf8_strftime(): %s\n", err->message);
+		g_error_free(err);
+		err = NULL;
+		locale = g_strdup(format);
+	}
+
+	/* A return value of 0 is either an error (in
+	 * which case, the contents of the buffer are
+	 * undefined) or the empty string (in which
+	 * case, no harm is done here). */
+	if ((len = purple_internal_strftime(buf, sizeof(buf), locale, tm)) == 0)
+	{
+		g_free(locale);
+		return "";
+	}
+
+	g_free(locale);
+
+	utf8 = g_locale_to_utf8(buf, len, NULL, NULL, &err);
+	if (err != NULL)
+	{
+		purple_debug_error("util", "Result conversion failed in purple_utf8_strftime(): %s\n", err->message);
+		g_error_free(err);
+	}
+	else
+	{
+		purple_strlcpy(buf, utf8);
+		g_free(utf8);
+	}
+
+	return buf;
+}
+
+const char *
+purple_date_format_short(const struct tm *tm)
+{
+	return purple_utf8_strftime("%x", tm);
+}
+
+const char *
+purple_date_format_long(const struct tm *tm)
+{
+	/*
+	 * This string determines how some dates are displayed.  The default
+	 * string "%x %X" shows the date then the time.  Translators can
+	 * change this to "%X %x" if they want the time to be shown first,
+	 * followed by the date.
+	 */
+	return purple_utf8_strftime(_("%x %X"), tm);
+}
+
+const char *
+purple_date_format_full(const struct tm *tm)
+{
+	return purple_utf8_strftime("%c", tm);
+}
+
+const char *
+purple_time_format(const struct tm *tm)
+{
+	return purple_utf8_strftime("%X", tm);
+}
+
+time_t
+purple_time_build(int year, int month, int day, int hour, int min, int sec)
+{
+	struct tm tm;
+
+	tm.tm_year = year - 1900;
+	tm.tm_mon = month - 1;
+	tm.tm_mday = day;
+	tm.tm_hour = hour;
+	tm.tm_min = min;
+	tm.tm_sec = sec >= 0 ? sec : time(NULL) % 60;
+
+	return mktime(&tm);
+}
+
+/* originally taken from GLib trunk 1-6-11 */
+/* originally licensed as LGPL 2+ */
+static time_t
+mktime_utc(struct tm *tm)
+{
+	time_t retval;
+
+#ifndef HAVE_TIMEGM
+	static const gint days_before[] =
+	{
+		0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
+	};
+#endif
+
+#ifndef HAVE_TIMEGM
+	if (tm->tm_mon < 0 || tm->tm_mon > 11)
+		return (time_t) -1;
+
+	retval = (tm->tm_year - 70) * 365;
+	retval += (tm->tm_year - 68) / 4;
+	retval += days_before[tm->tm_mon] + tm->tm_mday - 1;
+
+	if (tm->tm_year % 4 == 0 && tm->tm_mon < 2)
+		retval -= 1;
+
+	retval = ((((retval * 24) + tm->tm_hour) * 60) + tm->tm_min) * 60 + tm->tm_sec;
+#else
+	retval = timegm (tm);
+#endif /* !HAVE_TIMEGM */
+
+	return retval;
+}
+
+time_t
+purple_str_to_time(const char *timestamp, gboolean utc,
+	struct tm *tm, long *tz_off, const char **rest)
+{
+	struct tm t;
+	const gchar *str;
+	gint year = 0;
+	long tzoff = PURPLE_NO_TZ_OFF;
+	time_t retval;
+	gboolean mktime_with_utc = FALSE;
+
+	if (rest != NULL)
+		*rest = NULL;
+
+	g_return_val_if_fail(timestamp != NULL, 0);
+
+	memset(&t, 0, sizeof(struct tm));
+
+	str = timestamp;
+
+	/* Strip leading whitespace */
+	while (g_ascii_isspace(*str))
+		str++;
+
+	if (*str == '\0') {
+		if (rest != NULL && *str != '\0')
+			*rest = str;
+
+		return 0;
+	}
+
+	if (!g_ascii_isdigit(*str) && *str != '-' && *str != '+') {
+		if (rest != NULL && *str != '\0')
+			*rest = str;
+
+		return 0;
+	}
+
+	/* 4 digit year */
+	if (sscanf(str, "%04d", &year) && year >= 1900) {
+		str += 4;
+
+		if (*str == '-' || *str == '/')
+			str++;
+
+		t.tm_year = year - 1900;
+	}
+
+	/* 2 digit month */
+	if (!sscanf(str, "%02d", &t.tm_mon)) {
+		if (rest != NULL && *str != '\0')
+			*rest = str;
+
+		return 0;
+	}
+
+	str += 2;
+	t.tm_mon -= 1;
+
+	if (*str == '-' || *str == '/')
+		str++;
+
+	/* 2 digit day */
+	if (!sscanf(str, "%02d", &t.tm_mday)) {
+		if (rest != NULL && *str != '\0')
+			*rest = str;
+
+		return 0;
+	}
+
+	str += 2;
+
+	/* Grab the year off the end if there's still stuff */
+	if (*str == '/' || *str == '-') {
+		/* But make sure we don't read the year twice */
+		if (year >= 1900) {
+			if (rest != NULL && *str != '\0')
+				*rest = str;
+
+			return 0;
+		}
+
+		str++;
+
+		if (!sscanf(str, "%04d", &t.tm_year)) {
+			if (rest != NULL && *str != '\0')
+				*rest = str;
+
+			return 0;
+		}
+
+		t.tm_year -= 1900;
+	} else if (*str == 'T' || *str == '.') {
+		str++;
+
+		/* Continue grabbing the hours/minutes/seconds */
+		if ((sscanf(str, "%02d:%02d:%02d", &t.tm_hour, &t.tm_min, &t.tm_sec) == 3 &&
+				(str += 8)) ||
+		    (sscanf(str, "%02d%02d%02d", &t.tm_hour, &t.tm_min, &t.tm_sec) == 3 &&
+				(str += 6)))
+		{
+			gint sign, tzhrs, tzmins;
+
+			if (*str == '.') {
+				/* Cut off those pesky micro-seconds */
+				do {
+					str++;
+				} while (*str >= '0' && *str <= '9');
+			}
+
+			sign = (*str == '+') ? 1 : -1;
+
+			/* Process the timezone */
+			if (*str == '+' || *str == '-') {
+				str++;
+
+				if (((sscanf(str, "%02d:%02d", &tzhrs, &tzmins) == 2 && (str += 5)) ||
+					(sscanf(str, "%02d%02d", &tzhrs, &tzmins) == 2 && (str += 4))))
+				{
+					mktime_with_utc = TRUE;
+					tzoff = tzhrs * 60 * 60 + tzmins * 60;
+					tzoff *= sign;
+				}
+			} else if (*str == 'Z') {
+				/* 'Z' = Zulu = UTC */
+				str++;
+				mktime_with_utc = TRUE;
+				tzoff = 0;
+			}
+
+			if (!mktime_with_utc)
+			{
+				/* No timezone specified. */
+
+				if (utc) {
+					mktime_with_utc = TRUE;
+					tzoff = 0;
+				} else {
+					/* Local Time */
+					t.tm_isdst = -1;
+				}
+			}
+		}
+	}
+
+	if (rest != NULL && *str != '\0') {
+		/* Strip trailing whitespace */
+		while (g_ascii_isspace(*str))
+			str++;
+
+		if (*str != '\0')
+			*rest = str;
+	}
+
+	if (mktime_with_utc)
+		retval = mktime_utc(&t);
+	else
+		retval = mktime(&t);
+
+	if (tm != NULL)
+		*tm = t;
+
+	if (tzoff != PURPLE_NO_TZ_OFF)
+		retval -= tzoff;
+
+	if (tz_off != NULL)
+		*tz_off = tzoff;
+
+	return retval;
+}
+
+/**************************************************************************
+ * Markup Functions
+ **************************************************************************/
+
+/*
+ * This function is stolen from glib's gmarkup.c and modified to not
+ * replace ' with &apos;
+ */
+static void append_escaped_text(GString *str,
+		const gchar *text, gssize length)
+{
+	const gchar *p;
+	const gchar *end;
+	gunichar c;
+
+	p = text;
+	end = text + length;
+
+	while (p != end)
+	{
+		const gchar *next;
+		next = g_utf8_next_char (p);
+
+		switch (*p)
+		{
+			case '&':
+				g_string_append (str, "&amp;");
+				break;
+
+			case '<':
+				g_string_append (str, "&lt;");
+				break;
+
+			case '>':
+				g_string_append (str, "&gt;");
+				break;
+
+			case '"':
+				g_string_append (str, "&quot;");
+				break;
+
+			default:
+				c = g_utf8_get_char (p);
+				if ((0x1 <= c && c <= 0x8) ||
+						(0xb <= c && c <= 0xc) ||
+						(0xe <= c && c <= 0x1f) ||
+						(0x7f <= c && c <= 0x84) ||
+						(0x86 <= c && c <= 0x9f))
+					g_string_append_printf (str, "&#x%x;", c);
+				else
+					g_string_append_len (str, p, next - p);
+				break;
+		}
+
+		p = next;
+	}
+}
+
+/* This function is stolen from glib's gmarkup.c */
+gchar *purple_markup_escape_text(const gchar *text, gssize length)
+{
+	GString *str;
+
+	g_return_val_if_fail(text != NULL, NULL);
+
+	if (length < 0)
+		length = strlen(text);
+
+	/* prealloc at least as long as original text */
+	str = g_string_sized_new(length);
+	append_escaped_text(str, text, length);
+
+	return g_string_free(str, FALSE);
+}
+
+const char *
+purple_markup_unescape_entity(const char *text, int *length)
+{
+	const char *pln;
+	int len, pound;
+	char temp[2];
+
+	if (!text || *text != '&')
+		return NULL;
+
+#define IS_ENTITY(s)  (!g_ascii_strncasecmp(text, s, (len = sizeof(s) - 1)))
+
+	if(IS_ENTITY("&amp;"))
+		pln = "&";
+	else if(IS_ENTITY("&lt;"))
+		pln = "<";
+	else if(IS_ENTITY("&gt;"))
+		pln = ">";
+	else if(IS_ENTITY("&nbsp;"))
+		pln = " ";
+	else if(IS_ENTITY("&copy;"))
+		pln = "\302\251";      /* or use g_unichar_to_utf8(0xa9); */
+	else if(IS_ENTITY("&quot;"))
+		pln = "\"";
+	else if(IS_ENTITY("&reg;"))
+		pln = "\302\256";      /* or use g_unichar_to_utf8(0xae); */
+	else if(IS_ENTITY("&apos;"))
+		pln = "\'";
+	else if(*(text+1) == '#' &&
+			(sscanf(text, "&#%u%1[;]", &pound, temp) == 2 ||
+			 sscanf(text, "&#x%x%1[;]", &pound, temp) == 2) &&
+			pound != 0) {
+		static char buf[7];
+		int buflen = g_unichar_to_utf8((gunichar)pound, buf);
+		buf[buflen] = '\0';
+		pln = buf;
+
+		len = (*(text+2) == 'x' ? 3 : 2);
+		while(isxdigit((gint) text[len])) len++;
+		if(text[len] == ';') len++;
+	}
+	else
+		return NULL;
+
+	if (length)
+		*length = len;
+	return pln;
+}
+
+char *
+purple_markup_get_css_property(const gchar *style,
+				const gchar *opt)
+{
+	const gchar *css_str = style;
+	const gchar *css_value_start;
+	const gchar *css_value_end;
+	gchar *tmp;
+	gchar *ret;
+
+	g_return_val_if_fail(opt != NULL, NULL);
+
+	if (!css_str)
+		return NULL;
+
+	/* find the CSS property */
+	while (1)
+	{
+		/* skip whitespace characters */
+		while (*css_str && g_ascii_isspace(*css_str))
+			css_str++;
+		if (!g_ascii_isalpha(*css_str))
+			return NULL;
+		if (g_ascii_strncasecmp(css_str, opt, strlen(opt)))
+		{
+			/* go to next css property positioned after the next ';' */
+			while (*css_str && *css_str != '"' && *css_str != ';')
+				css_str++;
+			if(*css_str != ';')
+				return NULL;
+			css_str++;
+		}
+		else
+			break;
+	}
+
+	/* find the CSS value position in the string */
+	css_str += strlen(opt);
+	while (*css_str && g_ascii_isspace(*css_str))
+		css_str++;
+	if (*css_str != ':')
+		return NULL;
+	css_str++;
+	while (*css_str && g_ascii_isspace(*css_str))
+		css_str++;
+	if (*css_str == '\0' || *css_str == '"' || *css_str == ';')
+		return NULL;
+
+	/* mark the CSS value */
+	css_value_start = css_str;
+	while (*css_str && *css_str != '"' && *css_str != ';')
+		css_str++;
+	css_value_end = css_str - 1;
+
+	/* Removes trailing whitespace */
+	while (css_value_end > css_value_start && g_ascii_isspace(*css_value_end))
+		css_value_end--;
+
+	tmp = g_strndup(css_value_start, css_value_end - css_value_start + 1);
+	ret = purple_unescape_html(tmp);
+	g_free(tmp);
+
+	return ret;
+}
+
+gboolean purple_markup_is_rtl(const char *html)
+{
+	GData *attributes;
+	const gchar *start, *end;
+	gboolean res = FALSE;
+
+	if (purple_markup_find_tag("span", html, &start, &end, &attributes))
+	{
+		/* tmp is a member of attributes and is free with g_datalist_clear call */
+		const char *tmp = g_datalist_get_data(&attributes, "dir");
+		if (tmp && !g_ascii_strcasecmp(tmp, "RTL"))
+			res = TRUE;
+		if (!res)
+		{
+			tmp = g_datalist_get_data(&attributes, "style");
+			if (tmp)
+			{
+				char *tmp2 = purple_markup_get_css_property(tmp, "direction");
+				if (tmp2 && !g_ascii_strcasecmp(tmp2, "RTL"))
+					res = TRUE;
+				g_free(tmp2);
+			}
+
+		}
+		g_datalist_clear(&attributes);
+	}
+	return res;
+}
+
+gboolean
+purple_markup_find_tag(const char *needle, const char *haystack,
+					 const char **start, const char **end, GData **attributes)
+{
+	GData *attribs;
+	const char *cur = haystack;
+	char *name = NULL;
+	gboolean found = FALSE;
+	gboolean in_tag = FALSE;
+	gboolean in_attr = FALSE;
+	const char *in_quotes = NULL;
+	size_t needlelen;
+
+	g_return_val_if_fail(    needle != NULL, FALSE);
+	g_return_val_if_fail(   *needle != '\0', FALSE);
+	g_return_val_if_fail(  haystack != NULL, FALSE);
+	g_return_val_if_fail(     start != NULL, FALSE);
+	g_return_val_if_fail(       end != NULL, FALSE);
+	g_return_val_if_fail(attributes != NULL, FALSE);
+
+	needlelen = strlen(needle);
+	g_datalist_init(&attribs);
+
+	while (*cur && !found) {
+		if (in_tag) {
+			if (in_quotes) {
+				const char *close = cur;
+
+				while (*close && *close != *in_quotes)
+					close++;
+
+				/* if we got the close quote, store the value and carry on from    *
+				 * after it. if we ran to the end of the string, point to the NULL *
+				 * and we're outta here */
+				if (*close) {
+					/* only store a value if we have an attribute name */
+					if (name) {
+						size_t len = close - cur;
+						char *val = g_strndup(cur, len);
+
+						g_datalist_set_data_full(&attribs, name, val, g_free);
+						g_free(name);
+						name = NULL;
+					}
+
+					in_quotes = NULL;
+					cur = close + 1;
+				} else {
+					cur = close;
+				}
+			} else if (in_attr) {
+				const char *close = cur;
+
+				while (*close && *close != '>' && *close != '"' &&
+						*close != '\'' && *close != ' ' && *close != '=')
+					close++;
+
+				/* if we got the equals, store the name of the attribute. if we got
+				 * the quote, save the attribute and go straight to quote mode.
+				 * otherwise the tag closed or we reached the end of the string,
+				 * so we can get outta here */
+				switch (*close) {
+				case '"':
+				case '\'':
+					in_quotes = close;
+					/* fall through */
+				case '=':
+					{
+						size_t len = close - cur;
+
+						/* don't store a blank attribute name */
+						if (len) {
+							g_free(name);
+							name = g_ascii_strdown(cur, len);
+						}
+
+						in_attr = FALSE;
+						cur = close + 1;
+					}
+					break;
+				case ' ':
+				case '>':
+					in_attr = FALSE;
+					/* fall through */
+				default:
+					cur = close;
+					break;
+				}
+			} else {
+				switch (*cur) {
+				case ' ':
+					/* swallow extra spaces inside tag */
+					while (*cur && *cur == ' ') cur++;
+					in_attr = TRUE;
+					break;
+				case '>':
+					found = TRUE;
+					*end = cur;
+					break;
+				case '"':
+				case '\'':
+					in_quotes = cur;
+					/* fall through */
+				default:
+					cur++;
+					break;
+				}
+			}
+		} else {
+			/* if we hit a < followed by the name of our tag... */
+			if (*cur == '<' && !g_ascii_strncasecmp(cur + 1, needle, needlelen)) {
+				*start = cur;
+				cur = cur + needlelen + 1;
+
+				/* if we're pointing at a space or a >, we found the right tag. if *
+				 * we're not, we've found a longer tag, so we need to skip to the  *
+				 * >, but not being distracted by >s inside quotes.                */
+				if (*cur == ' ' || *cur == '>') {
+					in_tag = TRUE;
+				} else {
+					while (*cur && *cur != '"' && *cur != '\'' && *cur != '>') {
+						if (*cur == '"') {
+							cur++;
+							while (*cur && *cur != '"')
+								cur++;
+						} else if (*cur == '\'') {
+							cur++;
+							while (*cur && *cur != '\'')
+								cur++;
+						} else {
+							cur++;
+						}
+					}
+				}
+			} else {
+				cur++;
+			}
+		}
+	}
+
+	/* clean up any attribute name from a premature termination */
+	g_free(name);
+
+	if (found) {
+		*attributes = attribs;
+	} else {
+		*start = NULL;
+		*end = NULL;
+		*attributes = NULL;
+	}
+
+	return found;
+}
+
+gboolean
+purple_markup_extract_info_field(const char *str, int len, PurpleNotifyUserInfo *user_info,
+							   const char *start_token, int skip,
+							   const char *end_token, char check_value,
+							   const char *no_value_token,
+							   const char *display_name, gboolean is_link,
+							   const char *link_prefix,
+							   PurpleInfoFieldFormatCallback format_cb)
+{
+	const char *p, *q;
+
+	g_return_val_if_fail(str          != NULL, FALSE);
+	g_return_val_if_fail(user_info    != NULL, FALSE);
+	g_return_val_if_fail(start_token  != NULL, FALSE);
+	g_return_val_if_fail(end_token    != NULL, FALSE);
+	g_return_val_if_fail(display_name != NULL, FALSE);
+
+	p = strstr(str, start_token);
+
+	if (p == NULL)
+		return FALSE;
+
+	p += strlen(start_token) + skip;
+
+	if (p >= str + len)
+		return FALSE;
+
+	if (check_value != '\0' && *p == check_value)
+		return FALSE;
+
+	q = strstr(p, end_token);
+
+	/* Trim leading blanks */
+	while (*p != '\n' && g_ascii_isspace(*p)) {
+		p += 1;
+	}
+
+	/* Trim trailing blanks */
+	while (q > p && g_ascii_isspace(*(q - 1))) {
+		q -= 1;
+	}
+
+	/* Don't bother with null strings */
+	if (p == q)
+		return FALSE;
+
+	if (q != NULL && (!no_value_token ||
+					  (no_value_token && strncmp(p, no_value_token,
+												 strlen(no_value_token)))))
+	{
+		GString *dest = g_string_new("");
+
+		if (is_link)
+		{
+			g_string_append(dest, "<a href=\"");
+
+			if (link_prefix)
+				g_string_append(dest, link_prefix);
+
+			if (format_cb != NULL)
+			{
+				char *reformatted = format_cb(p, q - p);
+				g_string_append(dest, reformatted);
+				g_free(reformatted);
+			}
+			else
+				g_string_append_len(dest, p, q - p);
+			g_string_append(dest, "\">");
+
+			if (link_prefix)
+				g_string_append(dest, link_prefix);
+
+			g_string_append_len(dest, p, q - p);
+			g_string_append(dest, "</a>");
+		}
+		else
+		{
+			if (format_cb != NULL)
+			{
+				char *reformatted = format_cb(p, q - p);
+				g_string_append(dest, reformatted);
+				g_free(reformatted);
+			}
+			else
+				g_string_append_len(dest, p, q - p);
+		}
+
+		purple_notify_user_info_add_pair(user_info, display_name, dest->str);
+		g_string_free(dest, TRUE);
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+struct purple_parse_tag {
+	char *src_tag;
+	char *dest_tag;
+	gboolean ignore;
+};
+
+/* NOTE: Do not put `do {} while(0)` around this macro (as this is the method
+         recommended in the GCC docs). It contains 'continue's that should
+         affect the while-loop in purple_markup_html_to_xhtml and doing the
+         above would break that.
+         Also, remember to put braces in constructs that require them for
+         multiple statements when using this macro. */
+#define ALLOW_TAG_ALT(x, y) if(!g_ascii_strncasecmp(c, "<" x " ", strlen("<" x " "))) { \
+						const char *o = c + strlen("<" x); \
+						const char *p = NULL, *q = NULL, *r = NULL; \
+						/* o = iterating over full tag \
+						 * p = > (end of tag) \
+						 * q = start of quoted bit \
+						 * r = < inside tag \
+						 */ \
+						GString *innards = g_string_new(""); \
+						while(o && *o) { \
+							if(!q && (*o == '\"' || *o == '\'') ) { \
+								q = o; \
+							} else if(q) { \
+								if(*o == *q) { /* end of quoted bit */ \
+									char *unescaped = g_strndup(q+1, o-q-1); \
+									char *escaped = g_markup_escape_text(unescaped, -1); \
+									g_string_append_printf(innards, "%c%s%c", *q, escaped, *q); \
+									g_free(unescaped); \
+									g_free(escaped); \
+									q = NULL; \
+								} else if(*c == '\\') { \
+									o++; \
+								} \
+							} else if(*o == '<') { \
+								r = o; \
+							} else if(*o == '>') { \
+								p = o; \
+								break; \
+							} else { \
+								innards = g_string_append_c(innards, *o); \
+							} \
+							o++; \
+						} \
+						if(p && !r) { /* got an end of tag and no other < earlier */\
+							if(*(p-1) != '/') { \
+								struct purple_parse_tag *pt = g_new0(struct purple_parse_tag, 1); \
+								pt->src_tag = x; \
+								pt->dest_tag = y; \
+								tags = g_list_prepend(tags, pt); \
+							} \
+							if(xhtml) { \
+								xhtml = g_string_append(xhtml, "<" y); \
+								xhtml = g_string_append(xhtml, innards->str); \
+								xhtml = g_string_append_c(xhtml, '>'); \
+							} \
+							c = p + 1; \
+						} else { /* got end of tag with earlier < *or* didn't get anything */ \
+							if(xhtml) \
+								xhtml = g_string_append(xhtml, "&lt;"); \
+							if(plain) \
+								plain = g_string_append_c(plain, '<'); \
+							c++; \
+						} \
+						g_string_free(innards, TRUE); \
+						continue; \
+					} \
+					if(!g_ascii_strncasecmp(c, "<" x, strlen("<" x)) && \
+							(*(c+strlen("<" x)) == '>' || \
+							 !g_ascii_strncasecmp(c+strlen("<" x), "/>", 2))) { \
+						if(xhtml) \
+							xhtml = g_string_append(xhtml, "<" y); \
+						c += strlen("<" x); \
+						if(*c != '/') { \
+							struct purple_parse_tag *pt = g_new0(struct purple_parse_tag, 1); \
+							pt->src_tag = x; \
+							pt->dest_tag = y; \
+							tags = g_list_prepend(tags, pt); \
+							if(xhtml) \
+								xhtml = g_string_append_c(xhtml, '>'); \
+						} else { \
+							if(xhtml) \
+								xhtml = g_string_append(xhtml, "/>");\
+						} \
+						c = strchr(c, '>') + 1; \
+						continue; \
+					}
+/* Don't forget to check the note above for ALLOW_TAG_ALT. */
+#define ALLOW_TAG(x) ALLOW_TAG_ALT(x, x)
+void
+purple_markup_html_to_xhtml(const char *html, char **xhtml_out,
+						  char **plain_out)
+{
+	GString *xhtml = NULL;
+	GString *plain = NULL;
+	GString *url = NULL;
+	GString *cdata = NULL;
+	GList *tags = NULL, *tag;
+	const char *c = html;
+	char quote = '\0';
+
+#define CHECK_QUOTE(ptr) if (*(ptr) == '\'' || *(ptr) == '\"') \
+			quote = *(ptr++); \
+		else \
+			quote = '\0';
+
+#define VALID_CHAR(ptr) (*(ptr) && *(ptr) != quote && (quote || (*(ptr) != ' ' && *(ptr) != '>')))
+
+	g_return_if_fail(xhtml_out != NULL || plain_out != NULL);
+
+	if(xhtml_out)
+		xhtml = g_string_new("");
+	if(plain_out)
+		plain = g_string_new("");
+
+	while(c && *c) {
+		if(*c == '<') {
+			if(*(c+1) == '/') { /* closing tag */
+				tag = tags;
+				while(tag) {
+					struct purple_parse_tag *pt = tag->data;
+					if(!g_ascii_strncasecmp((c+2), pt->src_tag, strlen(pt->src_tag)) && *(c+strlen(pt->src_tag)+2) == '>') {
+						c += strlen(pt->src_tag) + 3;
+						break;
+					}
+					tag = tag->next;
+				}
+				if(tag) {
+					while(tags) {
+						struct purple_parse_tag *pt = tags->data;
+						if(xhtml && !pt->ignore)
+							g_string_append_printf(xhtml, "</%s>", pt->dest_tag);
+						if(plain && purple_strequal(pt->src_tag, "a")) {
+							/* if this is a link, we have to add the url to the plaintext, too */
+							if (cdata && url &&
+									(!g_string_equal(cdata, url) && (g_ascii_strncasecmp(url->str, "mailto:", 7) != 0 ||
+									                                 g_utf8_collate(url->str + 7, cdata->str) != 0)))
+								g_string_append_printf(plain, " <%s>", g_strstrip(url->str));
+							if (cdata) {
+								g_string_free(cdata, TRUE);
+								cdata = NULL;
+							}
+
+						}
+						if(tags == tag)
+							break;
+						tags = g_list_remove(tags, pt);
+						g_free(pt);
+					}
+					g_free(tag->data);
+					tags = g_list_remove(tags, tag->data);
+				} else {
+					/* a closing tag we weren't expecting...
+					 * we'll let it slide, if it's really a tag...if it's
+					 * just a </ we'll escape it properly */
+					const char *end = c+2;
+					while(*end && g_ascii_isalpha(*end))
+						end++;
+					if(*end == '>') {
+						c = end+1;
+					} else {
+						if(xhtml)
+							xhtml = g_string_append(xhtml, "&lt;");
+						if(plain)
+							plain = g_string_append_c(plain, '<');
+						c++;
+					}
+				}
+			} else { /* opening tag */
+				ALLOW_TAG("blockquote");
+				ALLOW_TAG("cite");
+				ALLOW_TAG("div");
+				ALLOW_TAG("em");
+				ALLOW_TAG("h1");
+				ALLOW_TAG("h2");
+				ALLOW_TAG("h3");
+				ALLOW_TAG("h4");
+				ALLOW_TAG("h5");
+				ALLOW_TAG("h6");
+				/* we only allow html to start the message */
+				if(c == html) {
+					ALLOW_TAG("html");
+				}
+				ALLOW_TAG_ALT("i", "em");
+				ALLOW_TAG_ALT("italic", "em");
+				ALLOW_TAG("li");
+				ALLOW_TAG("ol");
+				ALLOW_TAG("p");
+				ALLOW_TAG("pre");
+				ALLOW_TAG("q");
+				ALLOW_TAG("span");
+				ALLOW_TAG("ul");
+
+
+				/* we skip <HR> because it's not legal in XHTML-IM.  However,
+				 * we still want to send something sensible, so we put a
+				 * linebreak in its place. <BR> also needs special handling
+				 * because putting a </BR> to close it would just be dumb. */
+				if((!g_ascii_strncasecmp(c, "<br", 3)
+							|| !g_ascii_strncasecmp(c, "<hr", 3))
+						&& (*(c+3) == '>' ||
+							!g_ascii_strncasecmp(c+3, "/>", 2) ||
+							!g_ascii_strncasecmp(c+3, " />", 3))) {
+					c = strchr(c, '>') + 1;
+					if(xhtml)
+						xhtml = g_string_append(xhtml, "<br/>");
+					if(plain && *c != '\n')
+						plain = g_string_append_c(plain, '\n');
+					continue;
+				}
+				if(!g_ascii_strncasecmp(c, "<b>", 3) || !g_ascii_strncasecmp(c, "<bold>", strlen("<bold>")) || !g_ascii_strncasecmp(c, "<strong>", strlen("<strong>"))) {
+					struct purple_parse_tag *pt = g_new0(struct purple_parse_tag, 1);
+					if (*(c+2) == '>')
+						pt->src_tag = "b";
+					else if (*(c+2) == 'o')
+						pt->src_tag = "bold";
+					else
+						pt->src_tag = "strong";
+					pt->dest_tag = "span";
+					tags = g_list_prepend(tags, pt);
+					c = strchr(c, '>') + 1;
+					if(xhtml)
+						xhtml = g_string_append(xhtml, "<span style='font-weight: bold;'>");
+					continue;
+				}
+				if(!g_ascii_strncasecmp(c, "<u>", 3) || !g_ascii_strncasecmp(c, "<underline>", strlen("<underline>"))) {
+					struct purple_parse_tag *pt = g_new0(struct purple_parse_tag, 1);
+					pt->src_tag = *(c+2) == '>' ? "u" : "underline";
+					pt->dest_tag = "span";
+					tags = g_list_prepend(tags, pt);
+					c = strchr(c, '>') + 1;
+					if (xhtml)
+						xhtml = g_string_append(xhtml, "<span style='text-decoration: underline;'>");
+					continue;
+				}
+				if(!g_ascii_strncasecmp(c, "<s>", 3) || !g_ascii_strncasecmp(c, "<strike>", strlen("<strike>"))) {
+					struct purple_parse_tag *pt = g_new0(struct purple_parse_tag, 1);
+					pt->src_tag = *(c+2) == '>' ? "s" : "strike";
+					pt->dest_tag = "span";
+					tags = g_list_prepend(tags, pt);
+					c = strchr(c, '>') + 1;
+					if(xhtml)
+						xhtml = g_string_append(xhtml, "<span style='text-decoration: line-through;'>");
+					continue;
+				}
+				if(!g_ascii_strncasecmp(c, "<sub>", 5)) {
+					struct purple_parse_tag *pt = g_new0(struct purple_parse_tag, 1);
+					pt->src_tag = "sub";
+					pt->dest_tag = "span";
+					tags = g_list_prepend(tags, pt);
+					c = strchr(c, '>') + 1;
+					if(xhtml)
+						xhtml = g_string_append(xhtml, "<span style='vertical-align:sub;'>");
+					continue;
+				}
+				if(!g_ascii_strncasecmp(c, "<sup>", 5)) {
+					struct purple_parse_tag *pt = g_new0(struct purple_parse_tag, 1);
+					pt->src_tag = "sup";
+					pt->dest_tag = "span";
+					tags = g_list_prepend(tags, pt);
+					c = strchr(c, '>') + 1;
+					if(xhtml)
+						xhtml = g_string_append(xhtml, "<span style='vertical-align:super;'>");
+					continue;
+				}
+				if (!g_ascii_strncasecmp(c, "<img", 4) && (*(c+4) == '>' || *(c+4) == ' ')) {
+					const char *p = c + 4;
+					GString *src = NULL, *alt = NULL;
+					while (*p && *p != '>') {
+						if (!g_ascii_strncasecmp(p, "src=", 4)) {
+							const char *q = p + 4;
+							if (src)
+								g_string_free(src, TRUE);
+							src = g_string_new("");
+							CHECK_QUOTE(q);
+							while (VALID_CHAR(q)) {
+								src = g_string_append_c(src, *q);
+								q++;
+							}
+							p = q;
+						} else if (!g_ascii_strncasecmp(p, "alt=", 4)) {
+							const char *q = p + 4;
+							if (alt)
+								g_string_free(alt, TRUE);
+							alt = g_string_new("");
+							CHECK_QUOTE(q);
+							while (VALID_CHAR(q)) {
+								alt = g_string_append_c(alt, *q);
+								q++;
+							}
+							p = q;
+						} else {
+							p++;
+						}
+					}
+					if ((c = strchr(p, '>')) != NULL)
+						c++;
+					else
+						c = p;
+					/* src and alt are required! */
+					if(src && xhtml)
+						g_string_append_printf(xhtml, "<img src='%s' alt='%s' />", g_strstrip(src->str), alt ? alt->str : "");
+					if(alt) {
+						if(plain)
+							plain = g_string_append(plain, alt->str);
+						if(!src && xhtml)
+							xhtml = g_string_append(xhtml, alt->str);
+						g_string_free(alt, TRUE);
+					}
+					g_string_free(src, TRUE);
+					continue;
+				}
+				if (!g_ascii_strncasecmp(c, "<a", 2) && (*(c+2) == '>' || *(c+2) == ' ')) {
+					const char *p = c + 2;
+					struct purple_parse_tag *pt;
+					while (*p && *p != '>') {
+						if (!g_ascii_strncasecmp(p, "href=", 5)) {
+							const char *q = p + 5;
+							if (url)
+								g_string_free(url, TRUE);
+							url = g_string_new("");
+							if (cdata)
+								g_string_free(cdata, TRUE);
+							cdata = g_string_new("");
+							CHECK_QUOTE(q);
+							while (VALID_CHAR(q)) {
+								int len;
+								if ((*q == '&') && (purple_markup_unescape_entity(q, &len) == NULL))
+									url = g_string_append(url, "&amp;");
+								else
+									url = g_string_append_c(url, *q);
+								q++;
+							}
+							p = q;
+						} else {
+							p++;
+						}
+					}
+					if ((c = strchr(p, '>')) != NULL)
+						c++;
+					else
+						c = p;
+					pt = g_new0(struct purple_parse_tag, 1);
+					pt->src_tag = "a";
+					pt->dest_tag = "a";
+					tags = g_list_prepend(tags, pt);
+					if(xhtml)
+						g_string_append_printf(xhtml, "<a href=\"%s\">", url ? g_strstrip(url->str) : "");
+					continue;
+				}
+				if(!g_ascii_strncasecmp(c, "<font", 5) && (*(c+5) == '>' || *(c+5) == ' ')) {
+					const char *p = c + 5;
+					GString *style = g_string_new("");
+					struct purple_parse_tag *pt;
+					while (*p && *p != '>') {
+						if (!g_ascii_strncasecmp(p, "back=", 5)) {
+							const char *q = p + 5;
+							GString *color = g_string_new("");
+							CHECK_QUOTE(q);
+							while (VALID_CHAR(q)) {
+								color = g_string_append_c(color, *q);
+								q++;
+							}
+							g_string_append_printf(style, "background: %s; ", color->str);
+							g_string_free(color, TRUE);
+							p = q;
+						} else if (!g_ascii_strncasecmp(p, "color=", 6)) {
+							const char *q = p + 6;
+							GString *color = g_string_new("");
+							CHECK_QUOTE(q);
+							while (VALID_CHAR(q)) {
+								color = g_string_append_c(color, *q);
+								q++;
+							}
+							g_string_append_printf(style, "color: %s; ", color->str);
+							g_string_free(color, TRUE);
+							p = q;
+						} else if (!g_ascii_strncasecmp(p, "face=", 5)) {
+							const char *q = p + 5;
+							GString *face = g_string_new("");
+							CHECK_QUOTE(q);
+							while (VALID_CHAR(q)) {
+								face = g_string_append_c(face, *q);
+								q++;
+							}
+							g_string_append_printf(style, "font-family: %s; ", g_strstrip(face->str));
+							g_string_free(face, TRUE);
+							p = q;
+						} else if (!g_ascii_strncasecmp(p, "size=", 5)) {
+							const char *q = p + 5;
+							int sz;
+							const char *size = "medium";
+							CHECK_QUOTE(q);
+							sz = atoi(q);
+							switch (sz)
+							{
+							case 1:
+							  size = "xx-small";
+							  break;
+							case 2:
+							  size = "small";
+							  break;
+							case 3:
+							  size = "medium";
+							  break;
+							case 4:
+							  size = "large";
+							  break;
+							case 5:
+							  size = "x-large";
+							  break;
+							case 6:
+							case 7:
+							  size = "xx-large";
+							  break;
+							default:
+							  break;
+							}
+							g_string_append_printf(style, "font-size: %s; ", size);
+							p = q;
+						} else {
+							p++;
+						}
+					}
+					if ((c = strchr(p, '>')) != NULL)
+						c++;
+					else
+						c = p;
+					pt = g_new0(struct purple_parse_tag, 1);
+					pt->src_tag = "font";
+					pt->dest_tag = "span";
+					tags = g_list_prepend(tags, pt);
+					if(style->len && xhtml)
+						g_string_append_printf(xhtml, "<span style='%s'>", g_strstrip(style->str));
+					else
+						pt->ignore = TRUE;
+					g_string_free(style, TRUE);
+					continue;
+				}
+				if (!g_ascii_strncasecmp(c, "<body ", 6)) {
+					const char *p = c + 6;
+					gboolean did_something = FALSE;
+					while (*p && *p != '>') {
+						if (!g_ascii_strncasecmp(p, "bgcolor=", 8)) {
+							const char *q = p + 8;
+							struct purple_parse_tag *pt = g_new0(struct purple_parse_tag, 1);
+							GString *color = g_string_new("");
+							CHECK_QUOTE(q);
+							while (VALID_CHAR(q)) {
+								color = g_string_append_c(color, *q);
+								q++;
+							}
+							if (xhtml)
+								g_string_append_printf(xhtml, "<span style='background: %s;'>", g_strstrip(color->str));
+							g_string_free(color, TRUE);
+							if ((c = strchr(p, '>')) != NULL)
+								c++;
+							else
+								c = p;
+							pt->src_tag = "body";
+							pt->dest_tag = "span";
+							tags = g_list_prepend(tags, pt);
+							did_something = TRUE;
+							break;
+						}
+						p++;
+					}
+					if (did_something) continue;
+				}
+				/* this has to come after the special case for bgcolor */
+				ALLOW_TAG("body");
+				if(!g_ascii_strncasecmp(c, "<!--", strlen("<!--"))) {
+					char *p = strstr(c + strlen("<!--"), "-->");
+					if(p) {
+						if(xhtml)
+							xhtml = g_string_append(xhtml, "<!--");
+						c += strlen("<!--");
+						continue;
+					}
+				}
+
+				if(xhtml)
+					xhtml = g_string_append(xhtml, "&lt;");
+				if(plain)
+					plain = g_string_append_c(plain, '<');
+				c++;
+			}
+		} else if(*c == '&') {
+			char buf[7];
+			const char *pln;
+			int len;
+
+			if ((pln = purple_markup_unescape_entity(c, &len)) == NULL) {
+				len = 1;
+				g_snprintf(buf, sizeof(buf), "%c", *c);
+				pln = buf;
+			}
+			if(xhtml)
+				xhtml = g_string_append_len(xhtml, c, len);
+			if(plain)
+				plain = g_string_append(plain, pln);
+			if(cdata)
+				cdata = g_string_append_len(cdata, c, len);
+			c += len;
+		} else {
+			if(xhtml)
+				xhtml = g_string_append_c(xhtml, *c);
+			if(plain)
+				plain = g_string_append_c(plain, *c);
+			if(cdata)
+				cdata = g_string_append_c(cdata, *c);
+			c++;
+		}
+	}
+	if(xhtml) {
+		for (tag = tags; tag ; tag = tag->next) {
+			struct purple_parse_tag *pt = tag->data;
+			if(!pt->ignore)
+				g_string_append_printf(xhtml, "</%s>", pt->dest_tag);
+		}
+	}
+	g_list_free(tags);
+	if(xhtml_out)
+		*xhtml_out = g_string_free(xhtml, FALSE);
+	if(plain_out)
+		*plain_out = g_string_free(plain, FALSE);
+	if(url)
+		g_string_free(url, TRUE);
+	if (cdata)
+		g_string_free(cdata, TRUE);
+#undef CHECK_QUOTE
+#undef VALID_CHAR
+}
+
+/* The following are probably reasonable changes:
+ * - \n should be converted to a normal space
+ * - in addition to <br>, <p> and <div> etc. should also be converted into \n
+ * - We want to turn </td>#whitespace<td> sequences into a single tab
+ * - We want to turn <td> into a single tab (for msn profile "parsing")
+ * - We want to turn </tr>#whitespace<tr> sequences into a single \n
+ * - <script>...</script> and <style>...</style> should be completely removed
+ */
+
+char *
+purple_markup_strip_html(const char *str)
+{
+	int i, j, k, entlen;
+	gboolean visible = TRUE;
+	gboolean closing_td_p = FALSE;
+	gchar *str2;
+	const gchar *cdata_close_tag = NULL, *ent;
+	gchar *href = NULL;
+	int href_st = 0;
+
+	if(!str)
+		return NULL;
+
+	str2 = g_strdup(str);
+
+	for (i = 0, j = 0; str2[i]; i++)
+	{
+		if (str2[i] == '<')
+		{
+			if (cdata_close_tag)
+			{
+				/* Note: Don't even assume any other tag is a tag in CDATA */
+				if (g_ascii_strncasecmp(str2 + i, cdata_close_tag,
+						strlen(cdata_close_tag)) == 0)
+				{
+					i += strlen(cdata_close_tag) - 1;
+					cdata_close_tag = NULL;
+				}
+				continue;
+			}
+			else if (g_ascii_strncasecmp(str2 + i, "<td", 3) == 0 && closing_td_p)
+			{
+				str2[j++] = '\t';
+				visible = TRUE;
+			}
+			else if (g_ascii_strncasecmp(str2 + i, "</td>", 5) == 0)
+			{
+				closing_td_p = TRUE;
+				visible = FALSE;
+			}
+			else
+			{
+				closing_td_p = FALSE;
+				visible = TRUE;
+			}
+
+			k = i + 1;
+
+			if(g_ascii_isspace(str2[k]))
+				visible = TRUE;
+			else if (str2[k])
+			{
+				/* Scan until we end the tag either implicitly (closed start
+				 * tag) or explicitly, using a sloppy method (i.e., < or >
+				 * inside quoted attributes will screw us up)
+				 */
+				while (str2[k] && str2[k] != '<' && str2[k] != '>')
+				{
+					k++;
+				}
+
+				/* If we've got an <a> tag with an href, save the address
+				 * to print later. */
+				if (g_ascii_strncasecmp(str2 + i, "<a", 2) == 0 &&
+				    g_ascii_isspace(str2[i+2]))
+				{
+					int st; /* start of href, inclusive [ */
+					int end; /* end of href, exclusive ) */
+					char delim = ' ';
+					/* Find start of href */
+					for (st = i + 3; st < k; st++)
+					{
+						if (g_ascii_strncasecmp(str2+st, "href=", 5) == 0)
+						{
+							st += 5;
+							if (str2[st] == '"' || str2[st] == '\'')
+							{
+								delim = str2[st];
+								st++;
+							}
+							break;
+						}
+					}
+					/* find end of address */
+					for (end = st; end < k && str2[end] != delim; end++)
+					{
+						/* All the work is done in the loop construct above. */
+					}
+
+					/* If there's an address, save it.  If there was
+					 * already one saved, kill it. */
+					if (st < k)
+					{
+						char *tmp;
+						g_free(href);
+						tmp = g_strndup(str2 + st, end - st);
+						href = purple_unescape_html(tmp);
+						g_free(tmp);
+						href_st = j;
+					}
+				}
+
+				/* Replace </a> with an ascii representation of the
+				 * address the link was pointing to. */
+				else if (href != NULL && g_ascii_strncasecmp(str2 + i, "</a>", 4) == 0)
+				{
+					size_t hrlen = strlen(href);
+
+					/* Only insert the href if it's different from the CDATA. */
+					if ((hrlen != (gsize)(j - href_st) ||
+					     strncmp(str2 + href_st, href, hrlen)) &&
+					    (hrlen != (gsize)(j - href_st + 7) || /* 7 == strlen("http://") */
+					     strncmp(str2 + href_st, href + 7, hrlen - 7)))
+					{
+						str2[j++] = ' ';
+						str2[j++] = '(';
+						g_memmove(str2 + j, href, hrlen);
+						j += hrlen;
+						str2[j++] = ')';
+						g_free(href);
+						href = NULL;
+					}
+				}
+
+				/* Check for tags which should be mapped to newline (but ignore some of
+				 * the tags at the beginning of the text) */
+				else if ((j && (g_ascii_strncasecmp(str2 + i, "<p>", 3) == 0
+				              || g_ascii_strncasecmp(str2 + i, "<tr", 3) == 0
+				              || g_ascii_strncasecmp(str2 + i, "<hr", 3) == 0
+				              || g_ascii_strncasecmp(str2 + i, "<li", 3) == 0
+				              || g_ascii_strncasecmp(str2 + i, "<div", 4) == 0))
+				 || g_ascii_strncasecmp(str2 + i, "<br", 3) == 0
+				 || g_ascii_strncasecmp(str2 + i, "</table>", 8) == 0)
+				{
+					str2[j++] = '\n';
+				}
+				/* Check for tags which begin CDATA and need to be closed */
+#if 0 /* FIXME.. option is end tag optional, we can't handle this right now */
+				else if (g_ascii_strncasecmp(str2 + i, "<option", 7) == 0)
+				{
+					/* FIXME: We should not do this if the OPTION is SELECT'd */
+					cdata_close_tag = "</option>";
+				}
+#endif
+				else if (g_ascii_strncasecmp(str2 + i, "<script", 7) == 0)
+				{
+					cdata_close_tag = "</script>";
+				}
+				else if (g_ascii_strncasecmp(str2 + i, "<style", 6) == 0)
+				{
+					cdata_close_tag = "</style>";
+				}
+				/* Update the index and continue checking after the tag */
+				i = (str2[k] == '<' || str2[k] == '\0')? k - 1: k;
+				continue;
+			}
+		}
+		else if (cdata_close_tag)
+		{
+			continue;
+		}
+		else if (!g_ascii_isspace(str2[i]))
+		{
+			visible = TRUE;
+		}
+
+		if (str2[i] == '&' && (ent = purple_markup_unescape_entity(str2 + i, &entlen)) != NULL)
+		{
+			while (*ent)
+				str2[j++] = *ent++;
+			i += entlen - 1;
+			continue;
+		}
+
+		if (visible)
+			str2[j++] = g_ascii_isspace(str2[i])? ' ': str2[i];
+	}
+
+	g_free(href);
+
+	str2[j] = '\0';
+
+	return str2;
+}
+
+static gboolean
+badchar(char c)
+{
+	switch (c) {
+	case ' ':
+	case ',':
+	case '\0':
+	case '\n':
+	case '\r':
+	case '<':
+	case '>':
+	case '"':
+		return TRUE;
+	default:
+		return FALSE;
+	}
+}
+
+static gboolean
+badentity(const char *c)
+{
+	if (!g_ascii_strncasecmp(c, "&lt;", 4) ||
+		!g_ascii_strncasecmp(c, "&gt;", 4) ||
+		!g_ascii_strncasecmp(c, "&quot;", 6)) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static const char *
+process_link(GString *ret,
+		const char *start, const char *c,
+		int matchlen,
+		const char *urlprefix,
+		int inside_paren)
+{
+	char *url_buf, *tmpurlbuf;
+	const char *t;
+
+	for (t = c;; t++) {
+		if (!badchar(*t) && !badentity(t))
+			continue;
+
+		if (t - c == matchlen)
+			break;
+
+		if (*t == ',' && *(t + 1) != ' ') {
+			continue;
+		}
+
+		if (t > start && *(t - 1) == '.')
+			t--;
+		if (t > start && *(t - 1) == ')' && inside_paren > 0)
+			t--;
+
+		url_buf = g_strndup(c, t - c);
+		tmpurlbuf = purple_unescape_html(url_buf);
+		g_string_append_printf(ret, "<A HREF=\"%s%s\">%s</A>",
+				urlprefix,
+				tmpurlbuf, url_buf);
+		g_free(tmpurlbuf);
+		g_free(url_buf);
+		return t;
+	}
+
+	return c;
+}
+
+char *
+purple_markup_linkify(const char *text)
+{
+	const char *c, *t, *q = NULL;
+	char *tmpurlbuf, *url_buf;
+	gunichar g;
+	gboolean inside_html = FALSE;
+	int inside_paren = 0;
+	GString *ret;
+
+	if (text == NULL)
+		return NULL;
+
+	ret = g_string_new("");
+
+	c = text;
+	while (*c) {
+
+		if(*c == '(' && !inside_html) {
+			inside_paren++;
+			ret = g_string_append_c(ret, *c);
+			c++;
+		}
+
+		if(inside_html) {
+			if(*c == '>') {
+				inside_html = FALSE;
+			} else if(!q && (*c == '\"' || *c == '\'')) {
+				q = c;
+			} else if(q) {
+				if(*c == *q)
+					q = NULL;
+			}
+		} else if(*c == '<') {
+			inside_html = TRUE;
+			if (!g_ascii_strncasecmp(c, "<A", 2)) {
+				while (1) {
+					if (!g_ascii_strncasecmp(c, "/A>", 3)) {
+						inside_html = FALSE;
+						break;
+					}
+					ret = g_string_append_c(ret, *c);
+					c++;
+					if (!(*c))
+						break;
+				}
+			}
+		} else if (!g_ascii_strncasecmp(c, "http://", 7)) {
+			c = process_link(ret, text, c, 7, "", inside_paren);
+		} else if (!g_ascii_strncasecmp(c, "https://", 8)) {
+			c = process_link(ret, text, c, 8, "", inside_paren);
+		} else if (!g_ascii_strncasecmp(c, "ftp://", 6)) {
+			c = process_link(ret, text, c, 6, "", inside_paren);
+		} else if (!g_ascii_strncasecmp(c, "sftp://", 7)) {
+			c = process_link(ret, text, c, 7, "", inside_paren);
+		} else if (!g_ascii_strncasecmp(c, "file://", 7)) {
+			c = process_link(ret, text, c, 7, "", inside_paren);
+		} else if (!g_ascii_strncasecmp(c, "www.", 4) && c[4] != '.' && (c == text || badchar(c[-1]) || badentity(c-1))) {
+			c = process_link(ret, text, c, 4, "http://", inside_paren);
+		} else if (!g_ascii_strncasecmp(c, "ftp.", 4) && c[4] != '.' && (c == text || badchar(c[-1]) || badentity(c-1))) {
+			c = process_link(ret, text, c, 4, "ftp://", inside_paren);
+		} else if (!g_ascii_strncasecmp(c, "xmpp:", 5) && (c == text || badchar(c[-1]) || badentity(c-1))) {
+			c = process_link(ret, text, c, 5, "", inside_paren);
+		} else if (!g_ascii_strncasecmp(c, "mailto:", 7)) {
+			t = c;
+			while (1) {
+				if (badchar(*t) || badentity(t)) {
+					char *d;
+					if (t - c == 7) {
+						break;
+					}
+					if (t > text && *(t - 1) == '.')
+						t--;
+					if ((d = strstr(c + 7, "?")) != NULL && d < t)
+						url_buf = g_strndup(c + 7, d - c - 7);
+					else
+						url_buf = g_strndup(c + 7, t - c - 7);
+					if (!purple_email_is_valid(url_buf)) {
+						g_free(url_buf);
+						break;
+					}
+					g_free(url_buf);
+					url_buf = g_strndup(c, t - c);
+					tmpurlbuf = purple_unescape_html(url_buf);
+					g_string_append_printf(ret, "<A HREF=\"%s\">%s</A>",
+							  tmpurlbuf, url_buf);
+					g_free(url_buf);
+					g_free(tmpurlbuf);
+					c = t;
+					break;
+				}
+				t++;
+			}
+		} else if (c != text && (*c == '@')) {
+			int flag;
+			GString *gurl_buf = NULL;
+			const char illegal_chars[] = "!@#$%^&*()[]{}/|\\<>\":;\r\n \0";
+
+			if (strchr(illegal_chars,*(c - 1)) || strchr(illegal_chars, *(c + 1)))
+				flag = 0;
+			else {
+				flag = 1;
+				gurl_buf = g_string_new("");
+			}
+
+			t = c;
+			while (flag) {
+				/* iterate backwards grabbing the local part of an email address */
+				g = g_utf8_get_char(t);
+				if (badchar(*t) || (g >= 127) || (*t == '(') ||
+					((*t == ';') && ((t > (text+2) && (!g_ascii_strncasecmp(t - 3, "&lt;", 4) ||
+				                                       !g_ascii_strncasecmp(t - 3, "&gt;", 4))) ||
+				                     (t > (text+4) && (!g_ascii_strncasecmp(t - 5, "&quot;", 6)))))) {
+					/* local part will already be part of ret, strip it out */
+					ret = g_string_truncate(ret, ret->len - (c - t));
+					ret = g_string_append_unichar(ret, g);
+					break;
+				} else {
+					g_string_prepend_unichar(gurl_buf, g);
+					t = g_utf8_find_prev_char(text, t);
+					if (t < text) {
+						ret = g_string_assign(ret, "");
+						break;
+					}
+				}
+			}
+
+			t = g_utf8_find_next_char(c, NULL);
+
+			while (flag) {
+				/* iterate forwards grabbing the domain part of an email address */
+				g = g_utf8_get_char(t);
+				if (badchar(*t) || (g >= 127) || (*t == ')') || badentity(t)) {
+					char *d;
+
+					url_buf = g_string_free(gurl_buf, FALSE);
+
+					/* strip off trailing periods */
+					if (strlen(url_buf) > 0) {
+						for (d = url_buf + strlen(url_buf) - 1; *d == '.'; d--, t--)
+							*d = '\0';
+					}
+
+					tmpurlbuf = purple_unescape_html(url_buf);
+					if (purple_email_is_valid(tmpurlbuf)) {
+						g_string_append_printf(ret, "<A HREF=\"mailto:%s\">%s</A>",
+								tmpurlbuf, url_buf);
+					} else {
+						g_string_append(ret, url_buf);
+					}
+					g_free(url_buf);
+					g_free(tmpurlbuf);
+					c = t;
+
+					break;
+				} else {
+					g_string_append_unichar(gurl_buf, g);
+					t = g_utf8_find_next_char(t, NULL);
+				}
+			}
+		}
+
+		if(*c == ')' && !inside_html) {
+			inside_paren--;
+			ret = g_string_append_c(ret, *c);
+			c++;
+		}
+
+		if (*c == 0)
+			break;
+
+		ret = g_string_append_c(ret, *c);
+		c++;
+
+	}
+	return g_string_free(ret, FALSE);
+}
+
+char *purple_unescape_text(const char *in)
+{
+    GString *ret;
+    const char *c = in;
+
+    if (in == NULL)
+        return NULL;
+
+    ret = g_string_new("");
+    while (*c) {
+        int len;
+        const char *ent;
+
+        if ((ent = purple_markup_unescape_entity(c, &len)) != NULL) {
+            g_string_append(ret, ent);
+            c += len;
+        } else {
+            g_string_append_c(ret, *c);
+            c++;
+        }
+    }
+
+    return g_string_free(ret, FALSE);
+}
+
+char *purple_unescape_html(const char *html)
+{
+	GString *ret;
+	const char *c = html;
+
+	if (html == NULL)
+		return NULL;
+
+	ret = g_string_new("");
+	while (*c) {
+		int len;
+		const char *ent;
+
+		if ((ent = purple_markup_unescape_entity(c, &len)) != NULL) {
+			g_string_append(ret, ent);
+			c += len;
+		} else if (!strncmp(c, "<br>", 4)) {
+			g_string_append_c(ret, '\n');
+			c += 4;
+		} else {
+			g_string_append_c(ret, *c);
+			c++;
+		}
+	}
+
+	return g_string_free(ret, FALSE);
+}
+
+char *
+purple_markup_slice(const char *str, guint x, guint y)
+{
+	GString *ret;
+	GQueue *q;
+	guint z = 0;
+	gboolean appended = FALSE;
+	gunichar c;
+	char *tag;
+
+	g_return_val_if_fail(str != NULL, NULL);
+	g_return_val_if_fail(x <= y, NULL);
+
+	if (x == y)
+		return g_strdup("");
+
+	ret = g_string_new("");
+	q = g_queue_new();
+
+	while (*str && (z < y)) {
+		c = g_utf8_get_char(str);
+
+		if (c == '<') {
+			char *end = strchr(str, '>');
+
+			if (!end) {
+				g_string_free(ret, TRUE);
+				while ((tag = g_queue_pop_head(q)))
+					g_free(tag);
+				g_queue_free(q);
+				return NULL;
+			}
+
+			if (!g_ascii_strncasecmp(str, "<img ", 5)) {
+				z += strlen("[Image]");
+			} else if (!g_ascii_strncasecmp(str, "<br", 3)) {
+				z += 1;
+			} else if (!g_ascii_strncasecmp(str, "<hr>", 4)) {
+				z += strlen("\n---\n");
+			} else if (!g_ascii_strncasecmp(str, "</", 2)) {
+				/* pop stack */
+				char *tmp;
+
+				tmp = g_queue_pop_head(q);
+				g_free(tmp);
+				/* z += 0; */
+			} else {
+				/* push it unto the stack */
+				char *tmp;
+
+				tmp = g_strndup(str, end - str + 1);
+				g_queue_push_head(q, tmp);
+				/* z += 0; */
+			}
+
+			if (z >= x) {
+				g_string_append_len(ret, str, end - str + 1);
+			}
+
+			str = end;
+		} else if (c == '&') {
+			char *end = strchr(str, ';');
+			if (!end) {
+				g_string_free(ret, TRUE);
+				while ((tag = g_queue_pop_head(q)))
+					g_free(tag);
+				g_queue_free(q);
+
+				return NULL;
+			}
+
+			if (z >= x)
+				g_string_append_len(ret, str, end - str + 1);
+
+			z++;
+			str = end;
+		} else {
+			if (z == x && z > 0 && !appended) {
+				GList *l = q->tail;
+
+				while (l) {
+					tag = l->data;
+					g_string_append(ret, tag);
+					l = l->prev;
+				}
+				appended = TRUE;
+			}
+
+			if (z >= x)
+				g_string_append_unichar(ret, c);
+			z++;
+		}
+
+		str = g_utf8_next_char(str);
+	}
+
+	while ((tag = g_queue_pop_head(q))) {
+		char *name;
+
+		name = purple_markup_get_tag_name(tag);
+		g_string_append_printf(ret, "</%s>", name);
+		g_free(name);
+		g_free(tag);
+	}
+
+	g_queue_free(q);
+	return g_string_free(ret, FALSE);
+}
+
+char *
+purple_markup_get_tag_name(const char *tag)
+{
+	int i;
+	g_return_val_if_fail(tag != NULL, NULL);
+	g_return_val_if_fail(*tag == '<', NULL);
+
+	for (i = 1; tag[i]; i++)
+		if (tag[i] == '>' || tag[i] == ' ' || tag[i] == '/')
+			break;
+
+	return g_strndup(tag+1, i-1);
+}
+
+/**************************************************************************
+ * Path/Filename Functions
+ **************************************************************************/
+const char *
+purple_home_dir(void)
+{
+#ifndef _WIN32
+	return g_get_home_dir();
+#else
+	return wpurple_data_dir();
+#endif
+}
+
+/* Returns the argument passed to -c IFF it was present, or ~/.purple. */
+const char *
+purple_user_dir(void)
+{
+	if (custom_user_dir != NULL)
+		return custom_user_dir;
+	else if (!user_dir)
+		user_dir = g_build_filename(purple_home_dir(), ".purple", NULL);
+
+	return user_dir;
+}
+
+void purple_util_set_user_dir(const char *dir)
+{
+	g_free(custom_user_dir);
+
+	if (dir != NULL && *dir)
+		custom_user_dir = g_strdup(dir);
+	else
+		custom_user_dir = NULL;
+}
+
+int purple_build_dir (const char *path, int mode)
+{
+	return g_mkdir_with_parents(path, mode);
+}
+
+/*
+ * This function is long and beautiful, like my--um, yeah.  Anyway,
+ * it includes lots of error checking so as we don't overwrite
+ * people's settings if there is a problem writing the new values.
+ */
+gboolean
+purple_util_write_data_to_file(const char *filename, const char *data, gssize size)
+{
+	const char *user_dir = purple_user_dir();
+	gchar *filename_full;
+	gboolean ret = FALSE;
+
+	g_return_val_if_fail(user_dir != NULL, FALSE);
+
+	purple_debug_info("util", "Writing file %s to directory %s\n",
+					filename, user_dir);
+
+	/* Ensure the user directory exists */
+	if (!g_file_test(user_dir, G_FILE_TEST_IS_DIR))
+	{
+		if (g_mkdir(user_dir, S_IRUSR | S_IWUSR | S_IXUSR) == -1)
+		{
+			purple_debug_error("util", "Error creating directory %s: %s\n",
+							 user_dir, g_strerror(errno));
+			return FALSE;
+		}
+	}
+
+	filename_full = g_strdup_printf("%s" G_DIR_SEPARATOR_S "%s", user_dir, filename);
+
+	ret = purple_util_write_data_to_file_absolute(filename_full, data, size);
+
+	g_free(filename_full);
+	return ret;
+}
+
+gboolean
+purple_util_write_data_to_file_absolute(const char *filename_full, const char *data, gssize size)
+{
+	gchar *filename_temp;
+	FILE *file;
+	size_t real_size, byteswritten;
+	struct stat st;
+#ifndef HAVE_FILENO
+	int fd;
+#endif
+
+	purple_debug_info("util", "Writing file %s\n",
+					filename_full);
+
+	g_return_val_if_fail((size >= -1), FALSE);
+
+	filename_temp = g_strdup_printf("%s.save", filename_full);
+
+	/* Remove an old temporary file, if one exists */
+	if (g_file_test(filename_temp, G_FILE_TEST_EXISTS))
+	{
+		if (g_unlink(filename_temp) == -1)
+		{
+			purple_debug_error("util", "Error removing old file "
+					   "%s: %s\n",
+					   filename_temp, g_strerror(errno));
+		}
+	}
+
+	/* Open file */
+	file = g_fopen(filename_temp, "wb");
+	if (file == NULL)
+	{
+		purple_debug_error("util", "Error opening file %s for "
+				   "writing: %s\n",
+				   filename_temp, g_strerror(errno));
+		g_free(filename_temp);
+		return FALSE;
+	}
+
+	/* Write to file */
+	real_size = (size == -1) ? strlen(data) : (size_t) size;
+	byteswritten = fwrite(data, 1, real_size, file);
+
+#ifdef HAVE_FILENO
+#ifndef _WIN32
+	/* Set file permissions */
+	if (fchmod(fileno(file), S_IRUSR | S_IWUSR) == -1) {
+		purple_debug_error("util", "Error setting permissions of "
+			"file %s: %s\n", filename_temp, g_strerror(errno));
+	}
+#endif
+
+	/* Apparently XFS (and possibly other filesystems) do not
+	 * guarantee that file data is flushed before file metadata,
+	 * so this procedure is insufficient without some flushage. */
+	if (fflush(file) < 0) {
+		purple_debug_error("util", "Error flushing %s: %s\n",
+				   filename_temp, g_strerror(errno));
+		g_free(filename_temp);
+		fclose(file);
+		return FALSE;
+	}
+	if (fsync(fileno(file)) < 0) {
+		purple_debug_error("util", "Error syncing file contents for %s: %s\n",
+				   filename_temp, g_strerror(errno));
+		g_free(filename_temp);
+		fclose(file);
+		return FALSE;
+	}
+#endif
+
+	/* Close file */
+	if (fclose(file) != 0)
+	{
+		purple_debug_error("util", "Error closing file %s: %s\n",
+				   filename_temp, g_strerror(errno));
+		g_free(filename_temp);
+		return FALSE;
+	}
+
+#ifndef HAVE_FILENO
+	/* This is the same effect (we hope) as the HAVE_FILENO block
+	 * above, but for systems without fileno(). */
+	if ((fd = open(filename_temp, O_RDWR)) < 0) {
+		purple_debug_error("util", "Error opening file %s for flush: %s\n",
+				   filename_temp, g_strerror(errno));
+		g_free(filename_temp);
+		return FALSE;
+	}
+
+#ifndef _WIN32
+	/* copy-pasta! */
+	if (fchmod(fd, S_IRUSR | S_IWUSR) == -1) {
+		purple_debug_error("util", "Error setting permissions of "
+			"file %s: %s\n", filename_temp, g_strerror(errno));
+	}
+#endif
+
+	if (fsync(fd) < 0) {
+		purple_debug_error("util", "Error syncing %s: %s\n",
+				   filename_temp, g_strerror(errno));
+		g_free(filename_temp);
+		close(fd);
+		return FALSE;
+	}
+	if (close(fd) < 0) {
+		purple_debug_error("util", "Error closing %s after sync: %s\n",
+				   filename_temp, g_strerror(errno));
+		g_free(filename_temp);
+		return FALSE;
+	}
+#endif
+
+	/* Ensure the file is the correct size */
+	if (byteswritten != real_size)
+	{
+		purple_debug_error("util", "Error writing to file %s: Wrote %"
+				   G_GSIZE_FORMAT " bytes "
+				   "but should have written %" G_GSIZE_FORMAT
+				   "; is your disk full?\n",
+				   filename_temp, byteswritten, real_size);
+		g_free(filename_temp);
+		return FALSE;
+	}
+#ifndef __COVERITY__
+	/* Use stat to be absolutely sure.
+	 * It causes TOCTOU coverity warning (against g_rename below),
+	 * but it's not a threat for us.
+	 */
+	if ((g_stat(filename_temp, &st) == -1) || ((gsize)st.st_size != real_size))
+	{
+		purple_debug_error("util", "Error writing data to file %s: "
+				   "Incomplete file written; is your disk "
+				   "full?\n",
+				   filename_temp);
+		g_free(filename_temp);
+		return FALSE;
+	}
+#endif /* __COVERITY__ */
+
+	/* Rename to the REAL name */
+	if (g_rename(filename_temp, filename_full) == -1)
+	{
+		purple_debug_error("util", "Error renaming %s to %s: %s\n",
+				   filename_temp, filename_full,
+				   g_strerror(errno));
+	}
+
+	g_free(filename_temp);
+
+	return TRUE;
+}
+
+xmlnode *
+purple_util_read_xml_from_file(const char *filename, const char *description)
+{
+	return xmlnode_from_file(purple_user_dir(), filename, description, "util");
+}
+
+/*
+ * Like mkstemp() but returns a file pointer, uses a pre-set template,
+ * uses the semantics of tempnam() for the directory to use and allocates
+ * the space for the filepath.
+ *
+ * Caller is responsible for closing the file and removing it when done,
+ * as well as freeing the space pointed-to by "path" with g_free().
+ *
+ * Returns NULL on failure and cleans up after itself if so.
+ */
+static const char *purple_mkstemp_templ = {"purpleXXXXXX"};
+
+FILE *
+purple_mkstemp(char **fpath, gboolean binary)
+{
+	const gchar *tmpdir;
+	int fd;
+	FILE *fp = NULL;
+
+	g_return_val_if_fail(fpath != NULL, NULL);
+
+	if((tmpdir = (gchar*)g_get_tmp_dir()) != NULL) {
+		if((*fpath = g_strdup_printf("%s" G_DIR_SEPARATOR_S "%s", tmpdir, purple_mkstemp_templ)) != NULL) {
+			fd = g_mkstemp(*fpath);
+			if(fd == -1) {
+				purple_debug(PURPLE_DEBUG_ERROR, "purple_mkstemp",
+						   "Couldn't make \"%s\", error: %d\n",
+						   *fpath, errno);
+			} else {
+				if((fp = fdopen(fd, "r+")) == NULL) {
+					close(fd);
+					purple_debug(PURPLE_DEBUG_ERROR, "purple_mkstemp",
+							   "Couldn't fdopen(), error: %d\n", errno);
+				}
+			}
+
+			if(!fp) {
+				g_free(*fpath);
+				*fpath = NULL;
+			}
+		}
+	} else {
+		purple_debug(PURPLE_DEBUG_ERROR, "purple_mkstemp",
+				   "g_get_tmp_dir() failed!\n");
+	}
+
+	return fp;
+}
+
+const char *
+purple_util_get_image_extension(gconstpointer data, size_t len)
+{
+	g_return_val_if_fail(data != NULL, NULL);
+	g_return_val_if_fail(len   > 0,    NULL);
+
+	if (len >= 4)
+	{
+		if (!strncmp((char *)data, "GIF8", 4))
+			return "gif";
+		else if (!strncmp((char *)data, "\xff\xd8\xff", 3)) /* 4th may be e0 through ef */
+			return "jpg";
+		else if (!strncmp((char *)data, "\x89PNG", 4))
+			return "png";
+		else if (!strncmp((char *)data, "MM", 2) ||
+				 !strncmp((char *)data, "II", 2))
+			return "tif";
+		else if (!strncmp((char *)data, "BM", 2))
+			return "bmp";
+	}
+
+	return "icon";
+}
+
+/*
+ * We thought about using non-cryptographic hashes like CRC32 here.
+ * They would be faster, but we think using something more secure is
+ * important, so that it is more difficult for someone to maliciously
+ * replace one buddy's icon with something else.
+ */
+char *
+purple_util_get_image_checksum(gconstpointer image_data, size_t image_len)
+{
+	PurpleCipherContext *context;
+	gchar digest[41];
+
+	context = purple_cipher_context_new_by_name("sha1", NULL);
+	if (context == NULL)
+	{
+		purple_debug_error("util", "Could not find sha1 cipher\n");
+		g_return_val_if_reached(NULL);
+	}
+
+	/* Hash the image data */
+	purple_cipher_context_append(context, image_data, image_len);
+	if (!purple_cipher_context_digest_to_str(context, sizeof(digest), digest, NULL))
+	{
+		purple_debug_error("util", "Failed to get SHA-1 digest.\n");
+		g_return_val_if_reached(NULL);
+	}
+	purple_cipher_context_destroy(context);
+
+	return g_strdup(digest);
+}
+
+char *
+purple_util_get_image_filename(gconstpointer image_data, size_t image_len)
+{
+	/* Return the filename */
+	char *checksum = purple_util_get_image_checksum(image_data, image_len);
+	char *filename = g_strdup_printf("%s.%s", checksum,
+	                       purple_util_get_image_extension(image_data, image_len));
+	g_free(checksum);
+	return filename;
+}
+
+gboolean
+purple_program_is_valid(const char *program)
+{
+	GError *error = NULL;
+	char **argv;
+	gchar *progname;
+	gboolean is_valid = FALSE;
+
+	g_return_val_if_fail(program != NULL,  FALSE);
+	g_return_val_if_fail(*program != '\0', FALSE);
+
+	if (!g_shell_parse_argv(program, NULL, &argv, &error)) {
+		purple_debug(PURPLE_DEBUG_ERROR, "program_is_valid",
+				   "Could not parse program '%s': %s\n",
+				   program, error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	if (argv == NULL) {
+		return FALSE;
+	}
+
+	progname = g_find_program_in_path(argv[0]);
+	is_valid = (progname != NULL);
+
+	if(purple_debug_is_verbose())
+		purple_debug_info("program_is_valid", "Tested program %s.  %s.\n", program,
+				is_valid ? "Valid" : "Invalid");
+
+	g_strfreev(argv);
+	g_free(progname);
+
+	return is_valid;
+}
+
+
+gboolean
+purple_running_gnome(void)
+{
+#ifndef _WIN32
+	gchar *tmp = g_find_program_in_path("gnome-open");
+
+	if (tmp == NULL)
+		return FALSE;
+	g_free(tmp);
+
+	tmp = (gchar *)g_getenv("GNOME_DESKTOP_SESSION_ID");
+
+	return ((tmp != NULL) && (*tmp != '\0'));
+#else
+	return FALSE;
+#endif
+}
+
+gboolean
+purple_running_kde(void)
+{
+#ifndef _WIN32
+	gchar *tmp = g_find_program_in_path("kfmclient");
+	const char *session;
+
+	if (tmp == NULL)
+		return FALSE;
+	g_free(tmp);
+
+	session = g_getenv("KDE_FULL_SESSION");
+	if (purple_strequal(session, "true"))
+		return TRUE;
+
+	/* If you run Purple from Konsole under !KDE, this will provide a
+	 * a false positive.  Since we do the GNOME checks first, this is
+	 * only a problem if you're running something !(KDE || GNOME) and
+	 * you run Purple from Konsole. This really shouldn't be a problem. */
+	return ((g_getenv("KDEDIR") != NULL) || g_getenv("KDEDIRS") != NULL);
+#else
+	return FALSE;
+#endif
+}
+
+gboolean
+purple_running_osx(void)
+{
+#if defined(__APPLE__)
+	return TRUE;
+#else
+	return FALSE;
+#endif
+}
+
+typedef union purple_sockaddr {
+	struct sockaddr         sa;
+	struct sockaddr_in      sa_in;
+#if defined(AF_INET6)
+	struct sockaddr_in6     sa_in6;
+#endif
+	struct sockaddr_storage sa_stor;
+} PurpleSockaddr;
+
+char *
+purple_fd_get_ip(int fd)
+{
+	PurpleSockaddr addr;
+	socklen_t namelen = sizeof(addr);
+	int family;
+
+	g_return_val_if_fail(fd != 0, NULL);
+
+	if (getsockname(fd, &(addr.sa), &namelen))
+		return NULL;
+
+	family = addr.sa.sa_family;
+
+	if (family == AF_INET) {
+		return g_strdup(inet_ntoa(addr.sa_in.sin_addr));
+	}
+#if defined(AF_INET6) && defined(HAVE_INET_NTOP)
+	else if (family == AF_INET6) {
+		char host[INET6_ADDRSTRLEN];
+		const char *tmp;
+
+		tmp = inet_ntop(family, &(addr.sa_in6.sin6_addr), host, sizeof(host));
+		return g_strdup(tmp);
+	}
+#endif
+
+	return NULL;
+}
+
+int
+purple_socket_get_family(int fd)
+{
+	PurpleSockaddr addr;
+	socklen_t len = sizeof(addr);
+
+	g_return_val_if_fail(fd >= 0, -1);
+
+	if (getsockname(fd, &(addr.sa), &len))
+		return -1;
+
+	return addr.sa.sa_family;
+}
+
+gboolean
+purple_socket_speaks_ipv4(int fd)
+{
+	int family;
+
+	g_return_val_if_fail(fd >= 0, FALSE);
+
+	family = purple_socket_get_family(fd);
+
+	switch (family) {
+	case AF_INET:
+		return TRUE;
+#if defined(IPV6_V6ONLY)
+	case AF_INET6:
+	{
+		int val = 0;
+		guint len = sizeof(val);
+
+		if (getsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &val, &len) != 0)
+			return FALSE;
+		return !val;
+	}
+#endif
+	default:
+		return FALSE;
+	}
+}
+
+/**************************************************************************
+ * String Functions
+ **************************************************************************/
+gboolean
+purple_strequal(const gchar *left, const gchar *right)
+{
+#if GLIB_CHECK_VERSION(2,16,0)
+	return (g_strcmp0(left, right) == 0);
+#else
+	return ((left == NULL && right == NULL) ||
+	        (left != NULL && right != NULL && strcmp(left, right) == 0));
+#endif
+}
+
+const char *
+purple_normalize(const PurpleAccount *account, const char *str)
+{
+	const char *ret = NULL;
+	static char buf[BUF_LEN];
+
+	/* This should prevent a crash if purple_normalize gets called with NULL str, see #10115 */
+	g_return_val_if_fail(str != NULL, "");
+
+	if (account != NULL)
+	{
+		PurplePlugin *prpl = purple_find_prpl(purple_account_get_protocol_id(account));
+
+		if (prpl != NULL)
+		{
+			PurplePluginProtocolInfo *prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+
+			if (prpl_info->normalize)
+				ret = prpl_info->normalize(account, str);
+		}
+	}
+
+	if (ret == NULL)
+	{
+		char *tmp;
+
+		tmp = g_utf8_normalize(str, -1, G_NORMALIZE_DEFAULT);
+		g_snprintf(buf, sizeof(buf), "%s", tmp);
+		g_free(tmp);
+
+		ret = buf;
+	}
+
+	return ret;
+}
+
+/*
+ * You probably don't want to call this directly, it is
+ * mainly for use as a PRPL callback function.  See the
+ * comments in util.h.
+ */
+const char *
+purple_normalize_nocase(const PurpleAccount *account, const char *str)
+{
+	static char buf[BUF_LEN];
+	char *tmp1, *tmp2;
+
+	g_return_val_if_fail(str != NULL, NULL);
+
+	tmp1 = g_utf8_strdown(str, -1);
+	tmp2 = g_utf8_normalize(tmp1, -1, G_NORMALIZE_DEFAULT);
+	g_snprintf(buf, sizeof(buf), "%s", tmp2 ? tmp2 : "");
+	g_free(tmp2);
+	g_free(tmp1);
+
+	return buf;
+}
+
+gchar *
+purple_strdup_withhtml(const gchar *src)
+{
+	gulong destsize, i, j;
+	gchar *dest;
+
+	g_return_val_if_fail(src != NULL, NULL);
+
+	/* New length is (length of src) + (number of \n's * 3) - (number of \r's) + 1 */
+	destsize = 1;
+	for (i = 0; src[i] != '\0'; i++)
+	{
+		if (src[i] == '\n')
+			destsize += 4;
+		else if (src[i] != '\r')
+			destsize++;
+	}
+
+	dest = g_malloc(destsize);
+
+	/* Copy stuff, ignoring \r's, because they are dumb */
+	for (i = 0, j = 0; src[i] != '\0'; i++) {
+		if (src[i] == '\n') {
+			strcpy(&dest[j], "<BR>");
+			j += 4;
+		} else if (src[i] != '\r')
+			dest[j++] = src[i];
+	}
+
+	dest[destsize-1] = '\0';
+
+	return dest;
+}
+
+gboolean
+purple_str_has_prefix(const char *s, const char *p)
+{
+	return g_str_has_prefix(s, p);
+}
+
+gboolean
+purple_str_has_suffix(const char *s, const char *x)
+{
+	return g_str_has_suffix(s, x);
+}
+
+char *
+purple_str_add_cr(const char *text)
+{
+	char *ret = NULL;
+	int count = 0, j;
+	guint i;
+
+	g_return_val_if_fail(text != NULL, NULL);
+
+	if (text[0] == '\n')
+		count++;
+	for (i = 1; i < strlen(text); i++)
+		if (text[i] == '\n' && text[i - 1] != '\r')
+			count++;
+
+	if (count == 0)
+		return g_strdup(text);
+
+	ret = g_malloc0(strlen(text) + count + 1);
+
+	i = 0; j = 0;
+	if (text[i] == '\n')
+		ret[j++] = '\r';
+	ret[j++] = text[i++];
+	for (; i < strlen(text); i++) {
+		if (text[i] == '\n' && text[i - 1] != '\r')
+			ret[j++] = '\r';
+		ret[j++] = text[i];
+	}
+
+	return ret;
+}
+
+void
+purple_str_strip_char(char *text, char thechar)
+{
+	int i, j;
+
+	g_return_if_fail(text != NULL);
+
+	for (i = 0, j = 0; text[i]; i++)
+		if (text[i] != thechar)
+			text[j++] = text[i];
+
+	text[j] = '\0';
+}
+
+void
+purple_util_chrreplace(char *string, char delimiter,
+					 char replacement)
+{
+	int i = 0;
+
+	g_return_if_fail(string != NULL);
+
+	while (string[i] != '\0')
+	{
+		if (string[i] == delimiter)
+			string[i] = replacement;
+		i++;
+	}
+}
+
+gchar *
+purple_strreplace(const char *string, const char *delimiter,
+				const char *replacement)
+{
+	gchar **split;
+	gchar *ret;
+
+	g_return_val_if_fail(string      != NULL, NULL);
+	g_return_val_if_fail(delimiter   != NULL, NULL);
+	g_return_val_if_fail(replacement != NULL, NULL);
+
+	split = g_strsplit(string, delimiter, 0);
+	ret = g_strjoinv(replacement, split);
+	g_strfreev(split);
+
+	return ret;
+}
+
+gchar *
+purple_strcasereplace(const char *string, const char *delimiter,
+					const char *replacement)
+{
+	gchar *ret;
+	int length_del, length_rep, i, j;
+
+	g_return_val_if_fail(string      != NULL, NULL);
+	g_return_val_if_fail(delimiter   != NULL, NULL);
+	g_return_val_if_fail(replacement != NULL, NULL);
+
+	length_del = strlen(delimiter);
+	length_rep = strlen(replacement);
+
+	/* Count how many times the delimiter appears */
+	i = 0; /* position in the source string */
+	j = 0; /* number of occurrences of "delimiter" */
+	while (string[i] != '\0') {
+		if (!g_ascii_strncasecmp(&string[i], delimiter, length_del)) {
+			i += length_del;
+			j += length_rep;
+		} else {
+			i++;
+			j++;
+		}
+	}
+
+	ret = g_malloc(j+1);
+
+	i = 0; /* position in the source string */
+	j = 0; /* position in the destination string */
+	while (string[i] != '\0') {
+		if (!g_ascii_strncasecmp(&string[i], delimiter, length_del)) {
+			strncpy(&ret[j], replacement, length_rep);
+			i += length_del;
+			j += length_rep;
+		} else {
+			ret[j] = string[i];
+			i++;
+			j++;
+		}
+	}
+
+	ret[j] = '\0';
+
+	return ret;
+}
+
+/** TODO: Expose this when we can add API */
+static const char *
+purple_strcasestr_len(const char *haystack, gssize hlen, const char *needle, gssize nlen)
+{
+	const char *tmp, *ret;
+
+	g_return_val_if_fail(haystack != NULL, NULL);
+	g_return_val_if_fail(needle != NULL, NULL);
+
+	if (hlen == -1)
+		hlen = strlen(haystack);
+	if (nlen == -1)
+		nlen = strlen(needle);
+	tmp = haystack,
+	ret = NULL;
+
+	g_return_val_if_fail(hlen > 0, NULL);
+	g_return_val_if_fail(nlen > 0, NULL);
+
+	while (*tmp && !ret && (hlen - (tmp - haystack)) >= nlen) {
+		if (!g_ascii_strncasecmp(needle, tmp, nlen))
+			ret = tmp;
+		else
+			tmp++;
+	}
+
+	return ret;
+}
+
+const char *
+purple_strcasestr(const char *haystack, const char *needle)
+{
+	return purple_strcasestr_len(haystack, -1, needle, -1);
+}
+
+char *
+purple_str_size_to_units(size_t size)
+{
+	static const char * const size_str[] = { "bytes", "KiB", "MiB", "GiB" };
+	float size_mag;
+	int size_index = 0;
+
+	if (size == (size_t)-1) {
+		return g_strdup(_("Calculating..."));
+	}
+	else if (size == 0) {
+		return g_strdup(_("Unknown."));
+	}
+	else {
+		size_mag = (float)size;
+
+		while ((size_index < 3) && (size_mag > 1024)) {
+			size_mag /= 1024;
+			size_index++;
+		}
+
+		if (size_index == 0) {
+			return g_strdup_printf("%" G_GSIZE_FORMAT " %s", size, size_str[size_index]);
+		} else {
+			return g_strdup_printf("%.2f %s", size_mag, size_str[size_index]);
+		}
+	}
+}
+
+char *
+purple_str_seconds_to_string(guint secs)
+{
+	char *ret = NULL;
+	guint days, hrs, mins;
+
+	if (secs < 60)
+	{
+		return g_strdup_printf(dngettext(PACKAGE, "%d second", "%d seconds", secs), secs);
+	}
+
+	days = secs / (60 * 60 * 24);
+	secs = secs % (60 * 60 * 24);
+	hrs  = secs / (60 * 60);
+	secs = secs % (60 * 60);
+	mins = secs / 60;
+	secs = secs % 60;
+
+	if (days > 0)
+	{
+		ret = g_strdup_printf(dngettext(PACKAGE, "%d day", "%d days", days), days);
+	}
+
+	if (hrs > 0)
+	{
+		if (ret != NULL)
+		{
+			char *tmp = g_strdup_printf(
+					dngettext(PACKAGE, "%s, %d hour", "%s, %d hours", hrs),
+							ret, hrs);
+			g_free(ret);
+			ret = tmp;
+		}
+		else
+			ret = g_strdup_printf(dngettext(PACKAGE, "%d hour", "%d hours", hrs), hrs);
+	}
+
+	if (mins > 0)
+	{
+		if (ret != NULL)
+		{
+			char *tmp = g_strdup_printf(
+					dngettext(PACKAGE, "%s, %d minute", "%s, %d minutes", mins),
+							ret, mins);
+			g_free(ret);
+			ret = tmp;
+		}
+		else
+			ret = g_strdup_printf(dngettext(PACKAGE, "%d minute", "%d minutes", mins), mins);
+	}
+
+	return ret;
+}
+
+
+char *
+purple_str_binary_to_ascii(const unsigned char *binary, guint len)
+{
+	GString *ret;
+	guint i;
+
+	g_return_val_if_fail(len > 0, NULL);
+
+	ret = g_string_sized_new(len);
+
+	for (i = 0; i < len; i++)
+		if (binary[i] < 32 || binary[i] > 126)
+			g_string_append_printf(ret, "\\x%02hhx", binary[i]);
+		else if (binary[i] == '\\')
+			g_string_append(ret, "\\\\");
+		else
+			g_string_append_c(ret, binary[i]);
+
+	return g_string_free(ret, FALSE);
+}
+
+/**************************************************************************
+ * URI/URL Functions
+ **************************************************************************/
+
+void purple_got_protocol_handler_uri(const char *uri)
+{
+	char proto[11];
+	char delimiter;
+	const char *tmp, *param_string;
+	char *cmd;
+	GHashTable *params = NULL;
+	int len;
+	if (!(tmp = strchr(uri, ':')) || tmp == uri) {
+		purple_debug_error("util", "Malformed protocol handler message - missing protocol.\n");
+		return;
+	}
+
+	len = MIN(sizeof(proto) - 1, (gsize)(tmp - uri));
+
+	strncpy(proto, uri, len);
+	proto[len] = '\0';
+
+	tmp++;
+
+	if (g_str_equal(proto, "xmpp"))
+		delimiter = ';';
+	else
+		delimiter = '&';
+
+	purple_debug_info("util", "Processing message '%s' for protocol '%s' using delimiter '%c'.\n", tmp, proto, delimiter);
+
+	if ((param_string = strchr(tmp, '?'))) {
+		const char *keyend = NULL, *pairstart;
+		char *key, *value = NULL;
+
+		cmd = g_strndup(tmp, (param_string - tmp));
+		param_string++;
+
+		params = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+		pairstart = tmp = param_string;
+
+		while (*tmp || *pairstart) {
+			if (*tmp == delimiter || !(*tmp)) {
+				/* If there is no explicit value */
+				if (keyend == NULL)
+					keyend = tmp;
+
+				if (keyend && keyend != pairstart) {
+					char *p;
+					key = g_strndup(pairstart, (keyend - pairstart));
+					/* If there is an explicit value */
+					if (keyend != tmp && keyend != (tmp - 1))
+						value = g_strndup(keyend + 1, (tmp - keyend - 1));
+					for (p = key; *p; ++p)
+						*p = g_ascii_tolower(*p);
+					g_hash_table_insert(params, key, value);
+				}
+				keyend = value = NULL;
+				pairstart = (*tmp) ? tmp + 1 : tmp;
+			} else if (*tmp == '=')
+				keyend = tmp;
+
+			if (*tmp)
+				tmp++;
+		}
+	} else
+		cmd = g_strdup(tmp);
+
+	purple_signal_emit_return_1(purple_get_core(), "uri-handler", proto, cmd, params);
+
+	g_free(cmd);
+	if (params)
+		g_hash_table_destroy(params);
+}
+
+/*
+ * TODO: Should probably add a "gboolean *ret_ishttps" parameter that
+ *       is set to TRUE if this URL is https, otherwise it is set to
+ *       FALSE.  But that change will break the API.
+ *
+ *       This is important for Yahoo! web messenger login.  They now
+ *       force https login, and if you access the web messenger login
+ *       page via http then it redirects you to the https version, but
+ *       purple_util_fetch_url() ignores the "https" and attempts to
+ *       fetch the URL via http again, which gets redirected again.
+ */
+gboolean
+purple_url_parse(const char *url, char **ret_host, int *ret_port,
+			   char **ret_path, char **ret_user, char **ret_passwd)
+{
+	gboolean is_https = FALSE;
+	const char * scan_info;
+	char port_str[6];
+	int f;
+	const char *at, *slash;
+	const char *turl;
+	char host[256], path[256], user[256], passwd[256];
+	int port = 0;
+	/* hyphen at end includes it in control set */
+
+#define ADDR_CTRL "A-Za-z0-9.-"
+#define PORT_CTRL "0-9"
+#define PAGE_CTRL "A-Za-z0-9.~_/:*!@&%%?=+^-"
+#define USER_CTRL "A-Za-z0-9.~_/*!&%%?=+^-"
+#define PASSWD_CTRL "A-Za-z0-9.~_/*!&%%?=+^-"
+
+	g_return_val_if_fail(url != NULL, FALSE);
+
+	if ((turl = purple_strcasestr(url, "http://")) != NULL)
+	{
+		turl += 7;
+		url = turl;
+	}
+	else if ((turl = purple_strcasestr(url, "https://")) != NULL)
+	{
+		is_https = TRUE;
+		turl += 8;
+		url = turl;
+	}
+
+	/* parse out authentication information if supplied */
+	/* Only care about @ char BEFORE the first / */
+	at = strchr(url, '@');
+	slash = strchr(url, '/');
+	f = 0;
+	if (at && (!slash || at < slash)) {
+		scan_info = "%255[" USER_CTRL "]:%255[" PASSWD_CTRL "]^@";
+		f = sscanf(url, scan_info, user, passwd);
+
+		if (f == 1) {
+			/* No passwd, possibly just username supplied */
+			scan_info = "%255[" USER_CTRL "]^@";
+			f = sscanf(url, scan_info, user);
+		}
+
+		url = at+1; /* move pointer after the @ char */
+	}
+
+	if (f < 1) {
+		*user = '\0';
+		*passwd = '\0';
+	} else if (f == 1)
+		*passwd = '\0';
+
+	scan_info = "%255[" ADDR_CTRL "]:%5[" PORT_CTRL "]/%255[" PAGE_CTRL "]";
+	f = sscanf(url, scan_info, host, port_str, path);
+
+	if (f == 1)
+	{
+		scan_info = "%255[" ADDR_CTRL "]/%255[" PAGE_CTRL "]";
+		f = sscanf(url, scan_info, host, path);
+		/* Use the default port */
+		if (is_https)
+			g_snprintf(port_str, sizeof(port_str), "443");
+		else
+			g_snprintf(port_str, sizeof(port_str), "80");
+	}
+
+	if (f == 0)
+		*host = '\0';
+
+	if (f <= 1)
+		*path = '\0';
+
+	if (sscanf(port_str, "%d", &port) != 1)
+		purple_debug_error("util", "Error parsing URL port from %s\n", url);
+
+	if (ret_host != NULL) *ret_host = g_strdup(host);
+	if (ret_port != NULL) *ret_port = port;
+	if (ret_path != NULL) *ret_path = g_strdup(path);
+	if (ret_user != NULL) *ret_user = g_strdup(user);
+	if (ret_passwd != NULL) *ret_passwd = g_strdup(passwd);
+
+	return ((*host != '\0') ? TRUE : FALSE);
+
+#undef ADDR_CTRL
+#undef PORT_CTRL
+#undef PAGE_CTRL
+#undef USER_CTRL
+#undef PASSWD_CTRL
+}
+
+/**
+ * The arguments to this function are similar to printf.
+ */
+static void
+purple_util_fetch_url_error(PurpleUtilFetchUrlData *gfud, const char *format, ...)
+{
+	gchar *error_message;
+	va_list args;
+
+	va_start(args, format);
+	error_message = g_strdup_vprintf(format, args);
+	va_end(args);
+
+	gfud->callback(gfud, gfud->user_data, NULL, 0, error_message);
+	g_free(error_message);
+	purple_util_fetch_url_cancel(gfud);
+}
+
+static void url_fetch_connect_cb(gpointer url_data, gint source, const gchar *error_message);
+static void ssl_url_fetch_connect_cb(gpointer data, PurpleSslConnection *ssl_connection, PurpleInputCondition cond);
+static void ssl_url_fetch_error_cb(PurpleSslConnection *ssl_connection, PurpleSslErrorType error, gpointer data);
+
+static gboolean
+parse_redirect(const char *data, gsize data_len,
+			   PurpleUtilFetchUrlData *gfud)
+{
+	gchar *s;
+	gchar *new_url, *temp_url, *end;
+	gboolean full;
+	int len;
+
+	if ((s = g_strstr_len(data, data_len, "\nLocation: ")) == NULL)
+		/* We're not being redirected */
+		return FALSE;
+
+	s += strlen("Location: ");
+	end = strchr(s, '\r');
+
+	/* Just in case :) */
+	if (end == NULL)
+		end = strchr(s, '\n');
+
+	if (end == NULL)
+		return FALSE;
+
+	len = end - s;
+
+	new_url = g_malloc(len + 1);
+	strncpy(new_url, s, len);
+	new_url[len] = '\0';
+
+	full = gfud->full;
+
+	if (*new_url == '/' || g_strstr_len(new_url, len, "://") == NULL)
+	{
+		temp_url = new_url;
+
+		new_url = g_strdup_printf("%s:%d%s", gfud->website.address,
+								  gfud->website.port, temp_url);
+
+		g_free(temp_url);
+
+		full = FALSE;
+	}
+
+	purple_debug_info("util", "Redirecting to %s\n", new_url);
+
+	gfud->num_times_redirected++;
+	if (gfud->num_times_redirected >= 5)
+	{
+		purple_util_fetch_url_error(gfud,
+				_("Could not open %s: Redirected too many times"),
+				gfud->url);
+		return TRUE;
+	}
+
+	/*
+	 * Try again, with this new location.  This code is somewhat
+	 * ugly, but we need to reuse the gfud because whoever called
+	 * us is holding a reference to it.
+	 */
+	g_free(gfud->url);
+	gfud->url = new_url;
+	gfud->full = full;
+	g_free(gfud->request);
+	gfud->request = NULL;
+
+	if (gfud->is_ssl) {
+		gfud->is_ssl = FALSE;
+		purple_ssl_close(gfud->ssl_connection);
+		gfud->ssl_connection = NULL;
+	} else {
+		purple_input_remove(gfud->inpa);
+		gfud->inpa = 0;
+		close(gfud->fd);
+		gfud->fd = -1;
+	}
+	gfud->request_written = 0;
+	gfud->len = 0;
+	gfud->data_len = 0;
+
+	g_free(gfud->website.user);
+	g_free(gfud->website.passwd);
+	g_free(gfud->website.address);
+	g_free(gfud->website.page);
+	purple_url_parse(new_url, &gfud->website.address, &gfud->website.port,
+				   &gfud->website.page, &gfud->website.user, &gfud->website.passwd);
+
+	if (purple_strcasestr(new_url, "https://") != NULL) {
+		gfud->is_ssl = TRUE;
+		gfud->ssl_connection = purple_ssl_connect(gfud->account,
+				gfud->website.address, gfud->website.port,
+				ssl_url_fetch_connect_cb, ssl_url_fetch_error_cb, gfud);
+	} else {
+		gfud->connect_data = purple_proxy_connect(NULL, gfud->account,
+				gfud->website.address, gfud->website.port,
+				url_fetch_connect_cb, gfud);
+	}
+
+	if (gfud->ssl_connection == NULL && gfud->connect_data == NULL)
+	{
+		purple_util_fetch_url_error(gfud, _("Unable to connect to %s"),
+				gfud->website.address);
+	}
+
+	return TRUE;
+}
+
+/* find the starting point of the content for the specified header and make
+ * sure that the content is safe to pass to sscanf */
+static const char *
+find_header_content(const char *data, gsize data_len, const char *header)
+{
+	const char *p = NULL;
+
+	gsize header_len = strlen(header);
+
+	if (data_len > header_len) {
+		/* Check if the first header matches (data won't start with a \n") */
+		if (header[0] == '\n')
+			p = (g_ascii_strncasecmp(data, header + 1, header_len - 1) == 0) ? data : NULL;
+		if (!p)
+			p = purple_strcasestr_len(data, data_len, header, header_len);
+		if (p)
+			p += header_len;
+	}
+
+	/* If we can find the header at all, try to sscanf it.
+	 * Response headers should end with at least \r\n, so sscanf is safe,
+	 * if we make sure that there is indeed a \n in our header.
+	 */
+	if (p && g_strstr_len(p, data_len - (p - data), "\n")) {
+		return p;
+	}
+
+	return NULL;
+}
+
+static gsize 
+parse_content_len(const char *data, gsize data_len)
+{
+	gsize content_len = 0;
+	const char *p = NULL;
+
+	p = find_header_content(data, data_len, "\nContent-Length: ");
+	if (p) {
+		if (sscanf(p, "%" G_GSIZE_FORMAT, &content_len) != 1) {
+			purple_debug_warning("util", "invalid number format\n");
+			content_len = 0;
+		}
+		purple_debug_misc("util", "parsed %" G_GSIZE_FORMAT "\n", content_len);
+	}
+
+	return content_len;
+}
+
+static gboolean
+content_is_chunked(const char *data, gsize data_len)
+{
+	const char *p = find_header_content(data, data_len, "\nTransfer-Encoding: ");
+	if (p && g_ascii_strncasecmp(p, "chunked", 7) == 0)
+		return TRUE;
+
+	return FALSE;
+}
+
+/* Process in-place */
+static void
+process_chunked_data(char *data, gsize *len)
+{
+	gsize sz;
+	gsize newlen = 0;
+	char *p = data;
+	char *s = data;
+
+	while (*s) {
+		/* Read the size of this chunk */
+		if (sscanf(s, "%" G_GSIZE_MODIFIER "x", &sz) != 1)
+		{
+			purple_debug_error("util", "Error processing chunked data: "
+					"Expected data length, found: %s\n", s);
+			break;
+		}
+		if (sz == 0) {
+			/* We've reached the last chunk */
+			/*
+			 * TODO: The spec allows "footers" to follow the last chunk.
+			 *       If there is more data after this line then we should
+			 *       treat it like a header.
+			 */
+			break;
+		}
+
+		/* Advance to the start of the data */
+		s = strstr(s, "\r\n");
+		if (s == NULL)
+			break;
+		s += 2;
+
+		if (sz > MAX_HTTP_CHUNK_SIZE || s + sz > data + *len) {
+			purple_debug_error("util", "Error processing chunked data: "
+					"Chunk size %" G_GSIZE_FORMAT " bytes was longer "
+					"than the data remaining in the buffer (%"
+					G_GSIZE_FORMAT " bytes)\n", sz, data + *len - s);
+			break;
+		}
+
+		/* Move all data overtop of the chunk length that we read in earlier */
+		g_memmove(p, s, sz);
+		p += sz;
+		s += sz;
+		newlen += sz;
+		if (*s == '\0' || (*s != '\r' && *(s + 1) != '\n')) {
+			purple_debug_error("util", "Error processing chunked data: "
+					"Expected \\r\\n, found: %s\n", s);
+			break;
+		}
+		s += 2;
+	}
+
+	/* NULL terminate the data */
+	*p = 0;
+
+	*len = newlen;
+}
+
+static void
+url_fetch_recv_cb(gpointer url_data, gint source, PurpleInputCondition cond)
+{
+	PurpleUtilFetchUrlData *gfud = url_data;
+	int len;
+	char buf[4096];
+	char *data_cursor;
+	gboolean got_eof = FALSE;
+
+	if (!gfud->is_ssl && source < 0) {
+		g_warn_if_reached();
+		len = -1;
+		errno = EINVAL;
+	}
+
+	/*
+	 * Read data in a loop until we can't read any more!  This is a
+	 * little confusing because we read using a different function
+	 * depending on whether the socket is ssl or cleartext.
+	 */
+	while ((gfud->is_ssl && ((len = purple_ssl_read(gfud->ssl_connection, buf, sizeof(buf))) > 0)) ||
+		(!gfud->is_ssl && source >= 0 && (len = read(source, buf, sizeof(buf))) > 0))
+	{
+		if((gfud->len + len) > gfud->max_len) {
+			purple_util_fetch_url_error(gfud, _("Error reading from %s: response too long (%d bytes limit)"),
+						    gfud->website.address, gfud->max_len);
+			return;
+		}
+
+		/* If we've filled up our buffer, make it bigger */
+		if((gfud->len + len) >= gfud->data_len) {
+			while((gfud->len + len) >= gfud->data_len)
+				gfud->data_len += sizeof(buf);
+
+			gfud->webdata = g_realloc(gfud->webdata, gfud->data_len);
+		}
+
+		data_cursor = gfud->webdata + gfud->len;
+
+		gfud->len += len;
+
+		memcpy(data_cursor, buf, len);
+
+		gfud->webdata[gfud->len] = '\0';
+
+		if(!gfud->got_headers) {
+			char *end_of_headers;
+
+			/* See if we've reached the end of the headers yet */
+			end_of_headers = strstr(gfud->webdata, "\r\n\r\n");
+			if (end_of_headers) {
+				guint header_len = (end_of_headers + 4 - gfud->webdata);
+				gsize content_len;
+
+				purple_debug_misc("util", "Response headers: '%.*s'\n",
+					header_len, gfud->webdata);
+
+				/* See if we can find a redirect. */
+				if(parse_redirect(gfud->webdata, header_len, gfud))
+					return;
+
+				gfud->got_headers = TRUE;
+
+				/* No redirect. See if we can find a content length. */
+				content_len = parse_content_len(gfud->webdata, header_len);
+				gfud->chunked = content_is_chunked(gfud->webdata, header_len);
+
+				if (content_len == 0) {
+					/* We'll stick with an initial 8192 */
+					content_len = 8192;
+				} else {
+					gfud->has_explicit_data_len = TRUE;
+					if (content_len > gfud->max_len) {
+						purple_debug_error("util",
+								"Overriding explicit Content-Length of %" G_GSIZE_FORMAT " with max of %" G_GSSIZE_FORMAT "\n",
+								content_len, gfud->max_len);
+						content_len = gfud->max_len;
+					}
+				}
+
+
+				/* If we're returning the headers too, we don't need to clean them out */
+				if (gfud->include_headers) {
+					char *new_data;
+					gfud->data_len = content_len + header_len;
+					new_data = g_try_realloc(gfud->webdata, gfud->data_len);
+					if (new_data == NULL) {
+						purple_debug_error("util",
+								"Failed to allocate %" G_GSIZE_FORMAT " bytes: %s\n",
+								content_len, g_strerror(errno));
+						purple_util_fetch_url_error(gfud,
+								_("Unable to allocate enough memory to hold "
+								  "the contents from %s.  The web server may "
+								  "be trying something malicious."),
+								gfud->website.address);
+
+						return;
+					}
+					gfud->webdata = new_data;
+				} else {
+					char *new_data;
+					gsize body_len = gfud->len - header_len;
+
+					content_len = MAX(content_len, body_len);
+
+					new_data = g_try_malloc(content_len);
+					if (new_data == NULL) {
+						purple_debug_error("util",
+								"Failed to allocate %" G_GSIZE_FORMAT " bytes: %s\n",
+								content_len, g_strerror(errno));
+						purple_util_fetch_url_error(gfud,
+								_("Unable to allocate enough memory to hold "
+								  "the contents from %s.  The web server may "
+								  "be trying something malicious."),
+								gfud->website.address);
+
+						return;
+					}
+
+					/* We may have read part of the body when reading the headers, don't lose it */
+					if (body_len > 0) {
+						memcpy(new_data, end_of_headers + 4, body_len);
+					}
+
+					/* Out with the old... */
+					g_free(gfud->webdata);
+
+					/* In with the new. */
+					gfud->len = body_len;
+					gfud->data_len = content_len;
+					gfud->webdata = new_data;
+				}
+			}
+		}
+
+		if(gfud->has_explicit_data_len && gfud->len >= gfud->data_len) {
+			got_eof = TRUE;
+			break;
+		}
+	}
+
+	if(len < 0) {
+		if(errno == EAGAIN) {
+			return;
+		} else {
+			purple_util_fetch_url_error(gfud, _("Error reading from %s: %s"),
+					gfud->website.address, g_strerror(errno));
+			return;
+		}
+	}
+
+	if((len == 0) || got_eof) {
+		gfud->webdata = g_realloc(gfud->webdata, gfud->len + 1);
+		gfud->webdata[gfud->len] = '\0';
+
+		if (!gfud->include_headers && gfud->chunked) {
+			/* Process only if we don't want the headers. */
+			process_chunked_data(gfud->webdata, &gfud->len);
+		}
+
+		gfud->callback(gfud, gfud->user_data, gfud->webdata, gfud->len, NULL);
+		purple_util_fetch_url_cancel(gfud);
+	}
+}
+
+static void ssl_url_fetch_recv_cb(gpointer data, PurpleSslConnection *ssl_connection, PurpleInputCondition cond)
+{
+	url_fetch_recv_cb(data, -1, cond);
+}
+
+/**
+ * This function is called when the socket is available to be written
+ * to.
+ *
+ * @param source The file descriptor that can be written to.  This can
+ *        be an http connection or it can be the SSL connection of an
+ *        https request.  So be careful what you use it for!  If it's
+ *        an https request then use purple_ssl_write() instead of
+ *        writing to it directly.
+ */
+static void
+url_fetch_send_cb(gpointer data, gint source, PurpleInputCondition cond)
+{
+	PurpleUtilFetchUrlData *gfud;
+	int len, total_len;
+
+	gfud = data;
+
+	if (gfud->request == NULL) {
+
+		PurpleProxyInfo *gpi = purple_proxy_get_setup(gfud->account);
+		GString *request_str = g_string_new(NULL);
+
+		g_string_append_printf(request_str, "GET %s%s HTTP/%s\r\n"
+						    "Connection: close\r\n",
+			(gfud->full ? "" : "/"),
+			(gfud->full ? (gfud->url ? gfud->url : "") : (gfud->website.page ? gfud->website.page : "")),
+			(gfud->http11 ? "1.1" : "1.0"));
+
+		if (gfud->user_agent)
+			g_string_append_printf(request_str, "User-Agent: %s\r\n", gfud->user_agent);
+
+		/* Host header is not forbidden in HTTP/1.0 requests, and HTTP/1.1
+		 * clients must know how to handle the "chunked" transfer encoding.
+		 * Purple doesn't know how to handle "chunked", so should always send
+		 * the Host header regardless, to get around some observed problems
+		 */
+		g_string_append_printf(request_str, "Accept: */*\r\n"
+						    "Host: %s\r\n",
+			(gfud->website.address ? gfud->website.address : ""));
+
+		if (purple_proxy_info_get_username(gpi) != NULL
+				&& (purple_proxy_info_get_type(gpi) == PURPLE_PROXY_USE_ENVVAR
+					|| purple_proxy_info_get_type(gpi) == PURPLE_PROXY_HTTP)) {
+			/* This chunk of code was copied from proxy.c http_start_connect_tunneling()
+			 * This is really a temporary hack - we need a more complete proxy handling solution,
+			 * so I didn't think it was worthwhile to refactor for reuse
+			 */
+			char *t1, *t2, *ntlm_type1;
+			char hostname[256];
+			int ret;
+
+			ret = gethostname(hostname, sizeof(hostname));
+			hostname[sizeof(hostname) - 1] = '\0';
+			if (ret < 0 || hostname[0] == '\0') {
+				purple_debug_warning("util", "proxy - gethostname() failed -- is your hostname set?");
+				strcpy(hostname, "localhost");
+			}
+
+			t1 = g_strdup_printf("%s:%s",
+				purple_proxy_info_get_username(gpi),
+				purple_proxy_info_get_password(gpi) ?
+					purple_proxy_info_get_password(gpi) : "");
+			t2 = purple_base64_encode((const guchar *)t1, strlen(t1));
+			g_free(t1);
+
+			ntlm_type1 = purple_ntlm_gen_type1(hostname, "");
+
+			g_string_append_printf(request_str,
+				"Proxy-Authorization: Basic %s\r\n"
+				"Proxy-Authorization: NTLM %s\r\n"
+				"Proxy-Connection: Keep-Alive\r\n",
+				t2, ntlm_type1);
+			g_free(ntlm_type1);
+			g_free(t2);
+		}
+
+		g_string_append(request_str, "\r\n");
+
+		gfud->request = g_string_free(request_str, FALSE);
+	}
+
+	if(purple_debug_is_unsafe())
+		purple_debug_misc("util", "Request: '%s'\n", gfud->request);
+	else
+		purple_debug_misc("util", "request constructed\n");
+
+	total_len = strlen(gfud->request);
+
+	if (gfud->is_ssl)
+		len = purple_ssl_write(gfud->ssl_connection, gfud->request + gfud->request_written,
+				total_len - gfud->request_written);
+	else
+		len = write(gfud->fd, gfud->request + gfud->request_written,
+				total_len - gfud->request_written);
+
+	if (len < 0 && errno == EAGAIN)
+		return;
+	else if (len < 0) {
+		purple_util_fetch_url_error(gfud, _("Error writing to %s: %s"),
+				gfud->website.address, g_strerror(errno));
+		return;
+	}
+	gfud->request_written += len;
+
+	if (gfud->request_written < (gsize)total_len)
+		return;
+
+	/* We're done writing our request, now start reading the response */
+	if (gfud->is_ssl) {
+		purple_input_remove(gfud->inpa);
+		gfud->inpa = 0;
+		purple_ssl_input_add(gfud->ssl_connection, ssl_url_fetch_recv_cb, gfud);
+	} else {
+		purple_input_remove(gfud->inpa);
+		gfud->inpa = purple_input_add(gfud->fd, PURPLE_INPUT_READ, url_fetch_recv_cb,
+			gfud);
+	}
+}
+
+static void
+url_fetch_connect_cb(gpointer url_data, gint source, const gchar *error_message)
+{
+	PurpleUtilFetchUrlData *gfud;
+
+	gfud = url_data;
+	gfud->connect_data = NULL;
+
+	if (source == -1)
+	{
+		purple_util_fetch_url_error(gfud, _("Unable to connect to %s: %s"),
+				(gfud->website.address ? gfud->website.address : ""), error_message);
+		return;
+	}
+
+	gfud->fd = source;
+
+	gfud->inpa = purple_input_add(source, PURPLE_INPUT_WRITE,
+								url_fetch_send_cb, gfud);
+	url_fetch_send_cb(gfud, source, PURPLE_INPUT_WRITE);
+}
+
+static void ssl_url_fetch_connect_cb(gpointer data, PurpleSslConnection *ssl_connection, PurpleInputCondition cond)
+{
+	PurpleUtilFetchUrlData *gfud;
+
+	gfud = data;
+
+	gfud->inpa = purple_input_add(ssl_connection->fd, PURPLE_INPUT_WRITE,
+			url_fetch_send_cb, gfud);
+	url_fetch_send_cb(gfud, ssl_connection->fd, PURPLE_INPUT_WRITE);
+}
+
+static void ssl_url_fetch_error_cb(PurpleSslConnection *ssl_connection, PurpleSslErrorType error, gpointer data)
+{
+	PurpleUtilFetchUrlData *gfud;
+
+	gfud = data;
+	gfud->ssl_connection = NULL;
+
+	purple_util_fetch_url_error(gfud, _("Unable to connect to %s: %s"),
+			(gfud->website.address ? gfud->website.address : ""),
+	purple_ssl_strerror(error));
+}
+
+PurpleUtilFetchUrlData *
+purple_util_fetch_url_request(const char *url, gboolean full,
+		const char *user_agent, gboolean http11,
+		const char *request, gboolean include_headers,
+		PurpleUtilFetchUrlCallback callback, void *user_data)
+{
+	return purple_util_fetch_url_request_len_with_account(NULL, url, full,
+					     user_agent, http11,
+					     request, include_headers, -1,
+					     callback, user_data);
+}
+
+PurpleUtilFetchUrlData *
+purple_util_fetch_url_request_len(const char *url, gboolean full,
+		const char *user_agent, gboolean http11,
+		const char *request, gboolean include_headers, gssize max_len,
+		PurpleUtilFetchUrlCallback callback, void *user_data)
+{
+	return purple_util_fetch_url_request_len_with_account(NULL, url, full,
+			user_agent, http11, request, include_headers, max_len, callback,
+			user_data);
+}
+
+PurpleUtilFetchUrlData *
+purple_util_fetch_url_request_len_with_account(PurpleAccount *account,
+		const char *url, gboolean full,	const char *user_agent, gboolean http11,
+		const char *request, gboolean include_headers, gssize max_len,
+		PurpleUtilFetchUrlCallback callback, void *user_data)
+{
+	PurpleUtilFetchUrlData *gfud;
+
+	g_return_val_if_fail(url      != NULL, NULL);
+	g_return_val_if_fail(callback != NULL, NULL);
+
+	if(purple_debug_is_unsafe())
+		purple_debug_info("util",
+				 "requested to fetch (%s), full=%d, user_agent=(%s), http11=%d\n",
+				 url, full, user_agent?user_agent:"(null)", http11);
+	else
+		purple_debug_info("util", "requesting to fetch a URL\n");
+
+	gfud = g_new0(PurpleUtilFetchUrlData, 1);
+
+	gfud->callback = callback;
+	gfud->user_data  = user_data;
+	gfud->url = g_strdup(url);
+	gfud->user_agent = g_strdup(user_agent);
+	gfud->http11 = http11;
+	gfud->full = full;
+	gfud->request = g_strdup(request);
+	gfud->include_headers = include_headers;
+	gfud->fd = -1;
+	if (max_len <= 0) {
+		max_len = DEFAULT_MAX_HTTP_DOWNLOAD;
+		purple_debug_error("util", "Defaulting max download from %s to %" G_GSSIZE_FORMAT "\n", url, max_len);
+	}
+	gfud->max_len = (gsize) max_len;
+	gfud->account = account;
+
+	purple_url_parse(url, &gfud->website.address, &gfud->website.port,
+				   &gfud->website.page, &gfud->website.user, &gfud->website.passwd);
+
+	if (purple_strcasestr(url, "https://") != NULL) {
+		if (!purple_ssl_is_supported()) {
+			purple_util_fetch_url_error(gfud,
+					_("Unable to connect to %s: %s"),
+					gfud->website.address,
+					_("Server requires TLS/SSL, but no TLS/SSL support was found."));
+			return NULL;
+		}
+
+		gfud->is_ssl = TRUE;
+		gfud->ssl_connection = purple_ssl_connect(account,
+				gfud->website.address, gfud->website.port,
+				ssl_url_fetch_connect_cb, ssl_url_fetch_error_cb, gfud);
+	} else {
+		gfud->connect_data = purple_proxy_connect(NULL, account,
+				gfud->website.address, gfud->website.port,
+				url_fetch_connect_cb, gfud);
+	}
+
+	if (gfud->ssl_connection == NULL && gfud->connect_data == NULL)
+	{
+		purple_util_fetch_url_error(gfud, _("Unable to connect to %s"),
+				gfud->website.address);
+		return NULL;
+	}
+
+	return gfud;
+}
+
+void
+purple_util_fetch_url_cancel(PurpleUtilFetchUrlData *gfud)
+{
+	if (gfud->ssl_connection != NULL)
+		purple_ssl_close(gfud->ssl_connection);
+
+	if (gfud->connect_data != NULL)
+		purple_proxy_connect_cancel(gfud->connect_data);
+
+	if (gfud->inpa > 0)
+		purple_input_remove(gfud->inpa);
+
+	if (gfud->fd >= 0)
+		close(gfud->fd);
+
+	g_free(gfud->website.user);
+	g_free(gfud->website.passwd);
+	g_free(gfud->website.address);
+	g_free(gfud->website.page);
+	g_free(gfud->url);
+	g_free(gfud->user_agent);
+	g_free(gfud->request);
+	g_free(gfud->webdata);
+
+	g_free(gfud);
+}
+
+const char *
+purple_url_decode(const char *str)
+{
+	static char buf[BUF_LEN];
+	guint i, j = 0;
+	char *bum;
+	char hex[3];
+
+	g_return_val_if_fail(str != NULL, NULL);
+
+	/*
+	 * XXX - This check could be removed and buf could be made
+	 * dynamically allocated, but this is easier.
+	 */
+	if (strlen(str) >= BUF_LEN)
+		return NULL;
+
+	for (i = 0; i < strlen(str); i++) {
+
+		if (str[i] != '%')
+			buf[j++] = str[i];
+		else {
+			strncpy(hex, str + ++i, 2);
+			hex[2] = '\0';
+
+			/* i is pointing to the start of the number */
+			i++;
+
+			/*
+			 * Now it's at the end and at the start of the for loop
+			 * will be at the next character.
+			 */
+			buf[j++] = strtol(hex, NULL, 16);
+		}
+	}
+
+	buf[j] = '\0';
+
+	if (!g_utf8_validate(buf, -1, (const char **)&bum))
+		*bum = '\0';
+
+	return buf;
+}
+
+const char *
+purple_url_encode(const char *str)
+{
+	const char *iter;
+	static char buf[BUF_LEN];
+	char utf_char[6];
+	guint i, j = 0;
+
+	g_return_val_if_fail(str != NULL, NULL);
+	g_return_val_if_fail(g_utf8_validate(str, -1, NULL), NULL);
+
+	iter = str;
+	for (; *iter && j < (BUF_LEN - 1) ; iter = g_utf8_next_char(iter)) {
+		gunichar c = g_utf8_get_char(iter);
+		/* If the character is an ASCII character and is alphanumeric
+		 * no need to escape */
+		if (c < 128 && (isalnum(c) || c == '-' || c == '.' || c == '_' || c == '~')) {
+			buf[j++] = c;
+		} else {
+			int bytes = g_unichar_to_utf8(c, utf_char);
+			for (i = 0; (int)i < bytes; i++) {
+				if (j > (BUF_LEN - 4))
+					break;
+				if (i >= sizeof(utf_char)) {
+					g_warn_if_reached();
+					break;
+				}
+				sprintf(buf + j, "%%%02X", utf_char[i] & 0xff);
+				j += 3;
+			}
+		}
+	}
+
+	buf[j] = '\0';
+
+	return buf;
+}
+
+/* Originally lifted from
+ * http://www.oreillynet.com/pub/a/network/excerpt/spcookbook_chap03/index3.html
+ * ... and slightly modified to be a bit more rfc822 compliant
+ * ... and modified a bit more to make domain checking rfc1035 compliant
+ *     with the exception permitted in rfc1101 for domains to start with digit
+ *     but not completely checking to avoid conflicts with IP addresses
+ */
+gboolean
+purple_email_is_valid(const char *address)
+{
+	const char *c, *domain;
+	static char *rfc822_specials = "()<>@,;:\\\"[]";
+
+	g_return_val_if_fail(address != NULL, FALSE);
+
+	if (*address == '.') return FALSE;
+
+	/* first we validate the name portion (name@domain) (rfc822)*/
+	for (c = address;  *c;  c++) {
+		if (*c == '\"' && (c == address || *(c - 1) == '.' || *(c - 1) == '\"')) {
+			while (*++c) {
+				if (*c == '\\') {
+					if (*c++ && *c < 127 && *c != '\n' && *c != '\r') continue;
+					else return FALSE;
+				}
+				if (*c == '\"') break;
+				if (*c < ' ' || *c >= 127) return FALSE;
+			}
+			if (!*c++) return FALSE;
+			if (*c == '@') break;
+			if (*c != '.') return FALSE;
+			continue;
+		}
+		if (*c == '@') break;
+		if (*c <= ' ' || *c >= 127) return FALSE;
+		if (strchr(rfc822_specials, *c)) return FALSE;
+	}
+
+	/* It's obviously not an email address if we didn't find an '@' above */
+	if (*c == '\0') return FALSE;
+
+	/* strictly we should return false if (*(c - 1) == '.') too, but I think
+	 * we should permit user.@domain type addresses - they do work :) */
+	if (c == address) return FALSE;
+
+	/* next we validate the domain portion (name@domain) (rfc1035 & rfc1011) */
+	if (!*(domain = ++c)) return FALSE;
+	do {
+		if (*c == '.' && (c == domain || *(c - 1) == '.' || *(c - 1) == '-'))
+			return FALSE;
+		if (*c == '-' && (*(c - 1) == '.' || *(c - 1) == '@')) return FALSE;
+		if ((*c < '0' && *c != '-' && *c != '.') || (*c > '9' && *c < 'A') ||
+			(*c > 'Z' && *c < 'a') || (*c > 'z')) return FALSE;
+	} while (*++c);
+
+	if (*(c - 1) == '-') return FALSE;
+
+	return ((c - domain) > 3 ? TRUE : FALSE);
+}
+
+gboolean
+purple_ipv4_address_is_valid(const char *ip)
+{
+	int c, o1, o2, o3, o4;
+	char end;
+
+	g_return_val_if_fail(ip != NULL, FALSE);
+
+	c = sscanf(ip, "%d.%d.%d.%d%c", &o1, &o2, &o3, &o4, &end);
+	if (c != 4 || o1 < 0 || o1 > 255 || o2 < 0 || o2 > 255 || o3 < 0 || o3 > 255 || o4 < 0 || o4 > 255)
+		return FALSE;
+	return TRUE;
+}
+
+gboolean
+purple_ipv6_address_is_valid(const gchar *ip)
+{
+	const gchar *c;
+	gboolean double_colon = FALSE;
+	gint chunks = 1;
+	gint in = 0;
+
+	g_return_val_if_fail(ip != NULL, FALSE);
+
+	if (*ip == '\0')
+		return FALSE;
+
+	for (c = ip; *c; ++c) {
+		if ((*c >= '0' && *c <= '9') ||
+		        (*c >= 'a' && *c <= 'f') ||
+		        (*c >= 'A' && *c <= 'F')) {
+			if (++in > 4)
+				/* Only four hex digits per chunk */
+				return FALSE;
+			continue;
+		} else if (*c == ':') {
+			/* The start of a new chunk */
+			++chunks;
+			in = 0;
+			if (*(c + 1) == ':') {
+				/*
+				 * '::' indicates a consecutive series of chunks full
+				 * of zeroes. There can be only one of these per address.
+				 */
+				if (double_colon)
+					return FALSE;
+				double_colon = TRUE;
+			}
+		} else
+			return FALSE;
+	}
+
+	/*
+	 * Either we saw a '::' and there were fewer than 8 chunks -or-
+	 * we didn't see a '::' and saw exactly 8 chunks.
+	 */
+	return (double_colon && chunks < 8) || (!double_colon && chunks == 8);
+}
+
+/* TODO 3.0.0: Add ipv6 check, too */
+gboolean
+purple_ip_address_is_valid(const char *ip)
+{
+	return purple_ipv4_address_is_valid(ip);
+}
+
+/* Stolen from gnome_uri_list_extract_uris */
+GList *
+purple_uri_list_extract_uris(const gchar *uri_list)
+{
+	const gchar *p, *q;
+	gchar *retval;
+	GList *result = NULL;
+
+	g_return_val_if_fail (uri_list != NULL, NULL);
+
+	p = uri_list;
+
+	/* We don't actually try to validate the URI according to RFC
+	* 2396, or even check for allowed characters - we just ignore
+	* comments and trim whitespace off the ends.  We also
+	* allow LF delimination as well as the specified CRLF.
+	*/
+	while (p) {
+		if (*p != '#') {
+			while (isspace(*p))
+				p++;
+
+			q = p;
+			while (*q && (*q != '\n') && (*q != '\r'))
+				q++;
+
+			if (q > p) {
+				q--;
+				while (q > p && isspace(*q))
+					q--;
+
+				retval = (gchar*)g_malloc (q - p + 2);
+				strncpy (retval, p, q - p + 1);
+				retval[q - p + 1] = '\0';
+
+				result = g_list_prepend (result, retval);
+			}
+		}
+		p = strchr (p, '\n');
+		if (p)
+			p++;
+	}
+
+	return g_list_reverse (result);
+}
+
+
+/* Stolen from gnome_uri_list_extract_filenames */
+GList *
+purple_uri_list_extract_filenames(const gchar *uri_list)
+{
+	GList *tmp_list, *node, *result;
+
+	g_return_val_if_fail (uri_list != NULL, NULL);
+
+	result = purple_uri_list_extract_uris(uri_list);
+
+	tmp_list = result;
+	while (tmp_list) {
+		gchar *s = (gchar*)tmp_list->data;
+
+		node = tmp_list;
+		tmp_list = tmp_list->next;
+
+		if (!strncmp (s, "file:", 5)) {
+			node->data = g_filename_from_uri (s, NULL, NULL);
+			/* not sure if this fallback is useful at all */
+			if (!node->data) node->data = g_strdup (s+5);
+		} else {
+			result = g_list_delete_link(result, node);
+		}
+		g_free (s);
+	}
+	return result;
+}
+
+/**************************************************************************
+ * UTF8 String Functions
+ **************************************************************************/
+gchar *
+purple_utf8_try_convert(const char *str)
+{
+	gsize converted;
+	gchar *utf8;
+
+	g_return_val_if_fail(str != NULL, NULL);
+
+	if (g_utf8_validate(str, -1, NULL)) {
+		return g_strdup(str);
+	}
+
+	utf8 = g_locale_to_utf8(str, -1, &converted, NULL, NULL);
+	if (utf8 != NULL)
+		return utf8;
+
+	utf8 = g_convert(str, -1, "UTF-8", "ISO-8859-15", &converted, NULL, NULL);
+	if ((utf8 != NULL) && (converted == strlen(str)))
+		return utf8;
+
+	g_free(utf8);
+
+	return NULL;
+}
+
+#define utf8_first(x) ((x & 0x80) == 0 || (x & 0xe0) == 0xc0 \
+		       || (x & 0xf0) == 0xe0 || (x & 0xf8) == 0xf0)
+gchar *
+purple_utf8_salvage(const char *str)
+{
+	GString *workstr;
+	const char *end;
+
+	g_return_val_if_fail(str != NULL, NULL);
+
+	workstr = g_string_sized_new(strlen(str));
+
+	do {
+		(void)g_utf8_validate(str, -1, &end);
+		workstr = g_string_append_len(workstr, str, end - str);
+		str = end;
+		if (*str == '\0')
+			break;
+		do {
+			workstr = g_string_append_c(workstr, '?');
+			str++;
+		} while (!utf8_first(*str));
+	} while (*str != '\0');
+
+	return g_string_free(workstr, FALSE);
+}
+
+gchar *
+purple_utf8_strip_unprintables(const gchar *str)
+{
+	gchar *workstr, *iter;
+	const gchar *bad;
+
+	if (str == NULL)
+		/* Act like g_strdup */
+		return NULL;
+
+	if (!g_utf8_validate(str, -1, &bad)) {
+		purple_debug_error("util", "purple_utf8_strip_unprintables(%s) failed; "
+		                           "first bad character was %02x (%c)\n",
+		                   str, *bad, *bad);
+		g_return_val_if_reached(NULL);
+	}
+
+	workstr = iter = g_new(gchar, strlen(str) + 1);
+	while (*str) {
+		gunichar ch = g_utf8_get_char(str);
+		gchar *next = g_utf8_next_char(str);
+		/*
+		 * Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] |
+		 *          [#x10000-#x10FFFF]
+		 */
+		if ((ch == '\t' || ch == '\n' || ch == '\r') ||
+				(ch >= 0x20 && ch <= 0xD7FF) ||
+				(ch >= 0xE000 && ch <= 0xFFFD) ||
+				(ch >= 0x10000 && ch <= 0x10FFFF)) {
+			memcpy(iter, str, next - str);
+			iter += (next - str);
+		}
+
+		str = next;
+	}
+
+	/* nul-terminate the new string */
+	*iter = '\0';
+
+	return workstr;
+}
+
+/*
+ * This function is copied from g_strerror() but changed to use
+ * gai_strerror().
+ */
+G_CONST_RETURN gchar *
+purple_gai_strerror(gint errnum)
+{
+#if GLIB_CHECK_VERSION(2, 32, 0)
+	static GPrivate msg_private = G_PRIVATE_INIT(g_free);
+#else
+	static GStaticPrivate msg_private = G_STATIC_PRIVATE_INIT;
+#endif
+	char *msg;
+	int saved_errno = errno;
+
+	const char *msg_locale;
+
+	msg_locale = gai_strerror(errnum);
+	if (g_get_charset(NULL))
+	{
+		/* This string is already UTF-8--great! */
+		errno = saved_errno;
+		return msg_locale;
+	}
+	else
+	{
+		gchar *msg_utf8 = g_locale_to_utf8(msg_locale, -1, NULL, NULL, NULL);
+		if (msg_utf8)
+		{
+			/* Stick in the quark table so that we can return a static result */
+			GQuark msg_quark = g_quark_from_string(msg_utf8);
+			g_free(msg_utf8);
+
+			msg_utf8 = (gchar *)g_quark_to_string(msg_quark);
+			errno = saved_errno;
+			return msg_utf8;
+		}
+	}
+
+#if GLIB_CHECK_VERSION(2, 32, 0)
+	msg = g_private_get(&msg_private);
+#else
+	msg = g_static_private_get(&msg_private);
+#endif
+	if (!msg)
+	{
+		msg = g_new(gchar, 64);
+#if GLIB_CHECK_VERSION(2, 32, 0)
+		g_private_set(&msg_private, msg);
+#else
+		g_static_private_set(&msg_private, msg, g_free);
+#endif
+	}
+
+	sprintf(msg, "unknown error (%d)", errnum);
+
+	errno = saved_errno;
+	return msg;
+}
+
+char *
+purple_utf8_ncr_encode(const char *str)
+{
+	GString *out;
+
+	g_return_val_if_fail(str != NULL, NULL);
+	g_return_val_if_fail(g_utf8_validate(str, -1, NULL), NULL);
+
+	out = g_string_new("");
+
+	for(; *str; str = g_utf8_next_char(str)) {
+		gunichar wc = g_utf8_get_char(str);
+
+		/* super simple check. hopefully not too wrong. */
+		if(wc >= 0x80) {
+			g_string_append_printf(out, "&#%u;", (guint32) wc);
+		} else {
+			g_string_append_unichar(out, wc);
+		}
+	}
+
+	return g_string_free(out, FALSE);
+}
+
+
+char *
+purple_utf8_ncr_decode(const char *str)
+{
+	GString *out;
+	char *buf, *b;
+
+	g_return_val_if_fail(str != NULL, NULL);
+	g_return_val_if_fail(g_utf8_validate(str, -1, NULL), NULL);
+
+	buf = (char *) str;
+	out = g_string_new("");
+
+	while( (b = strstr(buf, "&#")) ) {
+		gunichar wc;
+		int base = 0;
+
+		/* append everything leading up to the &# */
+		g_string_append_len(out, buf, b-buf);
+
+		b += 2; /* skip past the &# */
+
+		/* strtoul will treat 0x prefix as hex, but not just x */
+		if(*b == 'x' || *b == 'X') {
+			base = 16;
+			b++;
+		}
+
+		/* advances buf to the end of the ncr segment */
+		wc = (gunichar) strtoul(b, &buf, base);
+
+		/* this mimics the previous impl of ncr_decode */
+		if(*buf == ';') {
+			g_string_append_unichar(out, wc);
+			buf++;
+		}
+	}
+
+	/* append whatever's left */
+	g_string_append(out, buf);
+
+	return g_string_free(out, FALSE);
+}
+
+
+int
+purple_utf8_strcasecmp(const char *a, const char *b)
+{
+	char *a_norm = NULL;
+	char *b_norm = NULL;
+	int ret = -1;
+
+	if(!a && b)
+		return -1;
+	else if(!b && a)
+		return 1;
+	else if(!a && !b)
+		return 0;
+
+	if(!g_utf8_validate(a, -1, NULL) || !g_utf8_validate(b, -1, NULL))
+	{
+		purple_debug_error("purple_utf8_strcasecmp",
+						 "One or both parameters are invalid UTF8\n");
+		return ret;
+	}
+
+	a_norm = g_utf8_casefold(a, -1);
+	b_norm = g_utf8_casefold(b, -1);
+	ret = g_utf8_collate(a_norm, b_norm);
+	g_free(a_norm);
+	g_free(b_norm);
+
+	return ret;
+}
+
+/* previously conversation::find_nick() */
+gboolean
+purple_utf8_has_word(const char *haystack, const char *needle)
+{
+	char *hay, *pin, *p;
+	const char *start, *prev_char;
+	gunichar before, after;
+	int n;
+	gboolean ret = FALSE;
+
+	start = hay = g_utf8_strdown(haystack, -1);
+
+	pin = g_utf8_strdown(needle, -1);
+	n = strlen(pin);
+
+	while ((p = strstr(start, pin)) != NULL) {
+		prev_char = g_utf8_find_prev_char(hay, p);
+		before = (gunichar)-2;
+		if (prev_char) {
+			before = g_utf8_get_char(prev_char);
+		}
+		after = g_utf8_get_char_validated(p + n, - 1);
+
+		if ((p == hay ||
+				/* The character before is a reasonable guess for a word boundary
+				   ("!g_unichar_isalnum()" is not a valid way to determine word
+				    boundaries, but it is the only reasonable thing to do here),
+				   and isn't the '&' from a "&amp;" or some such entity*/
+				(before != (gunichar)-2 && !g_unichar_isalnum(before) && *(p - 1) != '&'))
+				&& after != (gunichar)-2 && !g_unichar_isalnum(after)) {
+			ret = TRUE;
+			break;
+		}
+		start = p + 1;
+	}
+
+	g_free(pin);
+	g_free(hay);
+
+	return ret;
+}
+
+void
+purple_print_utf8_to_console(FILE *filestream, char *message)
+{
+	gchar *message_conv;
+	GError *error = NULL;
+
+	/* Try to convert 'message' to user's locale */
+	message_conv = g_locale_from_utf8(message, -1, NULL, NULL, &error);
+	if (message_conv != NULL) {
+		fputs(message_conv, filestream);
+		g_free(message_conv);
+	}
+	else
+	{
+		/* use 'message' as a fallback */
+		g_warning("%s\n", error->message);
+		g_error_free(error);
+		fputs(message, filestream);
+	}
+}
+
+gboolean purple_message_meify(char *message, gssize len)
+{
+	char *c;
+	gboolean inside_html = FALSE;
+
+	g_return_val_if_fail(message != NULL, FALSE);
+
+	if(len == -1)
+		len = strlen(message);
+
+	for (c = message; *c; c++, len--) {
+		if(inside_html) {
+			if(*c == '>')
+				inside_html = FALSE;
+		} else {
+			if(*c == '<')
+				inside_html = TRUE;
+			else
+				break;
+		}
+	}
+
+	if(*c && !g_ascii_strncasecmp(c, "/me ", 4)) {
+		memmove(c, c+4, len-3);
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+char *purple_text_strip_mnemonic(const char *in)
+{
+	char *out;
+	char *a;
+	char *a0;
+	const char *b;
+
+	g_return_val_if_fail(in != NULL, NULL);
+
+	out = g_malloc(strlen(in)+1);
+	a = out;
+	b = in;
+
+	a0 = a; /* The last non-space char seen so far, or the first char */
+
+	while(*b) {
+		if(*b == '_') {
+			if(a > out && b > in && *(b-1) == '(' && *(b+1) && !(*(b+1) & 0x80) && *(b+2) == ')') {
+				/* Detected CJK style shortcut (Bug 875311) */
+				a = a0;	/* undo the left parenthesis */
+				b += 3;	/* and skip the whole mess */
+			} else if(*(b+1) == '_') {
+				*(a++) = '_';
+				b += 2;
+				a0 = a;
+			} else {
+				b++;
+			}
+		/* We don't want to corrupt the middle of UTF-8 characters */
+		} else if (!(*b & 0x80)) {	/* other 1-byte char */
+			if (*b != ' ')
+				a0 = a;
+			*(a++) = *(b++);
+		} else {
+			/* Multibyte utf8 char, don't look for _ inside these */
+			int n = 0;
+			int i;
+			if ((*b & 0xe0) == 0xc0) {
+				n = 2;
+			} else if ((*b & 0xf0) == 0xe0) {
+				n = 3;
+			} else if ((*b & 0xf8) == 0xf0) {
+				n = 4;
+			} else if ((*b & 0xfc) == 0xf8) {
+				n = 5;
+			} else if ((*b & 0xfe) == 0xfc) {
+				n = 6;
+			} else {		/* Illegal utf8 */
+				n = 1;
+			}
+			a0 = a; /* unless we want to delete CJK spaces too */
+			for (i = 0; i < n && *b; i += 1) {
+				*(a++) = *(b++);
+			}
+		}
+	}
+	*a = '\0';
+
+	return out;
+}
+
+const char* purple_unescape_filename(const char *escaped) {
+	return purple_url_decode(escaped);
+}
+
+
+/* this is almost identical to purple_url_encode (hence purple_url_decode
+ * being used above), but we want to keep certain characters unescaped
+ * for compat reasons */
+const char *
+purple_escape_filename(const char *str)
+{
+	const char *iter;
+	static char buf[BUF_LEN];
+	char utf_char[6];
+	guint i, j = 0;
+
+	g_return_val_if_fail(str != NULL, NULL);
+	g_return_val_if_fail(g_utf8_validate(str, -1, NULL), NULL);
+
+	iter = str;
+	for (; *iter && j < (BUF_LEN - 1) ; iter = g_utf8_next_char(iter)) {
+		gunichar c = g_utf8_get_char(iter);
+		/* If the character is an ASCII character and is alphanumeric,
+		 * or one of the specified values, no need to escape */
+		if (c < 128 && (g_ascii_isalnum(c) || c == '@' || c == '-' ||
+				c == '_' || c == '.' || c == '#')) {
+			buf[j++] = c;
+		} else {
+			int bytes = g_unichar_to_utf8(c, utf_char);
+			for (i = 0; (int)i < bytes; i++) {
+				if (j > (BUF_LEN - 4))
+					break;
+				if (i >= sizeof(utf_char)) {
+					g_warn_if_reached();
+					break;
+				}
+				sprintf(buf + j, "%%%02x", utf_char[i] & 0xff);
+				j += 3;
+			}
+		}
+	}
+#ifdef _WIN32
+	/* File/Directory names in windows cannot end in periods/spaces.
+	 * http://msdn.microsoft.com/en-us/library/aa365247%28VS.85%29.aspx
+	 */
+	while (j > 0 && (buf[j - 1] == '.' || buf[j - 1] == ' '))
+		j--;
+#endif
+	buf[j] = '\0';
+
+	return buf;
+}
+
+const char *_purple_oscar_convert(const char *act, const char *protocol)
+{
+	if (act && purple_strequal(protocol, "prpl-oscar")) {
+		int i;
+		for (i = 0; act[i] != '\0'; i++)
+			if (!isdigit(act[i]))
+				return "prpl-aim";
+		return "prpl-icq";
+	}
+	return protocol;
+}
+
+void purple_restore_default_signal_handlers(void)
+{
+#ifndef _WIN32
+#ifdef HAVE_SIGNAL_H
+	signal(SIGHUP, SIG_DFL);	/* 1: terminal line hangup */
+	signal(SIGINT, SIG_DFL);	/* 2: interrupt program */
+	signal(SIGQUIT, SIG_DFL);	/* 3: quit program */
+	signal(SIGILL,  SIG_DFL);	/* 4:  illegal instruction (not reset when caught) */
+	signal(SIGTRAP, SIG_DFL);	/* 5:  trace trap (not reset when caught) */
+	signal(SIGABRT, SIG_DFL);	/* 6:  abort program */
+
+#ifdef SIGPOLL
+	signal(SIGPOLL,  SIG_DFL);	/* 7:  pollable event (POSIX) */
+#endif /* SIGPOLL */
+
+#ifdef SIGEMT
+	signal(SIGEMT,  SIG_DFL);	/* 7:  EMT instruction (Non-POSIX) */
+#endif /* SIGEMT */
+
+	signal(SIGFPE,  SIG_DFL);	/* 8:  floating point exception */
+	signal(SIGBUS,  SIG_DFL);	/* 10: bus error */
+	signal(SIGSEGV, SIG_DFL);	/* 11: segmentation violation */
+	signal(SIGSYS,  SIG_DFL);	/* 12: bad argument to system call */
+	signal(SIGPIPE, SIG_DFL);	/* 13: write on a pipe with no reader */
+	signal(SIGALRM, SIG_DFL);	/* 14: real-time timer expired */
+	signal(SIGTERM, SIG_DFL);	/* 15: software termination signal */
+	signal(SIGCHLD, SIG_DFL);	/* 20: child status has changed */
+	signal(SIGXCPU, SIG_DFL);	/* 24: exceeded CPU time limit */
+	signal(SIGXFSZ, SIG_DFL);	/* 25: exceeded file size limit */
+#endif /* HAVE_SIGNAL_H */
+#endif /* !_WIN32 */
+}
+
+static void
+set_status_with_attrs(PurpleStatus *status, ...)
+{
+	va_list args;
+	va_start(args, status);
+	purple_status_set_active_with_attrs(status, TRUE, args);
+	va_end(args);
+}
+
+void purple_util_set_current_song(const char *title, const char *artist, const char *album)
+{
+	GList *list = purple_accounts_get_all();
+	for (; list; list = list->next) {
+		PurplePresence *presence;
+		PurpleStatus *tune;
+		PurpleAccount *account = list->data;
+		if (!purple_account_get_enabled(account, purple_core_get_ui()))
+			continue;
+
+		presence = purple_account_get_presence(account);
+		tune = purple_presence_get_status(presence, "tune");
+		if (!tune)
+			continue;
+		if (title) {
+			set_status_with_attrs(tune,
+					PURPLE_TUNE_TITLE, title,
+					PURPLE_TUNE_ARTIST, artist,
+					PURPLE_TUNE_ALBUM, album,
+					NULL);
+		} else {
+			purple_status_set_active(tune, FALSE);
+		}
+	}
+}
+
+char * purple_util_format_song_info(const char *title, const char *artist, const char *album, gpointer unused)
+{
+	GString *string;
+	char *esc;
+
+	if (!title || !*title)
+		return NULL;
+
+	esc = g_markup_escape_text(title, -1);
+	string = g_string_new("");
+	g_string_append_printf(string, "%s", esc);
+	g_free(esc);
+
+	if (artist && *artist) {
+		esc = g_markup_escape_text(artist, -1);
+		g_string_append_printf(string, _(" - %s"), esc);
+		g_free(esc);
+	}
+
+	if (album && *album) {
+		esc = g_markup_escape_text(album, -1);
+		g_string_append_printf(string, _(" (%s)"), esc);
+		g_free(esc);
+	}
+
+	return g_string_free(string, FALSE);
+}
+
+const gchar *
+purple_get_host_name(void)
+{
+	return g_get_host_name();
+}
+
+gchar *
+purple_uuid_random(void)
+{
+	guint32 tmp, a, b;
+
+	tmp = g_random_int();
+	a = 0x4000 | (tmp & 0xFFF); /* 0x4000 to 0x4FFF */
+	tmp >>= 12;
+	b = ((1 << 3) << 12) | (tmp & 0x3FFF); /* 0x8000 to 0xBFFF */
+
+	tmp = g_random_int();
+
+	return g_strdup_printf("%08x-%04x-%04x-%04x-%04x%08x",
+			g_random_int(),
+			tmp & 0xFFFF,
+			a,
+			b,
+			(tmp >> 16) & 0xFFFF, g_random_int());
+}
diff -uNr pidgin-2.10.11.orig/libpurple/util.h pidgin-2.10.11/libpurple/util.h
--- pidgin-2.10.11.orig/libpurple/util.h	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/libpurple/util.h	2015-02-10 14:28:16.414019861 +0900
@@ -1487,4 +1487,10 @@
 }
 #endif
 
+/* to address incompatibility with cp932. */
+void botch_ucs(gchar *ucs, gsize len);
+void sanitize_ucs(gchar *ucs, gsize len);
+gchar *botch_utf(const gchar *utf, gsize len, gsize *newlen);
+gchar *sanitize_utf(const gchar *msg, gsize len, gsize *newlen);
+
 #endif /* _PURPLE_UTIL_H_ */
diff -uNr pidgin-2.10.11.orig/pidgin/gtkblist.c pidgin-2.10.11/pidgin/gtkblist.c
--- pidgin-2.10.11.orig/pidgin/gtkblist.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkblist.c	2015-02-10 14:28:16.414019861 +0900
@@ -70,6 +70,11 @@
 #include <gtk/gtk.h>
 #include <gdk/gdk.h>
 
+/* I noticed that some of short cuts are very annoying.
+   If you really want to use them, change this to 1. --yaz
+*/
+#define ENABLE_SHORTCUT 0
+
 typedef struct
 {
 	PurpleAccount *account;
@@ -3640,6 +3645,7 @@
 	{ N_("/Tools/System _Log"), NULL, gtk_blist_show_systemlog_cb, 3, "<Item>", NULL },
 	{ "/Tools/sep3", NULL, NULL, 0, "<Separator>", NULL },
 	{ N_("/Tools/Mute _Sounds"), NULL, pidgin_blist_mute_sounds_cb, 0, "<CheckItem>", NULL },
+
 	/* Help */
 	{ N_("/_Help"), NULL, NULL, 0, "<Branch>", NULL },
 	{ N_("/Help/Online _Help"), "F1", gtk_blist_show_onlinehelp_cb, 0, "<StockItem>", GTK_STOCK_HELP },
diff -uNr pidgin-2.10.11.orig/pidgin/gtkconv.c pidgin-2.10.11/pidgin/gtkconv.c
--- pidgin-2.10.11.orig/pidgin/gtkconv.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkconv.c	2015-02-10 14:28:16.417353357 +0900
@@ -1,3 +1,4 @@
+/* -*- coding: utf-8 -*- */
 /**
  * @file gtkconv.c GTK+ Conversation API
  * @ingroup pidgin
@@ -116,6 +117,10 @@
 static GdkColor *nick_colors = NULL;
 static guint nbr_nick_colors;
 
+/* yaz. If you want to use shortcut keys that may conflict with
+   inputmethods, change this to 1. */
+#define ENABLE_SHORTCUT 0
+
 typedef struct {
 	GtkWidget *window;
 
@@ -268,6 +273,43 @@
 	return FALSE;
 }
 
+static gboolean
+size_allocate_cb(GtkWidget *w, GtkAllocation *allocation, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+
+	if (!GTK_WIDGET_VISIBLE(w))
+		return FALSE;
+
+	if (!PIDGIN_IS_PIDGIN_CONVERSATION(conv))
+		return FALSE;
+	if (gtkconv->auto_resize) {
+		return FALSE;
+	}
+
+	if (gdk_window_get_state(gtkconv->win->window->window) & GDK_WINDOW_STATE_MAXIMIZED) {
+		return FALSE;
+	}
+
+	/* I find that I resize the window when it has a bunch of conversations in it, mostly so that the
+	 * tab bar will fit, but then I don't want new windows taking up the entire screen.  I check to see
+	 * if there is only one conversation in the window.  This way we'll be setting new windows to the
+	 * size of the last resized new window. */
+	/* I think that the above justification is not the majority, and that the new tab resizing should
+	 * negate it anyway.  --luke */
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+	{
+		if (w == gtkconv->lower_hbox)
+			purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/im/entry_height", allocation->height);
+	}
+	else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+	{
+		if (w == gtkconv->lower_hbox)
+			purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/chat/entry_height", allocation->height);
+	}
+	return FALSE;
+}
+
 static void
 default_formatize(PidginConversation *c)
 {
@@ -445,6 +487,20 @@
 	gtkconv->send_history = g_list_prepend(first, NULL);
 }
 
+#if 0
+static void
+reset_default_size(PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+		gtk_widget_set_size_request(gtkconv->lower_hbox, -1,
+					    purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/chat/entry_height"));
+	else
+		gtk_widget_set_size_request(gtkconv->lower_hbox, -1,
+					    purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/im/entry_height"));
+}
+#endif
+
 static gboolean
 check_for_and_do_command(PurpleConversation *conv)
 {
@@ -3076,13 +3132,21 @@
 
 	{ "/Conversation/sep0", NULL, NULL, 0, "<Separator>", NULL },
 
+#if ENABLE_SHORTCUT
 	{ N_("/Conversation/_Find..."), NULL, menu_find_cb, 0,
 			"<StockItem>", GTK_STOCK_FIND },
+#else
+	{ N_("/Conversation/_Find..."), NULL, menu_find_cb, 0,
+      "<Item>", NULL },
+#endif
 	{ N_("/Conversation/View _Log"), NULL, menu_view_log_cb, 0, "<Item>", NULL },
 	{ N_("/Conversation/_Save As..."), NULL, menu_save_as_cb, 0,
 			"<StockItem>", GTK_STOCK_SAVE_AS },
+#if ENABLE_SHORTCUT
 	{ N_("/Conversation/Clea_r Scrollback"), "<CTL>L", menu_clear_cb, 0, "<StockItem>", GTK_STOCK_CLEAR },
-
+#else
+	{ N_("/Conversation/Clea_r Scrollback"), NULL, menu_clear_cb, 0, "<Item>", NULL },
+#endif
 	{ "/Conversation/sep1", NULL, NULL, 0, "<Separator>", NULL },
 
 #ifdef USE_VV
@@ -3100,8 +3164,13 @@
 	{ N_("/Conversation/Get _Attention"), NULL, menu_get_attention_cb, 0, "<StockItem>", PIDGIN_STOCK_TOOLBAR_SEND_ATTENTION },
 	{ N_("/Conversation/Add Buddy _Pounce..."), NULL, menu_add_pounce_cb,
 			0, "<Item>", NULL },
+#if ENABLE_SHORTCUT
 	{ N_("/Conversation/_Get Info"), "<CTL>O", menu_get_info_cb, 0,
 			"<StockItem>", PIDGIN_STOCK_TOOLBAR_USER_INFO },
+#else
+	{ N_("/Conversation/_Get Info"), NULL, menu_get_info_cb, 0,
+			"<StockItem>", PIDGIN_STOCK_TOOLBAR_USER_INFO },
+#endif
 	{ N_("/Conversation/In_vite..."), NULL, menu_invite_cb, 0,
 			"<Item>", NULL },
 	{ N_("/Conversation/M_ore"), NULL, NULL, 0, "<Branch>", NULL },
@@ -3882,7 +3951,11 @@
 		gtk_widget_destroy(win->menu.send_to);
 
 	/* Build the Send To menu */
+#if ENABLE_SHORTCUT
 	win->menu.send_to = gtk_menu_item_new_with_mnemonic(_("S_end To"));
+#else
+	win->menu.send_to = gtk_menu_item_new_with_mnemonic(_("Send To")); //to free Alt-s. intentional. --yaz
+#endif
 	gtk_widget_show(win->menu.send_to);
 
 	menu = gtk_menu_new();
@@ -4636,12 +4709,10 @@
 		height += 2 * focus_width;
 
 	diff = height - gtkconv->entry->allocation.height;
-	if (ABS(diff) < oneline.height / 2)
+	if (diff == 0 || (diff < 0 && -diff < oneline.height / 2))
 		return FALSE;
-
 	gtk_widget_set_size_request(gtkconv->lower_hbox, -1,
-		diff + gtkconv->lower_hbox->allocation.height);
-
+				    diff + gtkconv->lower_hbox->allocation.height);
 	return FALSE;
 }
 
@@ -4870,6 +4941,10 @@
 	switch (event->keyval) {
 		case GDK_Return:
 		case GDK_KP_Enter:
+			if (gtk_im_context_filter_keypress (GTK_ENTRY(entry)->im_context, event)) {
+				GTK_ENTRY(entry)->need_im_reset = TRUE;
+				return TRUE;
+			}
 			if (gtk_imhtml_search_find(GTK_IMHTML(gtkconv->imhtml), gtk_entry_get_text(GTK_ENTRY(entry)))) {
 				gtk_widget_modify_base(gtkconv->quickfind.entry, GTK_STATE_NORMAL, NULL);
 			} else {
@@ -4923,7 +4998,7 @@
 static GtkWidget *
 setup_common_pane(PidginConversation *gtkconv)
 {
-	GtkWidget *vbox, *frame, *imhtml_sw, *event_box;
+	GtkWidget *paned, *vbox, *frame, *imhtml_sw, *event_box;
 	GtkCellRenderer *rend;
 	GtkTreePath *path;
 	PurpleConversation *conv = gtkconv->active_conv;
@@ -4931,8 +5006,12 @@
 	gboolean chat = (conv->type == PURPLE_CONV_TYPE_CHAT);
 	int buddyicon_size = 0;
 
+	paned = gtk_vpaned_new();
+	gtk_widget_show(paned);
+
 	/* Setup the top part of the pane */
 	vbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_paned_pack1(GTK_PANED(paned), vbox, TRUE, TRUE);
 	gtk_widget_show(vbox);
 
 	/* Setup the info pane */
@@ -5054,20 +5133,32 @@
 	g_signal_connect(G_OBJECT(gtkconv->imhtml), "key_release_event",
 	                 G_CALLBACK(refocus_entry_cb), gtkconv);
 
+	/* Setup the bottom half of the conversation window */
+	vbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_paned_pack2(GTK_PANED(paned), vbox, FALSE, TRUE);
+	gtk_widget_show(vbox);
+
 	pidgin_conv_setup_quickfind(gtkconv, vbox);
 
 	gtkconv->lower_hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
-	gtk_box_pack_start(GTK_BOX(vbox), gtkconv->lower_hbox, FALSE, FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox), gtkconv->lower_hbox, TRUE, TRUE, 0);
 	gtk_widget_show(gtkconv->lower_hbox);
 
+	vbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_box_pack_end(GTK_BOX(gtkconv->lower_hbox), vbox, TRUE, TRUE, 0);
+	gtk_widget_show(vbox);
+
 	/* Setup the toolbar, entry widget and all signals */
 	frame = pidgin_create_imhtml(TRUE, &gtkconv->entry, &gtkconv->toolbar, NULL);
-	gtk_box_pack_start(GTK_BOX(gtkconv->lower_hbox), frame, TRUE, TRUE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox), frame, TRUE, TRUE, 0);
 	gtk_widget_show(frame);
 
 	gtk_widget_set_name(gtkconv->entry, "pidgin_conv_entry");
 	gtk_imhtml_set_protocol_name(GTK_IMHTML(gtkconv->entry),
 			purple_account_get_protocol_name(conv->account));
+	gtk_widget_set_size_request(gtkconv->lower_hbox, -1,
+			chat ? purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/chat/entry_height") :
+			purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/im/entry_height"));
 
 	g_signal_connect(G_OBJECT(gtkconv->entry), "populate-popup",
 	                 G_CALLBACK(entry_popup_menu_cb), gtkconv);
@@ -5077,6 +5168,8 @@
 	                       G_CALLBACK(send_cb), gtkconv);
 	g_signal_connect_after(G_OBJECT(gtkconv->entry), "button_press_event",
 	                       G_CALLBACK(entry_stop_rclick_cb), NULL);
+	g_signal_connect(G_OBJECT(gtkconv->lower_hbox), "size-allocate",
+	                 G_CALLBACK(size_allocate_cb), gtkconv);
 
 	gtkconv->entry_buffer =
 		gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->entry));
@@ -5101,7 +5194,7 @@
 	default_formatize(gtkconv);
 	g_signal_connect_after(G_OBJECT(gtkconv->entry), "format_function_clear",
 	                       G_CALLBACK(clear_formatting_cb), gtkconv);
-	return vbox;
+	return paned;
 }
 
 static void
@@ -6773,6 +6866,9 @@
 		AtkObject *accessibility_obj;
 		/* I think this is a little longer than it needs to be but I'm lazy. */
 		char *style;
+		gboolean ellipsis;
+		int side;
+		char *tab_title = NULL;
 
 		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
 			im = PURPLE_CONV_IM(conv);
@@ -6842,8 +6938,26 @@
 			style = "tab-label";
 		}
 
+		// nosuke's tab width patch
+		side = purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/tab_side");
+		side &= ~8; 
+		if ( (side == GTK_POS_LEFT || side == GTK_POS_RIGHT) &&
+		     purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/trim_vertical_tabs") )
+			ellipsis = TRUE;
+		else
+			ellipsis = FALSE;
+
+		if (ellipsis) {
+			tab_title = pidgin_gtk_ellipsis_text(gtkconv->tab_label, title, 60, "...");
+		}
+		else {
+			tab_title = g_strdup(title);
+		}
+
 		gtk_widget_set_name(gtkconv->tab_label, style);
-		gtk_label_set_text(GTK_LABEL(gtkconv->tab_label), title);
+		gtk_label_set_text(GTK_LABEL(gtkconv->tab_label), tab_title);
+		g_free(tab_title); tab_title = NULL;
+
 		gtk_widget_set_state(gtkconv->tab_label, GTK_STATE_ACTIVE);
 
 		if (gtkconv->unseen_state == PIDGIN_UNSEEN_TEXT ||
@@ -7242,6 +7356,24 @@
 	return page_num;
 }
 
+//nosuke
+static void
+trim_vertical_tabs_pref_cb(const char *name, PurplePrefType type,
+						   gconstpointer value, gpointer data)
+{
+	GList *l;
+	PurpleConversation *conv;
+
+	for (l = purple_get_conversations(); l != NULL; l = l->next) {
+		conv = (PurpleConversation *)l->data;
+
+		if (!PIDGIN_IS_PIDGIN_CONVERSATION(conv))
+			continue;
+
+		pidgin_conv_update_fields(conv, PIDGIN_CONV_SET_TITLE);
+	}
+}
+
 static void
 close_on_tabs_pref_cb(const char *name, PurplePrefType type,
 					  gconstpointer value, gpointer data)
@@ -7312,6 +7444,7 @@
 			pidgin_conv_tab_pack(gtkwin, gtkconvs->data);
 		}
 	}
+	trim_vertical_tabs_pref_cb(name, type, value, data);
 }
 
 static void
@@ -7370,7 +7503,7 @@
 		else
 			gtk_widget_hide(gtkconv->toolbar);
 
-		g_idle_add((GSourceFunc)resize_imhtml_cb,gtkconv);
+//		g_idle_add((GSourceFunc)resize_imhtml_cb,gtkconv);
 	}
 }
 
@@ -7883,6 +8016,7 @@
 	purple_prefs_add_none(PIDGIN_PREFS_ROOT "/conversations");
 	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/use_smooth_scrolling", TRUE);
 	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/close_on_tabs", TRUE);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/trim_vertical_tabs", FALSE);
 	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/send_bold", FALSE);
 	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/send_italic", FALSE);
 	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/send_underline", FALSE);
@@ -7941,6 +8075,8 @@
 	/* Connect callbacks. */
 	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/close_on_tabs",
 								close_on_tabs_pref_cb, NULL);
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/trim_vertical_tabs",
+								  trim_vertical_tabs_pref_cb, NULL);
 	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/show_timestamps",
 								show_timestamps_pref_cb, NULL);
 	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/show_formatting_toolbar",
diff -uNr pidgin-2.10.11.orig/pidgin/gtkconv.c.orig pidgin-2.10.11/pidgin/gtkconv.c.orig
--- pidgin-2.10.11.orig/pidgin/gtkconv.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkconv.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,10292 @@
+/**
+ * @file gtkconv.c GTK+ Conversation API
+ * @ingroup pidgin
+ */
+
+/* pidgin
+ *
+ * Pidgin is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+#define _PIDGIN_GTKCONV_C_
+
+#include "internal.h"
+#include "pidgin.h"
+
+#ifdef USE_GTKSPELL
+# include <gtkspell/gtkspell.h>
+# ifdef _WIN32
+#  include "wspell.h"
+# endif
+#endif
+
+#include <gdk/gdkkeysyms.h>
+
+#include "account.h"
+#include "cmds.h"
+#include "core.h"
+#include "debug.h"
+#include "idle.h"
+#include "imgstore.h"
+#include "log.h"
+#include "notify.h"
+#include "prpl.h"
+#include "request.h"
+#include "util.h"
+#include "version.h"
+
+#include "gtkdnd-hints.h"
+#include "gtkblist.h"
+#include "gtkconv.h"
+#include "gtkconvwin.h"
+#include "gtkdialogs.h"
+#include "gtkimhtml.h"
+#include "gtkimhtmltoolbar.h"
+#include "gtklog.h"
+#include "gtkmenutray.h"
+#include "gtkpounce.h"
+#include "gtkprefs.h"
+#include "gtkprivacy.h"
+#include "gtkthemes.h"
+#include "gtkutils.h"
+#include "pidginstock.h"
+#include "pidgintooltip.h"
+
+#include "gtknickcolors.h"
+
+#define CLOSE_CONV_TIMEOUT_SECS  (10 * 60)
+
+#define AUTO_RESPONSE "&lt;AUTO-REPLY&gt; : "
+
+typedef enum
+{
+	PIDGIN_CONV_SET_TITLE			= 1 << 0,
+	PIDGIN_CONV_BUDDY_ICON			= 1 << 1,
+	PIDGIN_CONV_MENU			= 1 << 2,
+	PIDGIN_CONV_TAB_ICON			= 1 << 3,
+	PIDGIN_CONV_TOPIC			= 1 << 4,
+	PIDGIN_CONV_SMILEY_THEME		= 1 << 5,
+	PIDGIN_CONV_COLORIZE_TITLE		= 1 << 6
+}PidginConvFields;
+
+enum {
+	CONV_ICON_COLUMN,
+	CONV_TEXT_COLUMN,
+	CONV_EMBLEM_COLUMN,
+	CONV_PROTOCOL_ICON_COLUMN,
+	CONV_NUM_COLUMNS
+} PidginInfopaneColumns;
+
+#define	PIDGIN_CONV_ALL	((1 << 7) - 1)
+
+/* XXX: These color defines shouldn't really be here. But the nick-color
+ * generation algorithm uses them, so keeping these around until we fix that. */
+#define DEFAULT_SEND_COLOR "#204a87"
+#define DEFAULT_HIGHLIGHT_COLOR "#AF7F00"
+
+#define BUDDYICON_SIZE_MIN    32
+#define BUDDYICON_SIZE_MAX    96
+
+/* Undef this to turn off "custom-smiley" debug messages */
+#define DEBUG_CUSTOM_SMILEY
+
+#define LUMINANCE(c) (float)((0.3*(c.red))+(0.59*(c.green))+(0.11*(c.blue)))
+
+/* From http://www.w3.org/TR/AERT#color-contrast */
+#define MIN_BRIGHTNESS_CONTRAST 75
+#define MIN_COLOR_CONTRAST 200
+
+#define NUM_NICK_COLORS 220
+static GdkColor *nick_colors = NULL;
+static guint nbr_nick_colors;
+
+typedef struct {
+	GtkWidget *window;
+
+	GtkWidget *entry;
+	GtkWidget *message;
+
+	PurpleConversation *conv;
+
+} InviteBuddyInfo;
+
+static GtkWidget *invite_dialog = NULL;
+static GtkWidget *warn_close_dialog = NULL;
+
+static PidginWindow *hidden_convwin = NULL;
+static GList *window_list = NULL;
+
+/* Lists of status icons at all available sizes for use as window icons */
+static GList *available_list = NULL;
+static GList *away_list = NULL;
+static GList *busy_list = NULL;
+static GList *xa_list = NULL;
+static GList *offline_list = NULL;
+static GHashTable *prpl_lists = NULL;
+
+static gboolean update_send_to_selection(PidginWindow *win);
+static void generate_send_to_items(PidginWindow *win);
+
+/* Prototypes. <-- because Paco-Paco hates this comment. */
+static gboolean infopane_entry_activate(PidginConversation *gtkconv);
+static void got_typing_keypress(PidginConversation *gtkconv, gboolean first);
+static void gray_stuff_out(PidginConversation *gtkconv);
+static void add_chat_buddy_common(PurpleConversation *conv, PurpleConvChatBuddy *cb, const char *old_name);
+static gboolean tab_complete(PurpleConversation *conv);
+static void pidgin_conv_updated(PurpleConversation *conv, PurpleConvUpdateType type);
+static void conv_set_unseen(PurpleConversation *gtkconv, PidginUnseenState state);
+static void gtkconv_set_unseen(PidginConversation *gtkconv, PidginUnseenState state);
+static void update_typing_icon(PidginConversation *gtkconv);
+static void update_typing_message(PidginConversation *gtkconv, const char *message);
+static const char *item_factory_translate_func (const char *path, gpointer func_data);
+gboolean pidgin_conv_has_focus(PurpleConversation *conv);
+static GdkColor* generate_nick_colors(guint *numcolors, GdkColor background);
+static gboolean color_is_visible(GdkColor foreground, GdkColor background, guint color_contrast, guint brightness_contrast);
+static GtkTextTag *get_buddy_tag(PurpleConversation *conv, const char *who, PurpleMessageFlags flag, gboolean create);
+static void pidgin_conv_update_fields(PurpleConversation *conv, PidginConvFields fields);
+static void focus_out_from_menubar(GtkWidget *wid, PidginWindow *win);
+static void pidgin_conv_tab_pack(PidginWindow *win, PidginConversation *gtkconv);
+static gboolean infopane_press_cb(GtkWidget *widget, GdkEventButton *e, PidginConversation *conv);
+static void hide_conv(PidginConversation *gtkconv, gboolean closetimer);
+
+static void pidgin_conv_set_position_size(PidginWindow *win, int x, int y,
+		int width, int height);
+static gboolean pidgin_conv_xy_to_right_infopane(PidginWindow *win, int x, int y);
+
+static const GdkColor *get_nick_color(PidginConversation *gtkconv, const char *name)
+{
+	static GdkColor col;
+	GtkStyle *style = gtk_widget_get_style(gtkconv->imhtml);
+	float scale;
+
+	col = nick_colors[g_str_hash(name) % nbr_nick_colors];
+	scale = ((1-(LUMINANCE(style->base[GTK_STATE_NORMAL]) / LUMINANCE(style->white))) *
+		       (LUMINANCE(style->white)/MAX(MAX(col.red, col.blue), col.green)));
+
+	/* The colors are chosen to look fine on white; we should never have to darken */
+	if (scale > 1) {
+		col.red   *= scale;
+		col.green *= scale;
+		col.blue  *= scale;
+	}
+
+	return &col;
+}
+
+static PurpleBlistNode *
+get_conversation_blist_node(PurpleConversation *conv)
+{
+	PurpleBlistNode *node = NULL;
+
+	switch (purple_conversation_get_type(conv)) {
+		case PURPLE_CONV_TYPE_IM:
+			node = PURPLE_BLIST_NODE(purple_find_buddy(conv->account, conv->name));
+			node = node ? node->parent : NULL;
+			break;
+		case PURPLE_CONV_TYPE_CHAT:
+			node = PURPLE_BLIST_NODE(purple_blist_find_chat(conv->account, conv->name));
+			break;
+		default:
+			break;
+	}
+	return node;
+}
+
+/**************************************************************************
+ * Callbacks
+ **************************************************************************/
+
+static gboolean
+close_this_sucker(gpointer data)
+{
+	PidginConversation *gtkconv = data;
+	GList *list = g_list_copy(gtkconv->convs);
+	g_list_foreach(list, (GFunc)purple_conversation_destroy, NULL);
+	g_list_free(list);
+	return FALSE;
+}
+
+static gboolean
+close_conv_cb(GtkButton *button, PidginConversation *gtkconv)
+{
+	/* We are going to destroy the conversations immediately only if the 'close immediately'
+	 * preference is selected. Otherwise, close the conversation after a reasonable timeout
+	 * (I am going to consider 10 minutes as a 'reasonable timeout' here.
+	 * For chats, close immediately if the chat is not in the buddylist, or if the chat is
+	 * not marked 'Persistent' */
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleAccount *account = purple_conversation_get_account(conv);
+	const char *name = purple_conversation_get_name(conv);
+
+	switch (purple_conversation_get_type(conv)) {
+		case PURPLE_CONV_TYPE_IM:
+		{
+			if (purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/im/close_immediately"))
+				close_this_sucker(gtkconv);
+			else
+				hide_conv(gtkconv, TRUE);
+			break;
+		}
+		case PURPLE_CONV_TYPE_CHAT:
+		{
+			PurpleChat *chat = purple_blist_find_chat(account, name);
+			if (!chat ||
+					!purple_blist_node_get_bool(&chat->node, "gtk-persistent"))
+				close_this_sucker(gtkconv);
+			else
+				hide_conv(gtkconv, FALSE);
+			break;
+		}
+		default:
+			;
+	}
+
+	return TRUE;
+}
+
+static gboolean
+lbox_size_allocate_cb(GtkWidget *w, GtkAllocation *allocation, gpointer data)
+{
+	purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/chat/userlist_width", allocation->width == 1 ? 0 : allocation->width);
+
+	return FALSE;
+}
+
+static void
+default_formatize(PidginConversation *c)
+{
+	PurpleConversation *conv = c->active_conv;
+	gtk_imhtml_setup_entry(GTK_IMHTML(c->entry), conv->features);
+}
+
+static void
+conversation_entry_clear(PidginConversation *gtkconv)
+{
+	GtkIMHtml *imhtml = GTK_IMHTML(gtkconv->entry);
+	gtk_source_undo_manager_begin_not_undoable_action(imhtml->undo_manager);
+	gtk_imhtml_clear(imhtml);
+	gtk_source_undo_manager_end_not_undoable_action(imhtml->undo_manager);
+}
+
+static void
+clear_formatting_cb(GtkIMHtml *imhtml, PidginConversation *gtkconv)
+{
+	default_formatize(gtkconv);
+}
+
+static const char *
+pidgin_get_cmd_prefix(void)
+{
+	return "/";
+}
+
+static PurpleCmdRet
+say_command_cb(PurpleConversation *conv,
+              const char *cmd, char **args, char **error, void *data)
+{
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+		purple_conv_im_send(PURPLE_CONV_IM(conv), args[0]);
+	else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+		purple_conv_chat_send(PURPLE_CONV_CHAT(conv), args[0]);
+
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet
+me_command_cb(PurpleConversation *conv,
+              const char *cmd, char **args, char **error, void *data)
+{
+	char *tmp;
+
+	tmp = g_strdup_printf("/me %s", args[0]);
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+		purple_conv_im_send(PURPLE_CONV_IM(conv), tmp);
+	else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+		purple_conv_chat_send(PURPLE_CONV_CHAT(conv), tmp);
+
+	g_free(tmp);
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet
+debug_command_cb(PurpleConversation *conv,
+                 const char *cmd, char **args, char **error, void *data)
+{
+	char *tmp, *markup;
+
+	if (!g_ascii_strcasecmp(args[0], "version")) {
+		tmp = g_strdup_printf("Using Pidgin v%s with libpurple v%s.",
+				DISPLAY_VERSION, purple_core_get_version());
+	} else if (!g_ascii_strcasecmp(args[0], "plugins")) {
+		/* Show all the loaded plugins, including the protocol plugins and plugin loaders.
+		 * This is intentional, since third party prpls are often sources of bugs, and some
+		 * plugin loaders (e.g. mono) can also be buggy.
+		 */
+		GString *str = g_string_new("Loaded Plugins: ");
+		const GList *plugins = purple_plugins_get_loaded();
+		if (plugins) {
+			for (; plugins; plugins = plugins->next) {
+				str = g_string_append(str, purple_plugin_get_name(plugins->data));
+				if (plugins->next)
+					str = g_string_append(str, ", ");
+			}
+		} else {
+			str = g_string_append(str, "(none)");
+		}
+
+		tmp = g_string_free(str, FALSE);
+	} else {
+		purple_conversation_write(conv, NULL, _("Supported debug options are: plugins version"),
+		                        PURPLE_MESSAGE_NO_LOG|PURPLE_MESSAGE_ERROR, time(NULL));
+		return PURPLE_CMD_RET_OK;
+	}
+
+	markup = g_markup_escape_text(tmp, -1);
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+		purple_conv_im_send(PURPLE_CONV_IM(conv), markup);
+	else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+		purple_conv_chat_send(PURPLE_CONV_CHAT(conv), markup);
+
+	g_free(tmp);
+	g_free(markup);
+	return PURPLE_CMD_RET_OK;
+}
+
+static void clear_conversation_scrollback_cb(PurpleConversation *conv,
+                                             void *data)
+{
+	PidginConversation *gtkconv = NULL;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	if (gtkconv)
+		gtk_imhtml_clear(GTK_IMHTML(gtkconv->imhtml));
+}
+
+static PurpleCmdRet
+clear_command_cb(PurpleConversation *conv,
+                 const char *cmd, char **args, char **error, void *data)
+{
+	purple_conversation_clear_message_history(conv);
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet
+clearall_command_cb(PurpleConversation *conv,
+                 const char *cmd, char **args, char **error, void *data)
+{
+	purple_conversation_foreach(purple_conversation_clear_message_history);
+	return PURPLE_CMD_RET_OK;
+}
+
+static PurpleCmdRet
+help_command_cb(PurpleConversation *conv,
+                 const char *cmd, char **args, char **error, void *data)
+{
+	GList *l, *text;
+	GString *s;
+
+	if (args[0] != NULL) {
+		s = g_string_new("");
+		text = purple_cmd_help(conv, args[0]);
+
+		if (text) {
+			for (l = text; l; l = l->next)
+				if (l->next)
+					g_string_append_printf(s, "%s\n", (char *)l->data);
+				else
+					g_string_append_printf(s, "%s", (char *)l->data);
+		} else {
+			g_string_append(s, _("No such command (in this context)."));
+		}
+	} else {
+		s = g_string_new(_("Use \"/help &lt;command&gt;\" for help on a specific command.\n"
+											 "The following commands are available in this context:\n"));
+
+		text = purple_cmd_list(conv);
+		for (l = text; l; l = l->next)
+			if (l->next)
+				g_string_append_printf(s, "%s, ", (char *)l->data);
+			else
+				g_string_append_printf(s, "%s.", (char *)l->data);
+		g_list_free(text);
+	}
+
+	purple_conversation_write(conv, NULL, s->str, PURPLE_MESSAGE_NO_LOG, time(NULL));
+	g_string_free(s, TRUE);
+
+	return PURPLE_CMD_RET_OK;
+}
+
+static void
+send_history_add(PidginConversation *gtkconv, const char *message)
+{
+	GList *first;
+
+	first = g_list_first(gtkconv->send_history);
+	g_free(first->data);
+	first->data = g_strdup(message);
+	gtkconv->send_history = g_list_prepend(first, NULL);
+}
+
+static gboolean
+check_for_and_do_command(PurpleConversation *conv)
+{
+	PidginConversation *gtkconv;
+	char *cmd;
+	const char *prefix;
+	GtkTextIter start;
+	gboolean retval = FALSE;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	prefix = pidgin_get_cmd_prefix();
+
+	cmd = gtk_imhtml_get_text(GTK_IMHTML(gtkconv->entry), NULL, NULL);
+	gtk_text_buffer_get_start_iter(GTK_IMHTML(gtkconv->entry)->text_buffer, &start);
+
+	if (cmd && (strncmp(cmd, prefix, strlen(prefix)) == 0)
+	   && !gtk_text_iter_get_child_anchor(&start)) {
+		PurpleCmdStatus status;
+		char *error, *cmdline, *markup, *send_history;
+		GtkTextIter end;
+
+		send_history = gtk_imhtml_get_markup(GTK_IMHTML(gtkconv->entry));
+		send_history_add(gtkconv, send_history);
+		g_free(send_history);
+
+		cmdline = cmd + strlen(prefix);
+
+		if (strcmp(cmdline, "xyzzy") == 0) {
+			purple_conversation_write(conv, "", "Nothing happens",
+					PURPLE_MESSAGE_NO_LOG, time(NULL));
+			g_free(cmd);
+			return TRUE;
+		}
+
+		gtk_text_iter_forward_chars(&start, g_utf8_strlen(prefix, -1));
+		gtk_text_buffer_get_end_iter(GTK_IMHTML(gtkconv->entry)->text_buffer, &end);
+		markup = gtk_imhtml_get_markup_range(GTK_IMHTML(gtkconv->entry), &start, &end);
+		status = purple_cmd_do_command(conv, cmdline, markup, &error);
+		g_free(markup);
+
+		switch (status) {
+			case PURPLE_CMD_STATUS_OK:
+				retval = TRUE;
+				break;
+			case PURPLE_CMD_STATUS_NOT_FOUND:
+				{
+					PurplePluginProtocolInfo *prpl_info = NULL;
+					PurpleConnection *gc;
+
+					if ((gc = purple_conversation_get_gc(conv)))
+						prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+
+					if ((prpl_info != NULL) && (prpl_info->options & OPT_PROTO_SLASH_COMMANDS_NATIVE)) {
+						char *spaceslash;
+
+						/* If the first word in the entered text has a '/' in it, then the user
+						 * probably didn't mean it as a command. So send the text as message. */
+						spaceslash = cmdline;
+						while (*spaceslash && *spaceslash != ' ' && *spaceslash != '/')
+							spaceslash++;
+
+						if (*spaceslash != '/') {
+							purple_conversation_write(conv, "", _("Unknown command."), PURPLE_MESSAGE_NO_LOG, time(NULL));
+							retval = TRUE;
+						}
+					}
+					break;
+				}
+			case PURPLE_CMD_STATUS_WRONG_ARGS:
+				purple_conversation_write(conv, "", _("Syntax Error:  You typed the wrong number of arguments "
+								    "to that command."),
+						PURPLE_MESSAGE_NO_LOG, time(NULL));
+				retval = TRUE;
+				break;
+			case PURPLE_CMD_STATUS_FAILED:
+				purple_conversation_write(conv, "", error ? error : _("Your command failed for an unknown reason."),
+						PURPLE_MESSAGE_NO_LOG, time(NULL));
+				g_free(error);
+				retval = TRUE;
+				break;
+			case PURPLE_CMD_STATUS_WRONG_TYPE:
+				if(purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+					purple_conversation_write(conv, "", _("That command only works in chats, not IMs."),
+							PURPLE_MESSAGE_NO_LOG, time(NULL));
+				else
+					purple_conversation_write(conv, "", _("That command only works in IMs, not chats."),
+							PURPLE_MESSAGE_NO_LOG, time(NULL));
+				retval = TRUE;
+				break;
+			case PURPLE_CMD_STATUS_WRONG_PRPL:
+				purple_conversation_write(conv, "", _("That command doesn't work on this protocol."),
+						PURPLE_MESSAGE_NO_LOG, time(NULL));
+				retval = TRUE;
+				break;
+		}
+	}
+
+	g_free(cmd);
+	return retval;
+}
+
+static void
+send_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleAccount *account;
+	PurpleConnection *gc;
+	PurpleMessageFlags flags = 0;
+	char *buf, *clean;
+
+	account = purple_conversation_get_account(conv);
+
+	if (check_for_and_do_command(conv)) {
+		conversation_entry_clear(gtkconv);
+		return;
+	}
+
+	if ((purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) &&
+		purple_conv_chat_has_left(PURPLE_CONV_CHAT(conv)))
+		return;
+
+	if (!purple_account_is_connected(account))
+		return;
+
+	buf = gtk_imhtml_get_markup(GTK_IMHTML(gtkconv->entry));
+	clean = gtk_imhtml_get_text(GTK_IMHTML(gtkconv->entry), NULL, NULL);
+
+	gtk_widget_grab_focus(gtkconv->entry);
+
+	if (strlen(clean) == 0) {
+		g_free(buf);
+		g_free(clean);
+		return;
+	}
+
+	purple_idle_touch();
+
+	/* XXX: is there a better way to tell if the message has images? */
+	if (GTK_IMHTML(gtkconv->entry)->im_images != NULL)
+		flags |= PURPLE_MESSAGE_IMAGES;
+
+	gc = purple_account_get_connection(account);
+	if (gc && (conv->features & PURPLE_CONNECTION_NO_NEWLINES)) {
+		char **bufs;
+		int i;
+
+		bufs = gtk_imhtml_get_markup_lines(GTK_IMHTML(gtkconv->entry));
+		for (i = 0; bufs[i]; i++) {
+			send_history_add(gtkconv, bufs[i]);
+			if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+				purple_conv_im_send_with_flags(PURPLE_CONV_IM(conv), bufs[i], flags);
+			else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+				purple_conv_chat_send_with_flags(PURPLE_CONV_CHAT(conv), bufs[i], flags);
+		}
+
+		g_strfreev(bufs);
+
+	} else {
+		send_history_add(gtkconv, buf);
+		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+			purple_conv_im_send_with_flags(PURPLE_CONV_IM(conv), buf, flags);
+		else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+			purple_conv_chat_send_with_flags(PURPLE_CONV_CHAT(conv), buf, flags);
+	}
+
+	g_free(clean);
+	g_free(buf);
+
+	conversation_entry_clear(gtkconv);
+	gtkconv_set_unseen(gtkconv, PIDGIN_UNSEEN_NONE);
+}
+
+static void
+add_remove_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	PurpleAccount *account;
+	const char *name;
+	PurpleConversation *conv = gtkconv->active_conv;
+
+	account = purple_conversation_get_account(conv);
+	name    = purple_conversation_get_name(conv);
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		PurpleBuddy *b;
+
+		b = purple_find_buddy(account, name);
+		if (b != NULL)
+			pidgin_dialogs_remove_buddy(b);
+		else if (account != NULL && purple_account_is_connected(account))
+			purple_blist_request_add_buddy(account, (char *)name, NULL, NULL);
+	} else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+		PurpleChat *c;
+
+		c = purple_blist_find_chat(account, name);
+		if (c != NULL)
+			pidgin_dialogs_remove_chat(c);
+		else if (account != NULL && purple_account_is_connected(account))
+			purple_blist_request_add_chat(account, NULL, NULL, name);
+	}
+
+	gtk_widget_grab_focus(PIDGIN_CONVERSATION(conv)->entry);
+}
+
+static void chat_do_info(PidginConversation *gtkconv, const char *who)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleConnection *gc;
+
+	if ((gc = purple_conversation_get_gc(conv))) {
+		pidgin_retrieve_user_info_in_chat(gc, who, purple_conv_chat_get_id(PURPLE_CONV_CHAT(conv)));
+	}
+}
+
+
+static void
+info_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		pidgin_retrieve_user_info(purple_conversation_get_gc(conv),
+					  purple_conversation_get_name(conv));
+		gtk_widget_grab_focus(gtkconv->entry);
+	} else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+		/* Get info of the person currently selected in the GtkTreeView */
+		PidginChatPane *gtkchat;
+		GtkTreeIter iter;
+		GtkTreeModel *model;
+		GtkTreeSelection *sel;
+		char *name;
+
+		gtkchat = gtkconv->u.chat;
+
+		model = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+		sel   = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+
+		if (gtk_tree_selection_get_selected(sel, NULL, &iter))
+			gtk_tree_model_get(GTK_TREE_MODEL(model), &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+		else
+			return;
+
+		chat_do_info(gtkconv, name);
+		g_free(name);
+	}
+}
+
+static void
+block_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleAccount *account;
+
+	account = purple_conversation_get_account(conv);
+
+	if (account != NULL && purple_account_is_connected(account))
+		pidgin_request_add_block(account, purple_conversation_get_name(conv));
+
+	gtk_widget_grab_focus(PIDGIN_CONVERSATION(conv)->entry);
+}
+
+static void
+unblock_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleAccount *account;
+
+	account = purple_conversation_get_account(conv);
+
+	if (account != NULL && purple_account_is_connected(account))
+		pidgin_request_add_permit(account, purple_conversation_get_name(conv));
+
+	gtk_widget_grab_focus(PIDGIN_CONVERSATION(conv)->entry);
+}
+
+static gboolean
+chat_invite_filter(const PidginBuddyCompletionEntry *entry, gpointer data)
+{
+	PurpleAccount *filter_account = data;
+	PurpleAccount *account = NULL;
+
+	if (entry->is_buddy) {
+		if (PURPLE_BUDDY_IS_ONLINE(entry->entry.buddy))
+			account = purple_buddy_get_account(entry->entry.buddy);
+		else
+			return FALSE;
+	} else {
+		account = entry->entry.logged_buddy->account;
+	}
+	if (account == filter_account)
+		return TRUE;
+	return FALSE;
+}
+
+static void
+do_invite(GtkWidget *w, int resp, InviteBuddyInfo *info)
+{
+	const char *buddy, *message;
+	PurpleConversation *conv;
+
+	conv = info->conv;
+
+	if (resp == GTK_RESPONSE_OK) {
+		buddy   = gtk_entry_get_text(GTK_ENTRY(info->entry));
+		message = gtk_entry_get_text(GTK_ENTRY(info->message));
+
+		if (!g_ascii_strcasecmp(buddy, ""))
+			return;
+
+		serv_chat_invite(purple_conversation_get_gc(conv),
+						 purple_conv_chat_get_id(PURPLE_CONV_CHAT(conv)),
+						 message, buddy);
+	}
+
+	gtk_widget_destroy(invite_dialog);
+	invite_dialog = NULL;
+
+	g_free(info);
+}
+
+static void
+invite_dnd_recv(GtkWidget *widget, GdkDragContext *dc, gint x, gint y,
+				GtkSelectionData *sd, guint inf, guint t, gpointer data)
+{
+	InviteBuddyInfo *info = (InviteBuddyInfo *)data;
+	const char *convprotocol;
+	gboolean success = TRUE;
+
+	convprotocol = purple_account_get_protocol_id(purple_conversation_get_account(info->conv));
+
+	if (sd->target == gdk_atom_intern("PURPLE_BLIST_NODE", FALSE))
+	{
+		PurpleBlistNode *node = NULL;
+		PurpleBuddy *buddy;
+
+		memcpy(&node, sd->data, sizeof(node));
+
+		if (PURPLE_BLIST_NODE_IS_CONTACT(node))
+			buddy = purple_contact_get_priority_buddy((PurpleContact *)node);
+		else if (PURPLE_BLIST_NODE_IS_BUDDY(node))
+			buddy = (PurpleBuddy *)node;
+		else
+			return;
+
+		if (strcmp(convprotocol, purple_account_get_protocol_id(buddy->account)))
+		{
+			purple_notify_error(PIDGIN_CONVERSATION(info->conv), NULL,
+							  _("That buddy is not on the same protocol as this "
+								"chat."), NULL);
+			success = FALSE;
+		}
+		else
+			gtk_entry_set_text(GTK_ENTRY(info->entry), purple_buddy_get_name(buddy));
+
+		gtk_drag_finish(dc, success, (dc->action == GDK_ACTION_MOVE), t);
+	}
+	else if (sd->target == gdk_atom_intern("application/x-im-contact", FALSE))
+	{
+		char *protocol = NULL;
+		char *username = NULL;
+		PurpleAccount *account;
+
+		if (pidgin_parse_x_im_contact((const char *)sd->data, FALSE, &account,
+										&protocol, &username, NULL))
+		{
+			if (account == NULL)
+			{
+				purple_notify_error(PIDGIN_CONVERSATION(info->conv), NULL,
+					_("You are not currently signed on with an account that "
+					  "can invite that buddy."), NULL);
+			}
+			else if (strcmp(convprotocol, purple_account_get_protocol_id(account)))
+			{
+				purple_notify_error(PIDGIN_CONVERSATION(info->conv), NULL,
+								  _("That buddy is not on the same protocol as this "
+									"chat."), NULL);
+				success = FALSE;
+			}
+			else
+			{
+				gtk_entry_set_text(GTK_ENTRY(info->entry), username);
+			}
+		}
+
+		g_free(username);
+		g_free(protocol);
+
+		gtk_drag_finish(dc, success, (dc->action == GDK_ACTION_MOVE), t);
+	}
+}
+
+static const GtkTargetEntry dnd_targets[] =
+{
+	{"PURPLE_BLIST_NODE", GTK_TARGET_SAME_APP, 0},
+	{"application/x-im-contact", 0, 1}
+};
+
+static void
+invite_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	InviteBuddyInfo *info = NULL;
+
+	if (invite_dialog == NULL) {
+		PidginWindow *gtkwin;
+		GtkWidget *label;
+		GtkWidget *vbox, *hbox;
+		GtkWidget *table;
+		GtkWidget *img;
+
+		img = gtk_image_new_from_stock(PIDGIN_STOCK_DIALOG_QUESTION,
+		                               gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_HUGE));
+
+		info = g_new0(InviteBuddyInfo, 1);
+		info->conv = conv;
+
+		gtkwin    = pidgin_conv_get_window(gtkconv);
+
+		/* Create the new dialog. */
+		invite_dialog = gtk_dialog_new_with_buttons(
+			_("Invite Buddy Into Chat Room"),
+			GTK_WINDOW(gtkwin->window), 0,
+			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+			PIDGIN_STOCK_INVITE, GTK_RESPONSE_OK, NULL);
+
+		gtk_dialog_set_default_response(GTK_DIALOG(invite_dialog),
+		                                GTK_RESPONSE_OK);
+		gtk_container_set_border_width(GTK_CONTAINER(invite_dialog), PIDGIN_HIG_BOX_SPACE);
+		gtk_window_set_resizable(GTK_WINDOW(invite_dialog), FALSE);
+		gtk_dialog_set_has_separator(GTK_DIALOG(invite_dialog), FALSE);
+
+		info->window = GTK_WIDGET(invite_dialog);
+
+		/* Setup the outside spacing. */
+		vbox = GTK_DIALOG(invite_dialog)->vbox;
+
+		gtk_box_set_spacing(GTK_BOX(vbox), PIDGIN_HIG_BORDER);
+		gtk_container_set_border_width(GTK_CONTAINER(vbox), PIDGIN_HIG_BOX_SPACE);
+
+		/* Setup the inner hbox and put the dialog's icon in it. */
+		hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BORDER);
+		gtk_container_add(GTK_CONTAINER(vbox), hbox);
+		gtk_box_pack_start(GTK_BOX(hbox), img, FALSE, FALSE, 0);
+		gtk_misc_set_alignment(GTK_MISC(img), 0, 0);
+
+		/* Setup the right vbox. */
+		vbox = gtk_vbox_new(FALSE, 0);
+		gtk_container_add(GTK_CONTAINER(hbox), vbox);
+
+		/* Put our happy label in it. */
+		label = gtk_label_new(_("Please enter the name of the user you wish "
+								"to invite, along with an optional invite "
+								"message."));
+		gtk_widget_set_size_request(label, 350, -1);
+		gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);
+		gtk_misc_set_alignment(GTK_MISC(label), 0, 0);
+		gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);
+
+		/* hbox for the table, and to give it some spacing on the left. */
+		hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+		gtk_container_add(GTK_CONTAINER(vbox), hbox);
+
+		/* Setup the table we're going to use to lay stuff out. */
+		table = gtk_table_new(2, 2, FALSE);
+		gtk_table_set_row_spacings(GTK_TABLE(table), PIDGIN_HIG_BOX_SPACE);
+		gtk_table_set_col_spacings(GTK_TABLE(table), PIDGIN_HIG_BOX_SPACE);
+		gtk_container_set_border_width(GTK_CONTAINER(table), PIDGIN_HIG_BORDER);
+		gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);
+
+		/* Now the Buddy label */
+		label = gtk_label_new(NULL);
+		gtk_label_set_markup_with_mnemonic(GTK_LABEL(label), _("_Buddy:"));
+		gtk_misc_set_alignment(GTK_MISC(label), 0, 0);
+		gtk_table_attach_defaults(GTK_TABLE(table), label, 0, 1, 0, 1);
+
+		/* Now the Buddy drop-down entry field. */
+		info->entry = gtk_entry_new();
+		pidgin_setup_screenname_autocomplete_with_filter(info->entry, NULL, chat_invite_filter,
+				purple_conversation_get_account(conv));
+		gtk_table_attach_defaults(GTK_TABLE(table), info->entry, 1, 2, 0, 1);
+		gtk_label_set_mnemonic_widget(GTK_LABEL(label), info->entry);
+
+		/* Now the label for "Message" */
+		label = gtk_label_new(NULL);
+		gtk_label_set_markup_with_mnemonic(GTK_LABEL(label), _("_Message:"));
+		gtk_misc_set_alignment(GTK_MISC(label), 0, 0);
+		gtk_table_attach_defaults(GTK_TABLE(table), label, 0, 1, 1, 2);
+
+
+		/* And finally, the Message entry field. */
+		info->message = gtk_entry_new();
+		gtk_entry_set_activates_default(GTK_ENTRY(info->message), TRUE);
+
+		gtk_table_attach_defaults(GTK_TABLE(table), info->message, 1, 2, 1, 2);
+		gtk_label_set_mnemonic_widget(GTK_LABEL(label), info->message);
+
+		/* Connect the signals. */
+		g_signal_connect(G_OBJECT(invite_dialog), "response",
+						 G_CALLBACK(do_invite), info);
+		/* Setup drag-and-drop */
+		gtk_drag_dest_set(info->window,
+						  GTK_DEST_DEFAULT_MOTION |
+						  GTK_DEST_DEFAULT_DROP,
+						  dnd_targets,
+						  sizeof(dnd_targets) / sizeof(GtkTargetEntry),
+						  GDK_ACTION_COPY);
+		gtk_drag_dest_set(info->entry,
+						  GTK_DEST_DEFAULT_MOTION |
+						  GTK_DEST_DEFAULT_DROP,
+						  dnd_targets,
+						  sizeof(dnd_targets) / sizeof(GtkTargetEntry),
+						  GDK_ACTION_COPY);
+
+		g_signal_connect(G_OBJECT(info->window), "drag_data_received",
+						 G_CALLBACK(invite_dnd_recv), info);
+		g_signal_connect(G_OBJECT(info->entry), "drag_data_received",
+						 G_CALLBACK(invite_dnd_recv), info);
+	}
+
+	gtk_widget_show_all(invite_dialog);
+
+	if (info != NULL)
+		gtk_widget_grab_focus(info->entry);
+}
+
+static void
+menu_new_conv_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	pidgin_dialogs_im();
+}
+
+static void
+menu_join_chat_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	pidgin_blist_joinchat_show();
+}
+
+static void
+savelog_writefile_cb(void *user_data, const char *filename)
+{
+	PurpleConversation *conv = (PurpleConversation *)user_data;
+	FILE *fp;
+	const char *name;
+	char **lines;
+	gchar *text;
+
+	if ((fp = g_fopen(filename, "w+")) == NULL) {
+		purple_notify_error(PIDGIN_CONVERSATION(conv), NULL, _("Unable to open file."), NULL);
+		return;
+	}
+
+	name = purple_conversation_get_name(conv);
+	fprintf(fp, "<html>\n<head>\n");
+	fprintf(fp, "<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n");
+	fprintf(fp, "<title>%s</title>\n</head>\n<body>\n", name);
+	fprintf(fp, _("<h1>Conversation with %s</h1>\n"), name);
+
+	lines = gtk_imhtml_get_markup_lines(
+		GTK_IMHTML(PIDGIN_CONVERSATION(conv)->imhtml));
+	text = g_strjoinv("<br>\n", lines);
+	fprintf(fp, "%s", text);
+	g_free(text);
+	g_strfreev(lines);
+
+	fprintf(fp, "\n</body>\n</html>\n");
+	fclose(fp);
+}
+
+/*
+ * It would be kinda cool if this gave the option of saving a
+ * plaintext v. HTML file.
+ */
+static void
+menu_save_as_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv = pidgin_conv_window_get_active_conversation(win);
+	PurpleBuddy *buddy = purple_find_buddy(conv->account, conv->name);
+	const char *name;
+	gchar *buf;
+	gchar *c;
+
+	if (buddy != NULL)
+		name = purple_buddy_get_contact_alias(buddy);
+	else
+		name = purple_normalize(conv->account, conv->name);
+
+	buf = g_strdup_printf("%s.html", name);
+	for (c = buf ; *c ; c++)
+	{
+		if (*c == '/' || *c == '\\')
+			*c = ' ';
+	}
+	purple_request_file(PIDGIN_CONVERSATION(conv), _("Save Conversation"),
+					  buf,
+					  TRUE, G_CALLBACK(savelog_writefile_cb), NULL,
+					  NULL, NULL, conv,
+					  conv);
+
+	g_free(buf);
+}
+
+static void
+menu_view_log_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+	PurpleLogType type;
+	PidginBuddyList *gtkblist;
+	GdkCursor *cursor;
+	const char *name;
+	PurpleAccount *account;
+	GSList *buddies;
+	GSList *cur;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+		type = PURPLE_LOG_IM;
+	else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+		type = PURPLE_LOG_CHAT;
+	else
+		return;
+
+	gtkblist = pidgin_blist_get_default_gtk_blist();
+
+	cursor = gdk_cursor_new(GDK_WATCH);
+	gdk_window_set_cursor(gtkblist->window->window, cursor);
+	gdk_window_set_cursor(win->window->window, cursor);
+	gdk_cursor_unref(cursor);
+	gdk_display_flush(gdk_drawable_get_display(GDK_DRAWABLE(widget->window)));
+
+	name = purple_conversation_get_name(conv);
+	account = purple_conversation_get_account(conv);
+
+	buddies = purple_find_buddies(account, name);
+	for (cur = buddies; cur != NULL; cur = cur->next)
+	{
+		PurpleBlistNode *node = cur->data;
+		if ((node != NULL) && ((node->prev != NULL) || (node->next != NULL)))
+		{
+			pidgin_log_show_contact((PurpleContact *)node->parent);
+			g_slist_free(buddies);
+			gdk_window_set_cursor(gtkblist->window->window, NULL);
+			gdk_window_set_cursor(win->window->window, NULL);
+			return;
+		}
+	}
+	g_slist_free(buddies);
+
+	pidgin_log_show(type, name, account);
+
+	gdk_window_set_cursor(gtkblist->window->window, NULL);
+	gdk_window_set_cursor(win->window->window, NULL);
+}
+
+static void
+menu_clear_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+	purple_conversation_clear_message_history(conv);
+}
+
+static void
+menu_find_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *gtkwin = data;
+	PidginConversation *gtkconv = pidgin_conv_window_get_active_gtkconv(gtkwin);
+	gtk_widget_show_all(gtkconv->quickfind.container);
+	gtk_widget_grab_focus(gtkconv->quickfind.entry);
+}
+
+#ifdef USE_VV
+static void
+menu_initiate_media_call_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = (PidginWindow *)data;
+	PurpleConversation *conv = pidgin_conv_window_get_active_conversation(win);
+	PurpleAccount *account = purple_conversation_get_account(conv);
+
+	purple_prpl_initiate_media(account,
+			purple_conversation_get_name(conv),
+			action == 0 ? PURPLE_MEDIA_AUDIO :
+			action == 1 ? PURPLE_MEDIA_VIDEO :
+			action == 2 ? PURPLE_MEDIA_AUDIO |
+			PURPLE_MEDIA_VIDEO : PURPLE_MEDIA_NONE);
+}
+#endif
+
+static void
+menu_send_file_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv = pidgin_conv_window_get_active_conversation(win);
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		serv_send_file(purple_conversation_get_gc(conv), purple_conversation_get_name(conv), NULL);
+	}
+
+}
+
+static void
+menu_get_attention_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv = pidgin_conv_window_get_active_conversation(win);
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		purple_prpl_send_attention(purple_conversation_get_gc(conv),
+			purple_conversation_get_name(conv), 0);
+	}
+}
+
+static void
+menu_add_pounce_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+
+	conv = pidgin_conv_window_get_active_gtkconv(win)->active_conv;
+
+	pidgin_pounce_editor_show(purple_conversation_get_account(conv),
+								purple_conversation_get_name(conv), NULL);
+}
+
+static void
+menu_insert_link_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PidginConversation *gtkconv;
+	GtkIMHtmlToolbar *toolbar;
+
+	gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+	toolbar = GTK_IMHTMLTOOLBAR(gtkconv->toolbar);
+
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toolbar->link),
+			!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->link)));
+}
+
+static void
+menu_insert_image_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PidginConversation *gtkconv;
+	GtkIMHtmlToolbar *toolbar;
+
+	gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+	toolbar = GTK_IMHTMLTOOLBAR(gtkconv->toolbar);
+
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toolbar->image),
+			!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toolbar->image)));
+}
+
+
+static void
+menu_alias_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+	PurpleAccount *account;
+	const char *name;
+
+	conv    = pidgin_conv_window_get_active_conversation(win);
+	account = purple_conversation_get_account(conv);
+	name    = purple_conversation_get_name(conv);
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		PurpleBuddy *b;
+
+		b = purple_find_buddy(account, name);
+		if (b != NULL)
+			pidgin_dialogs_alias_buddy(b);
+	} else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+		PurpleChat *c;
+
+		c = purple_blist_find_chat(account, name);
+		if (c != NULL)
+			pidgin_dialogs_alias_chat(c);
+	}
+}
+
+static void
+menu_get_info_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	info_cb(NULL, PIDGIN_CONVERSATION(conv));
+}
+
+static void
+menu_invite_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	invite_cb(NULL, PIDGIN_CONVERSATION(conv));
+}
+
+static void
+menu_block_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	block_cb(NULL, PIDGIN_CONVERSATION(conv));
+}
+
+static void
+menu_unblock_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	unblock_cb(NULL, PIDGIN_CONVERSATION(conv));
+}
+
+static void
+menu_add_remove_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	add_remove_cb(NULL, PIDGIN_CONVERSATION(conv));
+}
+
+static gboolean
+close_already(gpointer data)
+{
+	purple_conversation_destroy(data);
+	return FALSE;
+}
+
+static void
+hide_conv(PidginConversation *gtkconv, gboolean closetimer)
+{
+	GList *list;
+
+	purple_signal_emit(pidgin_conversations_get_handle(),
+			"conversation-hiding", gtkconv);
+
+	for (list = g_list_copy(gtkconv->convs); list; list = g_list_delete_link(list, list)) {
+		PurpleConversation *conv = list->data;
+		if (closetimer) {
+			guint timer = GPOINTER_TO_INT(purple_conversation_get_data(conv, "close-timer"));
+			if (timer)
+				purple_timeout_remove(timer);
+			timer = purple_timeout_add_seconds(CLOSE_CONV_TIMEOUT_SECS, close_already, conv);
+			purple_conversation_set_data(conv, "close-timer", GINT_TO_POINTER(timer));
+		}
+#if 0
+		/* I will miss you */
+		purple_conversation_set_ui_ops(conv, NULL);
+#else
+		pidgin_conv_window_remove_gtkconv(gtkconv->win, gtkconv);
+		pidgin_conv_window_add_gtkconv(hidden_convwin, gtkconv);
+#endif
+	}
+}
+
+static void
+menu_close_conv_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+
+	close_conv_cb(NULL, PIDGIN_CONVERSATION(pidgin_conv_window_get_active_conversation(win)));
+}
+
+static void
+menu_logging_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+	gboolean logging;
+	PurpleBlistNode *node;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	if (conv == NULL)
+		return;
+
+	logging = gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(widget));
+
+	if (logging == purple_conversation_is_logging(conv))
+		return;
+
+	node = get_conversation_blist_node(conv);
+
+	if (logging)
+	{
+		/* Enable logging first so the message below can be logged. */
+		purple_conversation_set_logging(conv, TRUE);
+
+		purple_conversation_write(conv, NULL,
+								_("Logging started. Future messages in this conversation will be logged."),
+								conv->logs ? (PURPLE_MESSAGE_SYSTEM) :
+								             (PURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_NO_LOG),
+								time(NULL));
+	}
+	else
+	{
+		purple_conversation_write(conv, NULL,
+								_("Logging stopped. Future messages in this conversation will not be logged."),
+								conv->logs ? (PURPLE_MESSAGE_SYSTEM) :
+								             (PURPLE_MESSAGE_SYSTEM | PURPLE_MESSAGE_NO_LOG),
+								time(NULL));
+
+		/* Disable the logging second, so that the above message can be logged. */
+		purple_conversation_set_logging(conv, FALSE);
+	}
+
+	/* Save the setting IFF it's different than the pref. */
+	switch (conv->type)
+	{
+		case PURPLE_CONV_TYPE_IM:
+			if (logging == purple_prefs_get_bool("/purple/logging/log_ims"))
+				purple_blist_node_remove_setting(node, "enable-logging");
+			else
+				purple_blist_node_set_bool(node, "enable-logging", logging);
+			break;
+
+		case PURPLE_CONV_TYPE_CHAT:
+			if (logging == purple_prefs_get_bool("/purple/logging/log_chats"))
+				purple_blist_node_remove_setting(node, "enable-logging");
+			else
+				purple_blist_node_set_bool(node, "enable-logging", logging);
+			break;
+
+		default:
+			break;
+	}
+}
+
+static void
+menu_toolbar_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	purple_prefs_set_bool(PIDGIN_PREFS_ROOT "/conversations/show_formatting_toolbar",
+	                    gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(widget)));
+}
+
+static void
+menu_sounds_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	PidginWindow *win = data;
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+	PurpleBlistNode *node;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	if (!conv)
+		return;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+
+	gtkconv->make_sound =
+		gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(widget));
+	node = get_conversation_blist_node(conv);
+	if (node)
+		purple_blist_node_set_bool(node, "gtk-mute-sound", !gtkconv->make_sound);
+}
+
+static void
+menu_timestamps_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	purple_prefs_set_bool(PIDGIN_PREFS_ROOT "/conversations/show_timestamps",
+		gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(widget)));
+}
+
+static void
+chat_do_im(PidginConversation *gtkconv, const char *who)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleAccount *account;
+	PurpleConnection *gc;
+	PurplePluginProtocolInfo *prpl_info = NULL;
+	gchar *real_who = NULL;
+
+	account = purple_conversation_get_account(conv);
+	g_return_if_fail(account != NULL);
+
+	gc = purple_account_get_connection(account);
+	g_return_if_fail(gc != NULL);
+
+	prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+
+	if (prpl_info && prpl_info->get_cb_real_name)
+		real_who = prpl_info->get_cb_real_name(gc,
+				purple_conv_chat_get_id(PURPLE_CONV_CHAT(conv)), who);
+
+	if(!who && !real_who)
+		return;
+
+	pidgin_dialogs_im_with_user(account, real_who ? real_who : who);
+
+	g_free(real_who);
+}
+
+static void pidgin_conv_chat_update_user(PurpleConversation *conv, const char *user);
+
+static void
+ignore_cb(GtkWidget *w, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleConvChat *chat;
+	const char *name;
+
+	chat = PURPLE_CONV_CHAT(conv);
+	name = g_object_get_data(G_OBJECT(w), "user_data");
+
+	if (name == NULL)
+		return;
+
+	if (purple_conv_chat_is_user_ignored(chat, name))
+		purple_conv_chat_unignore(chat, name);
+	else
+		purple_conv_chat_ignore(chat, name);
+
+	pidgin_conv_chat_update_user(conv, name);
+}
+
+static void
+menu_chat_im_cb(GtkWidget *w, PidginConversation *gtkconv)
+{
+	const char *who = g_object_get_data(G_OBJECT(w), "user_data");
+
+	chat_do_im(gtkconv, who);
+}
+
+static void
+menu_chat_send_file_cb(GtkWidget *w, PidginConversation *gtkconv)
+{
+	PurplePluginProtocolInfo *prpl_info;
+	PurpleConversation *conv = gtkconv->active_conv;
+	const char *who = g_object_get_data(G_OBJECT(w), "user_data");
+	PurpleConnection *gc  = purple_conversation_get_gc(conv);
+	gchar *real_who = NULL;
+
+	g_return_if_fail(gc != NULL);
+
+	prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+
+	if (prpl_info && prpl_info->get_cb_real_name)
+		real_who = prpl_info->get_cb_real_name(gc,
+				purple_conv_chat_get_id(PURPLE_CONV_CHAT(conv)), who);
+
+	serv_send_file(gc, real_who ? real_who : who, NULL);
+	g_free(real_who);
+}
+
+static void
+menu_chat_info_cb(GtkWidget *w, PidginConversation *gtkconv)
+{
+	char *who;
+
+	who = g_object_get_data(G_OBJECT(w), "user_data");
+
+	chat_do_info(gtkconv, who);
+}
+
+static void
+menu_chat_get_away_cb(GtkWidget *w, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurplePluginProtocolInfo *prpl_info = NULL;
+	PurpleConnection *gc;
+	char *who;
+
+	gc  = purple_conversation_get_gc(conv);
+	who = g_object_get_data(G_OBJECT(w), "user_data");
+
+	if (gc != NULL) {
+		prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+
+		/*
+		 * May want to expand this to work similarly to menu_info_cb?
+		 */
+
+		if (prpl_info->get_cb_away != NULL)
+		{
+			prpl_info->get_cb_away(gc,
+				purple_conv_chat_get_id(PURPLE_CONV_CHAT(conv)), who);
+		}
+	}
+}
+
+static void
+menu_chat_add_remove_cb(GtkWidget *w, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleAccount *account;
+	PurpleBuddy *b;
+	char *name;
+
+	account = purple_conversation_get_account(conv);
+	name    = g_object_get_data(G_OBJECT(w), "user_data");
+	b       = purple_find_buddy(account, name);
+
+	if (b != NULL)
+		pidgin_dialogs_remove_buddy(b);
+	else if (account != NULL && purple_account_is_connected(account))
+		purple_blist_request_add_buddy(account, name, NULL, NULL);
+
+	gtk_widget_grab_focus(PIDGIN_CONVERSATION(conv)->entry);
+}
+
+static GtkTextMark *
+get_mark_for_user(PidginConversation *gtkconv, const char *who)
+{
+	GtkTextBuffer *buf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->imhtml));
+	char *tmp = g_strconcat("user:", who, NULL);
+	GtkTextMark *mark = gtk_text_buffer_get_mark(buf, tmp);
+
+	g_free(tmp);
+	return mark;
+}
+
+static void
+menu_last_said_cb(GtkWidget *w, PidginConversation *gtkconv)
+{
+	GtkTextMark *mark;
+	const char *who;
+
+	who = g_object_get_data(G_OBJECT(w), "user_data");
+	mark = get_mark_for_user(gtkconv, who);
+
+	if (mark != NULL)
+		gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(gtkconv->imhtml), mark, 0.1, FALSE, 0, 0);
+	else
+		g_return_if_reached();
+}
+
+static GtkWidget *
+create_chat_menu(PurpleConversation *conv, const char *who, PurpleConnection *gc)
+{
+	static GtkWidget *menu = NULL;
+	PurplePluginProtocolInfo *prpl_info = NULL;
+	PurpleConvChat *chat = PURPLE_CONV_CHAT(conv);
+	gboolean is_me = FALSE;
+	GtkWidget *button;
+	PurpleBuddy *buddy = NULL;
+
+	if (gc != NULL)
+		prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+
+	/*
+	 * If a menu already exists, destroy it before creating a new one,
+	 * thus freeing-up the memory it occupied.
+	 */
+	if (menu)
+		gtk_widget_destroy(menu);
+
+	if (!strcmp(chat->nick, purple_normalize(conv->account, who)))
+		is_me = TRUE;
+
+	menu = gtk_menu_new();
+
+	if (!is_me) {
+		button = pidgin_new_item_from_stock(menu, _("IM"), PIDGIN_STOCK_TOOLBAR_MESSAGE_NEW,
+					G_CALLBACK(menu_chat_im_cb), PIDGIN_CONVERSATION(conv), 0, 0, NULL);
+
+		if (gc == NULL)
+			gtk_widget_set_sensitive(button, FALSE);
+		else
+			g_object_set_data_full(G_OBJECT(button), "user_data", g_strdup(who), g_free);
+
+
+		if (prpl_info && prpl_info->send_file)
+		{
+			gboolean can_receive_file = TRUE;
+
+			button = pidgin_new_item_from_stock(menu, _("Send File"),
+				PIDGIN_STOCK_TOOLBAR_SEND_FILE, G_CALLBACK(menu_chat_send_file_cb),
+				PIDGIN_CONVERSATION(conv), 0, 0, NULL);
+
+			if (gc == NULL || prpl_info == NULL)
+				can_receive_file = FALSE;
+			else {
+				gchar *real_who = NULL;
+				if (prpl_info->get_cb_real_name)
+					real_who = prpl_info->get_cb_real_name(gc,
+						purple_conv_chat_get_id(PURPLE_CONV_CHAT(conv)), who);
+				if (!(!prpl_info->can_receive_file || prpl_info->can_receive_file(gc, real_who ? real_who : who)))
+					can_receive_file = FALSE;
+				g_free(real_who);
+			}
+
+			if (!can_receive_file)
+				gtk_widget_set_sensitive(button, FALSE);
+			else
+				g_object_set_data_full(G_OBJECT(button), "user_data", g_strdup(who), g_free);
+		}
+
+
+		if (purple_conv_chat_is_user_ignored(PURPLE_CONV_CHAT(conv), who))
+			button = pidgin_new_item_from_stock(menu, _("Un-Ignore"), PIDGIN_STOCK_IGNORE,
+							G_CALLBACK(ignore_cb), PIDGIN_CONVERSATION(conv), 0, 0, NULL);
+		else
+			button = pidgin_new_item_from_stock(menu, _("Ignore"), PIDGIN_STOCK_IGNORE,
+							G_CALLBACK(ignore_cb), PIDGIN_CONVERSATION(conv), 0, 0, NULL);
+
+		if (gc == NULL)
+			gtk_widget_set_sensitive(button, FALSE);
+		else
+			g_object_set_data_full(G_OBJECT(button), "user_data", g_strdup(who), g_free);
+	}
+
+	if (prpl_info && (prpl_info->get_info || prpl_info->get_cb_info)) {
+		button = pidgin_new_item_from_stock(menu, _("Info"), PIDGIN_STOCK_TOOLBAR_USER_INFO,
+						G_CALLBACK(menu_chat_info_cb), PIDGIN_CONVERSATION(conv), 0, 0, NULL);
+
+		if (gc == NULL)
+			gtk_widget_set_sensitive(button, FALSE);
+		else
+			g_object_set_data_full(G_OBJECT(button), "user_data", g_strdup(who), g_free);
+	}
+
+	if (prpl_info && prpl_info->get_cb_away) {
+		button = pidgin_new_item_from_stock(menu, _("Get Away Message"), PIDGIN_STOCK_AWAY,
+					G_CALLBACK(menu_chat_get_away_cb), PIDGIN_CONVERSATION(conv), 0, 0, NULL);
+
+		if (gc == NULL)
+			gtk_widget_set_sensitive(button, FALSE);
+		else
+			g_object_set_data_full(G_OBJECT(button), "user_data", g_strdup(who), g_free);
+	}
+
+	if (!is_me && prpl_info && !(prpl_info->options & OPT_PROTO_UNIQUE_CHATNAME)) {
+		if ((buddy = purple_find_buddy(conv->account, who)) != NULL)
+			button = pidgin_new_item_from_stock(menu, _("Remove"), GTK_STOCK_REMOVE,
+						G_CALLBACK(menu_chat_add_remove_cb), PIDGIN_CONVERSATION(conv), 0, 0, NULL);
+		else
+			button = pidgin_new_item_from_stock(menu, _("Add"), GTK_STOCK_ADD,
+						G_CALLBACK(menu_chat_add_remove_cb), PIDGIN_CONVERSATION(conv), 0, 0, NULL);
+
+		if (gc == NULL)
+			gtk_widget_set_sensitive(button, FALSE);
+		else
+			g_object_set_data_full(G_OBJECT(button), "user_data", g_strdup(who), g_free);
+	}
+
+	button = pidgin_new_item_from_stock(menu, _("Last Said"), GTK_STOCK_INDEX,
+						G_CALLBACK(menu_last_said_cb), PIDGIN_CONVERSATION(conv), 0, 0, NULL);
+	g_object_set_data_full(G_OBJECT(button), "user_data", g_strdup(who), g_free);
+	if (!get_mark_for_user(PIDGIN_CONVERSATION(conv), who))
+		gtk_widget_set_sensitive(button, FALSE);
+
+	if (buddy != NULL)
+	{
+		if (purple_account_is_connected(conv->account))
+			pidgin_append_blist_node_proto_menu(menu, conv->account->gc,
+												  (PurpleBlistNode *)buddy);
+		pidgin_append_blist_node_extended_menu(menu, (PurpleBlistNode *)buddy);
+		gtk_widget_show_all(menu);
+	}
+
+	return menu;
+}
+
+
+static gint
+gtkconv_chat_popup_menu_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PidginChatPane *gtkchat;
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	GtkTreeSelection *sel;
+	GtkTreeIter iter;
+	GtkTreeModel *model;
+	GtkWidget *menu;
+	gchar *who;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	gtkchat = gtkconv->u.chat;
+	account = purple_conversation_get_account(conv);
+	gc      = account->gc;
+
+	model = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+
+	sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+	if(!gtk_tree_selection_get_selected(sel, NULL, &iter))
+		return FALSE;
+
+	gtk_tree_model_get(GTK_TREE_MODEL(model), &iter, CHAT_USERS_NAME_COLUMN, &who, -1);
+	menu = create_chat_menu (conv, who, gc);
+	gtk_menu_popup(GTK_MENU(menu), NULL, NULL,
+				   pidgin_treeview_popup_menu_position_func, widget,
+				   0, GDK_CURRENT_TIME);
+	g_free(who);
+
+	return TRUE;
+}
+
+
+static gint
+right_click_chat_cb(GtkWidget *widget, GdkEventButton *event,
+					PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PidginChatPane *gtkchat;
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	GtkTreePath *path;
+	GtkTreeIter iter;
+	GtkTreeModel *model;
+	GtkTreeViewColumn *column;
+	gchar *who;
+	int x, y;
+
+	gtkchat = gtkconv->u.chat;
+	account = purple_conversation_get_account(conv);
+	gc      = account->gc;
+
+	model = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+
+	gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(gtkchat->list),
+								  event->x, event->y, &path, &column, &x, &y);
+
+	if (path == NULL)
+		return FALSE;
+
+	gtk_tree_selection_select_path(GTK_TREE_SELECTION(
+			gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list))), path);
+	gtk_tree_view_set_cursor(GTK_TREE_VIEW(gtkchat->list),
+							 path, NULL, FALSE);
+	gtk_widget_grab_focus(GTK_WIDGET(gtkchat->list));
+
+	gtk_tree_model_get_iter(GTK_TREE_MODEL(model), &iter, path);
+	gtk_tree_model_get(GTK_TREE_MODEL(model), &iter, CHAT_USERS_NAME_COLUMN, &who, -1);
+
+	/* emit chat-nick-clicked signal */
+	if (event->type == GDK_BUTTON_PRESS) {
+		gint plugin_return = GPOINTER_TO_INT(purple_signal_emit_return_1(
+					pidgin_conversations_get_handle(), "chat-nick-clicked",
+					conv, who, event->button));
+		if (plugin_return)
+			goto handled;
+	}
+
+	if (event->button == 1 && event->type == GDK_2BUTTON_PRESS) {
+		chat_do_im(gtkconv, who);
+	} else if (event->button == 2 && event->type == GDK_BUTTON_PRESS) {
+		/* Move to user's anchor */
+		GtkTextMark *mark = get_mark_for_user(gtkconv, who);
+
+		if(mark != NULL)
+			gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(gtkconv->imhtml), mark, 0.1, FALSE, 0, 0);
+	} else if (event->button == 3 && event->type == GDK_BUTTON_PRESS) {
+		GtkWidget *menu = create_chat_menu (conv, who, gc);
+		gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL,
+					   event->button, event->time);
+	}
+
+handled:
+	g_free(who);
+	gtk_tree_path_free(path);
+
+	return TRUE;
+}
+
+static void
+activate_list_cb(GtkTreeView *list, GtkTreePath *path, GtkTreeViewColumn *column, PidginConversation *gtkconv)
+{
+	GtkTreeIter iter;
+	GtkTreeModel *model;
+	gchar *who;
+
+	model = gtk_tree_view_get_model(GTK_TREE_VIEW(list));
+
+	gtk_tree_model_get_iter(GTK_TREE_MODEL(model), &iter, path);
+	gtk_tree_model_get(GTK_TREE_MODEL(model), &iter, CHAT_USERS_NAME_COLUMN, &who, -1);
+	chat_do_im(gtkconv, who);
+
+	g_free(who);
+}
+
+static void
+move_to_next_unread_tab(PidginConversation *gtkconv, gboolean forward)
+{
+	PidginConversation *next_gtkconv = NULL, *most_active = NULL;
+	PidginUnseenState unseen_state = PIDGIN_UNSEEN_NONE;
+	PidginWindow *win;
+	int initial, i, total, diff;
+
+	win   = gtkconv->win;
+	initial = gtk_notebook_page_num(GTK_NOTEBOOK(win->notebook),
+	                                gtkconv->tab_cont);
+	total = pidgin_conv_window_get_gtkconv_count(win);
+	/* By adding total here, the moduli calculated later will always have two
+	 * positive arguments. x % y where x < 0 is not guaranteed to return a
+	 * positive number.
+	 */
+	diff = (forward ? 1 : -1) + total;
+
+	for (i = (initial + diff) % total; i != initial; i = (i + diff) % total) {
+		next_gtkconv = pidgin_conv_window_get_gtkconv_at_index(win, i);
+		if (next_gtkconv->unseen_state > unseen_state) {
+			most_active = next_gtkconv;
+			unseen_state = most_active->unseen_state;
+			if(PIDGIN_UNSEEN_NICK == unseen_state) /* highest possible state */
+				break;
+		}
+	}
+
+	if (most_active == NULL) { /* no new messages */
+		i = (i + diff) % total;
+		most_active = pidgin_conv_window_get_gtkconv_at_index(win, i);
+	}
+
+	if (most_active != NULL && most_active != gtkconv)
+		pidgin_conv_window_switch_gtkconv(win, most_active);
+}
+
+static gboolean
+gtkconv_cycle_focus(PidginConversation *gtkconv, GtkDirectionType dir)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	gboolean chat = purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT;
+	GtkWidget *next = NULL;
+	struct {
+		GtkWidget *from;
+		GtkWidget *to;
+	} transitions[] = {
+		{gtkconv->entry, gtkconv->imhtml},
+		{gtkconv->imhtml, chat ? gtkconv->u.chat->list : gtkconv->entry},
+		{chat ? gtkconv->u.chat->list : NULL, gtkconv->entry},
+		{NULL, NULL}
+	}, *ptr;
+
+	for (ptr = transitions; !next && ptr->from; ptr++) {
+		GtkWidget *from, *to;
+		if (dir == GTK_DIR_TAB_FORWARD) {
+			from = ptr->from;
+			to = ptr->to;
+		} else {
+			from = ptr->to;
+			to = ptr->from;
+		}
+		if (gtk_widget_is_focus(from))
+			next = to;
+	}
+
+	if (next)
+		gtk_widget_grab_focus(next);
+	return !!next;
+}
+
+static gboolean
+conv_keypress_common(PidginConversation *gtkconv, GdkEventKey *event)
+{
+	PidginWindow *win;
+	int curconv;
+
+	win      = gtkconv->win;
+	curconv = gtk_notebook_get_current_page(GTK_NOTEBOOK(win->notebook));
+
+	/* clear any tooltips */
+	pidgin_tooltip_destroy();
+
+	/* If CTRL was held down... */
+	if (event->state & GDK_CONTROL_MASK) {
+		switch (event->keyval) {
+			case GDK_Page_Down:
+ 			case GDK_KP_Page_Down:
+			case ']':
+				if (!pidgin_conv_window_get_gtkconv_at_index(win, curconv + 1))
+					gtk_notebook_set_current_page(GTK_NOTEBOOK(win->notebook), 0);
+				else
+					gtk_notebook_set_current_page(GTK_NOTEBOOK(win->notebook), curconv + 1);
+				return TRUE;
+				break;
+
+			case GDK_Page_Up:
+ 			case GDK_KP_Page_Up:
+			case '[':
+				if (!pidgin_conv_window_get_gtkconv_at_index(win, curconv - 1))
+					gtk_notebook_set_current_page(GTK_NOTEBOOK(win->notebook), -1);
+				else
+					gtk_notebook_set_current_page(GTK_NOTEBOOK(win->notebook), curconv - 1);
+				return TRUE;
+				break;
+
+			case GDK_Tab:
+			case GDK_KP_Tab:
+			case GDK_ISO_Left_Tab:
+				if (event->state & GDK_SHIFT_MASK) {
+					move_to_next_unread_tab(gtkconv, FALSE);
+				} else {
+					move_to_next_unread_tab(gtkconv, TRUE);
+				}
+
+				return TRUE;
+				break;
+
+			case GDK_comma:
+				gtk_notebook_reorder_child(GTK_NOTEBOOK(win->notebook),
+						gtk_notebook_get_nth_page(GTK_NOTEBOOK(win->notebook), curconv),
+						curconv - 1);
+				return TRUE;
+				break;
+
+			case GDK_period:
+				gtk_notebook_reorder_child(GTK_NOTEBOOK(win->notebook),
+						gtk_notebook_get_nth_page(GTK_NOTEBOOK(win->notebook), curconv),
+						(curconv + 1) % gtk_notebook_get_n_pages(GTK_NOTEBOOK(win->notebook)));
+				return TRUE;
+				break;
+			case GDK_F6:
+				if (gtkconv_cycle_focus(gtkconv, event->state & GDK_SHIFT_MASK ? GTK_DIR_TAB_BACKWARD : GTK_DIR_TAB_FORWARD))
+					return TRUE;
+				break;
+		} /* End of switch */
+	}
+
+	/* If ALT (or whatever) was held down... */
+	else if (event->state & GDK_MOD1_MASK)
+	{
+		if (event->keyval > '0' && event->keyval <= '9')
+		{
+			guint switchto = event->keyval - '1';
+			if (switchto < pidgin_conv_window_get_gtkconv_count(win))
+				gtk_notebook_set_current_page(GTK_NOTEBOOK(win->notebook), switchto);
+
+			return TRUE;
+		}
+	}
+
+	/* If neither CTRL nor ALT were held down... */
+	else
+	{
+		switch (event->keyval) {
+		case GDK_F2:
+			if (gtk_widget_is_focus(GTK_WIDGET(win->notebook))) {
+				infopane_entry_activate(gtkconv);
+				return TRUE;
+			}
+			break;
+		case GDK_F6:
+			if (gtkconv_cycle_focus(gtkconv, event->state & GDK_SHIFT_MASK ? GTK_DIR_TAB_BACKWARD : GTK_DIR_TAB_FORWARD))
+				return TRUE;
+			break;
+		}
+	}
+	return FALSE;
+}
+
+static gboolean
+entry_key_press_cb(GtkWidget *entry, GdkEventKey *event, gpointer data)
+{
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+
+	gtkconv  = (PidginConversation *)data;
+	conv     = gtkconv->active_conv;
+
+	if (conv_keypress_common(gtkconv, event))
+		return TRUE;
+
+	/* If CTRL was held down... */
+	if (event->state & GDK_CONTROL_MASK) {
+		switch (event->keyval) {
+			case GDK_Up:
+				if (!gtkconv->send_history)
+					break;
+
+				if (gtkconv->entry != entry)
+					break;
+
+				if (!gtkconv->send_history->prev) {
+					GtkTextIter start, end;
+
+					g_free(gtkconv->send_history->data);
+
+					gtk_text_buffer_get_start_iter(gtkconv->entry_buffer,
+												   &start);
+					gtk_text_buffer_get_end_iter(gtkconv->entry_buffer, &end);
+
+					gtkconv->send_history->data =
+						gtk_imhtml_get_markup(GTK_IMHTML(gtkconv->entry));
+				}
+
+				if (gtkconv->send_history->next && gtkconv->send_history->next->data) {
+					GObject *object;
+					GtkTextIter iter;
+					GtkTextBuffer *buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->entry));
+
+					gtkconv->send_history = gtkconv->send_history->next;
+
+					/* Block the signal to prevent application of default formatting. */
+					object = g_object_ref(G_OBJECT(gtkconv->entry));
+					g_signal_handlers_block_matched(object, G_SIGNAL_MATCH_DATA, 0, 0, NULL,
+													NULL, gtkconv);
+					/* Clear the formatting. */
+					gtk_imhtml_clear_formatting(GTK_IMHTML(gtkconv->entry));
+					/* Unblock the signal. */
+					g_signal_handlers_unblock_matched(object, G_SIGNAL_MATCH_DATA, 0, 0, NULL,
+													  NULL, gtkconv);
+					g_object_unref(object);
+
+					gtk_imhtml_clear(GTK_IMHTML(gtkconv->entry));
+					gtk_imhtml_append_text_with_images(
+						GTK_IMHTML(gtkconv->entry), gtkconv->send_history->data,
+						0, NULL);
+					/* this is mainly just a hack so the formatting at the
+					 * cursor gets picked up. */
+					gtk_text_buffer_get_end_iter(buffer, &iter);
+					gtk_text_buffer_move_mark_by_name(buffer, "insert", &iter);
+				}
+
+				return TRUE;
+				break;
+
+			case GDK_Down:
+				if (!gtkconv->send_history)
+					break;
+
+				if (gtkconv->entry != entry)
+					break;
+
+				if (gtkconv->send_history->prev && gtkconv->send_history->prev->data) {
+					GObject *object;
+					GtkTextIter iter;
+					GtkTextBuffer *buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->entry));
+
+					gtkconv->send_history = gtkconv->send_history->prev;
+
+					/* Block the signal to prevent application of default formatting. */
+					object = g_object_ref(G_OBJECT(gtkconv->entry));
+					g_signal_handlers_block_matched(object, G_SIGNAL_MATCH_DATA, 0, 0, NULL,
+													NULL, gtkconv);
+					/* Clear the formatting. */
+					gtk_imhtml_clear_formatting(GTK_IMHTML(gtkconv->entry));
+					/* Unblock the signal. */
+					g_signal_handlers_unblock_matched(object, G_SIGNAL_MATCH_DATA, 0, 0, NULL,
+													  NULL, gtkconv);
+					g_object_unref(object);
+
+					gtk_imhtml_clear(GTK_IMHTML(gtkconv->entry));
+					gtk_imhtml_append_text_with_images(
+						GTK_IMHTML(gtkconv->entry), gtkconv->send_history->data,
+						0, NULL);
+					/* this is mainly just a hack so the formatting at the
+					 * cursor gets picked up. */
+					if (*(char *)gtkconv->send_history->data) {
+						gtk_text_buffer_get_end_iter(buffer, &iter);
+						gtk_text_buffer_move_mark_by_name(buffer, "insert", &iter);
+					} else {
+						/* Restore the default formatting */
+						default_formatize(gtkconv);
+					}
+				}
+
+				return TRUE;
+				break;
+		} /* End of switch */
+	}
+
+	/* If ALT (or whatever) was held down... */
+	else if (event->state & GDK_MOD1_MASK) 	{
+
+	}
+
+	/* If neither CTRL nor ALT were held down... */
+	else {
+		switch (event->keyval) {
+		case GDK_Tab:
+		case GDK_KP_Tab:
+		case GDK_ISO_Left_Tab:
+			if (gtkconv->entry != entry)
+				break;
+			{
+				gint plugin_return;
+				plugin_return = GPOINTER_TO_INT(purple_signal_emit_return_1(
+							pidgin_conversations_get_handle(), "chat-nick-autocomplete",
+							conv, event->state & GDK_SHIFT_MASK));
+				return plugin_return ? TRUE : tab_complete(conv);
+			}
+			break;
+
+		case GDK_Page_Up:
+ 		case GDK_KP_Page_Up:
+			gtk_imhtml_page_up(GTK_IMHTML(gtkconv->imhtml));
+			return TRUE;
+			break;
+
+		case GDK_Page_Down:
+ 		case GDK_KP_Page_Down:
+			gtk_imhtml_page_down(GTK_IMHTML(gtkconv->imhtml));
+			return TRUE;
+			break;
+
+		}
+	}
+	return FALSE;
+}
+
+/*
+ * NOTE:
+ *   This guy just kills a single right click from being propagated any
+ *   further.  I  have no idea *why* we need this, but we do ...  It
+ *   prevents right clicks on the GtkTextView in a convo dialog from
+ *   going all the way down to the notebook.  I suspect a bug in
+ *   GtkTextView, but I'm not ready to point any fingers yet.
+ */
+static gboolean
+entry_stop_rclick_cb(GtkWidget *widget, GdkEventButton *event, gpointer data)
+{
+	if (event->button == 3 && event->type == GDK_BUTTON_PRESS) {
+		/* Right single click */
+		g_signal_stop_emission_by_name(G_OBJECT(widget), "button_press_event");
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/*
+ * If someone tries to type into the conversation backlog of a
+ * conversation window then we yank focus from the conversation backlog
+ * and give it to the text entry box so that people can type
+ * all the live long day and it will get entered into the entry box.
+ */
+static gboolean
+refocus_entry_cb(GtkWidget *widget, GdkEventKey *event, gpointer data)
+{
+	PidginConversation *gtkconv = data;
+
+	/* If we have a valid key for the conversation display, then exit */
+	if ((event->state & GDK_CONTROL_MASK) ||
+		(event->keyval == GDK_F6) ||
+		(event->keyval == GDK_F10) ||
+		(event->keyval == GDK_Shift_L) ||
+		(event->keyval == GDK_Shift_R) ||
+		(event->keyval == GDK_Control_L) ||
+		(event->keyval == GDK_Control_R) ||
+		(event->keyval == GDK_Escape) ||
+		(event->keyval == GDK_Up) ||
+		(event->keyval == GDK_Down) ||
+		(event->keyval == GDK_Left) ||
+		(event->keyval == GDK_Right) ||
+		(event->keyval == GDK_Page_Up) ||
+		(event->keyval == GDK_KP_Page_Up) ||
+		(event->keyval == GDK_Page_Down) ||
+		(event->keyval == GDK_KP_Page_Down) ||
+		(event->keyval == GDK_Home) ||
+		(event->keyval == GDK_End) ||
+		(event->keyval == GDK_Tab) ||
+		(event->keyval == GDK_KP_Tab) ||
+		(event->keyval == GDK_ISO_Left_Tab))
+	{
+		if (event->type == GDK_KEY_PRESS)
+			return conv_keypress_common(gtkconv, event);
+		return FALSE;
+	}
+
+	if (event->type == GDK_KEY_RELEASE)
+		gtk_widget_grab_focus(gtkconv->entry);
+
+	gtk_widget_event(gtkconv->entry, (GdkEvent *)event);
+
+	return TRUE;
+}
+
+static void
+regenerate_options_items(PidginWindow *win);
+
+void
+pidgin_conv_switch_active_conversation(PurpleConversation *conv)
+{
+	PidginConversation *gtkconv;
+	PurpleConversation *old_conv;
+	GtkIMHtml *entry;
+	const char *protocol_name;
+
+	g_return_if_fail(conv != NULL);
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	old_conv = gtkconv->active_conv;
+
+	purple_debug_info("gtkconv", "setting active conversation on toolbar %p\n",
+		conv);
+	gtk_imhtmltoolbar_switch_active_conversation(GTK_IMHTMLTOOLBAR(gtkconv->toolbar),
+		conv);
+
+	if (old_conv == conv)
+		return;
+
+	purple_conversation_close_logs(old_conv);
+	gtkconv->active_conv = conv;
+
+	purple_conversation_set_logging(conv,
+		gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(gtkconv->win->menu.logging)));
+
+	entry = GTK_IMHTML(gtkconv->entry);
+	protocol_name = purple_account_get_protocol_name(conv->account);
+	gtk_imhtml_set_protocol_name(entry, protocol_name);
+	gtk_imhtml_set_protocol_name(GTK_IMHTML(gtkconv->imhtml), protocol_name);
+
+	if (!(conv->features & PURPLE_CONNECTION_HTML))
+		gtk_imhtml_clear_formatting(GTK_IMHTML(gtkconv->entry));
+	else if (conv->features & PURPLE_CONNECTION_FORMATTING_WBFO &&
+	         !(old_conv->features & PURPLE_CONNECTION_FORMATTING_WBFO))
+	{
+		/* The old conversation allowed formatting on parts of the
+		 * buffer, but the new one only allows it on the whole
+		 * buffer.  This code saves the formatting from the current
+		 * position of the cursor, clears the formatting, then
+		 * applies the saved formatting to the entire buffer. */
+
+		gboolean bold;
+		gboolean italic;
+		gboolean underline;
+		char *fontface   = gtk_imhtml_get_current_fontface(entry);
+		char *forecolor  = gtk_imhtml_get_current_forecolor(entry);
+		char *backcolor  = gtk_imhtml_get_current_backcolor(entry);
+		char *background = gtk_imhtml_get_current_background(entry);
+		gint fontsize    = gtk_imhtml_get_current_fontsize(entry);
+		gboolean bold2;
+		gboolean italic2;
+		gboolean underline2;
+
+		gtk_imhtml_get_current_format(entry, &bold, &italic, &underline);
+
+		/* Clear existing formatting */
+		gtk_imhtml_clear_formatting(entry);
+
+		/* Apply saved formatting to the whole buffer. */
+
+		gtk_imhtml_get_current_format(entry, &bold2, &italic2, &underline2);
+
+		if (bold != bold2)
+			gtk_imhtml_toggle_bold(entry);
+
+		if (italic != italic2)
+			gtk_imhtml_toggle_italic(entry);
+
+		if (underline != underline2)
+			gtk_imhtml_toggle_underline(entry);
+
+		gtk_imhtml_toggle_fontface(entry, fontface);
+
+		if (!(conv->features & PURPLE_CONNECTION_NO_FONTSIZE))
+			gtk_imhtml_font_set_size(entry, fontsize);
+
+		gtk_imhtml_toggle_forecolor(entry, forecolor);
+
+		if (!(conv->features & PURPLE_CONNECTION_NO_BGCOLOR))
+		{
+			gtk_imhtml_toggle_backcolor(entry, backcolor);
+			gtk_imhtml_toggle_background(entry, background);
+		}
+
+		g_free(fontface);
+		g_free(forecolor);
+		g_free(backcolor);
+		g_free(background);
+	}
+	else
+	{
+		/* This is done in default_formatize, which is called from clear_formatting_cb,
+		 * which is (obviously) a clear_formatting signal handler.  However, if we're
+		 * here, we didn't call gtk_imhtml_clear_formatting() (because we want to
+		 * preserve the formatting exactly as it is), so we have to do this now. */
+		gtk_imhtml_set_whole_buffer_formatting_only(entry,
+			(conv->features & PURPLE_CONNECTION_FORMATTING_WBFO));
+	}
+
+	purple_signal_emit(pidgin_conversations_get_handle(), "conversation-switched", conv);
+
+	gray_stuff_out(gtkconv);
+	update_typing_icon(gtkconv);
+	g_object_set_data(G_OBJECT(entry), "transient_buddy", NULL);
+	regenerate_options_items(gtkconv->win);
+
+	gtk_window_set_title(GTK_WINDOW(gtkconv->win->window),
+	                     gtk_label_get_text(GTK_LABEL(gtkconv->tab_label)));
+}
+
+static void
+menu_conv_sel_send_cb(GObject *m, gpointer data)
+{
+	PurpleAccount *account = g_object_get_data(m, "purple_account");
+	gchar *name = g_object_get_data(m, "purple_buddy_name");
+	PurpleConversation *conv;
+
+	if (gtk_check_menu_item_get_active((GtkCheckMenuItem*) m) == FALSE)
+		return;
+
+	conv = purple_conversation_new(PURPLE_CONV_TYPE_IM, account, name);
+	pidgin_conv_switch_active_conversation(conv);
+}
+
+static void
+insert_text_cb(GtkTextBuffer *textbuffer, GtkTextIter *position,
+			   gchar *new_text, gint new_text_length, gpointer user_data)
+{
+	PidginConversation *gtkconv = (PidginConversation *)user_data;
+
+	g_return_if_fail(gtkconv != NULL);
+
+	if (!purple_prefs_get_bool("/purple/conversations/im/send_typing"))
+		return;
+
+	got_typing_keypress(gtkconv, (gtk_text_iter_is_start(position) &&
+	                    gtk_text_iter_is_end(position)));
+}
+
+static void
+delete_text_cb(GtkTextBuffer *textbuffer, GtkTextIter *start_pos,
+			   GtkTextIter *end_pos, gpointer user_data)
+{
+	PidginConversation *gtkconv = (PidginConversation *)user_data;
+	PurpleConversation *conv;
+	PurpleConvIm *im;
+
+	g_return_if_fail(gtkconv != NULL);
+
+	conv = gtkconv->active_conv;
+
+	if (!purple_prefs_get_bool("/purple/conversations/im/send_typing"))
+		return;
+
+	im = PURPLE_CONV_IM(conv);
+
+	if (gtk_text_iter_is_start(start_pos) && gtk_text_iter_is_end(end_pos)) {
+
+		/* We deleted all the text, so turn off typing. */
+		purple_conv_im_stop_send_typed_timeout(im);
+
+		serv_send_typing(purple_conversation_get_gc(conv),
+						 purple_conversation_get_name(conv),
+						 PURPLE_NOT_TYPING);
+	}
+	else {
+		/* We're deleting, but not all of it, so it counts as typing. */
+		got_typing_keypress(gtkconv, FALSE);
+	}
+}
+
+/**************************************************************************
+ * A bunch of buddy icon functions
+ **************************************************************************/
+
+static GList *get_prpl_icon_list(PurpleAccount *account)
+{
+	GList *l = NULL;
+	PurplePlugin *prpl = purple_find_prpl(purple_account_get_protocol_id(account));
+	PurplePluginProtocolInfo *prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+	const char *prplname = prpl_info->list_icon(account, NULL);
+	l = g_hash_table_lookup(prpl_lists, prplname);
+	if (l)
+		return l;
+
+	l = g_list_prepend(l, pidgin_create_prpl_icon(account, PIDGIN_PRPL_ICON_LARGE));
+	l = g_list_prepend(l, pidgin_create_prpl_icon(account, PIDGIN_PRPL_ICON_MEDIUM));
+	l = g_list_prepend(l, pidgin_create_prpl_icon(account, PIDGIN_PRPL_ICON_SMALL));
+
+	g_hash_table_insert(prpl_lists, g_strdup(prplname), l);
+	return l;
+}
+
+static GList *
+pidgin_conv_get_tab_icons(PurpleConversation *conv)
+{
+	PurpleAccount *account = NULL;
+	const char *name = NULL;
+
+	g_return_val_if_fail(conv != NULL, NULL);
+
+	account = purple_conversation_get_account(conv);
+	name = purple_conversation_get_name(conv);
+
+	g_return_val_if_fail(account != NULL, NULL);
+	g_return_val_if_fail(name != NULL, NULL);
+
+	/* Use the buddy icon, if possible */
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		PurpleBuddy *b = purple_find_buddy(account, name);
+		if (b != NULL) {
+			PurplePresence *p;
+			p = purple_buddy_get_presence(b);
+			if (purple_presence_is_status_primitive_active(p, PURPLE_STATUS_AWAY))
+				return away_list;
+			if (purple_presence_is_status_primitive_active(p, PURPLE_STATUS_UNAVAILABLE))
+				return busy_list;
+			if (purple_presence_is_status_primitive_active(p, PURPLE_STATUS_EXTENDED_AWAY))
+				return xa_list;
+			if (purple_presence_is_status_primitive_active(p, PURPLE_STATUS_OFFLINE))
+				return offline_list;
+			else
+				return available_list;
+		}
+	}
+
+	return get_prpl_icon_list(account);
+}
+
+static const char *
+pidgin_conv_get_icon_stock(PurpleConversation *conv)
+{
+	PurpleAccount *account = NULL;
+	const char *stock = NULL;
+
+	g_return_val_if_fail(conv != NULL, NULL);
+
+	account = purple_conversation_get_account(conv);
+	g_return_val_if_fail(account != NULL, NULL);
+
+	/* Use the buddy icon, if possible */
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		const char *name = NULL;
+		PurpleBuddy *b;
+		name = purple_conversation_get_name(conv);
+		b = purple_find_buddy(account, name);
+		if (b != NULL) {
+			PurplePresence *p = purple_buddy_get_presence(b);
+			PurpleStatus *active = purple_presence_get_active_status(p);
+			PurpleStatusType *type = purple_status_get_type(active);
+			PurpleStatusPrimitive prim = purple_status_type_get_primitive(type);
+			stock = pidgin_stock_id_from_status_primitive(prim);
+		} else {
+			stock = PIDGIN_STOCK_STATUS_PERSON;
+		}
+	} else {
+		stock = PIDGIN_STOCK_STATUS_CHAT;
+	}
+
+	return stock;
+}
+
+static GdkPixbuf *
+pidgin_conv_get_icon(PurpleConversation *conv, GtkWidget *parent, const char *icon_size)
+{
+	PurpleAccount *account = NULL;
+	const char *name = NULL;
+	const char *stock = NULL;
+	GdkPixbuf *status = NULL;
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	GtkIconSize size;
+
+	g_return_val_if_fail(conv != NULL, NULL);
+
+	account = purple_conversation_get_account(conv);
+	name = purple_conversation_get_name(conv);
+
+	g_return_val_if_fail(account != NULL, NULL);
+	g_return_val_if_fail(name != NULL, NULL);
+
+	/* Use the buddy icon, if possible */
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		PurpleBuddy *b = purple_find_buddy(account, name);
+		if (b != NULL) {
+			/* I hate this hack.  It fixes a bug where the pending message icon
+			 * displays in the conv tab even though it shouldn't.
+			 * A better solution would be great. */
+			if (ops && ops->update)
+				ops->update(NULL, (PurpleBlistNode*)b);
+		}
+	}
+
+	stock = pidgin_conv_get_icon_stock(conv);
+	size = gtk_icon_size_from_name(icon_size);
+	status = gtk_widget_render_icon (parent, stock, size, "GtkWidget");
+	return status;
+}
+
+GdkPixbuf *
+pidgin_conv_get_tab_icon(PurpleConversation *conv, gboolean small_icon)
+{
+	const char *icon_size = small_icon ? PIDGIN_ICON_SIZE_TANGO_MICROSCOPIC : PIDGIN_ICON_SIZE_TANGO_EXTRA_SMALL;
+	return pidgin_conv_get_icon(conv, PIDGIN_CONVERSATION(conv)->icon, icon_size);
+}
+
+
+static void
+update_tab_icon(PurpleConversation *conv)
+{
+	PidginConversation *gtkconv;
+	PidginWindow *win;
+	GList *l;
+	GdkPixbuf *emblem = NULL;
+	const char *status = NULL;
+	const char *infopane_status = NULL;
+
+	g_return_if_fail(conv != NULL);
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	win = gtkconv->win;
+	if (conv != gtkconv->active_conv)
+		return;
+
+	status = infopane_status = pidgin_conv_get_icon_stock(conv);
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		PurpleBuddy *b = purple_find_buddy(conv->account, conv->name);
+		if (b)
+			emblem = pidgin_blist_get_emblem((PurpleBlistNode*)b);
+	}
+
+	g_return_if_fail(status != NULL);
+
+	g_object_set(G_OBJECT(gtkconv->icon), "stock", status, NULL);
+	g_object_set(G_OBJECT(gtkconv->menu_icon), "stock", status, NULL);
+
+	gtk_list_store_set(GTK_LIST_STORE(gtkconv->infopane_model),
+			&(gtkconv->infopane_iter),
+			CONV_ICON_COLUMN, infopane_status, -1);
+
+	gtk_list_store_set(GTK_LIST_STORE(gtkconv->infopane_model),
+			&(gtkconv->infopane_iter),
+			CONV_EMBLEM_COLUMN, emblem, -1);
+	if (emblem)
+		g_object_unref(emblem);
+
+	if (purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/blist/show_protocol_icons")) {
+		emblem = pidgin_create_prpl_icon(gtkconv->active_conv->account, PIDGIN_PRPL_ICON_SMALL);
+	} else {
+		emblem = NULL;
+	}
+
+	gtk_list_store_set(GTK_LIST_STORE(gtkconv->infopane_model),
+			&(gtkconv->infopane_iter),
+			CONV_PROTOCOL_ICON_COLUMN, emblem, -1);
+	if (emblem)
+		g_object_unref(emblem);
+
+	/* XXX seanegan Why do I have to do this? */
+	gtk_widget_queue_resize(gtkconv->infopane);
+	gtk_widget_queue_draw(gtkconv->infopane);
+
+	if (pidgin_conv_window_is_active_conversation(conv) &&
+		(purple_conversation_get_type(conv) != PURPLE_CONV_TYPE_IM ||
+		 gtkconv->u.im->anim == NULL))
+	{
+		l = pidgin_conv_get_tab_icons(conv);
+
+		gtk_window_set_icon_list(GTK_WINDOW(win->window), l);
+	}
+}
+
+#if 0
+/* This gets added as an idle handler when doing something that
+ * redraws the icon. It sets the auto_resize gboolean to TRUE.
+ * This way, when the size_allocate callback gets triggered, it notices
+ * that this is an autoresize, and after the main loop iterates, it
+ * gets set back to FALSE
+ */
+static gboolean reset_auto_resize_cb(gpointer data)
+{
+	PidginConversation *gtkconv = (PidginConversation *)data;
+	gtkconv->auto_resize = FALSE;
+	return FALSE;
+}
+#endif
+
+static gboolean
+redraw_icon(gpointer data)
+{
+	PidginConversation *gtkconv = (PidginConversation *)data;
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleAccount *account;
+
+	GdkPixbuf *buf;
+	GdkPixbuf *scale;
+	gint delay;
+	int scale_width, scale_height;
+	int size;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	account = purple_conversation_get_account(conv);
+
+	if (!(account && account->gc)) {
+		gtkconv->u.im->icon_timer = 0;
+		return FALSE;
+	}
+
+	gdk_pixbuf_animation_iter_advance(gtkconv->u.im->iter, NULL);
+	buf = gdk_pixbuf_animation_iter_get_pixbuf(gtkconv->u.im->iter);
+
+	scale_width = gdk_pixbuf_get_width(buf);
+	scale_height = gdk_pixbuf_get_height(buf);
+
+	gtk_widget_get_size_request(gtkconv->u.im->icon_container, NULL, &size);
+	size = MIN(size, MIN(scale_width, scale_height));
+	size = CLAMP(size, BUDDYICON_SIZE_MIN, BUDDYICON_SIZE_MAX);
+
+	if (scale_width == scale_height) {
+		scale_width = scale_height = size;
+	} else if (scale_height > scale_width) {
+		scale_width = size * scale_width / scale_height;
+		scale_height = size;
+	} else {
+		scale_height = size * scale_height / scale_width;
+		scale_width = size;
+	}
+
+	scale = gdk_pixbuf_scale_simple(buf, scale_width, scale_height,
+		GDK_INTERP_BILINEAR);
+	if (pidgin_gdk_pixbuf_is_opaque(scale))
+		pidgin_gdk_pixbuf_make_round(scale);
+
+	gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->u.im->icon), scale);
+	g_object_unref(G_OBJECT(scale));
+	gtk_widget_queue_draw(gtkconv->u.im->icon);
+
+	delay = gdk_pixbuf_animation_iter_get_delay_time(gtkconv->u.im->iter);
+
+	if (delay < 100)
+		delay = 100;
+
+	gtkconv->u.im->icon_timer = g_timeout_add(delay, redraw_icon, gtkconv);
+
+	return FALSE;
+}
+
+static void
+start_anim(GtkObject *obj, PidginConversation *gtkconv)
+{
+	int delay;
+
+	if (gtkconv->u.im->anim == NULL)
+		return;
+
+	if (gtkconv->u.im->icon_timer != 0)
+		return;
+
+	if (gdk_pixbuf_animation_is_static_image(gtkconv->u.im->anim))
+		return;
+
+	delay = gdk_pixbuf_animation_iter_get_delay_time(gtkconv->u.im->iter);
+
+	if (delay < 100)
+		delay = 100;
+
+	gtkconv->u.im->icon_timer = g_timeout_add(delay, redraw_icon, gtkconv);
+}
+
+static void
+remove_icon(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	GList *children;
+	GtkWidget *event;
+	PurpleConversation *conv = gtkconv->active_conv;
+
+	g_return_if_fail(conv != NULL);
+
+	gtk_widget_set_size_request(gtkconv->u.im->icon_container, -1, BUDDYICON_SIZE_MIN);
+	children = gtk_container_get_children(GTK_CONTAINER(gtkconv->u.im->icon_container));
+	if (children) {
+		/* We know there's only one child here. It'd be nice to shortcut to the
+		   event box, but we can't change the PidginConversation until 3.0 */
+		event = (GtkWidget *)children->data;
+		gtk_container_remove(GTK_CONTAINER(gtkconv->u.im->icon_container), event);
+		g_list_free(children);
+	}
+
+	if (gtkconv->u.im->anim != NULL)
+		g_object_unref(G_OBJECT(gtkconv->u.im->anim));
+
+	if (gtkconv->u.im->icon_timer != 0)
+		g_source_remove(gtkconv->u.im->icon_timer);
+
+	if (gtkconv->u.im->iter != NULL)
+		g_object_unref(G_OBJECT(gtkconv->u.im->iter));
+
+	gtkconv->u.im->icon_timer = 0;
+	gtkconv->u.im->icon = NULL;
+	gtkconv->u.im->anim = NULL;
+	gtkconv->u.im->iter = NULL;
+	gtkconv->u.im->show_icon = FALSE;
+}
+
+static void
+saveicon_writefile_cb(void *user_data, const char *filename)
+{
+	PidginConversation *gtkconv = (PidginConversation *)user_data;
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleBuddyIcon *icon;
+	const void *data;
+	size_t len;
+
+	icon = purple_conv_im_get_icon(PURPLE_CONV_IM(conv));
+	data = purple_buddy_icon_get_data(icon, &len);
+
+	if ((len <= 0) || (data == NULL) || !purple_util_write_data_to_file_absolute(filename, data, len)) {
+		purple_notify_error(gtkconv, NULL, _("Unable to save icon file to disk."), NULL);
+	}
+}
+
+static void
+custom_icon_sel_cb(const char *filename, gpointer data)
+{
+	if (filename) {
+		const gchar *name;
+		PurpleBuddy *buddy;
+		PurpleContact *contact;
+		PidginConversation *gtkconv = data;
+		PurpleConversation *conv = gtkconv->active_conv;
+		PurpleAccount *account = purple_conversation_get_account(conv);
+
+		name = purple_conversation_get_name(conv);
+		buddy = purple_find_buddy(account, name);
+		if (!buddy) {
+			purple_debug_info("custom-icon", "You can only set custom icons for people on your buddylist.\n");
+			return;
+		}
+		contact = purple_buddy_get_contact(buddy);
+
+		purple_buddy_icons_node_set_custom_icon_from_file((PurpleBlistNode*)contact, filename);
+	}
+}
+
+static void
+set_custom_icon_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	GtkWidget *win = pidgin_buddy_icon_chooser_new(GTK_WINDOW(gtkconv->win->window),
+						custom_icon_sel_cb, gtkconv);
+	gtk_widget_show_all(win);
+}
+
+static void
+change_size_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	int size = 0;
+	PurpleConversation *conv = gtkconv->active_conv;
+	GSList *buddies;
+
+	gtk_widget_get_size_request(gtkconv->u.im->icon_container, NULL, &size);
+
+	if (size == BUDDYICON_SIZE_MAX) {
+		size = BUDDYICON_SIZE_MIN;
+	} else {
+		size = BUDDYICON_SIZE_MAX;
+	}
+
+	gtk_widget_set_size_request(gtkconv->u.im->icon_container, -1, size);
+	pidgin_conv_update_buddy_icon(conv);
+
+	buddies = purple_find_buddies(purple_conversation_get_account(conv),
+			purple_conversation_get_name(conv));
+	for (; buddies; buddies = g_slist_delete_link(buddies, buddies)) {
+		PurpleBuddy *buddy = buddies->data;
+		PurpleContact *contact = purple_buddy_get_contact(buddy);
+		purple_blist_node_set_int((PurpleBlistNode*)contact, "pidgin-infopane-iconsize", size);
+	}
+}
+
+static void
+remove_custom_icon_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	const gchar *name;
+	PurpleBuddy *buddy;
+	PurpleAccount *account;
+	PurpleContact *contact;
+	PurpleConversation *conv = gtkconv->active_conv;
+
+	account = purple_conversation_get_account(conv);
+	name = purple_conversation_get_name(conv);
+	buddy = purple_find_buddy(account, name);
+	if (!buddy) {
+		return;
+	}
+	contact = purple_buddy_get_contact(buddy);
+
+	purple_buddy_icons_node_set_custom_icon_from_file((PurpleBlistNode*)contact, NULL);
+}
+
+static void
+icon_menu_save_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	const gchar *ext;
+	gchar *buf;
+
+	g_return_if_fail(conv != NULL);
+
+	ext = purple_buddy_icon_get_extension(purple_conv_im_get_icon(PURPLE_CONV_IM(conv)));
+
+	buf = g_strdup_printf("%s.%s", purple_normalize(conv->account, conv->name), ext);
+
+	purple_request_file(gtkconv, _("Save Icon"), buf, TRUE,
+					 G_CALLBACK(saveicon_writefile_cb), NULL,
+					conv->account, NULL, conv,
+					gtkconv);
+
+	g_free(buf);
+}
+
+static void
+stop_anim(GtkObject *obj, PidginConversation *gtkconv)
+{
+	if (gtkconv->u.im->icon_timer != 0)
+		g_source_remove(gtkconv->u.im->icon_timer);
+
+	gtkconv->u.im->icon_timer = 0;
+}
+
+
+static void
+toggle_icon_animate_cb(GtkWidget *w, PidginConversation *gtkconv)
+{
+	gtkconv->u.im->animate =
+		gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(w));
+
+	if (gtkconv->u.im->animate)
+		start_anim(NULL, gtkconv);
+	else
+		stop_anim(NULL, gtkconv);
+}
+
+static gboolean
+icon_menu(GtkObject *obj, GdkEventButton *e, PidginConversation *gtkconv)
+{
+	static GtkWidget *menu = NULL;
+	PurpleConversation *conv;
+	PurpleBuddy *buddy;
+
+	if (e->button == 1 && e->type == GDK_BUTTON_PRESS) {
+		change_size_cb(NULL, gtkconv);
+		return TRUE;
+	}
+
+	if (e->button != 3 || e->type != GDK_BUTTON_PRESS) {
+		return FALSE;
+	}
+
+	/*
+	 * If a menu already exists, destroy it before creating a new one,
+	 * thus freeing-up the memory it occupied.
+	 */
+	if (menu != NULL)
+		gtk_widget_destroy(menu);
+
+	menu = gtk_menu_new();
+
+	if (gtkconv->u.im->anim &&
+		!(gdk_pixbuf_animation_is_static_image(gtkconv->u.im->anim)))
+	{
+		pidgin_new_check_item(menu, _("Animate"),
+							G_CALLBACK(toggle_icon_animate_cb), gtkconv,
+							gtkconv->u.im->icon_timer);
+	}
+
+	pidgin_new_item_from_stock(menu, _("Hide Icon"), NULL, G_CALLBACK(remove_icon),
+							 gtkconv, 0, 0, NULL);
+
+	pidgin_new_item_from_stock(menu, _("Save Icon As..."), GTK_STOCK_SAVE_AS,
+							 G_CALLBACK(icon_menu_save_cb), gtkconv,
+							 0, 0, NULL);
+
+	pidgin_new_item_from_stock(menu, _("Set Custom Icon..."), NULL,
+							 G_CALLBACK(set_custom_icon_cb), gtkconv,
+							 0, 0, NULL);
+
+	pidgin_new_item_from_stock(menu, _("Change Size"), NULL,
+							 G_CALLBACK(change_size_cb), gtkconv,
+							 0, 0, NULL);
+
+	/* Is there a custom icon for this person? */
+	conv = gtkconv->active_conv;
+	buddy = purple_find_buddy(purple_conversation_get_account(conv),
+	                          purple_conversation_get_name(conv));
+	if (buddy)
+	{
+		PurpleContact *contact = purple_buddy_get_contact(buddy);
+		if (contact && purple_buddy_icons_node_has_custom_icon((PurpleBlistNode*)contact))
+		{
+			pidgin_new_item_from_stock(menu, _("Remove Custom Icon"), NULL,
+			                           G_CALLBACK(remove_custom_icon_cb), gtkconv,
+			                           0, 0, NULL);
+		}
+	}
+
+	gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, e->button, e->time);
+
+	return TRUE;
+}
+
+/**************************************************************************
+ * End of the bunch of buddy icon functions
+ **************************************************************************/
+void
+pidgin_conv_present_conversation(PurpleConversation *conv)
+{
+	PidginConversation *gtkconv;
+	GdkModifierType state;
+
+	pidgin_conv_attach_to_conversation(conv);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+
+	pidgin_conv_switch_active_conversation(conv);
+	/* Switch the tab only if the user initiated the event by pressing
+	 * a button or hitting a key. */
+	if (gtk_get_current_event_state(&state))
+		pidgin_conv_window_switch_gtkconv(gtkconv->win, gtkconv);
+	gtk_window_present(GTK_WINDOW(gtkconv->win->window));
+}
+
+GList *
+pidgin_conversations_find_unseen_list(PurpleConversationType type,
+										PidginUnseenState min_state,
+										gboolean hidden_only,
+										guint max_count)
+{
+	GList *l;
+	GList *r = NULL;
+	guint c = 0;
+
+	if (type == PURPLE_CONV_TYPE_IM) {
+		l = purple_get_ims();
+	} else if (type == PURPLE_CONV_TYPE_CHAT) {
+		l = purple_get_chats();
+	} else {
+		l = purple_get_conversations();
+	}
+
+	for (; l != NULL && (max_count == 0 || c < max_count); l = l->next) {
+		PurpleConversation *conv = (PurpleConversation*)l->data;
+		PidginConversation *gtkconv = PIDGIN_CONVERSATION(conv);
+
+		if(gtkconv == NULL || gtkconv->active_conv != conv)
+			continue;
+
+		if (gtkconv->unseen_state >= min_state
+			&& (!hidden_only ||
+				(hidden_only && gtkconv->win == hidden_convwin))) {
+
+			r = g_list_prepend(r, conv);
+			c++;
+		}
+	}
+
+	return r;
+}
+
+static void
+unseen_conv_menu_cb(GtkMenuItem *item, PurpleConversation *conv)
+{
+	g_return_if_fail(conv != NULL);
+	pidgin_conv_present_conversation(conv);
+}
+
+static void
+unseen_all_conv_menu_cb(GtkMenuItem *item, GList *list)
+{
+	g_return_if_fail(list != NULL);
+	/* Do not free the list from here. It will be freed from the
+	 * 'destroy' callback on the menuitem. */
+	while (list) {
+		pidgin_conv_present_conversation(list->data);
+		list = list->next;
+	}
+}
+
+guint
+pidgin_conversations_fill_menu(GtkWidget *menu, GList *convs)
+{
+	GList *l;
+	guint ret=0;
+
+	g_return_val_if_fail(menu != NULL, 0);
+	g_return_val_if_fail(convs != NULL, 0);
+
+	for (l = convs; l != NULL ; l = l->next) {
+		PurpleConversation *conv = (PurpleConversation*)l->data;
+		PidginConversation *gtkconv = PIDGIN_CONVERSATION(conv);
+
+		GtkWidget *icon = gtk_image_new_from_stock(pidgin_conv_get_icon_stock(conv),
+				gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_MICROSCOPIC));
+		GtkWidget *item;
+		gchar *text = g_strdup_printf("%s (%d)",
+				gtk_label_get_text(GTK_LABEL(gtkconv->tab_label)),
+				gtkconv->unseen_count);
+
+		item = gtk_image_menu_item_new_with_label(text);
+		gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), icon);
+		g_signal_connect(G_OBJECT(item), "activate", G_CALLBACK(unseen_conv_menu_cb), conv);
+		gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+		g_free(text);
+		ret++;
+	}
+
+	if (convs->next) {
+		/* There are more than one conversation. Add an option to show all conversations. */
+		GtkWidget *item;
+		GList *list = g_list_copy(convs);
+
+		pidgin_separator(menu);
+
+		item = gtk_menu_item_new_with_label(_("Show All"));
+		g_signal_connect(G_OBJECT(item), "activate", G_CALLBACK(unseen_all_conv_menu_cb), list);
+		g_signal_connect_swapped(G_OBJECT(item), "destroy", G_CALLBACK(g_list_free), list);
+		gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+	}
+
+	return ret;
+}
+
+PidginWindow *
+pidgin_conv_get_window(PidginConversation *gtkconv)
+{
+	g_return_val_if_fail(gtkconv != NULL, NULL);
+	return gtkconv->win;
+}
+
+static GtkItemFactoryEntry menu_items[] =
+{
+	/* Conversation menu */
+	{ N_("/_Conversation"), NULL, NULL, 0, "<Branch>", NULL },
+
+	{ N_("/Conversation/New Instant _Message..."), "<CTL>M", menu_new_conv_cb,
+			0, "<StockItem>", PIDGIN_STOCK_TOOLBAR_MESSAGE_NEW },
+	{ N_("/Conversation/Join a _Chat..."), NULL, menu_join_chat_cb,
+			0, "<StockItem>", PIDGIN_STOCK_CHAT },
+
+	{ "/Conversation/sep0", NULL, NULL, 0, "<Separator>", NULL },
+
+	{ N_("/Conversation/_Find..."), NULL, menu_find_cb, 0,
+			"<StockItem>", GTK_STOCK_FIND },
+	{ N_("/Conversation/View _Log"), NULL, menu_view_log_cb, 0, "<Item>", NULL },
+	{ N_("/Conversation/_Save As..."), NULL, menu_save_as_cb, 0,
+			"<StockItem>", GTK_STOCK_SAVE_AS },
+	{ N_("/Conversation/Clea_r Scrollback"), "<CTL>L", menu_clear_cb, 0, "<StockItem>", GTK_STOCK_CLEAR },
+
+	{ "/Conversation/sep1", NULL, NULL, 0, "<Separator>", NULL },
+
+#ifdef USE_VV
+	{ N_("/Conversation/M_edia"), NULL, NULL, 0, "<Branch>", NULL },
+
+	{ N_("/Conversation/Media/_Audio Call"), NULL, menu_initiate_media_call_cb, 0,
+		"<StockItem>", PIDGIN_STOCK_TOOLBAR_AUDIO_CALL },
+	{ N_("/Conversation/Media/_Video Call"), NULL, menu_initiate_media_call_cb, 1,
+		"<StockItem>", PIDGIN_STOCK_TOOLBAR_VIDEO_CALL },
+	{ N_("/Conversation/Media/Audio\\/Video _Call"), NULL, menu_initiate_media_call_cb, 2,
+		"<StockItem>", PIDGIN_STOCK_TOOLBAR_VIDEO_CALL },
+#endif
+
+	{ N_("/Conversation/Se_nd File..."), NULL, menu_send_file_cb, 0, "<StockItem>", PIDGIN_STOCK_TOOLBAR_SEND_FILE },
+	{ N_("/Conversation/Get _Attention"), NULL, menu_get_attention_cb, 0, "<StockItem>", PIDGIN_STOCK_TOOLBAR_SEND_ATTENTION },
+	{ N_("/Conversation/Add Buddy _Pounce..."), NULL, menu_add_pounce_cb,
+			0, "<Item>", NULL },
+	{ N_("/Conversation/_Get Info"), "<CTL>O", menu_get_info_cb, 0,
+			"<StockItem>", PIDGIN_STOCK_TOOLBAR_USER_INFO },
+	{ N_("/Conversation/In_vite..."), NULL, menu_invite_cb, 0,
+			"<Item>", NULL },
+	{ N_("/Conversation/M_ore"), NULL, NULL, 0, "<Branch>", NULL },
+
+	{ "/Conversation/sep2", NULL, NULL, 0, "<Separator>", NULL },
+
+	{ N_("/Conversation/Al_ias..."), NULL, menu_alias_cb, 0,
+			"<Item>", NULL },
+	{ N_("/Conversation/_Block..."), NULL, menu_block_cb, 0,
+			"<StockItem>", PIDGIN_STOCK_TOOLBAR_BLOCK },
+	{ N_("/Conversation/_Unblock..."), NULL, menu_unblock_cb, 0,
+			"<StockItem>", PIDGIN_STOCK_TOOLBAR_UNBLOCK },
+	{ N_("/Conversation/_Add..."), NULL, menu_add_remove_cb, 0,
+			"<StockItem>", GTK_STOCK_ADD },
+	{ N_("/Conversation/_Remove..."), NULL, menu_add_remove_cb, 0,
+			"<StockItem>", GTK_STOCK_REMOVE },
+
+	{ "/Conversation/sep3", NULL, NULL, 0, "<Separator>", NULL },
+
+	{ N_("/Conversation/Insert Lin_k..."), NULL, menu_insert_link_cb, 0,
+		"<StockItem>", PIDGIN_STOCK_TOOLBAR_INSERT_LINK },
+	{ N_("/Conversation/Insert Imag_e..."), NULL, menu_insert_image_cb, 0,
+		"<StockItem>", PIDGIN_STOCK_TOOLBAR_INSERT_IMAGE },
+
+	{ "/Conversation/sep4", NULL, NULL, 0, "<Separator>", NULL },
+
+
+	{ N_("/Conversation/_Close"), NULL, menu_close_conv_cb, 0,
+			"<StockItem>", GTK_STOCK_CLOSE },
+
+	/* Options */
+	{ N_("/_Options"), NULL, NULL, 0, "<Branch>", NULL },
+	{ N_("/Options/Enable _Logging"), NULL, menu_logging_cb, 0, "<CheckItem>", NULL },
+	{ N_("/Options/Enable _Sounds"), NULL, menu_sounds_cb, 0, "<CheckItem>", NULL },
+	{ "/Options/sep0", NULL, NULL, 0, "<Separator>", NULL },
+	{ N_("/Options/Show Formatting _Toolbars"), NULL, menu_toolbar_cb, 0, "<CheckItem>", NULL },
+	{ N_("/Options/Show Ti_mestamps"), NULL, menu_timestamps_cb, 0, "<CheckItem>", NULL },
+};
+
+static const int menu_item_count =
+sizeof(menu_items) / sizeof(*menu_items);
+
+static const char *
+item_factory_translate_func (const char *path, gpointer func_data)
+{
+	return _(path);
+}
+
+static void
+sound_method_pref_changed_cb(const char *name, PurplePrefType type,
+							 gconstpointer value, gpointer data)
+{
+	PidginWindow *win = data;
+	const char *method = value;
+
+	if (!strcmp(method, "none"))
+	{
+		gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(win->menu.sounds),
+		                               FALSE);
+		gtk_widget_set_sensitive(win->menu.sounds, FALSE);
+	}
+	else
+	{
+		PidginConversation *gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+
+		if (gtkconv != NULL)
+			gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(win->menu.sounds),
+			                               gtkconv->make_sound);
+		gtk_widget_set_sensitive(win->menu.sounds, TRUE);
+
+	}
+}
+
+/* Returns TRUE if some items were added to the menu, FALSE otherwise */
+static gboolean
+populate_menu_with_options(GtkWidget *menu, PidginConversation *gtkconv, gboolean all)
+{
+	GList *list;
+	PurpleConversation *conv;
+	PurpleBlistNode *node = NULL;
+	PurpleChat *chat = NULL;
+	PurpleBuddy *buddy = NULL;
+	gboolean ret;
+
+	conv = gtkconv->active_conv;
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+		chat = purple_blist_find_chat(conv->account, conv->name);
+
+		if ((chat == NULL) && (gtkconv->imhtml != NULL)) {
+			chat = g_object_get_data(G_OBJECT(gtkconv->imhtml), "transient_chat");
+		}
+
+		if ((chat == NULL) && (gtkconv->imhtml != NULL)) {
+			GHashTable *components;
+			PurpleAccount *account = purple_conversation_get_account(conv);
+			PurplePlugin *prpl = purple_find_prpl(purple_account_get_protocol_id(account));
+			PurplePluginProtocolInfo *prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+			if (purple_account_get_connection(account) != NULL &&
+					PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, chat_info_defaults)) {
+				components = prpl_info->chat_info_defaults(purple_account_get_connection(account),
+						purple_conversation_get_name(conv));
+			} else {
+				components = g_hash_table_new_full(g_str_hash, g_str_equal,
+						g_free, g_free);
+				g_hash_table_replace(components, g_strdup("channel"),
+						g_strdup(purple_conversation_get_name(conv)));
+			}
+			chat = purple_chat_new(conv->account, NULL, components);
+			purple_blist_node_set_flags((PurpleBlistNode *)chat,
+					PURPLE_BLIST_NODE_FLAG_NO_SAVE);
+			g_object_set_data_full(G_OBJECT(gtkconv->imhtml), "transient_chat",
+					chat, (GDestroyNotify)purple_blist_remove_chat);
+		}
+	} else {
+		if (!purple_account_is_connected(conv->account))
+			return FALSE;
+
+		buddy = purple_find_buddy(conv->account, conv->name);
+
+		/* gotta remain bug-compatible :( libpurple < 2.0.2 didn't handle
+		 * removing "isolated" buddy nodes well */
+		if (purple_version_check(2, 0, 2) == NULL) {
+			if ((buddy == NULL) && (gtkconv->imhtml != NULL)) {
+				buddy = g_object_get_data(G_OBJECT(gtkconv->imhtml), "transient_buddy");
+			}
+
+			if ((buddy == NULL) && (gtkconv->imhtml != NULL)) {
+				buddy = purple_buddy_new(conv->account, conv->name, NULL);
+				purple_blist_node_set_flags((PurpleBlistNode *)buddy,
+						PURPLE_BLIST_NODE_FLAG_NO_SAVE);
+				g_object_set_data_full(G_OBJECT(gtkconv->imhtml), "transient_buddy",
+						buddy, (GDestroyNotify)purple_buddy_destroy);
+			}
+		}
+	}
+
+	if (chat)
+		node = (PurpleBlistNode *)chat;
+	else if (buddy)
+		node = (PurpleBlistNode *)buddy;
+
+	/* Now add the stuff */
+	if (all) {
+		if (buddy)
+			pidgin_blist_make_buddy_menu(menu, buddy, TRUE);
+		else if (chat) {
+			/* XXX: */
+		}
+	} else if (node) {
+		if (purple_account_is_connected(conv->account))
+			pidgin_append_blist_node_proto_menu(menu, conv->account->gc, node);
+		pidgin_append_blist_node_extended_menu(menu, node);
+	}
+
+	if ((list = gtk_container_get_children(GTK_CONTAINER(menu))) == NULL) {
+		ret = FALSE;
+	} else {
+		g_list_free(list);
+		ret = TRUE;
+	}
+	return ret;
+}
+
+static void
+regenerate_media_items(PidginWindow *win)
+{
+#ifdef USE_VV
+	PurpleAccount *account;
+	PurpleConversation *conv;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	if (conv == NULL) {
+		purple_debug_error("gtkconv", "couldn't get active conversation"
+				" when regenerating media items\n");
+		return;
+	}
+
+	account = purple_conversation_get_account(conv);
+
+	if (account == NULL) {
+		purple_debug_error("gtkconv", "couldn't get account when"
+				" regenerating media items\n");
+		return;
+	}
+
+	/*
+	 * Check if account support voice and/or calls, and
+	 * if the current buddy	supports it.
+	 */
+	if (account != NULL && purple_conversation_get_type(conv)
+			== PURPLE_CONV_TYPE_IM) {
+		PurpleMediaCaps caps =
+				purple_prpl_get_media_caps(account,
+				purple_conversation_get_name(conv));
+
+		gtk_widget_set_sensitive(win->audio_call,
+				caps & PURPLE_MEDIA_CAPS_AUDIO
+				? TRUE : FALSE);
+		gtk_widget_set_sensitive(win->video_call,
+				caps & PURPLE_MEDIA_CAPS_VIDEO
+				? TRUE : FALSE);
+		gtk_widget_set_sensitive(win->audio_video_call,
+				caps & PURPLE_MEDIA_CAPS_AUDIO_VIDEO
+				? TRUE : FALSE);
+	} else if (purple_conversation_get_type(conv)
+			== PURPLE_CONV_TYPE_CHAT) {
+		/* for now, don't care about chats... */
+		gtk_widget_set_sensitive(win->audio_call, FALSE);
+		gtk_widget_set_sensitive(win->video_call, FALSE);
+		gtk_widget_set_sensitive(win->audio_video_call, FALSE);
+	} else {
+		gtk_widget_set_sensitive(win->audio_call, FALSE);
+		gtk_widget_set_sensitive(win->video_call, FALSE);
+		gtk_widget_set_sensitive(win->audio_video_call, FALSE);
+	}
+#endif
+}
+
+static void
+regenerate_options_items(PidginWindow *win)
+{
+	GtkWidget *menu;
+	PidginConversation *gtkconv;
+	GList *list;
+
+	gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+	menu = gtk_item_factory_get_widget(win->menu.item_factory, N_("/Conversation/More"));
+
+	/* Remove the previous entries */
+	for (list = gtk_container_get_children(GTK_CONTAINER(menu)); list; )
+	{
+		GtkWidget *w = list->data;
+		list = g_list_delete_link(list, list);
+		gtk_widget_destroy(w);
+	}
+
+	if (!populate_menu_with_options(menu, gtkconv, FALSE))
+	{
+		GtkWidget *item = gtk_menu_item_new_with_label(_("No actions available"));
+		gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+		gtk_widget_set_sensitive(item, FALSE);
+	}
+
+	gtk_widget_show_all(menu);
+}
+
+static void
+remove_from_list(GtkWidget *widget, PidginWindow *win)
+{
+	GList *list = g_object_get_data(G_OBJECT(win->window), "plugin-actions");
+	list = g_list_remove(list, widget);
+	g_object_set_data(G_OBJECT(win->window), "plugin-actions", list);
+}
+
+static void
+regenerate_plugins_items(PidginWindow *win)
+{
+	GList *action_items;
+	GtkWidget *menu;
+	GList *list;
+	PidginConversation *gtkconv;
+	PurpleConversation *conv;
+	GtkWidget *item;
+
+	if (win->window == NULL || win == hidden_convwin)
+		return;
+
+	gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+	if (gtkconv == NULL)
+		return;
+
+	conv = gtkconv->active_conv;
+	action_items = g_object_get_data(G_OBJECT(win->window), "plugin-actions");
+
+	/* Remove the old menuitems */
+	while (action_items) {
+		g_signal_handlers_disconnect_by_func(G_OBJECT(action_items->data),
+					G_CALLBACK(remove_from_list), win);
+		gtk_widget_destroy(action_items->data);
+		action_items = g_list_delete_link(action_items, action_items);
+	}
+
+	menu = gtk_item_factory_get_widget(win->menu.item_factory, N_("/Options"));
+
+	list = purple_conversation_get_extended_menu(conv);
+	if (list) {
+		action_items = g_list_prepend(NULL, (item = pidgin_separator(menu)));
+		g_signal_connect(G_OBJECT(item), "destroy", G_CALLBACK(remove_from_list), win);
+	}
+
+	for(; list; list = g_list_delete_link(list, list)) {
+		PurpleMenuAction *act = (PurpleMenuAction *) list->data;
+		item = pidgin_append_menu_action(menu, act, conv);
+		action_items = g_list_prepend(action_items, item);
+		gtk_widget_show_all(item);
+		g_signal_connect(G_OBJECT(item), "destroy", G_CALLBACK(remove_from_list), win);
+	}
+	g_object_set_data(G_OBJECT(win->window), "plugin-actions", action_items);
+}
+
+static void menubar_activated(GtkWidget *item, gpointer data)
+{
+	PidginWindow *win = data;
+	regenerate_media_items(win);
+	regenerate_options_items(win);
+	regenerate_plugins_items(win);
+
+	/* The following are to make sure the 'More' submenu is not regenerated every time
+	 * the focus shifts from 'Conversations' to some other menu and back. */
+	g_signal_handlers_block_by_func(G_OBJECT(item), G_CALLBACK(menubar_activated), data);
+	g_signal_connect(G_OBJECT(win->menu.menubar), "deactivate", G_CALLBACK(focus_out_from_menubar), data);
+}
+
+static void
+focus_out_from_menubar(GtkWidget *wid, PidginWindow *win)
+{
+	/* The menubar has been deactivated. Make sure the 'More' submenu is regenerated next time
+	 * the 'Conversation' menu pops up. */
+	GtkWidget *menuitem = gtk_item_factory_get_item(win->menu.item_factory, N_("/Conversation"));
+	g_signal_handlers_unblock_by_func(G_OBJECT(menuitem), G_CALLBACK(menubar_activated), win);
+	g_signal_handlers_disconnect_by_func(G_OBJECT(win->menu.menubar),
+				G_CALLBACK(focus_out_from_menubar), win);
+}
+
+static GtkWidget *
+setup_menubar(PidginWindow *win)
+{
+	GtkAccelGroup *accel_group;
+	const char *method;
+	GtkWidget *menuitem;
+
+	accel_group = gtk_accel_group_new ();
+	gtk_window_add_accel_group(GTK_WINDOW(win->window), accel_group);
+	g_object_unref(accel_group);
+
+	win->menu.item_factory =
+		gtk_item_factory_new(GTK_TYPE_MENU_BAR, "<main>", accel_group);
+
+	gtk_item_factory_set_translate_func(win->menu.item_factory,
+	                                    (GtkTranslateFunc)item_factory_translate_func,
+	                                    NULL, NULL);
+
+	gtk_item_factory_create_items(win->menu.item_factory, menu_item_count,
+	                              menu_items, win);
+	g_signal_connect(G_OBJECT(accel_group), "accel-changed",
+	                 G_CALLBACK(pidgin_save_accels_cb), NULL);
+
+	/* Make sure the 'Conversation -> More' menuitems are regenerated whenever
+	 * the 'Conversation' menu pops up because the entries can change after the
+	 * conversation is created. */
+	menuitem = gtk_item_factory_get_item(win->menu.item_factory, N_("/Conversation"));
+	g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(menubar_activated), win);
+
+	win->menu.menubar =
+		gtk_item_factory_get_widget(win->menu.item_factory, "<main>");
+
+	win->menu.view_log =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Conversation/View Log"));
+
+#ifdef USE_VV
+	win->audio_call =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+					    N_("/Conversation/Media/Audio Call"));
+	win->video_call =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+					    N_("/Conversation/Media/Video Call"));
+	win->audio_video_call =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+					    N_("/Conversation/Media/Audio\\/Video Call"));
+#endif
+
+	/* --- */
+
+	win->menu.send_file =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Conversation/Send File..."));
+
+	g_object_set_data(G_OBJECT(win->window), "get_attention",
+		gtk_item_factory_get_widget(win->menu.item_factory,
+			                    N_("/Conversation/Get Attention")));
+	win->menu.add_pounce =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Conversation/Add Buddy Pounce..."));
+
+	/* --- */
+
+	win->menu.get_info =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Conversation/Get Info"));
+
+	win->menu.invite =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Conversation/Invite..."));
+
+	/* --- */
+
+	win->menu.alias =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Conversation/Alias..."));
+
+	win->menu.block =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Conversation/Block..."));
+
+	win->menu.unblock =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+					    N_("/Conversation/Unblock..."));
+
+	win->menu.add =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Conversation/Add..."));
+
+	win->menu.remove =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Conversation/Remove..."));
+
+	/* --- */
+
+	win->menu.insert_link =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+				N_("/Conversation/Insert Link..."));
+
+	win->menu.insert_image =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+				N_("/Conversation/Insert Image..."));
+
+	/* --- */
+
+	win->menu.logging =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Options/Enable Logging"));
+	win->menu.sounds =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Options/Enable Sounds"));
+	method = purple_prefs_get_string(PIDGIN_PREFS_ROOT "/sound/method");
+	if (method != NULL && !strcmp(method, "none"))
+	{
+		gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(win->menu.sounds),
+		                               FALSE);
+		gtk_widget_set_sensitive(win->menu.sounds, FALSE);
+	}
+	purple_prefs_connect_callback(win, PIDGIN_PREFS_ROOT "/sound/method",
+				    sound_method_pref_changed_cb, win);
+
+	win->menu.show_formatting_toolbar =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Options/Show Formatting Toolbars"));
+	win->menu.show_timestamps =
+		gtk_item_factory_get_widget(win->menu.item_factory,
+		                            N_("/Options/Show Timestamps"));
+	win->menu.show_icon = NULL;
+
+	win->menu.tray = pidgin_menu_tray_new();
+	gtk_menu_shell_append(GTK_MENU_SHELL(win->menu.menubar),
+	                      win->menu.tray);
+	gtk_widget_show(win->menu.tray);
+
+	gtk_widget_show(win->menu.menubar);
+
+	return win->menu.menubar;
+}
+
+
+/**************************************************************************
+ * Utility functions
+ **************************************************************************/
+
+static void
+got_typing_keypress(PidginConversation *gtkconv, gboolean first)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleConvIm *im;
+
+	/*
+	 * We know we got something, so we at least have to make sure we don't
+	 * send PURPLE_TYPED any time soon.
+	 */
+
+	im = PURPLE_CONV_IM(conv);
+
+	purple_conv_im_stop_send_typed_timeout(im);
+	purple_conv_im_start_send_typed_timeout(im);
+
+	/* Check if we need to send another PURPLE_TYPING message */
+	if (first || (purple_conv_im_get_type_again(im) != 0 &&
+				  time(NULL) > purple_conv_im_get_type_again(im)))
+	{
+		unsigned int timeout;
+		timeout = serv_send_typing(purple_conversation_get_gc(conv),
+								   purple_conversation_get_name(conv),
+								   PURPLE_TYPING);
+		purple_conv_im_set_type_again(im, timeout);
+	}
+}
+
+#if 0
+static gboolean
+typing_animation(gpointer data) {
+	PidginConversation *gtkconv = data;
+	PidginWindow *gtkwin = gtkconv->win;
+	const char *stock_id = NULL;
+
+	if(gtkconv != pidgin_conv_window_get_active_gtkconv(gtkwin)) {
+		return FALSE;
+	}
+
+	switch (rand() % 5) {
+	case 0:
+		stock_id = PIDGIN_STOCK_ANIMATION_TYPING0;
+		break;
+	case 1:
+		stock_id = PIDGIN_STOCK_ANIMATION_TYPING1;
+		break;
+	case 2:
+		stock_id = PIDGIN_STOCK_ANIMATION_TYPING2;
+		break;
+	case 3:
+		stock_id = PIDGIN_STOCK_ANIMATION_TYPING3;
+		break;
+	case 4:
+		stock_id = PIDGIN_STOCK_ANIMATION_TYPING4;
+		break;
+	}
+	if (gtkwin->menu.typing_icon == NULL) {
+		 gtkwin->menu.typing_icon = gtk_image_new_from_stock(stock_id, GTK_ICON_SIZE_MENU);
+		 pidgin_menu_tray_append(PIDGIN_MENU_TRAY(gtkwin->menu.tray),
+                                                                  gtkwin->menu.typing_icon,
+                                                                  _("User is typing..."));
+	} else {
+		gtk_image_set_from_stock(GTK_IMAGE(gtkwin->menu.typing_icon), stock_id, GTK_ICON_SIZE_MENU);
+	}
+	gtk_widget_show(gtkwin->menu.typing_icon);
+	return TRUE;
+}
+#endif
+
+static void
+update_typing_message(PidginConversation *gtkconv, const char *message)
+{
+	GtkTextBuffer *buffer;
+	GtkTextMark *stmark, *enmark;
+
+	if (g_object_get_data(G_OBJECT(gtkconv->imhtml), "disable-typing-notification"))
+		return;
+
+	buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->imhtml));
+	stmark = gtk_text_buffer_get_mark(buffer, "typing-notification-start");
+	enmark = gtk_text_buffer_get_mark(buffer, "typing-notification-end");
+	if (stmark && enmark) {
+		GtkTextIter start, end;
+		gtk_text_buffer_get_iter_at_mark(buffer, &start, stmark);
+		gtk_text_buffer_get_iter_at_mark(buffer, &end, enmark);
+		gtk_text_buffer_delete_mark(buffer, stmark);
+		gtk_text_buffer_delete_mark(buffer, enmark);
+		gtk_text_buffer_delete(buffer, &start, &end);
+	} else if (message && *message == '\n' && message[1] == ' ' && message[2] == '\0')
+		message = NULL;
+
+#ifdef RESERVE_LINE
+	if (!message)
+		message = "\n ";   /* The blank space is required to avoid a GTK+/Pango bug */
+#endif
+
+	if (message) {
+		GtkTextIter iter;
+		gtk_text_buffer_get_end_iter(buffer, &iter);
+		gtk_text_buffer_create_mark(buffer, "typing-notification-start", &iter, TRUE);
+		gtk_text_buffer_insert_with_tags_by_name(buffer, &iter, message, -1, "TYPING-NOTIFICATION", NULL);
+		gtk_text_buffer_get_end_iter(buffer, &iter);
+		gtk_text_buffer_create_mark(buffer, "typing-notification-end", &iter, TRUE);
+	}
+}
+
+static void
+update_typing_icon(PidginConversation *gtkconv)
+{
+	PurpleConvIm *im = NULL;
+	PurpleConversation *conv = gtkconv->active_conv;
+	char *message = NULL;
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+		im = PURPLE_CONV_IM(conv);
+
+	if (im == NULL)
+		return;
+
+	if (purple_conv_im_get_typing_state(im) == PURPLE_NOT_TYPING) {
+#ifdef RESERVE_LINE
+		update_typing_message(gtkconv, NULL);
+#else
+		update_typing_message(gtkconv, "\n ");
+#endif
+		return;
+	}
+
+	if (purple_conv_im_get_typing_state(im) == PURPLE_TYPING) {
+		message = g_strdup_printf(_("\n%s is typing..."), purple_conversation_get_title(conv));
+	} else {
+		message = g_strdup_printf(_("\n%s has stopped typing"), purple_conversation_get_title(conv));
+	}
+
+	update_typing_message(gtkconv, message);
+	g_free(message);
+}
+
+static gboolean
+update_send_to_selection(PidginWindow *win)
+{
+	PurpleAccount *account;
+	PurpleConversation *conv;
+	GtkWidget *menu;
+	GList *child;
+	PurpleBuddy *b;
+
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	if (conv == NULL)
+		return FALSE;
+
+	account = purple_conversation_get_account(conv);
+
+	if (account == NULL)
+		return FALSE;
+
+	if (win->menu.send_to == NULL)
+		return FALSE;
+
+	if (!(b = purple_find_buddy(account, conv->name)))
+		return FALSE;
+
+
+	gtk_widget_show(win->menu.send_to);
+
+	menu = gtk_menu_item_get_submenu(GTK_MENU_ITEM(win->menu.send_to));
+
+	for (child = gtk_container_get_children(GTK_CONTAINER(menu));
+		 child != NULL;
+		 child = g_list_delete_link(child, child)) {
+
+		GtkWidget *item = child->data;
+		PurpleBuddy *item_buddy;
+		PurpleAccount *item_account = g_object_get_data(G_OBJECT(item), "purple_account");
+		gchar *buddy_name = g_object_get_data(G_OBJECT(item),
+		                                      "purple_buddy_name");
+		item_buddy = purple_find_buddy(item_account, buddy_name);
+
+		if (b == item_buddy) {
+			gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(item), TRUE);
+			g_list_free(child);
+			break;
+		}
+	}
+
+	return FALSE;
+}
+
+static gboolean
+send_to_item_enter_notify_cb(GtkWidget *menuitem, GdkEventCrossing *event, GtkWidget *label)
+{
+	gtk_widget_set_sensitive(GTK_WIDGET(label), TRUE);
+	return FALSE;
+}
+
+static gboolean
+send_to_item_leave_notify_cb(GtkWidget *menuitem, GdkEventCrossing *event, GtkWidget *label)
+{
+	gtk_widget_set_sensitive(GTK_WIDGET(label), FALSE);
+	return FALSE;
+}
+
+static void
+create_sendto_item(GtkWidget *menu, GtkSizeGroup *sg, GSList **group, PurpleBuddy *buddy, PurpleAccount *account, const char *name)
+{
+	GtkWidget *box;
+	GtkWidget *label;
+	GtkWidget *image;
+	GtkWidget *menuitem;
+	GdkPixbuf *pixbuf;
+	gchar *text;
+
+	/* Create a pixmap for the protocol icon. */
+	pixbuf = pidgin_create_prpl_icon(account, PIDGIN_PRPL_ICON_SMALL);
+
+	/* Now convert it to GtkImage */
+	if (pixbuf == NULL)
+		image = gtk_image_new();
+	else
+	{
+		image = gtk_image_new_from_pixbuf(pixbuf);
+		g_object_unref(G_OBJECT(pixbuf));
+	}
+
+	gtk_size_group_add_widget(sg, image);
+
+	/* Make our menu item */
+	text = g_strdup_printf("%s (%s)", name, purple_account_get_name_for_display(account));
+	menuitem = gtk_radio_menu_item_new_with_label(*group, text);
+	g_free(text);
+	*group = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(menuitem));
+
+	/* Do some evil, see some evil, speak some evil. */
+	box = gtk_hbox_new(FALSE, 0);
+
+	label = gtk_bin_get_child(GTK_BIN(menuitem));
+	g_object_ref(label);
+	gtk_container_remove(GTK_CONTAINER(menuitem), label);
+
+	gtk_box_pack_start(GTK_BOX(box), image, FALSE, FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(box), label, TRUE, TRUE, 4);
+
+	if (buddy != NULL &&
+	    !purple_presence_is_online(purple_buddy_get_presence(buddy)))
+	{
+		gtk_widget_set_sensitive(label, FALSE);
+
+		/* Set the label sensitive when the menuitem is highlighted and
+		 * insensitive again when the mouse leaves it. This way, it
+		 * doesn't appear weird from the highlighting of the embossed
+		 * (insensitive style) text.*/
+		g_signal_connect(menuitem, "enter-notify-event",
+				 G_CALLBACK(send_to_item_enter_notify_cb), label);
+		g_signal_connect(menuitem, "leave-notify-event",
+				 G_CALLBACK(send_to_item_leave_notify_cb), label);
+	}
+
+	g_object_unref(label);
+
+	gtk_container_add(GTK_CONTAINER(menuitem), box);
+
+	gtk_widget_show(label);
+	gtk_widget_show(image);
+	gtk_widget_show(box);
+
+	/* Set our data and callbacks. */
+	g_object_set_data(G_OBJECT(menuitem), "purple_account", account);
+	g_object_set_data_full(G_OBJECT(menuitem), "purple_buddy_name", g_strdup(name), g_free);
+
+	g_signal_connect(G_OBJECT(menuitem), "activate",
+	                 G_CALLBACK(menu_conv_sel_send_cb), NULL);
+
+	gtk_widget_show(menuitem);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
+}
+
+static gboolean
+compare_buddy_presence(PurplePresence *p1, PurplePresence *p2)
+{
+	/* This is necessary because multiple PurpleBuddy's don't share the same
+	 * PurplePresence anymore.
+	 */
+	PurpleBuddy *b1 = purple_presence_get_buddy(p1);
+	PurpleBuddy *b2 = purple_presence_get_buddy(p2);
+	if (purple_buddy_get_account(b1) == purple_buddy_get_account(b2) &&
+			strcmp(purple_buddy_get_name(b1), purple_buddy_get_name(b2)) == 0)
+		return FALSE;
+	return TRUE;
+}
+
+static void
+generate_send_to_items(PidginWindow *win)
+{
+	GtkWidget *menu;
+	GSList *group = NULL;
+	GtkSizeGroup *sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+	PidginConversation *gtkconv;
+	GSList *l, *buds;
+
+	g_return_if_fail(win != NULL);
+
+	gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+
+	g_return_if_fail(gtkconv != NULL);
+
+	if (win->menu.send_to != NULL)
+		gtk_widget_destroy(win->menu.send_to);
+
+	/* Build the Send To menu */
+	win->menu.send_to = gtk_menu_item_new_with_mnemonic(_("S_end To"));
+	gtk_widget_show(win->menu.send_to);
+
+	menu = gtk_menu_new();
+	gtk_menu_shell_insert(GTK_MENU_SHELL(win->menu.menubar),
+	                      win->menu.send_to, 2);
+	gtk_menu_item_set_submenu(GTK_MENU_ITEM(win->menu.send_to), menu);
+
+	gtk_widget_show(menu);
+
+	if (gtkconv->active_conv->type == PURPLE_CONV_TYPE_IM) {
+		buds = purple_find_buddies(gtkconv->active_conv->account, gtkconv->active_conv->name);
+
+		if (buds == NULL)
+		{
+			/* The user isn't on the buddy list. So we don't create any sendto menu. */
+		}
+		else
+		{
+			GList *list = NULL, *iter;
+			for (l = buds; l != NULL; l = l->next)
+			{
+				PurpleBlistNode *node;
+
+				node = PURPLE_BLIST_NODE(purple_buddy_get_contact(PURPLE_BUDDY(l->data)));
+
+				for (node = node->child; node != NULL; node = node->next)
+				{
+					PurpleBuddy *buddy = (PurpleBuddy *)node;
+					PurpleAccount *account;
+
+					if (!PURPLE_BLIST_NODE_IS_BUDDY(node))
+						continue;
+
+					account = purple_buddy_get_account(buddy);
+					if (purple_account_is_connected(account) || account == gtkconv->active_conv->account)
+					{
+						/* Use the PurplePresence to get unique buddies. */
+						PurplePresence *presence = purple_buddy_get_presence(buddy);
+						if (!g_list_find_custom(list, presence, (GCompareFunc)compare_buddy_presence))
+							list = g_list_prepend(list, presence);
+					}
+				}
+			}
+
+			/* Create the sendto menu only if it has more than one item to show */
+			if (list && list->next) {
+				/* Loop over the list backwards so we get the items in the right order,
+				 * since we did a g_list_prepend() earlier. */
+				for (iter = g_list_last(list); iter != NULL; iter = iter->prev) {
+					PurplePresence *pre = iter->data;
+					PurpleBuddy *buddy = purple_presence_get_buddy(pre);
+					create_sendto_item(menu, sg, &group, buddy,
+							purple_buddy_get_account(buddy), purple_buddy_get_name(buddy));
+				}
+			}
+			g_list_free(list);
+			g_slist_free(buds);
+		}
+	}
+
+	g_object_unref(sg);
+
+	gtk_widget_show(win->menu.send_to);
+	/* TODO: This should never be insensitive.  Possibly hidden or not. */
+	if (!group)
+		gtk_widget_set_sensitive(win->menu.send_to, FALSE);
+	update_send_to_selection(win);
+}
+
+static const char *
+get_chat_buddy_status_icon(PurpleConvChat *chat, const char *name, PurpleConvChatBuddyFlags flags)
+{
+	const char *image = NULL;
+
+	if (flags & PURPLE_CBFLAGS_FOUNDER) {
+		image = PIDGIN_STOCK_STATUS_FOUNDER;
+	} else if (flags & PURPLE_CBFLAGS_OP) {
+		image = PIDGIN_STOCK_STATUS_OPERATOR;
+	} else if (flags & PURPLE_CBFLAGS_HALFOP) {
+		image = PIDGIN_STOCK_STATUS_HALFOP;
+	} else if (flags & PURPLE_CBFLAGS_VOICE) {
+		image = PIDGIN_STOCK_STATUS_VOICE;
+	} else if ((!flags) && purple_conv_chat_is_user_ignored(chat, name)) {
+		image = PIDGIN_STOCK_STATUS_IGNORED;
+	} else {
+		return NULL;
+	}
+	return image;
+}
+
+static void
+deleting_chat_buddy_cb(PurpleConvChatBuddy *cb)
+{
+	if (cb->ui_data) {
+		GtkTreeRowReference *ref = cb->ui_data;
+		gtk_tree_row_reference_free(ref);
+		cb->ui_data = NULL;
+	}
+}
+
+static void
+add_chat_buddy_common(PurpleConversation *conv, PurpleConvChatBuddy *cb, const char *old_name)
+{
+	PidginConversation *gtkconv;
+	PidginChatPane *gtkchat;
+	PurpleConvChat *chat;
+	PurpleConnection *gc;
+	PurplePluginProtocolInfo *prpl_info;
+	GtkTreeModel *tm;
+	GtkListStore *ls;
+	GtkTreePath *newpath;
+	const char *stock;
+	GtkTreeIter iter;
+	gboolean is_me = FALSE;
+	gboolean is_buddy;
+	gchar *tmp, *alias_key, *name, *alias;
+	PurpleConvChatBuddyFlags flags;
+	GdkColor *color = NULL;
+
+	alias = cb->alias;
+	name  = cb->name;
+	flags = cb->flags;
+
+	chat    = PURPLE_CONV_CHAT(conv);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	gtkchat = gtkconv->u.chat;
+	gc      = purple_conversation_get_gc(conv);
+
+	if (!gc || !(prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl)))
+		return;
+
+	tm = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+	ls = GTK_LIST_STORE(tm);
+
+	stock = get_chat_buddy_status_icon(chat, name, flags);
+
+	if (!strcmp(chat->nick, purple_normalize(conv->account, old_name != NULL ? old_name : name)))
+		is_me = TRUE;
+
+	is_buddy = cb->buddy;
+
+	tmp = g_utf8_casefold(alias, -1);
+	alias_key = g_utf8_collate_key(tmp, -1);
+	g_free(tmp);
+
+	if (is_me) {
+		GtkTextTag *tag = gtk_text_tag_table_lookup(
+				gtk_text_buffer_get_tag_table(GTK_IMHTML(gtkconv->imhtml)->text_buffer),
+				"send-name");
+		g_object_get(tag, "foreground-gdk", &color, NULL);
+	} else {
+		GtkTextTag *tag;
+		if ((tag = get_buddy_tag(conv, name, 0, FALSE)))
+			g_object_set(G_OBJECT(tag), "style", PANGO_STYLE_NORMAL, NULL);
+		if ((tag = get_buddy_tag(conv, name, PURPLE_MESSAGE_NICK, FALSE)))
+			g_object_set(G_OBJECT(tag), "style", PANGO_STYLE_NORMAL, NULL);
+		color = (GdkColor*)get_nick_color(gtkconv, name);
+	}
+
+	gtk_list_store_insert_with_values(ls, &iter,
+/*
+* The GTK docs are mute about the effects of the "row" value for performance.
+* X-Chat hardcodes their value to 0 (prepend) and -1 (append), so we will too.
+* It *might* be faster to search the gtk_list_store and set row accurately,
+* but no one in #gtk+ seems to know anything about it either.
+* Inserting in the "wrong" location has no visible ill effects. - F.P.
+*/
+			-1, /* "row" */
+			CHAT_USERS_ICON_STOCK_COLUMN,  stock,
+			CHAT_USERS_ALIAS_COLUMN, alias,
+			CHAT_USERS_ALIAS_KEY_COLUMN, alias_key,
+			CHAT_USERS_NAME_COLUMN,  name,
+			CHAT_USERS_FLAGS_COLUMN, flags,
+			CHAT_USERS_COLOR_COLUMN, color,
+			CHAT_USERS_WEIGHT_COLUMN, is_buddy ? PANGO_WEIGHT_BOLD : PANGO_WEIGHT_NORMAL,
+			-1);
+
+	if (cb->ui_data) {
+		GtkTreeRowReference *ref = cb->ui_data;
+		gtk_tree_row_reference_free(ref);
+	}
+
+	newpath = gtk_tree_model_get_path(tm, &iter);
+	cb->ui_data = gtk_tree_row_reference_new(tm, newpath);
+	gtk_tree_path_free(newpath);
+
+	if (is_me && color)
+		gdk_color_free(color);
+	g_free(alias_key);
+}
+
+/**
+ * @param most_matched Used internally by this function.
+ * @param entered The partial string that the user types before hitting the
+ *        tab key.
+ * @param entered_bytes The length of entered.
+ * @param partial This is a return variable.  This will be set to a string
+ *        containing the largest common string between all matches.  This will
+ *        be inserted into the input box at the start of the word that the
+ *        user is tab completing.  For example, if a chat room contains
+ *        "AlfFan" and "AlfHater" and the user types "a<TAB>" then this will
+ *        contain "Alf"
+ * @param nick_partial Used internally by this function.  Shoudl be a
+ *        temporary buffer that is entered_bytes+1 bytes long.
+ * @param matches This is a return variable.  If the given name is a potential
+ *        match for the entered string, then add a copy of the name to this
+ *        list.  The caller is responsible for g_free'ing the data in this
+ *        list.
+ * @param name The buddy name or alias or slash command name that we're
+ *        checking for a match.
+ */
+static void
+tab_complete_process_item(int *most_matched, const char *entered, gsize entered_bytes, char **partial, char *nick_partial,
+				  GList **matches, char *name)
+{
+	memcpy(nick_partial, name, entered_bytes);
+	if (purple_utf8_strcasecmp(nick_partial, entered))
+		return;
+
+	/* if we're here, it's a possible completion */
+
+	if (*most_matched == -1) {
+		/*
+		 * this will only get called once, since from now
+		 * on *most_matched is >= 0
+		 */
+		*most_matched = strlen(name);
+		*partial = g_strdup(name);
+	}
+	else if (*most_matched) {
+		char *tmp = g_strdup(name);
+
+		while (purple_utf8_strcasecmp(tmp, *partial)) {
+			(*partial)[*most_matched] = '\0';
+			if (*most_matched < (goffset)strlen(tmp))
+				tmp[*most_matched] = '\0';
+			(*most_matched)--;
+		}
+		(*most_matched)++;
+
+		g_free(tmp);
+	}
+
+	*matches = g_list_insert_sorted(*matches, g_strdup(name),
+								   (GCompareFunc)purple_utf8_strcasecmp);
+}
+
+static gboolean
+tab_complete(PurpleConversation *conv)
+{
+	PidginConversation *gtkconv;
+	GtkTextIter cursor, word_start, start_buffer;
+	int start;
+	int most_matched = -1;
+	char *entered, *partial = NULL;
+	char *text;
+	char *nick_partial;
+	const char *prefix;
+	GList *matches = NULL;
+	gboolean command = FALSE;
+	gsize entered_bytes = 0;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+
+	gtk_text_buffer_get_start_iter(gtkconv->entry_buffer, &start_buffer);
+	gtk_text_buffer_get_iter_at_mark(gtkconv->entry_buffer, &cursor,
+			gtk_text_buffer_get_insert(gtkconv->entry_buffer));
+
+	word_start = cursor;
+
+	/* if there's nothing there just return */
+	if (!gtk_text_iter_compare(&cursor, &start_buffer))
+		return (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) ? TRUE : FALSE;
+
+	text = gtk_text_buffer_get_text(gtkconv->entry_buffer, &start_buffer,
+									&cursor, FALSE);
+
+	/* if we're at the end of ": " we need to move back 2 spaces */
+	start = strlen(text) - 1;
+
+	if (start >= 1 && !strncmp(&text[start-1], ": ", 2)) {
+		gtk_text_iter_backward_chars(&word_start, 2);
+	}
+
+	/* find the start of the word that we're tabbing.
+	 * Using gtk_text_iter_backward_word_start won't work, because a nick can contain
+	 * characters (e.g. '.', '/' etc.) that Pango may think are word separators. */
+	while (gtk_text_iter_backward_char(&word_start)) {
+		if (gtk_text_iter_get_char(&word_start) == ' ') {
+			/* Reached the whitespace before the start of the word. Move forward once */
+			gtk_text_iter_forward_char(&word_start);
+			break;
+		}
+	}
+
+	prefix = pidgin_get_cmd_prefix();
+	if (gtk_text_iter_get_offset(&word_start) == 0 &&
+			(strlen(text) >= strlen(prefix)) && !strncmp(text, prefix, strlen(prefix))) {
+		command = TRUE;
+		gtk_text_iter_forward_chars(&word_start, strlen(prefix));
+	}
+
+	g_free(text);
+
+	entered = gtk_text_buffer_get_text(gtkconv->entry_buffer, &word_start,
+									   &cursor, FALSE);
+	entered_bytes = strlen(entered);
+
+	if (!g_utf8_strlen(entered, -1)) {
+		g_free(entered);
+		return (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) ? TRUE : FALSE;
+	}
+
+	nick_partial = g_malloc0(entered_bytes + 1);
+
+	if (command) {
+		GList *list = purple_cmd_list(conv);
+		GList *l;
+
+		/* Commands */
+		for (l = list; l != NULL; l = l->next) {
+			tab_complete_process_item(&most_matched, entered, entered_bytes, &partial, nick_partial,
+									  &matches, l->data);
+		}
+		g_list_free(list);
+	} else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+		PurpleConvChat *chat = PURPLE_CONV_CHAT(conv);
+		GList *l = purple_conv_chat_get_users(chat);
+		GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(PIDGIN_CONVERSATION(conv)->u.chat->list));
+		GtkTreeIter iter;
+		int f;
+
+		/* Users */
+		for (; l != NULL; l = l->next) {
+			tab_complete_process_item(&most_matched, entered, entered_bytes, &partial, nick_partial,
+									  &matches, ((PurpleConvChatBuddy *)l->data)->name);
+		}
+
+
+		/* Aliases */
+		if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &iter))
+		{
+			do {
+				char *name;
+				char *alias;
+
+				gtk_tree_model_get(model, &iter,
+						   CHAT_USERS_NAME_COLUMN, &name,
+						   CHAT_USERS_ALIAS_COLUMN, &alias,
+						   -1);
+
+				if (name && alias && strcmp(name, alias))
+					tab_complete_process_item(&most_matched, entered, entered_bytes, &partial, nick_partial,
+										  &matches, alias);
+				g_free(name);
+				g_free(alias);
+
+				f = gtk_tree_model_iter_next(model, &iter);
+			} while (f != 0);
+		}
+	} else {
+		g_free(nick_partial);
+		g_free(entered);
+		return FALSE;
+	}
+
+	g_free(nick_partial);
+
+	/* we're only here if we're doing new style */
+
+	/* if there weren't any matches, return */
+	if (!matches) {
+		/* if matches isn't set partials won't be either */
+		g_free(entered);
+		return (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) ? TRUE : FALSE;
+	}
+
+	gtk_text_buffer_delete(gtkconv->entry_buffer, &word_start, &cursor);
+
+	if (!matches->next) {
+		/* there was only one match. fill it in. */
+		gtk_text_buffer_get_start_iter(gtkconv->entry_buffer, &start_buffer);
+		gtk_text_buffer_get_iter_at_mark(gtkconv->entry_buffer, &cursor,
+				gtk_text_buffer_get_insert(gtkconv->entry_buffer));
+
+		if (!gtk_text_iter_compare(&cursor, &start_buffer)) {
+			char *tmp = g_strdup_printf("%s: ", (char *)matches->data);
+			gtk_text_buffer_insert_at_cursor(gtkconv->entry_buffer, tmp, -1);
+			g_free(tmp);
+		}
+		else
+			gtk_text_buffer_insert_at_cursor(gtkconv->entry_buffer,
+											 matches->data, -1);
+
+		g_free(matches->data);
+		g_list_free(matches);
+	}
+	else {
+		/*
+		 * there were lots of matches, fill in as much as possible
+		 * and display all of them
+		 */
+		char *addthis = g_malloc0(1);
+
+		while (matches) {
+			char *tmp = addthis;
+			addthis = g_strconcat(tmp, matches->data, " ", NULL);
+			g_free(tmp);
+			g_free(matches->data);
+			matches = g_list_remove(matches, matches->data);
+		}
+
+		purple_conversation_write(conv, NULL, addthis, PURPLE_MESSAGE_NO_LOG,
+								time(NULL));
+		gtk_text_buffer_insert_at_cursor(gtkconv->entry_buffer, partial, -1);
+		g_free(addthis);
+	}
+
+	g_free(entered);
+	g_free(partial);
+
+	return TRUE;
+}
+
+static void topic_callback(GtkWidget *w, PidginConversation *gtkconv)
+{
+	PurplePluginProtocolInfo *prpl_info = NULL;
+	PurpleConnection *gc;
+	PurpleConversation *conv = gtkconv->active_conv;
+	PidginChatPane *gtkchat;
+	char *new_topic;
+	const char *current_topic;
+
+	gc      = purple_conversation_get_gc(conv);
+
+	if(!gc || !(prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl)))
+		return;
+
+	if(prpl_info->set_chat_topic == NULL)
+		return;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	gtkchat = gtkconv->u.chat;
+	new_topic = g_strdup(gtk_entry_get_text(GTK_ENTRY(gtkchat->topic_text)));
+	current_topic = purple_conv_chat_get_topic(PURPLE_CONV_CHAT(conv));
+
+	if(current_topic && !g_utf8_collate(new_topic, current_topic)){
+		g_free(new_topic);
+		return;
+	}
+
+	if (current_topic)
+		gtk_entry_set_text(GTK_ENTRY(gtkchat->topic_text), current_topic);
+	else
+		gtk_entry_set_text(GTK_ENTRY(gtkchat->topic_text), "");
+
+	prpl_info->set_chat_topic(gc, purple_conv_chat_get_id(PURPLE_CONV_CHAT(conv)),
+			new_topic);
+
+	g_free(new_topic);
+}
+
+static gint
+sort_chat_users(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer userdata)
+{
+	PurpleConvChatBuddyFlags f1 = 0, f2 = 0;
+	char *user1 = NULL, *user2 = NULL;
+	gboolean buddy1 = FALSE, buddy2 = FALSE;
+	gint ret = 0;
+
+	gtk_tree_model_get(model, a,
+	                   CHAT_USERS_ALIAS_KEY_COLUMN, &user1,
+	                   CHAT_USERS_FLAGS_COLUMN, &f1,
+	                   CHAT_USERS_WEIGHT_COLUMN, &buddy1,
+	                   -1);
+	gtk_tree_model_get(model, b,
+	                   CHAT_USERS_ALIAS_KEY_COLUMN, &user2,
+	                   CHAT_USERS_FLAGS_COLUMN, &f2,
+	                   CHAT_USERS_WEIGHT_COLUMN, &buddy2,
+	                   -1);
+
+	/* Only sort by membership levels */
+	f1 &= PURPLE_CBFLAGS_VOICE | PURPLE_CBFLAGS_HALFOP | PURPLE_CBFLAGS_OP |
+			PURPLE_CBFLAGS_FOUNDER;
+	f2 &= PURPLE_CBFLAGS_VOICE | PURPLE_CBFLAGS_HALFOP | PURPLE_CBFLAGS_OP |
+			PURPLE_CBFLAGS_FOUNDER;
+
+	if (user1 == NULL || user2 == NULL) {
+		if (!(user1 == NULL && user2 == NULL))
+			ret = (user1 == NULL) ? -1: 1;
+	} else if (f1 != f2) {
+		/* sort more important users first */
+		ret = (f1 > f2) ? -1 : 1;
+	} else if (buddy1 != buddy2) {
+		ret = (buddy1 > buddy2) ? -1 : 1;
+	} else {
+		ret = strcmp(user1, user2);
+	}
+
+	g_free(user1);
+	g_free(user2);
+
+	return ret;
+}
+
+static void
+update_chat_alias(PurpleBuddy *buddy, PurpleConversation *conv, PurpleConnection *gc, PurplePluginProtocolInfo *prpl_info)
+{
+	PidginConversation *gtkconv = PIDGIN_CONVERSATION(conv);
+	PurpleConvChat *chat = PURPLE_CONV_CHAT(conv);
+	GtkTreeModel *model;
+	char *normalized_name;
+	GtkTreeIter iter;
+	int f;
+
+	g_return_if_fail(buddy != NULL);
+	g_return_if_fail(conv != NULL);
+
+	/* This is safe because this callback is only used in chats, not IMs. */
+	model = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkconv->u.chat->list));
+
+	if (!gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &iter))
+		return;
+
+	normalized_name = g_strdup(purple_normalize(conv->account, buddy->name));
+
+	do {
+		char *name;
+
+		gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+
+		if (!strcmp(normalized_name, purple_normalize(conv->account, name))) {
+			const char *alias = name;
+			char *tmp;
+			char *alias_key = NULL;
+			PurpleBuddy *buddy2;
+
+			if (strcmp(chat->nick, purple_normalize(conv->account, name))) {
+				/* This user is not me, so look into updating the alias. */
+
+				if ((buddy2 = purple_find_buddy(conv->account, name)) != NULL) {
+					alias = purple_buddy_get_contact_alias(buddy2);
+				}
+
+				tmp = g_utf8_casefold(alias, -1);
+				alias_key = g_utf8_collate_key(tmp, -1);
+				g_free(tmp);
+
+				gtk_list_store_set(GTK_LIST_STORE(model), &iter,
+								CHAT_USERS_ALIAS_COLUMN, alias,
+								CHAT_USERS_ALIAS_KEY_COLUMN, alias_key,
+								-1);
+				g_free(alias_key);
+			}
+			g_free(name);
+			break;
+		}
+
+		f = gtk_tree_model_iter_next(model, &iter);
+
+		g_free(name);
+	} while (f != 0);
+
+	g_free(normalized_name);
+}
+
+static void
+blist_node_aliased_cb(PurpleBlistNode *node, const char *old_alias, PurpleConversation *conv)
+{
+	PurpleConnection *gc;
+	PurplePluginProtocolInfo *prpl_info;
+
+	g_return_if_fail(node != NULL);
+	g_return_if_fail(conv != NULL);
+
+	gc = purple_conversation_get_gc(conv);
+	g_return_if_fail(gc != NULL);
+	g_return_if_fail(gc->prpl != NULL);
+	prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+
+	if (prpl_info->options & OPT_PROTO_UNIQUE_CHATNAME)
+		return;
+
+	if (PURPLE_BLIST_NODE_IS_CONTACT(node))
+	{
+		PurpleBlistNode *bnode;
+
+		for(bnode = node->child; bnode; bnode = bnode->next) {
+
+			if(!PURPLE_BLIST_NODE_IS_BUDDY(bnode))
+				continue;
+
+			update_chat_alias((PurpleBuddy *)bnode, conv, gc, prpl_info);
+		}
+	}
+	else if (PURPLE_BLIST_NODE_IS_BUDDY(node))
+		update_chat_alias((PurpleBuddy *)node, conv, gc, prpl_info);
+	else if (PURPLE_BLIST_NODE_IS_CHAT(node) &&
+			purple_conversation_get_account(conv) == ((PurpleChat*)node)->account)
+	{
+		if (old_alias == NULL || g_utf8_collate(old_alias, purple_conversation_get_title(conv)) == 0)
+			pidgin_conv_update_fields(conv, PIDGIN_CONV_SET_TITLE);
+	}
+}
+
+static void
+buddy_cb_common(PurpleBuddy *buddy, PurpleConversation *conv, gboolean is_buddy)
+{
+	GtkTreeModel *model;
+	char *normalized_name;
+	GtkTreeIter iter;
+	GtkTextTag *texttag;
+	int f;
+
+	g_return_if_fail(buddy != NULL);
+	g_return_if_fail(conv != NULL);
+
+	/* Do nothing if the buddy does not belong to the conv's account */
+	if (purple_buddy_get_account(buddy) != purple_conversation_get_account(conv))
+		return;
+
+	/* This is safe because this callback is only used in chats, not IMs. */
+	model = gtk_tree_view_get_model(GTK_TREE_VIEW(PIDGIN_CONVERSATION(conv)->u.chat->list));
+
+	if (!gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &iter))
+		return;
+
+	normalized_name = g_strdup(purple_normalize(conv->account, buddy->name));
+
+	do {
+		char *name;
+
+		gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+
+		if (!strcmp(normalized_name, purple_normalize(conv->account, name))) {
+			gtk_list_store_set(GTK_LIST_STORE(model), &iter,
+			                   CHAT_USERS_WEIGHT_COLUMN, is_buddy ? PANGO_WEIGHT_BOLD : PANGO_WEIGHT_NORMAL, -1);
+			g_free(name);
+			break;
+		}
+
+		f = gtk_tree_model_iter_next(model, &iter);
+
+		g_free(name);
+	} while (f != 0);
+
+	g_free(normalized_name);
+
+	blist_node_aliased_cb((PurpleBlistNode *)buddy, NULL, conv);
+
+	texttag = get_buddy_tag(conv, purple_buddy_get_name(buddy), 0, FALSE); /* XXX: do we want the normalized name? */
+	if (texttag) {
+		g_object_set(texttag, "weight", is_buddy ? PANGO_WEIGHT_BOLD : PANGO_WEIGHT_NORMAL, NULL);
+	}
+}
+
+static void
+buddy_added_cb(PurpleBlistNode *node, PurpleConversation *conv)
+{
+	if (!PURPLE_BLIST_NODE_IS_BUDDY(node))
+		return;
+
+	buddy_cb_common(PURPLE_BUDDY(node), conv, TRUE);
+}
+
+static void
+buddy_removed_cb(PurpleBlistNode *node, PurpleConversation *conv)
+{
+	if (!PURPLE_BLIST_NODE_IS_BUDDY(node))
+		return;
+
+	/* If there's another buddy for the same "dude" on the list, do nothing. */
+	if (purple_find_buddy(purple_buddy_get_account(PURPLE_BUDDY(node)),
+		                  purple_buddy_get_name(PURPLE_BUDDY(node))) != NULL)
+		return;
+
+	buddy_cb_common(PURPLE_BUDDY(node), conv, FALSE);
+}
+
+static void send_menu_cb(GtkWidget *widget, PidginConversation *gtkconv)
+{
+	g_signal_emit_by_name(gtkconv->entry, "message_send");
+}
+
+static void
+entry_popup_menu_cb(GtkIMHtml *imhtml, GtkMenu *menu, gpointer data)
+{
+	GtkWidget *menuitem;
+	PidginConversation *gtkconv = data;
+
+	g_return_if_fail(menu != NULL);
+	g_return_if_fail(gtkconv != NULL);
+
+	menuitem = pidgin_new_item_from_stock(NULL, _("_Send"), NULL,
+										G_CALLBACK(send_menu_cb), gtkconv,
+										0, 0, NULL);
+	if (gtk_text_buffer_get_char_count(imhtml->text_buffer) == 0)
+		gtk_widget_set_sensitive(menuitem, FALSE);
+	gtk_menu_shell_insert(GTK_MENU_SHELL(menu), menuitem, 0);
+
+	menuitem = gtk_separator_menu_item_new();
+	gtk_widget_show(menuitem);
+	gtk_menu_shell_insert(GTK_MENU_SHELL(menu), menuitem, 1);
+}
+
+static gboolean resize_imhtml_cb(PidginConversation *gtkconv)
+{
+	GtkTextBuffer *buffer;
+	GtkTextIter iter;
+	int lines;
+	GdkRectangle oneline;
+	int height, diff;
+	int pad_top, pad_inside, pad_bottom;
+	int total_height = (gtkconv->imhtml->allocation.height + gtkconv->entry->allocation.height);
+	int max_height = total_height / 2;
+	int min_lines = purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/minimum_entry_lines");
+	int min_height;
+	gboolean interior_focus;
+	int focus_width;
+
+	pad_top = gtk_text_view_get_pixels_above_lines(GTK_TEXT_VIEW(gtkconv->entry));
+	pad_bottom = gtk_text_view_get_pixels_below_lines(GTK_TEXT_VIEW(gtkconv->entry));
+	pad_inside = gtk_text_view_get_pixels_inside_wrap(GTK_TEXT_VIEW(gtkconv->entry));
+
+	buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->entry));
+	gtk_text_buffer_get_start_iter(buffer, &iter);
+	gtk_text_view_get_iter_location(GTK_TEXT_VIEW(gtkconv->entry), &iter, &oneline);
+
+	lines = gtk_text_buffer_get_line_count(buffer);
+
+	height = 0;
+	do {
+		int lineheight = 0;
+		gtk_text_view_get_line_yrange(GTK_TEXT_VIEW(gtkconv->entry), &iter, NULL, &lineheight);
+		height += lineheight;
+		lines--;
+	} while (gtk_text_iter_forward_line(&iter));
+	height += lines * (oneline.height + pad_top + pad_bottom);
+
+	/* Make sure there's enough room for at least min_lines. Allocate enough space to
+	 * prevent scrolling when the second line is a continuation of the first line, or
+	 * is the beginning of a new paragraph. */
+	min_height = min_lines * (oneline.height + MAX(pad_inside, pad_top + pad_bottom));
+	height = CLAMP(height, MIN(min_height, max_height), max_height);
+
+	gtk_widget_style_get(gtkconv->entry,
+	                     "interior-focus", &interior_focus,
+	                     "focus-line-width", &focus_width,
+	                     NULL);
+	if (!interior_focus)
+		height += 2 * focus_width;
+
+	diff = height - gtkconv->entry->allocation.height;
+	if (ABS(diff) < oneline.height / 2)
+		return FALSE;
+
+	gtk_widget_set_size_request(gtkconv->lower_hbox, -1,
+		diff + gtkconv->lower_hbox->allocation.height);
+
+	return FALSE;
+}
+
+static void
+minimum_entry_lines_pref_cb(const char *name,
+                            PurplePrefType type,
+                            gconstpointer value,
+                            gpointer data)
+{
+	GList *l = purple_get_conversations();
+	PurpleConversation *conv;
+	while (l != NULL)
+	{
+		conv = (PurpleConversation *)l->data;
+
+		if (PIDGIN_IS_PIDGIN_CONVERSATION(conv))
+			resize_imhtml_cb(PIDGIN_CONVERSATION(conv));
+
+		l = l->next;
+	}
+}
+
+static void
+setup_chat_topic(PidginConversation *gtkconv, GtkWidget *vbox)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleConnection *gc = purple_conversation_get_gc(conv);
+	PurplePluginProtocolInfo *prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+	if (prpl_info->options & OPT_PROTO_CHAT_TOPIC)
+	{
+		GtkWidget *hbox, *label;
+		PidginChatPane *gtkchat = gtkconv->u.chat;
+
+		hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+
+		label = gtk_label_new(_("Topic:"));
+		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
+
+		gtkchat->topic_text = gtk_entry_new();
+		gtk_widget_set_size_request(gtkchat->topic_text, -1, BUDDYICON_SIZE_MIN);
+
+		if(prpl_info->set_chat_topic == NULL) {
+			gtk_editable_set_editable(GTK_EDITABLE(gtkchat->topic_text), FALSE);
+		} else {
+			g_signal_connect(GTK_OBJECT(gtkchat->topic_text), "activate",
+					G_CALLBACK(topic_callback), gtkconv);
+		}
+
+		gtk_box_pack_start(GTK_BOX(hbox), gtkchat->topic_text, TRUE, TRUE, 0);
+		g_signal_connect(G_OBJECT(gtkchat->topic_text), "key_press_event",
+			             G_CALLBACK(entry_key_press_cb), gtkconv);
+	}
+}
+
+static gboolean
+pidgin_conv_userlist_create_tooltip(GtkWidget *tipwindow, GtkTreePath *path,
+		gpointer userdata, int *w, int *h)
+{
+	PidginConversation *gtkconv = userdata;
+	GtkTreeIter iter;
+	GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkconv->u.chat->list));
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleBlistNode *node;
+	PurplePluginProtocolInfo *prpl_info;
+	PurpleAccount *account = purple_conversation_get_account(conv);
+	char *who = NULL;
+
+	if (account->gc == NULL)
+		return FALSE;
+
+	if (!gtk_tree_model_get_iter(GTK_TREE_MODEL(model), &iter, path))
+		return FALSE;
+
+	gtk_tree_model_get(GTK_TREE_MODEL(model), &iter, CHAT_USERS_NAME_COLUMN, &who, -1);
+
+	prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
+	node = (PurpleBlistNode*)(purple_find_buddy(conv->account, who));
+	if (node && prpl_info && (prpl_info->options & OPT_PROTO_UNIQUE_CHATNAME))
+		pidgin_blist_draw_tooltip(node, gtkconv->infopane);
+
+	g_free(who);
+	return FALSE;
+}
+
+static void
+setup_chat_userlist(PidginConversation *gtkconv, GtkWidget *hpaned)
+{
+	PidginChatPane *gtkchat = gtkconv->u.chat;
+	GtkWidget *lbox, *list;
+	GtkListStore *ls;
+	GtkCellRenderer *rend;
+	GtkTreeViewColumn *col;
+	int ul_width;
+	void *blist_handle = purple_blist_get_handle();
+	PurpleConversation *conv = gtkconv->active_conv;
+
+	/* Build the right pane. */
+	lbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_paned_pack2(GTK_PANED(hpaned), lbox, FALSE, TRUE);
+	gtk_widget_show(lbox);
+
+	/* Setup the label telling how many people are in the room. */
+	gtkchat->count = gtk_label_new(_("0 people in room"));
+	gtk_label_set_ellipsize(GTK_LABEL(gtkchat->count), PANGO_ELLIPSIZE_END);
+	gtk_box_pack_start(GTK_BOX(lbox), gtkchat->count, FALSE, FALSE, 0);
+	gtk_widget_show(gtkchat->count);
+
+	/* Setup the list of users. */
+
+	ls = gtk_list_store_new(CHAT_USERS_COLUMNS, GDK_TYPE_PIXBUF, G_TYPE_STRING,
+							G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INT,
+							GDK_TYPE_COLOR, G_TYPE_INT, G_TYPE_STRING);
+	gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(ls), CHAT_USERS_ALIAS_KEY_COLUMN,
+									sort_chat_users, NULL, NULL);
+
+	list = gtk_tree_view_new_with_model(GTK_TREE_MODEL(ls));
+
+	/* Allow a user to specify gtkrc settings for the chat userlist only */
+	gtk_widget_set_name(list, "pidgin_conv_userlist");
+
+	rend = gtk_cell_renderer_pixbuf_new();
+	g_object_set(G_OBJECT(rend),
+				 "stock-size", gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_EXTRA_SMALL),
+				 NULL);
+	col = gtk_tree_view_column_new_with_attributes(NULL, rend,
+			"stock-id", CHAT_USERS_ICON_STOCK_COLUMN, NULL);
+	gtk_tree_view_column_set_sizing(col, GTK_TREE_VIEW_COLUMN_AUTOSIZE);
+	gtk_tree_view_append_column(GTK_TREE_VIEW(list), col);
+	ul_width = purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/chat/userlist_width");
+	gtk_widget_set_size_request(lbox, ul_width, -1);
+
+	/* Hack to prevent completely collapsed userlist coming back with a 1 pixel width.
+	 * I would have liked to use the GtkPaned "max-position", but for some reason that didn't work */
+	if (ul_width == 0)
+		gtk_paned_set_position(GTK_PANED(hpaned), 999999);
+
+	g_signal_connect(G_OBJECT(list), "button_press_event",
+					 G_CALLBACK(right_click_chat_cb), gtkconv);
+	g_signal_connect(G_OBJECT(list), "row-activated",
+					 G_CALLBACK(activate_list_cb), gtkconv);
+	g_signal_connect(G_OBJECT(list), "popup-menu",
+			 G_CALLBACK(gtkconv_chat_popup_menu_cb), gtkconv);
+	g_signal_connect(G_OBJECT(lbox), "size-allocate", G_CALLBACK(lbox_size_allocate_cb), gtkconv);
+
+	pidgin_tooltip_setup_for_treeview(list, gtkconv,
+			pidgin_conv_userlist_create_tooltip, NULL);
+
+	rend = gtk_cell_renderer_text_new();
+	g_object_set(rend,
+				 "foreground-set", TRUE,
+				 "weight-set", TRUE,
+				 NULL);
+	g_object_set(G_OBJECT(rend), "editable", TRUE, NULL);
+
+	col = gtk_tree_view_column_new_with_attributes(NULL, rend,
+	                                               "text", CHAT_USERS_ALIAS_COLUMN,
+	                                               "foreground-gdk", CHAT_USERS_COLOR_COLUMN,
+	                                               "weight", CHAT_USERS_WEIGHT_COLUMN,
+	                                               NULL);
+
+	purple_signal_connect(blist_handle, "blist-node-added",
+						gtkchat, PURPLE_CALLBACK(buddy_added_cb), conv);
+	purple_signal_connect(blist_handle, "blist-node-removed",
+						gtkchat, PURPLE_CALLBACK(buddy_removed_cb), conv);
+	purple_signal_connect(blist_handle, "blist-node-aliased",
+						gtkchat, PURPLE_CALLBACK(blist_node_aliased_cb), conv);
+
+	gtk_tree_view_column_set_expand(col, TRUE);
+	g_object_set(rend, "ellipsize", PANGO_ELLIPSIZE_END, NULL);
+
+	gtk_tree_view_append_column(GTK_TREE_VIEW(list), col);
+
+	gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(list), FALSE);
+	gtk_widget_show(list);
+
+	gtkchat->list = list;
+
+	gtk_box_pack_start(GTK_BOX(lbox), 
+		pidgin_make_scrollable(list, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC, GTK_SHADOW_IN, -1, -1),
+		TRUE, TRUE, 0);
+}
+
+static gboolean
+pidgin_conv_create_tooltip(GtkWidget *tipwindow, gpointer userdata, int *w, int *h)
+{
+	PurpleBlistNode *node = NULL;
+	PurpleConversation *conv;
+	PidginConversation *gtkconv = userdata;
+
+	conv = gtkconv->active_conv;
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+		node = (PurpleBlistNode*)(purple_blist_find_chat(conv->account, conv->name));
+		if (!node)
+			node = g_object_get_data(G_OBJECT(gtkconv->imhtml), "transient_chat");
+	} else {
+		node = (PurpleBlistNode*)(purple_find_buddy(conv->account, conv->name));
+#if 0
+		/* Using the transient blist nodes to show the tooltip doesn't quite work yet. */
+		if (!node)
+			node = g_object_get_data(G_OBJECT(gtkconv->imhtml), "transient_buddy");
+#endif
+	}
+
+	if (node)
+		pidgin_blist_draw_tooltip(node, gtkconv->infopane);
+	return FALSE;
+}
+
+/* Quick Find {{{ */
+static gboolean
+pidgin_conv_end_quickfind(PidginConversation *gtkconv)
+{
+	gtk_widget_modify_base(gtkconv->quickfind.entry, GTK_STATE_NORMAL, NULL);
+
+	gtk_imhtml_search_clear(GTK_IMHTML(gtkconv->imhtml));
+	gtk_widget_hide_all(gtkconv->quickfind.container);
+
+	gtk_widget_grab_focus(gtkconv->entry);
+	return TRUE;
+}
+
+static gboolean
+quickfind_process_input(GtkWidget *entry, GdkEventKey *event, PidginConversation *gtkconv)
+{
+	switch (event->keyval) {
+		case GDK_Return:
+		case GDK_KP_Enter:
+			if (gtk_imhtml_search_find(GTK_IMHTML(gtkconv->imhtml), gtk_entry_get_text(GTK_ENTRY(entry)))) {
+				gtk_widget_modify_base(gtkconv->quickfind.entry, GTK_STATE_NORMAL, NULL);
+			} else {
+				GdkColor col;
+				col.red = 0xffff;
+				col.green = 0xafff;
+				col.blue = 0xafff;
+				gtk_widget_modify_base(gtkconv->quickfind.entry, GTK_STATE_NORMAL, &col);
+			}
+			break;
+		case GDK_Escape:
+			pidgin_conv_end_quickfind(gtkconv);
+			break;
+		default:
+			return FALSE;
+	}
+	return TRUE;
+}
+
+static void
+pidgin_conv_setup_quickfind(PidginConversation *gtkconv, GtkWidget *container)
+{
+	GtkWidget *widget = gtk_hbox_new(FALSE, 0);
+	GtkWidget *label, *entry, *close;
+
+	gtk_box_pack_start(GTK_BOX(container), widget, FALSE, FALSE, 0);
+
+	close = pidgin_create_small_button(gtk_label_new("×"));
+	gtk_box_pack_start(GTK_BOX(widget), close, FALSE, FALSE, 0);
+	gtk_tooltips_set_tip(gtkconv->tooltips, close,
+	                     _("Close Find bar"), NULL);
+
+	label = gtk_label_new(_("Find:"));
+	gtk_box_pack_start(GTK_BOX(widget), label, FALSE, FALSE, 10);
+
+	entry = gtk_entry_new();
+	gtk_box_pack_start(GTK_BOX(widget), entry, TRUE, TRUE, 0);
+
+	gtkconv->quickfind.entry = entry;
+	gtkconv->quickfind.container = widget;
+
+	/* Hook to signals and stuff */
+	g_signal_connect(G_OBJECT(entry), "key_press_event",
+			G_CALLBACK(quickfind_process_input), gtkconv);
+	g_signal_connect_swapped(G_OBJECT(close), "button-press-event",
+			G_CALLBACK(pidgin_conv_end_quickfind), gtkconv);
+}
+
+/* }}} */
+
+static GtkWidget *
+setup_common_pane(PidginConversation *gtkconv)
+{
+	GtkWidget *vbox, *frame, *imhtml_sw, *event_box;
+	GtkCellRenderer *rend;
+	GtkTreePath *path;
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleBuddy *buddy;
+	gboolean chat = (conv->type == PURPLE_CONV_TYPE_CHAT);
+	int buddyicon_size = 0;
+
+	/* Setup the top part of the pane */
+	vbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_widget_show(vbox);
+
+	/* Setup the info pane */
+	event_box = gtk_event_box_new();
+	gtk_event_box_set_visible_window(GTK_EVENT_BOX(event_box), FALSE);
+	gtk_widget_show(event_box);
+	gtkconv->infopane_hbox = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox), event_box, FALSE, FALSE, 0);
+	gtk_container_add(GTK_CONTAINER(event_box), gtkconv->infopane_hbox);
+	gtk_widget_show(gtkconv->infopane_hbox);
+	gtk_widget_add_events(event_box,
+	                      GDK_POINTER_MOTION_MASK | GDK_LEAVE_NOTIFY_MASK);
+	g_signal_connect(G_OBJECT(event_box), "button-press-event",
+	                 G_CALLBACK(infopane_press_cb), gtkconv);
+
+	pidgin_tooltip_setup_for_widget(event_box, gtkconv,
+		pidgin_conv_create_tooltip, NULL);
+
+	gtkconv->infopane = gtk_cell_view_new();
+	gtkconv->infopane_model = gtk_list_store_new(CONV_NUM_COLUMNS, G_TYPE_STRING, G_TYPE_STRING, GDK_TYPE_PIXBUF, GDK_TYPE_PIXBUF);
+	gtk_cell_view_set_model(GTK_CELL_VIEW(gtkconv->infopane),
+				GTK_TREE_MODEL(gtkconv->infopane_model));
+	g_object_unref(gtkconv->infopane_model);
+	gtk_list_store_append(gtkconv->infopane_model, &(gtkconv->infopane_iter));
+	gtk_box_pack_start(GTK_BOX(gtkconv->infopane_hbox), gtkconv->infopane, TRUE, TRUE, 0);
+	path = gtk_tree_path_new_from_string("0");
+	gtk_cell_view_set_displayed_row(GTK_CELL_VIEW(gtkconv->infopane), path);
+	gtk_tree_path_free(path);
+
+	if (chat) {
+		/* This empty widget is used to ensure that the infopane is consistently
+		   sized for chat windows. The correct fix is to put an icon in the chat
+		   window as well, because that would make "Set Custom Icon" consistent
+		   for both the buddy list and the chat window, but PidginConversation
+		   is pretty much stuck until 3.0. */
+		GtkWidget *sizing_vbox;
+		sizing_vbox = gtk_vbox_new(FALSE, 0);
+		gtk_widget_set_size_request(sizing_vbox, -1, BUDDYICON_SIZE_MIN);
+		gtk_box_pack_start(GTK_BOX(gtkconv->infopane_hbox), sizing_vbox, FALSE, FALSE, 0);
+		gtk_widget_show(sizing_vbox);
+	}
+	else {
+		gtkconv->u.im->icon_container = gtk_vbox_new(FALSE, 0);
+
+		if ((buddy = purple_find_buddy(purple_conversation_get_account(conv),
+						purple_conversation_get_name(conv))) != NULL) {
+			PurpleContact *contact = purple_buddy_get_contact(buddy);
+			if (contact) {
+				buddyicon_size = purple_blist_node_get_int((PurpleBlistNode*)contact, "pidgin-infopane-iconsize");
+			}
+		}
+		buddyicon_size = CLAMP(buddyicon_size, BUDDYICON_SIZE_MIN, BUDDYICON_SIZE_MAX);
+		gtk_widget_set_size_request(gtkconv->u.im->icon_container, -1, buddyicon_size);
+
+		gtk_box_pack_start(GTK_BOX(gtkconv->infopane_hbox),
+				   gtkconv->u.im->icon_container, FALSE, FALSE, 0);
+
+		gtk_widget_show(gtkconv->u.im->icon_container);
+	}
+
+	gtk_widget_show(gtkconv->infopane);
+
+	rend = gtk_cell_renderer_pixbuf_new();
+	gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(gtkconv->infopane), rend, FALSE);
+	gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(gtkconv->infopane), rend, "stock-id", CONV_ICON_COLUMN, NULL);
+	g_object_set(rend, "xalign", 0.0, "xpad", 6, "ypad", 0,
+			"stock-size", gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_EXTRA_SMALL),
+			NULL);
+
+	rend = gtk_cell_renderer_text_new();
+	gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(gtkconv->infopane), rend, TRUE);
+	gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(gtkconv->infopane), rend, "markup", CONV_TEXT_COLUMN, NULL);
+	g_object_set(rend, "ypad", 0, "yalign", 0.5, NULL);
+
+	g_object_set(rend, "ellipsize", PANGO_ELLIPSIZE_END, NULL);
+
+	rend = gtk_cell_renderer_pixbuf_new();
+	gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(gtkconv->infopane), rend, FALSE);
+	gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(gtkconv->infopane), rend, "pixbuf", CONV_PROTOCOL_ICON_COLUMN, NULL);
+	g_object_set(rend, "xalign", 0.0, "xpad", 3, "ypad", 0, NULL);
+
+	rend = gtk_cell_renderer_pixbuf_new();
+	gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(gtkconv->infopane), rend, FALSE);
+	gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(gtkconv->infopane), rend, "pixbuf", CONV_EMBLEM_COLUMN, NULL);
+	g_object_set(rend, "xalign", 0.0, "xpad", 6, "ypad", 0, NULL);
+
+	/* Setup the gtkimhtml widget */
+	frame = pidgin_create_imhtml(FALSE, &gtkconv->imhtml, NULL, &imhtml_sw);
+	gtk_widget_set_size_request(gtkconv->imhtml, -1, 0);
+	if (chat) {
+		GtkWidget *hpaned;
+
+		/* Add the topic */
+		setup_chat_topic(gtkconv, vbox);
+
+		/* Add the gtkimhtml frame */
+		hpaned = gtk_hpaned_new();
+		gtk_box_pack_start(GTK_BOX(vbox), hpaned, TRUE, TRUE, 0);
+		gtk_widget_show(hpaned);
+		gtk_paned_pack1(GTK_PANED(hpaned), frame, TRUE, TRUE);
+
+		/* Now add the userlist */
+		setup_chat_userlist(gtkconv, hpaned);
+	} else {
+		gtk_box_pack_start(GTK_BOX(vbox), frame, TRUE, TRUE, 0);
+	}
+	gtk_widget_show(frame);
+
+	gtk_widget_set_name(gtkconv->imhtml, "pidgin_conv_imhtml");
+	gtk_imhtml_show_comments(GTK_IMHTML(gtkconv->imhtml),TRUE);
+	g_object_set_data(G_OBJECT(gtkconv->imhtml), "gtkconv", gtkconv);
+
+	g_object_set(G_OBJECT(imhtml_sw), "vscrollbar-policy", GTK_POLICY_ALWAYS, NULL);
+
+	g_signal_connect_after(G_OBJECT(gtkconv->imhtml), "button_press_event",
+	                       G_CALLBACK(entry_stop_rclick_cb), NULL);
+	g_signal_connect(G_OBJECT(gtkconv->imhtml), "key_press_event",
+	                 G_CALLBACK(refocus_entry_cb), gtkconv);
+	g_signal_connect(G_OBJECT(gtkconv->imhtml), "key_release_event",
+	                 G_CALLBACK(refocus_entry_cb), gtkconv);
+
+	pidgin_conv_setup_quickfind(gtkconv, vbox);
+
+	gtkconv->lower_hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_box_pack_start(GTK_BOX(vbox), gtkconv->lower_hbox, FALSE, FALSE, 0);
+	gtk_widget_show(gtkconv->lower_hbox);
+
+	/* Setup the toolbar, entry widget and all signals */
+	frame = pidgin_create_imhtml(TRUE, &gtkconv->entry, &gtkconv->toolbar, NULL);
+	gtk_box_pack_start(GTK_BOX(gtkconv->lower_hbox), frame, TRUE, TRUE, 0);
+	gtk_widget_show(frame);
+
+	gtk_widget_set_name(gtkconv->entry, "pidgin_conv_entry");
+	gtk_imhtml_set_protocol_name(GTK_IMHTML(gtkconv->entry),
+			purple_account_get_protocol_name(conv->account));
+
+	g_signal_connect(G_OBJECT(gtkconv->entry), "populate-popup",
+	                 G_CALLBACK(entry_popup_menu_cb), gtkconv);
+	g_signal_connect(G_OBJECT(gtkconv->entry), "key_press_event",
+	                 G_CALLBACK(entry_key_press_cb), gtkconv);
+	g_signal_connect_after(G_OBJECT(gtkconv->entry), "message_send",
+	                       G_CALLBACK(send_cb), gtkconv);
+	g_signal_connect_after(G_OBJECT(gtkconv->entry), "button_press_event",
+	                       G_CALLBACK(entry_stop_rclick_cb), NULL);
+
+	gtkconv->entry_buffer =
+		gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->entry));
+	g_object_set_data(G_OBJECT(gtkconv->entry_buffer), "user_data", gtkconv);
+
+	if (!chat) {
+		/* For sending typing notifications for IMs */
+		g_signal_connect(G_OBJECT(gtkconv->entry_buffer), "insert_text",
+						 G_CALLBACK(insert_text_cb), gtkconv);
+		g_signal_connect(G_OBJECT(gtkconv->entry_buffer), "delete_range",
+						 G_CALLBACK(delete_text_cb), gtkconv);
+		gtkconv->u.im->typing_timer = 0;
+		gtkconv->u.im->animate = purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/im/animate_buddy_icons");
+		gtkconv->u.im->show_icon = TRUE;
+	}
+
+	g_signal_connect_swapped(G_OBJECT(gtkconv->entry_buffer), "changed",
+				 G_CALLBACK(resize_imhtml_cb), gtkconv);
+	g_signal_connect_swapped(G_OBJECT(gtkconv->entry), "size-allocate",
+				 G_CALLBACK(resize_imhtml_cb), gtkconv);
+
+	default_formatize(gtkconv);
+	g_signal_connect_after(G_OBJECT(gtkconv->entry), "format_function_clear",
+	                       G_CALLBACK(clear_formatting_cb), gtkconv);
+	return vbox;
+}
+
+static void
+conv_dnd_recv(GtkWidget *widget, GdkDragContext *dc, guint x, guint y,
+              GtkSelectionData *sd, guint info, guint t,
+              PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PidginWindow *win = gtkconv->win;
+	PurpleConversation *c;
+	PurpleAccount *convaccount = purple_conversation_get_account(conv);
+	PurpleConnection *gc = purple_account_get_connection(convaccount);
+	PurplePluginProtocolInfo *prpl_info = gc ? PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl) : NULL;
+
+	if (sd->target == gdk_atom_intern("PURPLE_BLIST_NODE", FALSE))
+	{
+		PurpleBlistNode *n = NULL;
+		PurpleBuddy *b;
+		PidginConversation *gtkconv = NULL;
+		PurpleAccount *buddyaccount;
+		const char *buddyname;
+
+		n = *(PurpleBlistNode **)sd->data;
+
+		if (PURPLE_BLIST_NODE_IS_CONTACT(n))
+			b = purple_contact_get_priority_buddy((PurpleContact*)n);
+		else if (PURPLE_BLIST_NODE_IS_BUDDY(n))
+			b = (PurpleBuddy*)n;
+		else
+			return;
+
+		buddyaccount = purple_buddy_get_account(b);
+		buddyname = purple_buddy_get_name(b);
+		/*
+		 * If a buddy is dragged to a chat window of the same protocol,
+		 * invite him to the chat.
+		 */
+		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT &&
+				prpl_info && PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, chat_invite) &&
+				strcmp(purple_account_get_protocol_id(convaccount),
+					purple_account_get_protocol_id(buddyaccount)) == 0) {
+		    purple_conv_chat_invite_user(PURPLE_CONV_CHAT(conv), buddyname, NULL, TRUE);
+		} else {
+			/*
+			 * If we already have an open conversation with this buddy, then
+			 * just move the conv to this window.  Otherwise, create a new
+			 * conv and add it to this window.
+			 */
+			c = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, buddyname, buddyaccount);
+			if (c != NULL) {
+				PidginWindow *oldwin;
+				gtkconv = PIDGIN_CONVERSATION(c);
+				oldwin = gtkconv->win;
+				if (oldwin != win) {
+					pidgin_conv_window_remove_gtkconv(oldwin, gtkconv);
+					pidgin_conv_window_add_gtkconv(win, gtkconv);
+				}
+			} else {
+				c = purple_conversation_new(PURPLE_CONV_TYPE_IM, buddyaccount, buddyname);
+				gtkconv = PIDGIN_CONVERSATION(c);
+				if (gtkconv->win != win) {
+					pidgin_conv_window_remove_gtkconv(gtkconv->win, gtkconv);
+					pidgin_conv_window_add_gtkconv(win, gtkconv);
+				}
+			}
+
+			/* Make this conversation the active conversation */
+			pidgin_conv_window_switch_gtkconv(win, gtkconv);
+		}
+
+		gtk_drag_finish(dc, TRUE, (dc->action == GDK_ACTION_MOVE), t);
+	}
+	else if (sd->target == gdk_atom_intern("application/x-im-contact", FALSE))
+	{
+		char *protocol = NULL;
+		char *username = NULL;
+		PurpleAccount *account;
+		PidginConversation *gtkconv;
+
+		if (pidgin_parse_x_im_contact((const char *)sd->data, FALSE, &account,
+						&protocol, &username, NULL))
+		{
+			if (account == NULL)
+			{
+				purple_notify_error(win, NULL,
+					_("You are not currently signed on with an account that "
+					  "can add that buddy."), NULL);
+			} else {
+				/*
+				 * If a buddy is dragged to a chat window of the same protocol,
+				 * invite him to the chat.
+				 */
+				if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT &&
+						prpl_info && PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, chat_invite) &&
+						strcmp(purple_account_get_protocol_id(convaccount), protocol) == 0) {
+					purple_conv_chat_invite_user(PURPLE_CONV_CHAT(conv), username, NULL, TRUE);
+				} else {
+					c = purple_conversation_new(PURPLE_CONV_TYPE_IM, account, username);
+					gtkconv = PIDGIN_CONVERSATION(c);
+					if (gtkconv->win != win) {
+						pidgin_conv_window_remove_gtkconv(gtkconv->win, gtkconv);
+						pidgin_conv_window_add_gtkconv(win, gtkconv);
+					}
+				}
+			}
+		}
+
+		g_free(username);
+		g_free(protocol);
+
+		gtk_drag_finish(dc, TRUE, (dc->action == GDK_ACTION_MOVE), t);
+	}
+	else if (sd->target == gdk_atom_intern("text/uri-list", FALSE)) {
+		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+			pidgin_dnd_file_manage(sd, convaccount, purple_conversation_get_name(conv));
+		gtk_drag_finish(dc, TRUE, (dc->action == GDK_ACTION_MOVE), t);
+	}
+	else
+		gtk_drag_finish(dc, FALSE, FALSE, t);
+}
+
+
+static const GtkTargetEntry te[] =
+{
+	GTK_IMHTML_DND_TARGETS,
+	{"PURPLE_BLIST_NODE", GTK_TARGET_SAME_APP, GTK_IMHTML_DRAG_NUM},
+	{"application/x-im-contact", 0, GTK_IMHTML_DRAG_NUM + 1}
+};
+
+static PidginConversation *
+pidgin_conv_find_gtkconv(PurpleConversation * conv)
+{
+	PurpleBuddy *bud = purple_find_buddy(conv->account, conv->name);
+	PurpleContact *c;
+	PurpleBlistNode *cn, *bn;
+
+	if (!bud)
+		return NULL;
+
+	if (!(c = purple_buddy_get_contact(bud)))
+		return NULL;
+
+	cn = PURPLE_BLIST_NODE(c);
+	for (bn = purple_blist_node_get_first_child(cn); bn; bn = purple_blist_node_get_sibling_next(bn)) {
+		PurpleBuddy *b = PURPLE_BUDDY(bn);
+		PurpleConversation *conv;
+		if ((conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, b->name, b->account))) {
+			if (conv->ui_data)
+				return conv->ui_data;
+		}
+	}
+
+	return NULL;
+}
+
+static void
+buddy_update_cb(PurpleBlistNode *bnode, gpointer null)
+{
+	GList *list;
+
+	g_return_if_fail(bnode);
+	if (!PURPLE_BLIST_NODE_IS_BUDDY(bnode))
+		return;
+
+	for (list = pidgin_conv_windows_get_list(); list; list = list->next)
+	{
+		PidginWindow *win = list->data;
+		PurpleConversation *conv = pidgin_conv_window_get_active_conversation(win);
+
+		if (purple_conversation_get_type(conv) != PURPLE_CONV_TYPE_IM)
+			continue;
+
+		pidgin_conv_update_fields(conv, PIDGIN_CONV_MENU);
+	}
+}
+
+static gboolean
+ignore_middle_click(GtkWidget *widget, GdkEventButton *e, gpointer null)
+{
+	/* A click on the pane is propagated to the notebook containing the pane.
+	 * So if Stu accidentally aims high and middle clicks on the pane-handle,
+	 * it causes a conversation tab to close. Let's stop that from happening.
+	 */
+	if (e->button == 2 && e->type == GDK_BUTTON_PRESS)
+		return TRUE;
+	return FALSE;
+}
+
+static void set_typing_font(GtkWidget *widget, GtkStyle *style, PidginConversation *gtkconv)
+{
+	static PangoFontDescription *font_desc = NULL;
+	static GdkColor *color = NULL;
+	static gboolean enable = TRUE;
+
+	if (font_desc == NULL) {
+		char *string = NULL;
+		gtk_widget_style_get(widget,
+				"typing-notification-font", &string,
+				"typing-notification-color", &color,
+				"typing-notification-enable", &enable,
+				NULL);
+		font_desc = pango_font_description_from_string(string);
+		g_free(string);
+		if (color == NULL) {
+			GdkColor def = {0, 0x8888, 0x8888, 0x8888};
+			color = gdk_color_copy(&def);
+		}
+	}
+
+	gtk_text_buffer_create_tag(GTK_IMHTML(widget)->text_buffer, "TYPING-NOTIFICATION",
+			"foreground-gdk", color,
+			"font-desc", font_desc,
+			NULL);
+
+	if (!enable) {
+		g_object_set_data(G_OBJECT(widget), "disable-typing-notification", GINT_TO_POINTER(TRUE));
+		/* or may be 'gtkconv->disable_typing = TRUE;' instead? */
+	}
+
+	g_signal_handlers_disconnect_by_func(G_OBJECT(widget), set_typing_font, gtkconv);
+}
+
+/**************************************************************************
+ * Conversation UI operations
+ **************************************************************************/
+static void
+private_gtkconv_new(PurpleConversation *conv, gboolean hidden)
+{
+	PidginConversation *gtkconv;
+	PurpleConversationType conv_type = purple_conversation_get_type(conv);
+	GtkWidget *pane = NULL;
+	GtkWidget *tab_cont;
+	PurpleBlistNode *convnode;
+	PurpleValue *value;
+
+	if (conv_type == PURPLE_CONV_TYPE_IM && (gtkconv = pidgin_conv_find_gtkconv(conv))) {
+		conv->ui_data = gtkconv;
+		if (!g_list_find(gtkconv->convs, conv))
+			gtkconv->convs = g_list_prepend(gtkconv->convs, conv);
+		pidgin_conv_switch_active_conversation(conv);
+		return;
+	}
+
+	gtkconv = g_new0(PidginConversation, 1);
+	conv->ui_data = gtkconv;
+	gtkconv->active_conv = conv;
+	gtkconv->convs = g_list_prepend(gtkconv->convs, conv);
+	gtkconv->send_history = g_list_append(NULL, NULL);
+
+	/* Setup some initial variables. */
+	gtkconv->tooltips = gtk_tooltips_new();
+	gtkconv->unseen_state = PIDGIN_UNSEEN_NONE;
+	gtkconv->unseen_count = 0;
+
+	if (conv_type == PURPLE_CONV_TYPE_IM) {
+		gtkconv->u.im = g_malloc0(sizeof(PidginImPane));
+	} else if (conv_type == PURPLE_CONV_TYPE_CHAT) {
+		gtkconv->u.chat = g_malloc0(sizeof(PidginChatPane));
+	}
+	pane = setup_common_pane(gtkconv);
+
+	gtk_imhtml_set_format_functions(GTK_IMHTML(gtkconv->imhtml),
+			gtk_imhtml_get_format_functions(GTK_IMHTML(gtkconv->imhtml)) | GTK_IMHTML_IMAGE);
+
+	if (pane == NULL) {
+		if (conv_type == PURPLE_CONV_TYPE_CHAT)
+			g_free(gtkconv->u.chat);
+		else if (conv_type == PURPLE_CONV_TYPE_IM)
+			g_free(gtkconv->u.im);
+
+		g_free(gtkconv);
+		conv->ui_data = NULL;
+		return;
+	}
+
+	/* Setup drag-and-drop */
+	gtk_drag_dest_set(pane,
+	                  GTK_DEST_DEFAULT_MOTION |
+	                  GTK_DEST_DEFAULT_DROP,
+	                  te, sizeof(te) / sizeof(GtkTargetEntry),
+	                  GDK_ACTION_COPY);
+	gtk_drag_dest_set(pane,
+	                  GTK_DEST_DEFAULT_MOTION |
+	                  GTK_DEST_DEFAULT_DROP,
+	                  te, sizeof(te) / sizeof(GtkTargetEntry),
+	                  GDK_ACTION_COPY);
+	gtk_drag_dest_set(gtkconv->imhtml, 0,
+	                  te, sizeof(te) / sizeof(GtkTargetEntry),
+	                  GDK_ACTION_COPY);
+
+	gtk_drag_dest_set(gtkconv->entry, 0,
+	                  te, sizeof(te) / sizeof(GtkTargetEntry),
+	                  GDK_ACTION_COPY);
+
+	g_signal_connect(G_OBJECT(pane), "button_press_event",
+	                 G_CALLBACK(ignore_middle_click), NULL);
+	g_signal_connect(G_OBJECT(pane), "drag_data_received",
+	                 G_CALLBACK(conv_dnd_recv), gtkconv);
+	g_signal_connect(G_OBJECT(gtkconv->imhtml), "drag_data_received",
+	                 G_CALLBACK(conv_dnd_recv), gtkconv);
+	g_signal_connect(G_OBJECT(gtkconv->entry), "drag_data_received",
+	                 G_CALLBACK(conv_dnd_recv), gtkconv);
+
+	g_signal_connect(gtkconv->imhtml, "style-set", G_CALLBACK(set_typing_font), gtkconv);
+
+	/* Setup the container for the tab. */
+	gtkconv->tab_cont = tab_cont = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	g_object_set_data(G_OBJECT(tab_cont), "PidginConversation", gtkconv);
+	gtk_container_set_border_width(GTK_CONTAINER(tab_cont), PIDGIN_HIG_BOX_SPACE);
+	gtk_container_add(GTK_CONTAINER(tab_cont), pane);
+	gtk_widget_show(pane);
+
+	convnode = get_conversation_blist_node(conv);
+	if (convnode == NULL || !purple_blist_node_get_bool(convnode, "gtk-mute-sound"))
+		gtkconv->make_sound = TRUE;
+
+	if (convnode != NULL &&
+	    (value = g_hash_table_lookup(convnode->settings, "enable-logging")) &&
+	    purple_value_get_type(value) == PURPLE_TYPE_BOOLEAN)
+	{
+		purple_conversation_set_logging(conv, purple_value_get_boolean(value));
+	}
+
+	if (purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/show_formatting_toolbar"))
+		gtk_widget_show(gtkconv->toolbar);
+	else
+		gtk_widget_hide(gtkconv->toolbar);
+
+	if (purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/im/show_buddy_icons"))
+		gtk_widget_show(gtkconv->infopane_hbox);
+	else
+		gtk_widget_hide(gtkconv->infopane_hbox);
+
+	gtk_imhtml_show_comments(GTK_IMHTML(gtkconv->imhtml),
+		purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/show_timestamps"));
+	gtk_imhtml_set_protocol_name(GTK_IMHTML(gtkconv->imhtml),
+								 purple_account_get_protocol_name(conv->account));
+
+	g_signal_connect_swapped(G_OBJECT(pane), "focus",
+	                         G_CALLBACK(gtk_widget_grab_focus),
+	                         gtkconv->entry);
+
+	if (hidden)
+		pidgin_conv_window_add_gtkconv(hidden_convwin, gtkconv);
+	else
+		pidgin_conv_placement_place(gtkconv);
+
+	if (nick_colors == NULL) {
+		nbr_nick_colors = NUM_NICK_COLORS;
+		nick_colors = generate_nick_colors(&nbr_nick_colors, gtk_widget_get_style(gtkconv->imhtml)->base[GTK_STATE_NORMAL]);
+	}
+
+	if (conv->features & PURPLE_CONNECTION_ALLOW_CUSTOM_SMILEY)
+		pidgin_themes_smiley_themeize_custom(gtkconv->entry);
+}
+
+static void
+pidgin_conv_new_hidden(PurpleConversation *conv)
+{
+	private_gtkconv_new(conv, TRUE);
+}
+
+void
+pidgin_conv_new(PurpleConversation *conv)
+{
+	private_gtkconv_new(conv, FALSE);
+	if (PIDGIN_IS_PIDGIN_CONVERSATION(conv))
+		purple_signal_emit(pidgin_conversations_get_handle(),
+				"conversation-displayed", PIDGIN_CONVERSATION(conv));
+}
+
+static void
+received_im_msg_cb(PurpleAccount *account, char *sender, char *message,
+				   PurpleConversation *conv, PurpleMessageFlags flags)
+{
+	PurpleConversationUiOps *ui_ops = pidgin_conversations_get_conv_ui_ops();
+	gboolean hide = FALSE;
+	guint timer;
+
+	/* create hidden conv if hide_new pref is always */
+	if (strcmp(purple_prefs_get_string(PIDGIN_PREFS_ROOT "/conversations/im/hide_new"), "always") == 0)
+		hide = TRUE;
+
+	/* create hidden conv if hide_new pref is away and account is away */
+	if (strcmp(purple_prefs_get_string(PIDGIN_PREFS_ROOT "/conversations/im/hide_new"), "away") == 0 &&
+	    !purple_status_is_available(purple_account_get_active_status(account)))
+		hide = TRUE;
+
+	if (conv && PIDGIN_IS_PIDGIN_CONVERSATION(conv) && !hide) {
+		PidginConversation *gtkconv = PIDGIN_CONVERSATION(conv);
+		if (gtkconv->win == hidden_convwin) {
+			pidgin_conv_attach_to_conversation(gtkconv->active_conv);
+		}
+		return;
+	}
+
+	if (hide) {
+		ui_ops->create_conversation = pidgin_conv_new_hidden;
+		purple_conversation_new(PURPLE_CONV_TYPE_IM, account, sender);
+		ui_ops->create_conversation = pidgin_conv_new;
+	}
+
+	/* Somebody wants to keep this conversation around, so don't time it out */
+	if (conv) {
+		timer = GPOINTER_TO_INT(purple_conversation_get_data(conv, "close-timer"));
+		if (timer) {
+			purple_timeout_remove(timer);
+			purple_conversation_set_data(conv, "close-timer", GINT_TO_POINTER(0));
+		}
+	}
+}
+
+static void
+pidgin_conv_destroy(PurpleConversation *conv)
+{
+	PidginConversation *gtkconv = PIDGIN_CONVERSATION(conv);
+
+	gtkconv->convs = g_list_remove(gtkconv->convs, conv);
+	/* Don't destroy ourselves until all our convos are gone */
+	if (gtkconv->convs) {
+		/* Make sure the destroyed conversation is not the active one */
+		if (gtkconv->active_conv == conv) {
+			gtkconv->active_conv = gtkconv->convs->data;
+			purple_conversation_update(gtkconv->active_conv, PURPLE_CONV_UPDATE_FEATURES);
+		}
+		return;
+	}
+
+	pidgin_conv_window_remove_gtkconv(gtkconv->win, gtkconv);
+
+	/* If the "Save Conversation" or "Save Icon" dialogs are open then close them */
+	purple_request_close_with_handle(gtkconv);
+	purple_notify_close_with_handle(gtkconv);
+
+	gtk_widget_destroy(gtkconv->tab_cont);
+	g_object_unref(gtkconv->tab_cont);
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		if (gtkconv->u.im->icon_timer != 0)
+			g_source_remove(gtkconv->u.im->icon_timer);
+
+		if (gtkconv->u.im->anim != NULL)
+			g_object_unref(G_OBJECT(gtkconv->u.im->anim));
+
+		if (gtkconv->u.im->typing_timer != 0)
+			g_source_remove(gtkconv->u.im->typing_timer);
+
+		g_free(gtkconv->u.im);
+	} else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+		purple_signals_disconnect_by_handle(gtkconv->u.chat);
+		g_free(gtkconv->u.chat);
+	}
+
+	gtk_object_sink(GTK_OBJECT(gtkconv->tooltips));
+
+	gtkconv->send_history = g_list_first(gtkconv->send_history);
+	g_list_foreach(gtkconv->send_history, (GFunc)g_free, NULL);
+	g_list_free(gtkconv->send_history);
+
+	if (gtkconv->attach.timer) {
+		g_source_remove(gtkconv->attach.timer);
+	}
+
+	g_free(gtkconv);
+}
+
+
+static void
+pidgin_conv_write_im(PurpleConversation *conv, const char *who,
+					  const char *message, PurpleMessageFlags flags,
+					  time_t mtime)
+{
+	PidginConversation *gtkconv;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+
+	if (conv != gtkconv->active_conv &&
+	    flags & PURPLE_MESSAGE_ACTIVE_ONLY)
+	{
+		/* Plugins that want these messages suppressed should be
+		 * calling purple_conv_im_write(), so they get suppressed here,
+		 * before being written to the log. */
+		purple_debug_info("gtkconv",
+		                "Suppressing message for an inactive conversation in pidgin_conv_write_im()\n");
+		return;
+	}
+
+	purple_conversation_write(conv, who, message, flags, mtime);
+}
+
+static const char *
+get_text_tag_color(GtkTextTag *tag)
+{
+	GdkColor *color = NULL;
+	gboolean set = FALSE;
+	static char colcode[] = "#XXXXXX";
+	if (tag)
+		g_object_get(G_OBJECT(tag), "foreground-set", &set, "foreground-gdk", &color, NULL);
+	if (set && color)
+		g_snprintf(colcode, sizeof(colcode), "#%02x%02x%02x",
+				color->red >> 8, color->green >> 8, color->blue >> 8);
+	else
+		colcode[0] = '\0';
+	if (color)
+		gdk_color_free(color);
+	return colcode;
+}
+
+/* The callback for an event on a link tag. */
+static gboolean buddytag_event(GtkTextTag *tag, GObject *imhtml,
+		GdkEvent *event, GtkTextIter *arg2, gpointer data)
+{
+	if (event->type == GDK_BUTTON_PRESS
+			|| event->type == GDK_2BUTTON_PRESS) {
+		GdkEventButton *btn_event = (GdkEventButton*) event;
+		PurpleConversation *conv = data;
+		char *buddyname;
+
+		/* strlen("BUDDY " or "HILIT ") == 6 */
+		g_return_val_if_fail((tag->name != NULL)
+				&& (strlen(tag->name) > 6), FALSE);
+
+		buddyname = (tag->name) + 6;
+
+		/* emit chat-nick-clicked signal */
+		if (event->type == GDK_BUTTON_PRESS) {
+			gint plugin_return = GPOINTER_TO_INT(purple_signal_emit_return_1(
+						pidgin_conversations_get_handle(), "chat-nick-clicked",
+						data, buddyname, btn_event->button));
+			if (plugin_return)
+				return TRUE;
+		}
+
+		if (btn_event->button == 1 &&
+				event->type == GDK_2BUTTON_PRESS) {
+			chat_do_im(PIDGIN_CONVERSATION(conv), buddyname);
+			return TRUE;
+		} else if (btn_event->button == 2
+				&& event->type == GDK_2BUTTON_PRESS) {
+			chat_do_info(PIDGIN_CONVERSATION(conv), buddyname);
+
+			return TRUE;
+		} else if (btn_event->button == 3
+				&& event->type == GDK_BUTTON_PRESS) {
+			GtkTextIter start, end;
+
+			/* we shouldn't display the popup
+			 * if the user has selected something: */
+			if (!gtk_text_buffer_get_selection_bounds(
+						gtk_text_iter_get_buffer(arg2),
+						&start, &end)) {
+				GtkWidget *menu = NULL;
+				PurpleConnection *gc =
+					purple_conversation_get_gc(conv);
+
+
+				menu = create_chat_menu(conv, buddyname, gc);
+				gtk_menu_popup(GTK_MENU(menu), NULL, NULL,
+						NULL, GTK_WIDGET(imhtml),
+						btn_event->button,
+						btn_event->time);
+
+				/* Don't propagate the event any further */
+				return TRUE;
+			}
+		}
+	}
+
+	return FALSE;
+}
+
+static GtkTextTag *get_buddy_tag(PurpleConversation *conv, const char *who, PurpleMessageFlags flag,
+		gboolean create)
+{
+	PidginConversation *gtkconv = PIDGIN_CONVERSATION(conv);
+	GtkTextTag *buddytag;
+	gchar *str;
+	gboolean highlight = (flag & PURPLE_MESSAGE_NICK);
+	GtkTextBuffer *buffer = GTK_IMHTML(gtkconv->imhtml)->text_buffer;
+
+	str = g_strdup_printf(highlight ? "HILIT %s" : "BUDDY %s", who);
+
+	buddytag = gtk_text_tag_table_lookup(
+			gtk_text_buffer_get_tag_table(buffer), str);
+
+	if (buddytag == NULL && create) {
+		if (highlight)
+			buddytag = gtk_text_buffer_create_tag(buffer, str,
+					"foreground", get_text_tag_color(gtk_text_tag_table_lookup(
+							gtk_text_buffer_get_tag_table(buffer), "highlight-name")),
+					"weight", PANGO_WEIGHT_BOLD,
+					NULL);
+		else
+			buddytag = gtk_text_buffer_create_tag(
+					buffer, str,
+					"foreground-gdk", get_nick_color(gtkconv, who),
+					"weight", purple_find_buddy(purple_conversation_get_account(conv), who) ? PANGO_WEIGHT_BOLD : PANGO_WEIGHT_NORMAL,
+					NULL);
+
+		g_object_set_data(G_OBJECT(buddytag), "cursor", "");
+		g_signal_connect(G_OBJECT(buddytag), "event",
+				G_CALLBACK(buddytag_event), conv);
+	}
+
+	g_free(str);
+
+	return buddytag;
+}
+
+static void pidgin_conv_calculate_newday(PidginConversation *gtkconv, time_t mtime)
+{
+	struct tm *tm = localtime(&mtime);
+
+	tm->tm_hour = tm->tm_min = tm->tm_sec = 0;
+	tm->tm_mday++;
+
+	gtkconv->newday = mktime(tm);
+}
+
+/* Detect string direction and encapsulate the string in RLE/LRE/PDF unicode characters
+   str - pointer to string (string is re-allocated and the pointer updated) */
+static void
+str_embed_direction_chars(char **str)
+{
+#ifdef HAVE_PANGO14
+	char pre_str[4];
+	char post_str[10];
+	char *ret;
+
+	if (PANGO_DIRECTION_RTL == pango_find_base_dir(*str, -1))
+	{
+		sprintf(pre_str, "%c%c%c",
+				0xE2, 0x80, 0xAB);	/* RLE */
+		sprintf(post_str, "%c%c%c%c%c%c%c%c%c",
+				0xE2, 0x80, 0xAC,	/* PDF */
+				0xE2, 0x80, 0x8E,	/* LRM */
+				0xE2, 0x80, 0xAC);	/* PDF */
+	}
+	else
+	{
+		sprintf(pre_str, "%c%c%c",
+				0xE2, 0x80, 0xAA);	/* LRE */
+		sprintf(post_str, "%c%c%c%c%c%c%c%c%c",
+				0xE2, 0x80, 0xAC,	/* PDF */
+				0xE2, 0x80, 0x8F,	/* RLM */
+				0xE2, 0x80, 0xAC);	/* PDF */
+	}
+
+	ret = g_strconcat(pre_str, *str, post_str, NULL);
+
+	g_free(*str);
+	*str = ret;
+#endif
+}
+
+static void
+pidgin_conv_write_conv(PurpleConversation *conv, const char *name, const char *alias,
+						const char *message, PurpleMessageFlags flags,
+						time_t mtime)
+{
+	PidginConversation *gtkconv;
+	PurpleConnection *gc;
+	PurpleAccount *account;
+	int gtk_font_options = 0;
+	int gtk_font_options_all = 0;
+	int max_scrollback_lines;
+	int line_count;
+	char buf2[BUF_LONG];
+	gboolean show_date;
+	char *mdate;
+	char *str;
+	char *with_font_tag;
+	char *sml_attrib = NULL;
+	size_t length;
+	PurpleConversationType type;
+	char *displaying;
+	gboolean plugin_return;
+	char *bracket;
+	int tag_count = 0;
+	gboolean is_rtl_message = FALSE;
+
+	g_return_if_fail(conv != NULL);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	g_return_if_fail(gtkconv != NULL);
+
+	if (gtkconv->attach.timer) {
+		/* We are currently in the process of filling up the buffer with the message
+		 * history of the conversation. So we do not need to add the message here.
+		 * Instead, this message will be added to the message-list, which in turn will
+		 * be processed and displayed by the attach-callback.
+		 */
+		return;
+	}
+
+	if (conv != gtkconv->active_conv)
+	{
+		if (flags & PURPLE_MESSAGE_ACTIVE_ONLY)
+		{
+			/* Unless this had PURPLE_MESSAGE_NO_LOG, this message
+			 * was logged.  Plugin writers: if this isn't what
+			 * you wanted, call purple_conv_im_write() instead of
+			 * purple_conversation_write(). */
+			purple_debug_info("gtkconv",
+			                "Suppressing message for an inactive conversation in pidgin_conv_write_conv()\n");
+			return;
+		}
+
+		/* Set the active conversation to the one that just messaged us. */
+		/* TODO: consider not doing this if the account is offline or something */
+		if (flags & (PURPLE_MESSAGE_SEND | PURPLE_MESSAGE_RECV))
+			pidgin_conv_switch_active_conversation(conv);
+	}
+
+	type = purple_conversation_get_type(conv);
+	account = purple_conversation_get_account(conv);
+	g_return_if_fail(account != NULL);
+	gc = purple_account_get_connection(account);
+	g_return_if_fail(gc != NULL || !(flags & (PURPLE_MESSAGE_SEND | PURPLE_MESSAGE_RECV)));
+
+	/* Make sure URLs are clickable */
+	if(flags & PURPLE_MESSAGE_NO_LINKIFY)
+		displaying = g_strdup(message);
+	else
+		displaying = purple_markup_linkify(message);
+
+	plugin_return = GPOINTER_TO_INT(purple_signal_emit_return_1(
+							pidgin_conversations_get_handle(), (type == PURPLE_CONV_TYPE_IM ?
+							"displaying-im-msg" : "displaying-chat-msg"),
+							account, name, &displaying, conv, flags));
+	if (plugin_return)
+	{
+		g_free(displaying);
+		return;
+	}
+	length = strlen(displaying) + 1;
+
+	/* Awful hack to work around GtkIMHtml's inefficient rendering of messages with lots of formatting changes.
+	 * If a message has over 100 '<' characters, strip formatting before appending it. Hopefully nobody actually
+	 * needs that much formatting, anyway.
+	 */
+	for (bracket = strchr(displaying, '<'); bracket && *(bracket + 1); bracket = strchr(bracket + 1, '<'))
+		tag_count++;
+
+	if (tag_count > 100) {
+		char *tmp = displaying;
+		displaying = purple_markup_strip_html(tmp);
+		g_free(tmp);
+	}
+
+	line_count = gtk_text_buffer_get_line_count(
+			gtk_text_view_get_buffer(GTK_TEXT_VIEW(
+				gtkconv->imhtml)));
+
+	max_scrollback_lines = purple_prefs_get_int(
+		PIDGIN_PREFS_ROOT "/conversations/scrollback_lines");
+	/* If we're sitting at more than 100 lines more than the
+	   max scrollback, trim down to max scrollback */
+	if (max_scrollback_lines > 0
+			&& line_count > (max_scrollback_lines + 100)) {
+		GtkTextBuffer *text_buffer = gtk_text_view_get_buffer(
+			GTK_TEXT_VIEW(gtkconv->imhtml));
+		GtkTextIter start, end;
+
+		gtk_text_buffer_get_start_iter(text_buffer, &start);
+		gtk_text_buffer_get_iter_at_line(text_buffer, &end,
+			(line_count - max_scrollback_lines));
+		gtk_imhtml_delete(GTK_IMHTML(gtkconv->imhtml), &start, &end);
+	}
+
+	if (type == PURPLE_CONV_TYPE_CHAT)
+	{
+		/* Create anchor for user */
+		GtkTextIter iter;
+		char *tmp = g_strconcat("user:", name, NULL);
+
+		gtk_text_buffer_get_end_iter(gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->imhtml)), &iter);
+		gtk_text_buffer_create_mark(gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->imhtml)),
+								tmp, &iter, TRUE);
+		g_free(tmp);
+	}
+
+	if (purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/use_smooth_scrolling"))
+		gtk_font_options_all |= GTK_IMHTML_USE_SMOOTHSCROLLING;
+
+	if (gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->imhtml))))
+		gtk_imhtml_append_text(GTK_IMHTML(gtkconv->imhtml), "<BR>", gtk_font_options_all | GTK_IMHTML_NO_SCROLL);
+
+	/* First message in a conversation. */
+	if (gtkconv->newday == 0)
+		pidgin_conv_calculate_newday(gtkconv, mtime);
+
+	/* Show the date on the first message in a new day, or if the message is
+	 * older than 20 minutes. */
+	show_date = (mtime >= gtkconv->newday) || (time(NULL) > mtime + 20*60);
+
+	mdate = purple_signal_emit_return_1(pidgin_conversations_get_handle(),
+	                                  "conversation-timestamp",
+	                                  conv, mtime, show_date);
+
+	if (mdate == NULL)
+	{
+		struct tm *tm = localtime(&mtime);
+		const char *tmp;
+		if (show_date)
+			tmp = purple_date_format_long(tm);
+		else
+			tmp = purple_time_format(tm);
+		mdate = g_strdup_printf("(%s)", tmp);
+	}
+
+	/* Bi-Directional support - set timestamp direction using unicode characters */
+	is_rtl_message = purple_markup_is_rtl(message);
+	/* Enforce direction only if message is RTL - doesn't effect LTR users */
+	if (is_rtl_message)
+		str_embed_direction_chars(&mdate);
+
+	if (mtime >= gtkconv->newday)
+		pidgin_conv_calculate_newday(gtkconv, mtime);
+
+	sml_attrib = g_strdup_printf("sml=\"%s\"", purple_account_get_protocol_name(account));
+
+	gtk_font_options |= GTK_IMHTML_NO_COMMENTS;
+
+	if ((flags & PURPLE_MESSAGE_RECV) &&
+			!purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/show_incoming_formatting"))
+		gtk_font_options |= GTK_IMHTML_NO_COLOURS | GTK_IMHTML_NO_FONTS | GTK_IMHTML_NO_SIZES | GTK_IMHTML_NO_FORMATTING;
+
+	/* this is gonna crash one day, I can feel it. */
+	if (PURPLE_PLUGIN_PROTOCOL_INFO(purple_find_prpl(purple_account_get_protocol_id(conv->account)))->options &
+	    OPT_PROTO_USE_POINTSIZE) {
+		gtk_font_options |= GTK_IMHTML_USE_POINTSIZE;
+	}
+
+	if (!(flags & PURPLE_MESSAGE_RECV) && (conv->features & PURPLE_CONNECTION_ALLOW_CUSTOM_SMILEY))
+	{
+		/* We want to see our own smileys. Need to revert it after send*/
+		pidgin_themes_smiley_themeize_custom(gtkconv->imhtml);
+	}
+
+	/* TODO: These colors should not be hardcoded so log.c can use them */
+	if (flags & PURPLE_MESSAGE_RAW) {
+		gtk_imhtml_append_text(GTK_IMHTML(gtkconv->imhtml), message, gtk_font_options_all);
+	} else if (flags & PURPLE_MESSAGE_SYSTEM) {
+		g_snprintf(buf2, sizeof(buf2),
+			   "<FONT %s><FONT SIZE=\"2\"><!--%s --></FONT><B>%s</B></FONT>",
+			   sml_attrib ? sml_attrib : "", mdate, displaying);
+
+		gtk_imhtml_append_text(GTK_IMHTML(gtkconv->imhtml), buf2, gtk_font_options_all);
+
+	} else if (flags & PURPLE_MESSAGE_ERROR) {
+		g_snprintf(buf2, sizeof(buf2),
+			   "<FONT COLOR=\"#ff0000\"><FONT %s><FONT SIZE=\"2\"><!--%s --></FONT><B>%s</B></FONT></FONT>",
+			   sml_attrib ? sml_attrib : "", mdate, displaying);
+
+		gtk_imhtml_append_text(GTK_IMHTML(gtkconv->imhtml), buf2, gtk_font_options_all);
+
+	} else if (flags & PURPLE_MESSAGE_NO_LOG) {
+		g_snprintf(buf2, BUF_LONG,
+			   "<B><FONT %s COLOR=\"#777777\">%s</FONT></B>",
+			   sml_attrib ? sml_attrib : "", displaying);
+
+		gtk_imhtml_append_text(GTK_IMHTML(gtkconv->imhtml), buf2, gtk_font_options_all);
+	} else {
+		char *new_message = g_memdup(displaying, length);
+		char *alias_escaped = (alias ? g_markup_escape_text(alias, strlen(alias)) : g_strdup(""));
+		/* The initial offset is to deal with
+		 * escaped entities making the string longer */
+		int tag_start_offset = 0;
+		const char *tagname = NULL;
+
+		GtkTextIter start, end;
+		GtkTextMark *mark;
+		GtkTextTag *tag;
+		GtkTextBuffer *buffer = GTK_IMHTML(gtkconv->imhtml)->text_buffer;
+
+		/* Enforce direction on alias */
+		if (is_rtl_message)
+			str_embed_direction_chars(&alias_escaped);
+
+		str = g_malloc(1024);
+		if (flags & PURPLE_MESSAGE_WHISPER) {
+			/* If we're whispering, it's not an autoresponse. */
+			if (purple_message_meify(new_message, -1 )) {
+				g_snprintf(str, 1024, "***%s", alias_escaped);
+				tag_start_offset += 3;
+				tagname = "whisper-action-name";
+			}
+			else {
+				g_snprintf(str, 1024, "*%s*:", alias_escaped);
+				tag_start_offset += 1;
+#if 0
+				tag_end_offset = 2;
+#endif
+				tagname = "whisper-name";
+			}
+		} else {
+			if (purple_message_meify(new_message, -1)) {
+				if (flags & PURPLE_MESSAGE_AUTO_RESP) {
+					g_snprintf(str, 1024, "%s ***%s", AUTO_RESPONSE, alias_escaped);
+					tag_start_offset += strlen(AUTO_RESPONSE) - 6 + 4;
+				} else {
+					g_snprintf(str, 1024, "***%s", alias_escaped);
+					tag_start_offset += 3;
+				}
+
+				if (flags & PURPLE_MESSAGE_NICK)
+					tagname = "highlight-name";
+				else
+					tagname = "action-name";
+			} else {
+				if (flags & PURPLE_MESSAGE_AUTO_RESP) {
+					g_snprintf(str, 1024, "%s %s", alias_escaped, AUTO_RESPONSE);
+					tag_start_offset += strlen(AUTO_RESPONSE) - 6 + 1;
+				} else {
+					g_snprintf(str, 1024, "%s:", alias_escaped);
+#if 0
+					tag_end_offset = 1;
+#endif
+				}
+
+				if (flags & PURPLE_MESSAGE_NICK) {
+					if (type == PURPLE_CONV_TYPE_IM) {
+						tagname = "highlight-name";
+					}
+				} else if (flags & PURPLE_MESSAGE_RECV) {
+					/* The tagname for chats is handled by get_buddy_tag */
+					if (type == PURPLE_CONV_TYPE_IM) {
+						tagname = "receive-name";
+					}
+				} else if (flags & PURPLE_MESSAGE_SEND) {
+					tagname = "send-name";
+				} else {
+					purple_debug_error("gtkconv", "message missing flags\n");
+				}
+			}
+		}
+
+		g_free(alias_escaped);
+
+		if (tagname)
+			tag = gtk_text_tag_table_lookup(gtk_text_buffer_get_tag_table(buffer), tagname);
+		else
+			tag = get_buddy_tag(conv, name, flags, TRUE);
+
+		if (GTK_IMHTML(gtkconv->imhtml)->show_comments) {
+			/* The color for the timestamp has to be set in the font-tags, unfortunately.
+			 * Applying the nick-tag to timestamps would work, but that can make it
+			 * bold. I thought applying the "comment" tag again, which has "weight" set
+			 * to PANGO_WEIGHT_NORMAL, would remove the boldness. But it doesn't. So
+			 * this will have to do. I don't terribly like it.  -- sadrul */
+			const char *color = get_text_tag_color(tag);
+			g_snprintf(buf2, BUF_LONG, "<FONT %s%s%s SIZE=\"2\"><!--%s --></FONT>",
+					color ? "COLOR=\"" : "", color ? color : "", color ? "\"" : "", mdate);
+			gtk_imhtml_append_text(GTK_IMHTML(gtkconv->imhtml), buf2, gtk_font_options_all | GTK_IMHTML_NO_SCROLL);
+		}
+
+		gtk_text_buffer_get_end_iter(buffer, &end);
+		mark = gtk_text_buffer_create_mark(buffer, NULL, &end, TRUE);
+
+		g_snprintf(buf2, BUF_LONG, "<FONT %s>%s</FONT> ", sml_attrib ? sml_attrib : "", str);
+		gtk_imhtml_append_text(GTK_IMHTML(gtkconv->imhtml), buf2, gtk_font_options_all | GTK_IMHTML_NO_SCROLL);
+
+		gtk_text_buffer_get_end_iter(buffer, &end);
+		gtk_text_buffer_get_iter_at_mark(buffer, &start, mark);
+		gtk_text_buffer_apply_tag(buffer, tag, &start, &end);
+		gtk_text_buffer_delete_mark(buffer, mark);
+
+		g_free(str);
+
+		if(gc){
+			char *pre = g_strdup_printf("<font %s>", sml_attrib ? sml_attrib : "");
+			char *post = "</font>";
+			int pre_len = strlen(pre);
+			int post_len = strlen(post);
+
+			with_font_tag = g_malloc(length + pre_len + post_len + 1);
+
+			strcpy(with_font_tag, pre);
+			memcpy(with_font_tag + pre_len, new_message, length);
+			strcpy(with_font_tag + pre_len + length, post);
+
+			length += pre_len + post_len;
+			g_free(pre);
+		} else
+			with_font_tag = g_memdup(new_message, length);
+
+		gtk_imhtml_append_text(GTK_IMHTML(gtkconv->imhtml),
+							 with_font_tag, gtk_font_options | gtk_font_options_all);
+
+		g_free(with_font_tag);
+		g_free(new_message);
+	}
+
+	g_free(mdate);
+	g_free(sml_attrib);
+
+	/* Tab highlighting stuff */
+	if (!(flags & PURPLE_MESSAGE_SEND) && !pidgin_conv_has_focus(conv))
+	{
+		PidginUnseenState unseen = PIDGIN_UNSEEN_NONE;
+
+		if ((flags & PURPLE_MESSAGE_NICK) == PURPLE_MESSAGE_NICK)
+			unseen = PIDGIN_UNSEEN_NICK;
+		else if (((flags & PURPLE_MESSAGE_SYSTEM) == PURPLE_MESSAGE_SYSTEM) ||
+			  ((flags & PURPLE_MESSAGE_ERROR) == PURPLE_MESSAGE_ERROR))
+			unseen = PIDGIN_UNSEEN_EVENT;
+		else if ((flags & PURPLE_MESSAGE_NO_LOG) == PURPLE_MESSAGE_NO_LOG)
+			unseen = PIDGIN_UNSEEN_NO_LOG;
+		else
+			unseen = PIDGIN_UNSEEN_TEXT;
+
+		gtkconv_set_unseen(gtkconv, unseen);
+	}
+
+	if (!(flags & PURPLE_MESSAGE_RECV) && (conv->features & PURPLE_CONNECTION_ALLOW_CUSTOM_SMILEY))
+	{
+		/* Restore the smiley-data */
+		pidgin_themes_smiley_themeize(gtkconv->imhtml);
+	}
+
+	purple_signal_emit(pidgin_conversations_get_handle(),
+		(type == PURPLE_CONV_TYPE_IM ? "displayed-im-msg" : "displayed-chat-msg"),
+		account, name, displaying, conv, flags);
+	g_free(displaying);
+	update_typing_message(gtkconv, NULL);
+}
+
+static gboolean get_iter_from_chatbuddy(PurpleConvChatBuddy *cb, GtkTreeIter *iter)
+{
+	GtkTreeRowReference *ref;
+	GtkTreePath *path;
+	GtkTreeModel *model;
+
+	g_return_val_if_fail(cb != NULL, FALSE);
+
+	ref = cb->ui_data;
+	if (!ref)
+		return FALSE;
+
+	if ((path = gtk_tree_row_reference_get_path(ref)) == NULL)
+		return FALSE;
+
+	model = gtk_tree_row_reference_get_model(ref);
+	if (!gtk_tree_model_get_iter(GTK_TREE_MODEL(model), iter, path)) {
+		gtk_tree_path_free(path);
+		return FALSE;
+	}
+
+	gtk_tree_path_free(path);
+	return TRUE;
+}
+
+static void
+pidgin_conv_chat_add_users(PurpleConversation *conv, GList *cbuddies, gboolean new_arrivals)
+{
+	PurpleConvChat *chat;
+	PidginConversation *gtkconv;
+	PidginChatPane *gtkchat;
+	GtkListStore *ls;
+	GList *l;
+
+	char tmp[BUF_LONG];
+	int num_users;
+
+	chat    = PURPLE_CONV_CHAT(conv);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	gtkchat = gtkconv->u.chat;
+
+	num_users = g_list_length(purple_conv_chat_get_users(chat));
+
+	g_snprintf(tmp, sizeof(tmp),
+			   ngettext("%d person in room", "%d people in room",
+						num_users),
+			   num_users);
+
+	gtk_label_set_text(GTK_LABEL(gtkchat->count), tmp);
+
+	ls = GTK_LIST_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list)));
+
+	gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(ls),  GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID,
+										 GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID);
+
+	l = cbuddies;
+	while (l != NULL) {
+		add_chat_buddy_common(conv, (PurpleConvChatBuddy *)l->data, NULL);
+		l = l->next;
+	}
+
+	/* Currently GTK+ maintains our sorted list after it's in the tree.
+	 * This may change if it turns out we can manage it faster ourselves.
+	 */
+	gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(ls),  CHAT_USERS_ALIAS_KEY_COLUMN,
+										 GTK_SORT_ASCENDING);
+}
+
+static void
+pidgin_conv_chat_rename_user(PurpleConversation *conv, const char *old_name,
+			      const char *new_name, const char *new_alias)
+{
+	PurpleConvChat *chat;
+	PidginConversation *gtkconv;
+	PidginChatPane *gtkchat;
+	PurpleConvChatBuddy *old_cbuddy, *new_cbuddy;
+	GtkTreeIter iter;
+	GtkTreeModel *model;
+	GtkTextTag *tag;
+
+	chat    = PURPLE_CONV_CHAT(conv);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	gtkchat = gtkconv->u.chat;
+
+	model = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+
+	if (!gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &iter))
+		return;
+
+	if ((tag = get_buddy_tag(conv, old_name, 0, FALSE)))
+		g_object_set(G_OBJECT(tag), "style", PANGO_STYLE_ITALIC, NULL);
+	if ((tag = get_buddy_tag(conv, old_name, PURPLE_MESSAGE_NICK, FALSE)))
+		g_object_set(G_OBJECT(tag), "style", PANGO_STYLE_ITALIC, NULL);
+
+	old_cbuddy = purple_conv_chat_cb_find(chat, old_name);
+	if (!old_cbuddy)
+		return;
+
+	if (get_iter_from_chatbuddy(old_cbuddy, &iter)) {
+		GtkTreeRowReference *ref = old_cbuddy->ui_data;
+
+		gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
+		gtk_tree_row_reference_free(ref);
+		old_cbuddy->ui_data = NULL;
+	}
+
+	g_return_if_fail(new_alias != NULL);
+
+	new_cbuddy = purple_conv_chat_cb_find(chat, new_name);
+
+	add_chat_buddy_common(conv, new_cbuddy, old_name);
+}
+
+static void
+pidgin_conv_chat_remove_users(PurpleConversation *conv, GList *users)
+{
+	PurpleConvChat *chat;
+	PidginConversation *gtkconv;
+	PidginChatPane *gtkchat;
+	GtkTreeIter iter;
+	GtkTreeModel *model;
+	GList *l;
+	char tmp[BUF_LONG];
+	int num_users;
+	gboolean f;
+	GtkTextTag *tag;
+
+	chat    = PURPLE_CONV_CHAT(conv);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	gtkchat = gtkconv->u.chat;
+
+	num_users = g_list_length(purple_conv_chat_get_users(chat));
+
+	for (l = users; l != NULL; l = l->next) {
+		model = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+
+		if (!gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &iter))
+			/* XXX: Break? */
+			continue;
+
+		do {
+			char *val;
+
+			gtk_tree_model_get(GTK_TREE_MODEL(model), &iter,
+							   CHAT_USERS_NAME_COLUMN, &val, -1);
+
+			if (!purple_utf8_strcasecmp((char *)l->data, val)) {
+				f = gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
+			}
+			else
+				f = gtk_tree_model_iter_next(GTK_TREE_MODEL(model), &iter);
+
+			g_free(val);
+		} while (f);
+
+		if ((tag = get_buddy_tag(conv, l->data, 0, FALSE)))
+			g_object_set(G_OBJECT(tag), "style", PANGO_STYLE_ITALIC, NULL);
+		if ((tag = get_buddy_tag(conv, l->data, PURPLE_MESSAGE_NICK, FALSE)))
+			g_object_set(G_OBJECT(tag), "style", PANGO_STYLE_ITALIC, NULL);
+	}
+
+	g_snprintf(tmp, sizeof(tmp),
+			   ngettext("%d person in room", "%d people in room",
+						num_users), num_users);
+
+	gtk_label_set_text(GTK_LABEL(gtkchat->count), tmp);
+}
+
+static void
+pidgin_conv_chat_update_user(PurpleConversation *conv, const char *user)
+{
+	PurpleConvChat *chat;
+	PurpleConvChatBuddy *cbuddy;
+	PidginConversation *gtkconv;
+	PidginChatPane *gtkchat;
+	GtkTreeIter iter;
+	GtkTreeModel *model;
+
+	chat    = PURPLE_CONV_CHAT(conv);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	gtkchat = gtkconv->u.chat;
+
+	model = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+
+	if (!gtk_tree_model_get_iter_first(GTK_TREE_MODEL(model), &iter))
+		return;
+
+	cbuddy = purple_conv_chat_cb_find(chat, user);
+	if (!cbuddy)
+		return;
+
+	if (get_iter_from_chatbuddy(cbuddy, &iter)) {
+		GtkTreeRowReference *ref = cbuddy->ui_data;
+		gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
+		gtk_tree_row_reference_free(ref);
+		cbuddy->ui_data = NULL;
+	}
+
+	if (cbuddy)
+		add_chat_buddy_common(conv, cbuddy, NULL);
+}
+
+gboolean
+pidgin_conv_has_focus(PurpleConversation *conv)
+{
+	PidginConversation *gtkconv = PIDGIN_CONVERSATION(conv);
+	PidginWindow *win;
+	gboolean has_focus;
+
+	win = gtkconv->win;
+
+	g_object_get(G_OBJECT(win->window), "has-toplevel-focus", &has_focus, NULL);
+
+	if (has_focus && pidgin_conv_window_is_active_conversation(conv))
+		return TRUE;
+
+	return FALSE;
+}
+
+static gboolean
+add_custom_smiley_for_imhtml(GtkIMHtml *imhtml, const char *sml, const char *smile)
+{
+	GtkIMHtmlSmiley *smiley;
+
+	smiley = gtk_imhtml_smiley_get(imhtml, sml, smile);
+
+	if (smiley) {
+		if (!(smiley->flags & GTK_IMHTML_SMILEY_CUSTOM)) {
+			return FALSE;
+		}
+		gtk_imhtml_smiley_reload(smiley);
+		return TRUE;
+	}
+
+	smiley = gtk_imhtml_smiley_create(NULL, smile, FALSE, GTK_IMHTML_SMILEY_CUSTOM);
+	gtk_imhtml_associate_smiley(imhtml, sml, smiley);
+	g_signal_connect_swapped(imhtml, "destroy", G_CALLBACK(gtk_imhtml_smiley_destroy), smiley);
+
+	return TRUE;
+}
+
+static gboolean
+pidgin_conv_custom_smiley_add(PurpleConversation *conv, const char *smile, gboolean remote)
+{
+	PidginConversation *gtkconv;
+	struct smiley_list *list;
+	const char *sml = NULL, *conv_sml;
+
+	if (!conv || !smile || !*smile) {
+		return FALSE;
+	}
+
+	/* If smileys are off, return false */
+	if (pidgin_themes_smileys_disabled())
+		return FALSE;
+
+	/* If possible add this smiley to the current theme.
+	 * The addition is only temporary: custom smilies aren't saved to disk. */
+	conv_sml = purple_account_get_protocol_name(conv->account);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+
+	for (list = (struct smiley_list *)current_smiley_theme->list; list; list = list->next) {
+		if (!strcmp(list->sml, conv_sml)) {
+			sml = list->sml;
+			break;
+		}
+	}
+
+	if (!add_custom_smiley_for_imhtml(GTK_IMHTML(gtkconv->imhtml), sml, smile))
+		return FALSE;
+
+	if (!remote)	/* If it's a local custom smiley, then add it for the entry */
+		if (!add_custom_smiley_for_imhtml(GTK_IMHTML(gtkconv->entry), sml, smile))
+			return FALSE;
+
+	return TRUE;
+}
+
+static void
+pidgin_conv_custom_smiley_write(PurpleConversation *conv, const char *smile,
+                                      const guchar *data, gsize size)
+{
+	PidginConversation *gtkconv;
+	GtkIMHtmlSmiley *smiley;
+	const char *sml;
+	GError *error = NULL;
+
+	sml = purple_account_get_protocol_name(conv->account);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	smiley = gtk_imhtml_smiley_get(GTK_IMHTML(gtkconv->imhtml), sml, smile);
+
+	if (!smiley)
+		return;
+
+	smiley->data = g_realloc(smiley->data, smiley->datasize + size);
+	g_memmove((guchar *)smiley->data + smiley->datasize, data, size);
+	smiley->datasize += size;
+
+	if (!smiley->loader)
+		return;
+
+	if (!gdk_pixbuf_loader_write(smiley->loader, data, size, &error) || error) {
+		purple_debug_warning("gtkconv", "gdk_pixbuf_loader_write() "
+				"failed with size=%zu: %s\n", size,
+				error ? error->message : "(no error message)");
+		if (error)
+			g_error_free(error);
+		/* We must stop using the GdkPixbufLoader because trying to load
+		   certain invalid GIFs with at least gdk-pixbuf 2.23.3 can return
+		   a GdkPixbuf that will cause some operations (like
+		   gdk_pixbuf_scale_simple()) to consume memory in an infinite loop.
+		   But we also don't want to set smiley->loader to NULL because our
+		   code might expect it to be set.  So create a new loader. */
+		g_object_unref(G_OBJECT(smiley->loader));
+		smiley->loader = gdk_pixbuf_loader_new();
+	}
+}
+
+static void
+pidgin_conv_custom_smiley_close(PurpleConversation *conv, const char *smile)
+{
+	PidginConversation *gtkconv;
+	GtkIMHtmlSmiley *smiley;
+	const char *sml;
+	GError *error = NULL;
+
+	g_return_if_fail(conv  != NULL);
+	g_return_if_fail(smile != NULL);
+
+	sml = purple_account_get_protocol_name(conv->account);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	smiley = gtk_imhtml_smiley_get(GTK_IMHTML(gtkconv->imhtml), sml, smile);
+
+	if (!smiley)
+		return;
+
+	if (!smiley->loader)
+		return;
+
+	purple_debug_info("gtkconv", "About to close the smiley pixbuf\n");
+
+	if (!gdk_pixbuf_loader_close(smiley->loader, &error) || error) {
+		purple_debug_warning("gtkconv", "gdk_pixbuf_loader_close() "
+				"failed: %s\n",
+				error ? error->message : "(no error message)");
+		if (error)
+			g_error_free(error);
+		/* We must stop using the GdkPixbufLoader because if we tried to
+		   load certain invalid GIFs with all current versions of GDK (as
+		   of 2011-06-15) then it's possible the loader will contain data
+		   that could cause some operations (like gdk_pixbuf_scale_simple())
+		   to consume memory in an infinite loop.  But we also don't want
+		   to set smiley->loader to NULL because our code might expect it
+		   to be set.  So create a new loader. */
+		g_object_unref(G_OBJECT(smiley->loader));
+		smiley->loader = gdk_pixbuf_loader_new();
+	}
+}
+
+static void
+pidgin_conv_send_confirm(PurpleConversation *conv, const char *message)
+{
+	PidginConversation *gtkconv = PIDGIN_CONVERSATION(conv);
+
+	gtk_imhtml_append_text(GTK_IMHTML(gtkconv->entry), message, 0);
+}
+
+/*
+ * Makes sure all the menu items and all the buttons are hidden/shown and
+ * sensitive/insensitive.  This is called after changing tabs and when an
+ * account signs on or off.
+ */
+static void
+gray_stuff_out(PidginConversation *gtkconv)
+{
+	PidginWindow *win;
+	PurpleConversation *conv = gtkconv->active_conv;
+	PurpleConnection *gc;
+	PurplePluginProtocolInfo *prpl_info = NULL;
+	GdkPixbuf *window_icon = NULL;
+	GtkIMHtmlButtons buttons;
+	PurpleAccount *account;
+
+	win     = pidgin_conv_get_window(gtkconv);
+	gc      = purple_conversation_get_gc(conv);
+	account = purple_conversation_get_account(conv);
+
+	if (gc != NULL)
+		prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+
+	if (win->menu.send_to != NULL)
+		update_send_to_selection(win);
+
+	/*
+	 * Handle hiding and showing stuff based on what type of conv this is.
+	 * Stuff that Purple IMs support in general should be shown for IM
+	 * conversations.  Stuff that Purple chats support in general should be
+	 * shown for chat conversations.  It doesn't matter whether the PRPL
+	 * supports it or not--that only affects if the button or menu item
+	 * is sensitive or not.
+	 */
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		/* Show stuff that applies to IMs, hide stuff that applies to chats */
+
+		/* Deal with menu items */
+		gtk_widget_show(win->menu.view_log);
+		gtk_widget_show(win->menu.send_file);
+		gtk_widget_show(g_object_get_data(G_OBJECT(win->window), "get_attention"));
+		gtk_widget_show(win->menu.add_pounce);
+		gtk_widget_show(win->menu.get_info);
+		gtk_widget_hide(win->menu.invite);
+		gtk_widget_show(win->menu.alias);
+		if (purple_privacy_check(account, purple_conversation_get_name(conv))) {
+			gtk_widget_hide(win->menu.unblock);
+			gtk_widget_show(win->menu.block);
+		} else {
+			gtk_widget_hide(win->menu.block);
+			gtk_widget_show(win->menu.unblock);
+		}
+
+		if (purple_find_buddy(account, purple_conversation_get_name(conv)) == NULL) {
+			gtk_widget_show(win->menu.add);
+			gtk_widget_hide(win->menu.remove);
+		} else {
+			gtk_widget_show(win->menu.remove);
+			gtk_widget_hide(win->menu.add);
+		}
+
+		gtk_widget_show(win->menu.insert_link);
+		gtk_widget_show(win->menu.insert_image);
+	} else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+		/* Show stuff that applies to Chats, hide stuff that applies to IMs */
+
+		/* Deal with menu items */
+		gtk_widget_show(win->menu.view_log);
+		gtk_widget_hide(win->menu.send_file);
+		gtk_widget_hide(g_object_get_data(G_OBJECT(win->window), "get_attention"));
+		gtk_widget_hide(win->menu.add_pounce);
+		gtk_widget_hide(win->menu.get_info);
+		gtk_widget_show(win->menu.invite);
+		gtk_widget_show(win->menu.alias);
+		gtk_widget_hide(win->menu.block);
+		gtk_widget_hide(win->menu.unblock);
+
+		if ((account == NULL) || purple_blist_find_chat(account, purple_conversation_get_name(conv)) == NULL) {
+			/* If the chat is NOT in the buddy list */
+			gtk_widget_show(win->menu.add);
+			gtk_widget_hide(win->menu.remove);
+		} else {
+			/* If the chat IS in the buddy list */
+			gtk_widget_hide(win->menu.add);
+			gtk_widget_show(win->menu.remove);
+		}
+
+		gtk_widget_show(win->menu.insert_link);
+		gtk_widget_show(win->menu.insert_image);
+	}
+
+	/*
+	 * Handle graying stuff out based on whether an account is connected
+	 * and what features that account supports.
+	 */
+	if ((gc != NULL) &&
+		((purple_conversation_get_type(conv) != PURPLE_CONV_TYPE_CHAT) ||
+		 !purple_conv_chat_has_left(PURPLE_CONV_CHAT(conv)) ))
+	{
+		/* Account is online */
+		/* Deal with the toolbar */
+		if (conv->features & PURPLE_CONNECTION_HTML)
+		{
+			buttons = GTK_IMHTML_ALL; /* Everything on */
+			if (conv->features & PURPLE_CONNECTION_NO_BGCOLOR)
+				buttons &= ~GTK_IMHTML_BACKCOLOR;
+			if (conv->features & PURPLE_CONNECTION_NO_FONTSIZE)
+			{
+				buttons &= ~GTK_IMHTML_GROW;
+				buttons &= ~GTK_IMHTML_SHRINK;
+			}
+			if (conv->features & PURPLE_CONNECTION_NO_URLDESC)
+				buttons &= ~GTK_IMHTML_LINKDESC;
+		} else {
+			buttons = GTK_IMHTML_SMILEY | GTK_IMHTML_IMAGE;
+		}
+
+		if (!(prpl_info->options & OPT_PROTO_IM_IMAGE))
+			conv->features |= PURPLE_CONNECTION_NO_IMAGES;
+
+		if(conv->features & PURPLE_CONNECTION_NO_IMAGES)
+			buttons &= ~GTK_IMHTML_IMAGE;
+
+		if (conv->features & PURPLE_CONNECTION_ALLOW_CUSTOM_SMILEY)
+			buttons |= GTK_IMHTML_CUSTOM_SMILEY;
+		else
+			buttons &= ~GTK_IMHTML_CUSTOM_SMILEY;
+
+		gtk_imhtml_set_format_functions(GTK_IMHTML(gtkconv->entry), buttons);
+		if (account != NULL)
+			gtk_imhtmltoolbar_associate_smileys(GTK_IMHTMLTOOLBAR(gtkconv->toolbar), purple_account_get_protocol_id(account));
+
+		/* Deal with menu items */
+		gtk_widget_set_sensitive(win->menu.view_log, TRUE);
+		gtk_widget_set_sensitive(win->menu.add_pounce, TRUE);
+		gtk_widget_set_sensitive(win->menu.get_info, (prpl_info->get_info != NULL));
+		gtk_widget_set_sensitive(win->menu.invite, (prpl_info->chat_invite != NULL));
+		gtk_widget_set_sensitive(win->menu.insert_link, (conv->features & PURPLE_CONNECTION_HTML));
+		gtk_widget_set_sensitive(win->menu.insert_image, !(conv->features & PURPLE_CONNECTION_NO_IMAGES));
+
+		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+		{
+			gtk_widget_set_sensitive(win->menu.add, (prpl_info->add_buddy != NULL) || (prpl_info->add_buddy_with_invite != NULL));
+			gtk_widget_set_sensitive(win->menu.remove, (prpl_info->remove_buddy != NULL));
+			gtk_widget_set_sensitive(win->menu.send_file,
+									 (prpl_info->send_file != NULL && (!prpl_info->can_receive_file ||
+									  prpl_info->can_receive_file(gc, purple_conversation_get_name(conv)))));
+			gtk_widget_set_sensitive(g_object_get_data(G_OBJECT(win->window), "get_attention"), (prpl_info->send_attention != NULL));
+			gtk_widget_set_sensitive(win->menu.alias,
+									 (account != NULL) &&
+									 (purple_find_buddy(account, purple_conversation_get_name(conv)) != NULL));
+		}
+		else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+		{
+			gtk_widget_set_sensitive(win->menu.add, (prpl_info->join_chat != NULL));
+			gtk_widget_set_sensitive(win->menu.remove, (prpl_info->join_chat != NULL));
+			gtk_widget_set_sensitive(win->menu.alias,
+									 (account != NULL) &&
+									 (purple_blist_find_chat(account, purple_conversation_get_name(conv)) != NULL));
+		}
+
+	} else {
+		/* Account is offline */
+		/* Or it's a chat that we've left. */
+
+		/* Then deal with menu items */
+		gtk_widget_set_sensitive(win->menu.view_log, TRUE);
+		gtk_widget_set_sensitive(win->menu.send_file, FALSE);
+		gtk_widget_set_sensitive(g_object_get_data(G_OBJECT(win->window),
+			"get_attention"), FALSE);
+		gtk_widget_set_sensitive(win->menu.add_pounce, TRUE);
+		gtk_widget_set_sensitive(win->menu.get_info, FALSE);
+		gtk_widget_set_sensitive(win->menu.invite, FALSE);
+		gtk_widget_set_sensitive(win->menu.alias, FALSE);
+		gtk_widget_set_sensitive(win->menu.add, FALSE);
+		gtk_widget_set_sensitive(win->menu.remove, FALSE);
+		gtk_widget_set_sensitive(win->menu.insert_link, TRUE);
+		gtk_widget_set_sensitive(win->menu.insert_image, FALSE);
+	}
+
+	/*
+	 * Update the window's icon
+	 */
+	if (pidgin_conv_window_is_active_conversation(conv))
+	{
+		GList *l = NULL;
+		if ((purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) &&
+				(gtkconv->u.im->anim))
+		{
+			PurpleBuddy *buddy = purple_find_buddy(conv->account, conv->name);
+			window_icon =
+				gdk_pixbuf_animation_get_static_image(gtkconv->u.im->anim);
+
+			if (buddy &&  !PURPLE_BUDDY_IS_ONLINE(buddy))
+				gdk_pixbuf_saturate_and_pixelate(window_icon, window_icon, 0.0, FALSE);
+
+			g_object_ref(window_icon);
+			l = g_list_append(l, window_icon);
+		} else {
+			l = pidgin_conv_get_tab_icons(conv);
+		}
+		gtk_window_set_icon_list(GTK_WINDOW(win->window), l);
+		if (window_icon != NULL) {
+			g_object_unref(G_OBJECT(window_icon));
+			g_list_free(l);
+		}
+	}
+}
+
+static void
+pidgin_conv_update_fields(PurpleConversation *conv, PidginConvFields fields)
+{
+	PidginConversation *gtkconv;
+	PidginWindow *win;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	if (!gtkconv)
+		return;
+	win = pidgin_conv_get_window(gtkconv);
+	if (!win)
+		return;
+
+	if (fields & PIDGIN_CONV_SET_TITLE)
+	{
+		purple_conversation_autoset_title(conv);
+	}
+
+	if (fields & PIDGIN_CONV_BUDDY_ICON)
+	{
+		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+			pidgin_conv_update_buddy_icon(conv);
+	}
+
+	if (fields & PIDGIN_CONV_MENU)
+	{
+		gray_stuff_out(PIDGIN_CONVERSATION(conv));
+		generate_send_to_items(win);
+	}
+
+	if (fields & PIDGIN_CONV_TAB_ICON)
+	{
+		update_tab_icon(conv);
+		generate_send_to_items(win);		/* To update the icons in SendTo menu */
+	}
+
+	if ((fields & PIDGIN_CONV_TOPIC) &&
+				purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+	{
+		const char *topic;
+		PurpleConvChat *chat = PURPLE_CONV_CHAT(conv);
+		PidginChatPane *gtkchat = gtkconv->u.chat;
+
+		if (gtkchat->topic_text != NULL)
+		{
+			topic = purple_conv_chat_get_topic(chat);
+
+			gtk_entry_set_text(GTK_ENTRY(gtkchat->topic_text), topic ? topic : "");
+			gtk_tooltips_set_tip(gtkconv->tooltips, gtkchat->topic_text,
+			                     topic ? topic : "", NULL);
+		}
+	}
+
+	if (fields & PIDGIN_CONV_SMILEY_THEME)
+		pidgin_themes_smiley_themeize(PIDGIN_CONVERSATION(conv)->imhtml);
+
+	if ((fields & PIDGIN_CONV_COLORIZE_TITLE) ||
+			(fields & PIDGIN_CONV_SET_TITLE) ||
+    			(fields & PIDGIN_CONV_TOPIC))
+	{
+		char *title;
+		PurpleConvIm *im = NULL;
+		PurpleAccount *account = purple_conversation_get_account(conv);
+		PurpleBuddy *buddy = NULL;
+		char *markup = NULL;
+		AtkObject *accessibility_obj;
+		/* I think this is a little longer than it needs to be but I'm lazy. */
+		char *style;
+
+		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM)
+			im = PURPLE_CONV_IM(conv);
+
+		if ((account == NULL) ||
+			!purple_account_is_connected(account) ||
+			((purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT)
+				&& purple_conv_chat_has_left(PURPLE_CONV_CHAT(conv))))
+			title = g_strdup_printf("(%s)", purple_conversation_get_title(conv));
+		else
+			title = g_strdup(purple_conversation_get_title(conv));
+
+		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+			buddy = purple_find_buddy(account, conv->name);
+			if (buddy) {
+				markup = pidgin_blist_get_name_markup(buddy, FALSE, FALSE);
+			} else {
+				markup = title;
+			}
+		} else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+			const char *topic = gtkconv->u.chat->topic_text
+				? gtk_entry_get_text(GTK_ENTRY(gtkconv->u.chat->topic_text))
+				: NULL;
+			char *esc = NULL, *tmp;
+			esc = topic ? g_markup_escape_text(topic, -1) : NULL;
+			tmp = g_markup_escape_text(purple_conversation_get_title(conv), -1);
+			markup = g_strdup_printf("%s%s<span color='%s' size='smaller'>%s</span>",
+						tmp, esc  && *esc ? "\n" : "",
+						pidgin_get_dim_grey_string(gtkconv->infopane),
+						esc ? esc : "");
+			g_free(tmp);
+			g_free(esc);
+		}
+		gtk_list_store_set(gtkconv->infopane_model, &(gtkconv->infopane_iter),
+				CONV_TEXT_COLUMN, markup, -1);
+	        /* XXX seanegan Why do I have to do this? */
+		gtk_widget_queue_draw(gtkconv->infopane);
+
+		if (title != markup)
+			g_free(markup);
+
+		if (!GTK_WIDGET_REALIZED(gtkconv->tab_label))
+			gtk_widget_realize(gtkconv->tab_label);
+
+		accessibility_obj = gtk_widget_get_accessible(gtkconv->tab_cont);
+		if (im != NULL &&
+		    purple_conv_im_get_typing_state(im) == PURPLE_TYPING) {
+			atk_object_set_description(accessibility_obj, _("Typing"));
+			style = "tab-label-typing";
+		} else if (im != NULL &&
+		         purple_conv_im_get_typing_state(im) == PURPLE_TYPED) {
+			atk_object_set_description(accessibility_obj, _("Stopped Typing"));
+			style = "tab-label-typed";
+		} else if (gtkconv->unseen_state == PIDGIN_UNSEEN_NICK)	{
+			atk_object_set_description(accessibility_obj, _("Nick Said"));
+			style = "tab-label-attention";
+		} else if (gtkconv->unseen_state == PIDGIN_UNSEEN_TEXT)	{
+			atk_object_set_description(accessibility_obj, _("Unread Messages"));
+			if (gtkconv->active_conv->type == PURPLE_CONV_TYPE_CHAT)
+				style = "tab-label-unreadchat";
+			else
+				style = "tab-label-attention";
+		} else if (gtkconv->unseen_state == PIDGIN_UNSEEN_EVENT) {
+			atk_object_set_description(accessibility_obj, _("New Event"));
+			style = "tab-label-event";
+		} else {
+			style = "tab-label";
+		}
+
+		gtk_widget_set_name(gtkconv->tab_label, style);
+		gtk_label_set_text(GTK_LABEL(gtkconv->tab_label), title);
+		gtk_widget_set_state(gtkconv->tab_label, GTK_STATE_ACTIVE);
+
+		if (gtkconv->unseen_state == PIDGIN_UNSEEN_TEXT ||
+				gtkconv->unseen_state == PIDGIN_UNSEEN_NICK ||
+				gtkconv->unseen_state == PIDGIN_UNSEEN_EVENT) {
+			PangoAttrList *list = pango_attr_list_new();
+			PangoAttribute *attr = pango_attr_weight_new(PANGO_WEIGHT_BOLD);
+			attr->start_index = 0;
+			attr->end_index = -1;
+			pango_attr_list_insert(list, attr);
+			gtk_label_set_attributes(GTK_LABEL(gtkconv->tab_label), list);
+			pango_attr_list_unref(list);
+		} else
+			gtk_label_set_attributes(GTK_LABEL(gtkconv->tab_label), NULL);
+
+		if (pidgin_conv_window_is_active_conversation(conv))
+			update_typing_icon(gtkconv);
+
+		gtk_label_set_text(GTK_LABEL(gtkconv->menu_label), title);
+		if (pidgin_conv_window_is_active_conversation(conv)) {
+			const char* current_title = gtk_window_get_title(GTK_WINDOW(win->window));
+			if (current_title == NULL || strcmp(current_title, title) != 0)
+				gtk_window_set_title(GTK_WINDOW(win->window), title);
+		}
+
+		g_free(title);
+	}
+}
+
+static void
+pidgin_conv_updated(PurpleConversation *conv, PurpleConvUpdateType type)
+{
+	PidginConvFields flags = 0;
+
+	g_return_if_fail(conv != NULL);
+
+	if (type == PURPLE_CONV_UPDATE_ACCOUNT)
+	{
+		flags = PIDGIN_CONV_ALL;
+	}
+	else if (type == PURPLE_CONV_UPDATE_TYPING ||
+	         type == PURPLE_CONV_UPDATE_UNSEEN ||
+	         type == PURPLE_CONV_UPDATE_TITLE)
+	{
+		flags = PIDGIN_CONV_COLORIZE_TITLE;
+	}
+	else if (type == PURPLE_CONV_UPDATE_TOPIC)
+	{
+		flags = PIDGIN_CONV_TOPIC;
+	}
+	else if (type == PURPLE_CONV_ACCOUNT_ONLINE ||
+	         type == PURPLE_CONV_ACCOUNT_OFFLINE)
+	{
+		flags = PIDGIN_CONV_MENU | PIDGIN_CONV_TAB_ICON | PIDGIN_CONV_SET_TITLE;
+	}
+	else if (type == PURPLE_CONV_UPDATE_AWAY)
+	{
+		flags = PIDGIN_CONV_TAB_ICON;
+	}
+	else if (type == PURPLE_CONV_UPDATE_ADD ||
+	         type == PURPLE_CONV_UPDATE_REMOVE ||
+	         type == PURPLE_CONV_UPDATE_CHATLEFT)
+	{
+		flags = PIDGIN_CONV_SET_TITLE | PIDGIN_CONV_MENU;
+	}
+	else if (type == PURPLE_CONV_UPDATE_ICON)
+	{
+		flags = PIDGIN_CONV_BUDDY_ICON;
+	}
+	else if (type == PURPLE_CONV_UPDATE_FEATURES)
+	{
+		flags = PIDGIN_CONV_MENU;
+	}
+
+	pidgin_conv_update_fields(conv, flags);
+}
+
+static void
+wrote_msg_update_unseen_cb(PurpleAccount *account, const char *who, const char *message,
+		PurpleConversation *conv, PurpleMessageFlags flags, gpointer null)
+{
+	PidginConversation *gtkconv = conv ? PIDGIN_CONVERSATION(conv) : NULL;
+	if (conv == NULL || (gtkconv && gtkconv->win != hidden_convwin))
+		return;
+	if (flags & (PURPLE_MESSAGE_SEND | PURPLE_MESSAGE_RECV)) {
+		PidginUnseenState unseen = PIDGIN_UNSEEN_NONE;
+
+		if ((flags & PURPLE_MESSAGE_NICK) == PURPLE_MESSAGE_NICK)
+			unseen = PIDGIN_UNSEEN_NICK;
+		else if (((flags & PURPLE_MESSAGE_SYSTEM) == PURPLE_MESSAGE_SYSTEM) ||
+			  ((flags & PURPLE_MESSAGE_ERROR) == PURPLE_MESSAGE_ERROR))
+			unseen = PIDGIN_UNSEEN_EVENT;
+		else if ((flags & PURPLE_MESSAGE_NO_LOG) == PURPLE_MESSAGE_NO_LOG)
+			unseen = PIDGIN_UNSEEN_NO_LOG;
+		else
+			unseen = PIDGIN_UNSEEN_TEXT;
+
+		conv_set_unseen(conv, unseen);
+	}
+}
+
+static PurpleConversationUiOps conversation_ui_ops =
+{
+	pidgin_conv_new,
+	pidgin_conv_destroy,              /* destroy_conversation */
+	NULL,                              /* write_chat           */
+	pidgin_conv_write_im,             /* write_im             */
+	pidgin_conv_write_conv,           /* write_conv           */
+	pidgin_conv_chat_add_users,       /* chat_add_users       */
+	pidgin_conv_chat_rename_user,     /* chat_rename_user     */
+	pidgin_conv_chat_remove_users,    /* chat_remove_users    */
+	pidgin_conv_chat_update_user,     /* chat_update_user     */
+	pidgin_conv_present_conversation, /* present              */
+	pidgin_conv_has_focus,            /* has_focus            */
+	pidgin_conv_custom_smiley_add,    /* custom_smiley_add    */
+	pidgin_conv_custom_smiley_write,  /* custom_smiley_write  */
+	pidgin_conv_custom_smiley_close,  /* custom_smiley_close  */
+	pidgin_conv_send_confirm,         /* send_confirm         */
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+PurpleConversationUiOps *
+pidgin_conversations_get_conv_ui_ops(void)
+{
+	return &conversation_ui_ops;
+}
+
+/**************************************************************************
+ * Public conversation utility functions
+ **************************************************************************/
+void
+pidgin_conv_update_buddy_icon(PurpleConversation *conv)
+{
+	PidginConversation *gtkconv;
+	PidginWindow *win;
+
+	PurpleBuddy *buddy;
+
+	PurpleStoredImage *custom_img = NULL;
+	gconstpointer data = NULL;
+	size_t len;
+
+	GdkPixbuf *buf;
+
+	GList *children;
+	GtkWidget *event;
+	GdkPixbuf *scale;
+	int scale_width, scale_height;
+	int size = 0;
+
+	PurpleAccount *account;
+
+	PurpleBuddyIcon *icon;
+
+	g_return_if_fail(conv != NULL);
+	g_return_if_fail(PIDGIN_IS_PIDGIN_CONVERSATION(conv));
+	g_return_if_fail(purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM);
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	win = gtkconv->win;
+	if (conv != gtkconv->active_conv)
+		return;
+
+	if (!gtkconv->u.im->show_icon)
+		return;
+
+	account = purple_conversation_get_account(conv);
+
+	/* Remove the current icon stuff */
+	children = gtk_container_get_children(GTK_CONTAINER(gtkconv->u.im->icon_container));
+	if (children) {
+		/* We know there's only one child here. It'd be nice to shortcut to the
+		   event box, but we can't change the PidginConversation until 3.0 */
+		event = (GtkWidget *)children->data;
+		gtk_container_remove(GTK_CONTAINER(gtkconv->u.im->icon_container), event);
+		g_list_free(children);
+	}
+
+	if (gtkconv->u.im->anim != NULL)
+		g_object_unref(G_OBJECT(gtkconv->u.im->anim));
+
+	gtkconv->u.im->anim = NULL;
+
+	if (gtkconv->u.im->icon_timer != 0)
+		g_source_remove(gtkconv->u.im->icon_timer);
+
+	gtkconv->u.im->icon_timer = 0;
+
+	if (gtkconv->u.im->iter != NULL)
+		g_object_unref(G_OBJECT(gtkconv->u.im->iter));
+
+	gtkconv->u.im->iter = NULL;
+
+	if (!purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/im/show_buddy_icons"))
+		return;
+
+	if (purple_conversation_get_gc(conv) == NULL)
+		return;
+
+	buddy = purple_find_buddy(account, purple_conversation_get_name(conv));
+	if (buddy)
+	{
+		PurpleContact *contact = purple_buddy_get_contact(buddy);
+		if (contact) {
+			custom_img = purple_buddy_icons_node_find_custom_icon((PurpleBlistNode*)contact);
+			if (custom_img) {
+				/* There is a custom icon for this user */
+				data = purple_imgstore_get_data(custom_img);
+				len = purple_imgstore_get_size(custom_img);
+			}
+		}
+	}
+
+	if (data == NULL) {
+		icon = purple_conv_im_get_icon(PURPLE_CONV_IM(conv));
+		if (icon == NULL)
+		{
+			gtk_widget_set_size_request(gtkconv->u.im->icon_container,
+			                            -1, BUDDYICON_SIZE_MIN);
+			return;
+		}
+
+		data = purple_buddy_icon_get_data(icon, &len);
+		if (data == NULL)
+		{
+			gtk_widget_set_size_request(gtkconv->u.im->icon_container,
+			                            -1, BUDDYICON_SIZE_MIN);
+			return;
+		}
+	}
+
+	gtkconv->u.im->anim = pidgin_pixbuf_anim_from_data(data, len);
+	purple_imgstore_unref(custom_img);
+
+	if (!gtkconv->u.im->anim) {
+		purple_debug_error("gtkconv", "Couldn't load icon for conv %s\n",
+				purple_conversation_get_name(conv));
+		return;
+	}
+
+	if (gdk_pixbuf_animation_is_static_image(gtkconv->u.im->anim)) {
+		GdkPixbuf *stat;
+		gtkconv->u.im->iter = NULL;
+		stat = gdk_pixbuf_animation_get_static_image(gtkconv->u.im->anim);
+		buf = gdk_pixbuf_add_alpha(stat, FALSE, 0, 0, 0);
+	} else {
+		GdkPixbuf *stat;
+		gtkconv->u.im->iter =
+			gdk_pixbuf_animation_get_iter(gtkconv->u.im->anim, NULL); /* LEAK */
+		stat = gdk_pixbuf_animation_iter_get_pixbuf(gtkconv->u.im->iter);
+		buf = gdk_pixbuf_add_alpha(stat, FALSE, 0, 0, 0);
+		if (gtkconv->u.im->animate)
+			start_anim(NULL, gtkconv);
+	}
+
+	scale_width = gdk_pixbuf_get_width(buf);
+	scale_height = gdk_pixbuf_get_height(buf);
+
+	gtk_widget_get_size_request(gtkconv->u.im->icon_container, NULL, &size);
+	size = MIN(size, MIN(scale_width, scale_height));
+
+	/* Some sanity checks */
+	size = CLAMP(size, BUDDYICON_SIZE_MIN, BUDDYICON_SIZE_MAX);
+	if (scale_width == scale_height) {
+		scale_width = scale_height = size;
+	} else if (scale_height > scale_width) {
+		scale_width = size * scale_width / scale_height;
+		scale_height = size;
+	} else {
+		scale_height = size * scale_height / scale_width;
+		scale_width = size;
+	}
+	scale = gdk_pixbuf_scale_simple(buf, scale_width, scale_height,
+				GDK_INTERP_BILINEAR);
+	g_object_unref(buf);
+	if (pidgin_gdk_pixbuf_is_opaque(scale))
+		pidgin_gdk_pixbuf_make_round(scale);
+
+	event = gtk_event_box_new();
+	gtk_container_add(GTK_CONTAINER(gtkconv->u.im->icon_container), event);
+	gtk_event_box_set_visible_window(GTK_EVENT_BOX(event), FALSE);
+	gtk_widget_add_events(event,
+                              GDK_POINTER_MOTION_MASK | GDK_LEAVE_NOTIFY_MASK);
+	g_signal_connect(G_OBJECT(event), "button-press-event",
+					 G_CALLBACK(icon_menu), gtkconv);
+
+	pidgin_tooltip_setup_for_widget(event, gtkconv, pidgin_conv_create_tooltip, NULL);
+	gtk_widget_show(event);
+
+	gtkconv->u.im->icon = gtk_image_new_from_pixbuf(scale);
+	gtk_container_add(GTK_CONTAINER(event), gtkconv->u.im->icon);
+	gtk_widget_show(gtkconv->u.im->icon);
+
+	g_object_unref(G_OBJECT(scale));
+
+	/* The buddy icon code needs badly to be fixed. */
+	if(pidgin_conv_window_is_active_conversation(conv))
+	{
+		buf = gdk_pixbuf_animation_get_static_image(gtkconv->u.im->anim);
+		if (buddy && !PURPLE_BUDDY_IS_ONLINE(buddy))
+			gdk_pixbuf_saturate_and_pixelate(buf, buf, 0.0, FALSE);
+		gtk_window_set_icon(GTK_WINDOW(win->window), buf);
+	}
+}
+
+void
+pidgin_conv_update_buttons_by_protocol(PurpleConversation *conv)
+{
+	PidginWindow *win;
+
+	if (!PIDGIN_IS_PIDGIN_CONVERSATION(conv))
+		return;
+
+	win = PIDGIN_CONVERSATION(conv)->win;
+
+	if (win != NULL && pidgin_conv_window_is_active_conversation(conv))
+		gray_stuff_out(PIDGIN_CONVERSATION(conv));
+}
+
+static gboolean
+pidgin_conv_xy_to_right_infopane(PidginWindow *win, int x, int y)
+{
+	gint pane_x, pane_y, x_rel;
+	PidginConversation *gtkconv;
+
+	gdk_window_get_origin(win->notebook->window, &pane_x, &pane_y);
+	x_rel = x - pane_x;
+	gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+	return (x_rel > gtkconv->infopane->allocation.x + gtkconv->infopane->allocation.width / 2);
+}
+
+int
+pidgin_conv_get_tab_at_xy(PidginWindow *win, int x, int y, gboolean *to_right)
+{
+	gint nb_x, nb_y, x_rel, y_rel;
+	GtkNotebook *notebook;
+	GtkWidget *page, *tab;
+	gint i, page_num = -1;
+	gint count;
+	gboolean horiz;
+
+	if (to_right)
+		*to_right = FALSE;
+
+	notebook = GTK_NOTEBOOK(win->notebook);
+
+	gdk_window_get_origin(win->notebook->window, &nb_x, &nb_y);
+	x_rel = x - nb_x;
+	y_rel = y - nb_y;
+
+	horiz = (gtk_notebook_get_tab_pos(notebook) == GTK_POS_TOP ||
+			gtk_notebook_get_tab_pos(notebook) == GTK_POS_BOTTOM);
+
+	count = gtk_notebook_get_n_pages(GTK_NOTEBOOK(notebook));
+
+	for (i = 0; i < count; i++) {
+
+		page = gtk_notebook_get_nth_page(GTK_NOTEBOOK(notebook), i);
+		tab = gtk_notebook_get_tab_label(GTK_NOTEBOOK(notebook), page);
+
+		/* Make sure the tab is not hidden beyond an arrow */
+		if (!GTK_WIDGET_DRAWABLE(tab) && gtk_notebook_get_show_tabs(notebook))
+			continue;
+
+		if (horiz) {
+			if (x_rel >= tab->allocation.x - PIDGIN_HIG_BOX_SPACE &&
+					x_rel <= tab->allocation.x + tab->allocation.width + PIDGIN_HIG_BOX_SPACE) {
+				page_num = i;
+
+				if (to_right && x_rel >= tab->allocation.x + tab->allocation.width/2)
+					*to_right = TRUE;
+
+				break;
+			}
+		} else {
+			if (y_rel >= tab->allocation.y - PIDGIN_HIG_BOX_SPACE &&
+					y_rel <= tab->allocation.y + tab->allocation.height + PIDGIN_HIG_BOX_SPACE) {
+				page_num = i;
+
+				if (to_right && y_rel >= tab->allocation.y + tab->allocation.height/2)
+					*to_right = TRUE;
+
+				break;
+			}
+		}
+	}
+
+	if (page_num == -1) {
+		/* Add after the last tab */
+		page_num = count - 1;
+	}
+
+	return page_num;
+}
+
+static void
+close_on_tabs_pref_cb(const char *name, PurplePrefType type,
+					  gconstpointer value, gpointer data)
+{
+	GList *l;
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+
+	for (l = purple_get_conversations(); l != NULL; l = l->next) {
+		conv = (PurpleConversation *)l->data;
+
+		if (!PIDGIN_IS_PIDGIN_CONVERSATION(conv))
+			continue;
+
+		gtkconv = PIDGIN_CONVERSATION(conv);
+
+		if (value)
+			gtk_widget_show(gtkconv->close);
+		else
+			gtk_widget_hide(gtkconv->close);
+	}
+}
+
+static void
+spellcheck_pref_cb(const char *name, PurplePrefType type,
+				   gconstpointer value, gpointer data)
+{
+#ifdef USE_GTKSPELL
+	GList *cl;
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+	GtkSpell *spell;
+
+	for (cl = purple_get_conversations(); cl != NULL; cl = cl->next) {
+
+		conv = (PurpleConversation *)cl->data;
+
+		if (!PIDGIN_IS_PIDGIN_CONVERSATION(conv))
+			continue;
+
+		gtkconv = PIDGIN_CONVERSATION(conv);
+
+		if (value)
+			pidgin_setup_gtkspell(GTK_TEXT_VIEW(gtkconv->entry));
+		else {
+			spell = gtkspell_get_from_text_view(GTK_TEXT_VIEW(gtkconv->entry));
+			if (spell)
+				gtkspell_detach(spell);
+		}
+	}
+#endif
+}
+
+static void
+tab_side_pref_cb(const char *name, PurplePrefType type,
+				 gconstpointer value, gpointer data)
+{
+	GList *gtkwins, *gtkconvs;
+	GtkPositionType pos;
+	PidginWindow *gtkwin;
+
+	pos = GPOINTER_TO_INT(value);
+
+	for (gtkwins = pidgin_conv_windows_get_list(); gtkwins != NULL; gtkwins = gtkwins->next) {
+		gtkwin = gtkwins->data;
+		gtk_notebook_set_tab_pos(GTK_NOTEBOOK(gtkwin->notebook), pos&~8);
+		for (gtkconvs = gtkwin->gtkconvs; gtkconvs != NULL; gtkconvs = gtkconvs->next) {
+			pidgin_conv_tab_pack(gtkwin, gtkconvs->data);
+		}
+	}
+}
+
+static void
+show_timestamps_pref_cb(const char *name, PurplePrefType type,
+						gconstpointer value, gpointer data)
+{
+	GList *l;
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+	PidginWindow *win;
+
+	for (l = purple_get_conversations(); l != NULL; l = l->next)
+	{
+		conv = (PurpleConversation *)l->data;
+
+		if (!PIDGIN_IS_PIDGIN_CONVERSATION(conv))
+			continue;
+
+		gtkconv = PIDGIN_CONVERSATION(conv);
+		win     = gtkconv->win;
+
+		gtk_check_menu_item_set_active(
+		        GTK_CHECK_MENU_ITEM(win->menu.show_timestamps),
+		        (gboolean)GPOINTER_TO_INT(value));
+
+		gtk_imhtml_show_comments(GTK_IMHTML(gtkconv->imhtml),
+			(gboolean)GPOINTER_TO_INT(value));
+	}
+}
+
+static void
+show_formatting_toolbar_pref_cb(const char *name, PurplePrefType type,
+								gconstpointer value, gpointer data)
+{
+	GList *l;
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+	PidginWindow *win;
+
+	for (l = purple_get_conversations(); l != NULL; l = l->next)
+	{
+		conv = (PurpleConversation *)l->data;
+
+		if (!PIDGIN_IS_PIDGIN_CONVERSATION(conv))
+			continue;
+
+		gtkconv = PIDGIN_CONVERSATION(conv);
+		win     = gtkconv->win;
+
+		gtk_check_menu_item_set_active(
+		        GTK_CHECK_MENU_ITEM(win->menu.show_formatting_toolbar),
+		        (gboolean)GPOINTER_TO_INT(value));
+
+		if ((gboolean)GPOINTER_TO_INT(value))
+			gtk_widget_show(gtkconv->toolbar);
+		else
+			gtk_widget_hide(gtkconv->toolbar);
+
+		g_idle_add((GSourceFunc)resize_imhtml_cb,gtkconv);
+	}
+}
+
+static void
+animate_buddy_icons_pref_cb(const char *name, PurplePrefType type,
+							gconstpointer value, gpointer data)
+{
+	GList *l;
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+	PidginWindow *win;
+
+	if (!purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/im/show_buddy_icons"))
+		return;
+
+	/* Set the "animate" flag for each icon based on the new preference */
+	for (l = purple_get_ims(); l != NULL; l = l->next) {
+		conv = (PurpleConversation *)l->data;
+		gtkconv = PIDGIN_CONVERSATION(conv);
+		if (gtkconv)
+			gtkconv->u.im->animate = GPOINTER_TO_INT(value);
+	}
+
+	/* Now either stop or start animation for the active conversation in each window */
+	for (l = pidgin_conv_windows_get_list(); l != NULL; l = l->next) {
+		win = l->data;
+		conv = pidgin_conv_window_get_active_conversation(win);
+		pidgin_conv_update_buddy_icon(conv);
+	}
+}
+
+static void
+show_buddy_icons_pref_cb(const char *name, PurplePrefType type,
+						 gconstpointer value, gpointer data)
+{
+	GList *l;
+
+	for (l = purple_get_conversations(); l != NULL; l = l->next) {
+		PurpleConversation *conv = l->data;
+		if (!PIDGIN_CONVERSATION(conv))
+			continue;
+		if (GPOINTER_TO_INT(value))
+			gtk_widget_show(PIDGIN_CONVERSATION(conv)->infopane_hbox);
+		else
+			gtk_widget_hide(PIDGIN_CONVERSATION(conv)->infopane_hbox);
+
+		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+			pidgin_conv_update_buddy_icon(conv);
+		}
+	}
+
+	/* Make the tabs show/hide correctly */
+	for (l = pidgin_conv_windows_get_list(); l != NULL; l = l->next) {
+		PidginWindow *win = l->data;
+		if (pidgin_conv_window_get_gtkconv_count(win) == 1)
+			gtk_notebook_set_show_tabs(GTK_NOTEBOOK(win->notebook),
+						   GPOINTER_TO_INT(value) == 0);
+	}
+}
+
+static void
+show_protocol_icons_pref_cb(const char *name, PurplePrefType type,
+						gconstpointer value, gpointer data)
+{
+	GList *l;
+	for (l = purple_get_conversations(); l != NULL; l = l->next) {
+		PurpleConversation *conv = l->data;
+		if (PIDGIN_CONVERSATION(conv))
+			update_tab_icon(conv);
+	}
+}
+
+static void
+conv_placement_usetabs_cb(const char *name, PurplePrefType type,
+						  gconstpointer value, gpointer data)
+{
+	purple_prefs_trigger_callback(PIDGIN_PREFS_ROOT "/conversations/placement");
+}
+
+static void
+account_status_changed_cb(PurpleAccount *account, PurpleStatus *oldstatus,
+                          PurpleStatus *newstatus)
+{
+	GList *l;
+	PurpleConversation *conv = NULL;
+	PidginConversation *gtkconv;
+
+	if(strcmp(purple_prefs_get_string(PIDGIN_PREFS_ROOT "/conversations/im/hide_new"), "away")!=0)
+		return;
+
+	if(purple_status_is_available(oldstatus) || !purple_status_is_available(newstatus))
+		return;
+
+	for (l = hidden_convwin->gtkconvs; l; ) {
+		gtkconv = l->data;
+		l = l->next;
+
+		conv = gtkconv->active_conv;
+		if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT ||
+				account != purple_conversation_get_account(conv))
+			continue;
+
+		pidgin_conv_attach_to_conversation(conv);
+
+		/* TODO: do we need to do anything for any other conversations that are in the same gtkconv here?
+		 * I'm a little concerned that not doing so will cause the "pending" indicator in the gtkblist not to be cleared. -DAA*/
+		purple_conversation_update(conv, PURPLE_CONV_UPDATE_UNSEEN);
+	}
+}
+
+static void
+hide_new_pref_cb(const char *name, PurplePrefType type,
+				 gconstpointer value, gpointer data)
+{
+	GList *l;
+	PurpleConversation *conv = NULL;
+	PidginConversation *gtkconv;
+	gboolean when_away = FALSE;
+
+	if(!hidden_convwin)
+		return;
+
+	if(strcmp(purple_prefs_get_string(PIDGIN_PREFS_ROOT "/conversations/im/hide_new"), "always")==0)
+		return;
+
+	if(strcmp(purple_prefs_get_string(PIDGIN_PREFS_ROOT "/conversations/im/hide_new"), "away")==0)
+		when_away = TRUE;
+
+	for (l = hidden_convwin->gtkconvs; l; )
+	{
+		gtkconv = l->data;
+		l = l->next;
+
+		conv = gtkconv->active_conv;
+
+		if (conv->type == PURPLE_CONV_TYPE_CHAT ||
+				gtkconv->unseen_count == 0 ||
+				(when_away && !purple_status_is_available(
+							purple_account_get_active_status(
+							purple_conversation_get_account(conv)))))
+			continue;
+
+		pidgin_conv_attach_to_conversation(conv);
+	}
+}
+
+
+static void
+conv_placement_pref_cb(const char *name, PurplePrefType type,
+					   gconstpointer value, gpointer data)
+{
+	PidginConvPlacementFunc func;
+
+	if (strcmp(name, PIDGIN_PREFS_ROOT "/conversations/placement"))
+		return;
+
+	func = pidgin_conv_placement_get_fnc(value);
+
+	if (func == NULL)
+		return;
+
+	pidgin_conv_placement_set_current_func(func);
+}
+
+static PidginConversation *
+get_gtkconv_with_contact(PurpleContact *contact)
+{
+	PurpleBlistNode *node;
+
+	node = ((PurpleBlistNode*)contact)->child;
+
+	for (; node; node = node->next)
+	{
+		PurpleBuddy *buddy = (PurpleBuddy*)node;
+		PurpleConversation *conv;
+		conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, buddy->name, buddy->account);
+		if (conv)
+			return PIDGIN_CONVERSATION(conv);
+	}
+	return NULL;
+}
+
+static void
+account_signed_off_cb(PurpleConnection *gc, gpointer event)
+{
+	GList *iter;
+
+	for (iter = purple_get_conversations(); iter; iter = iter->next)
+	{
+		PurpleConversation *conv = iter->data;
+
+		/* This seems fine in theory, but we also need to cover the
+		 * case of this account matching one of the other buddies in
+		 * one of the contacts containing the buddy corresponding to
+		 * a conversation.  It's easier to just update them all. */
+		/* if (purple_conversation_get_account(conv) == account) */
+			pidgin_conv_update_fields(conv, PIDGIN_CONV_TAB_ICON |
+							PIDGIN_CONV_MENU | PIDGIN_CONV_COLORIZE_TITLE);
+
+		if (PURPLE_CONNECTION_IS_CONNECTED(gc) &&
+				conv->type == PURPLE_CONV_TYPE_CHAT &&
+				conv->account == gc->account &&
+				purple_conversation_get_data(conv, "want-to-rejoin")) {
+			GHashTable *comps = NULL;
+			PurpleChat *chat = purple_blist_find_chat(conv->account, conv->name);
+			if (chat == NULL) {
+				if (PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl)->chat_info_defaults != NULL)
+					comps = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl)->chat_info_defaults(gc, conv->name);
+			} else {
+				comps = chat->components;
+			}
+			serv_join_chat(gc, comps);
+			if (chat == NULL && comps != NULL)
+				g_hash_table_destroy(comps);
+		}
+	}
+}
+
+static void
+account_signing_off(PurpleConnection *gc)
+{
+	GList *list = purple_get_chats();
+	PurpleAccount *account = purple_connection_get_account(gc);
+
+	/* We are about to sign off. See which chats we are currently in, and mark
+	 * them for rejoin on reconnect. */
+	while (list) {
+		PurpleConversation *conv = list->data;
+		if (!purple_conv_chat_has_left(PURPLE_CONV_CHAT(conv)) &&
+				purple_conversation_get_account(conv) == account) {
+			purple_conversation_set_data(conv, "want-to-rejoin", GINT_TO_POINTER(TRUE));
+			purple_conversation_write(conv, NULL, _("The account has disconnected and you are no "
+						"longer in this chat. You will automatically rejoin the chat when "
+						"the account reconnects."),
+					PURPLE_MESSAGE_SYSTEM, time(NULL));
+		}
+		list = list->next;
+	}
+}
+
+static void
+update_buddy_status_changed(PurpleBuddy *buddy, PurpleStatus *old, PurpleStatus *newstatus)
+{
+	PidginConversation *gtkconv;
+	PurpleConversation *conv;
+
+	gtkconv = get_gtkconv_with_contact(purple_buddy_get_contact(buddy));
+	if (gtkconv)
+	{
+		conv = gtkconv->active_conv;
+		pidgin_conv_update_fields(conv, PIDGIN_CONV_TAB_ICON
+		                              | PIDGIN_CONV_COLORIZE_TITLE
+		                              | PIDGIN_CONV_BUDDY_ICON);
+		if ((purple_status_is_online(old) ^ purple_status_is_online(newstatus)) != 0)
+			pidgin_conv_update_fields(conv, PIDGIN_CONV_MENU);
+	}
+}
+
+static void
+update_buddy_privacy_changed(PurpleBuddy *buddy)
+{
+	PidginConversation *gtkconv;
+	PurpleConversation *conv;
+
+	gtkconv = get_gtkconv_with_contact(purple_buddy_get_contact(buddy));
+	if (gtkconv) {
+		conv = gtkconv->active_conv;
+		pidgin_conv_update_fields(conv, PIDGIN_CONV_TAB_ICON | PIDGIN_CONV_MENU);
+	}
+}
+
+static void
+update_buddy_idle_changed(PurpleBuddy *buddy, gboolean old, gboolean newidle)
+{
+	PurpleConversation *conv;
+
+	conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, buddy->name, buddy->account);
+	if (conv)
+		pidgin_conv_update_fields(conv, PIDGIN_CONV_TAB_ICON);
+}
+
+static void
+update_buddy_icon(PurpleBuddy *buddy)
+{
+	PurpleConversation *conv;
+
+	conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, buddy->name, buddy->account);
+	if (conv)
+		pidgin_conv_update_fields(conv, PIDGIN_CONV_BUDDY_ICON);
+}
+
+static void
+update_buddy_sign(PurpleBuddy *buddy, const char *which)
+{
+	PurplePresence *presence;
+	PurpleStatus *on, *off;
+
+	presence = purple_buddy_get_presence(buddy);
+	if (!presence)
+		return;
+	off = purple_presence_get_status(presence, "offline");
+	on = purple_presence_get_status(presence, "available");
+
+	if (*(which+1) == 'f')
+		update_buddy_status_changed(buddy, on, off);
+	else
+		update_buddy_status_changed(buddy, off, on);
+}
+
+static void
+update_conversation_switched(PurpleConversation *conv)
+{
+	pidgin_conv_update_fields(conv, PIDGIN_CONV_TAB_ICON | PIDGIN_CONV_SET_TITLE |
+					PIDGIN_CONV_MENU | PIDGIN_CONV_BUDDY_ICON);
+}
+
+static void
+update_buddy_typing(PurpleAccount *account, const char *who)
+{
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+
+	conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, who, account);
+	if (!conv)
+		return;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+	if (gtkconv && gtkconv->active_conv == conv)
+		pidgin_conv_update_fields(conv, PIDGIN_CONV_COLORIZE_TITLE);
+}
+
+static void
+update_chat(PurpleConversation *conv)
+{
+	pidgin_conv_update_fields(conv, PIDGIN_CONV_TOPIC |
+					PIDGIN_CONV_MENU | PIDGIN_CONV_SET_TITLE);
+}
+
+static void
+update_chat_topic(PurpleConversation *conv, const char *old, const char *new)
+{
+	pidgin_conv_update_fields(conv, PIDGIN_CONV_TOPIC);
+}
+
+/* Message history stuff */
+
+/* Compare two PurpleConvMessage's, according to time in ascending order. */
+static int
+message_compare(gconstpointer p1, gconstpointer p2)
+{
+	const PurpleConvMessage *m1 = p1, *m2 = p2;
+	return (m1->when > m2->when);
+}
+
+/* Adds some message history to the gtkconv. This happens in a idle-callback. */
+static gboolean
+add_message_history_to_gtkconv(gpointer data)
+{
+	PidginConversation *gtkconv = data;
+	int count = 0;
+	int timer = gtkconv->attach.timer;
+	time_t when = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(gtkconv->entry), "attach-start-time"));
+	gboolean im = (gtkconv->active_conv->type == PURPLE_CONV_TYPE_IM);
+
+	gtkconv->attach.timer = 0;
+	while (gtkconv->attach.current && count < 100) {  /* XXX: 100 is a random value here */
+		PurpleConvMessage *msg = gtkconv->attach.current->data;
+		if (!im && when && when < msg->when) {
+			gtk_imhtml_append_text(GTK_IMHTML(gtkconv->imhtml), "<BR><HR>", 0);
+			g_object_set_data(G_OBJECT(gtkconv->entry), "attach-start-time", NULL);
+		}
+		pidgin_conv_write_conv(msg->conv, msg->who, msg->alias, msg->what, msg->flags, msg->when);
+		if (im) {
+			gtkconv->attach.current = g_list_delete_link(gtkconv->attach.current, gtkconv->attach.current);
+		} else {
+			gtkconv->attach.current = gtkconv->attach.current->prev;
+		}
+		count++;
+	}
+	gtkconv->attach.timer = timer;
+	if (gtkconv->attach.current)
+		return TRUE;
+
+	g_source_remove(gtkconv->attach.timer);
+	gtkconv->attach.timer = 0;
+	if (im) {
+		/* Print any message that was sent while the old history was being added back. */
+		GList *msgs = NULL;
+		GList *iter = gtkconv->convs;
+		for (; iter; iter = iter->next) {
+			PurpleConversation *conv = iter->data;
+			GList *history = purple_conversation_get_message_history(conv);
+			for (; history; history = history->next) {
+				PurpleConvMessage *msg = history->data;
+				if (msg->when > when)
+					msgs = g_list_prepend(msgs, msg);
+			}
+		}
+		msgs = g_list_sort(msgs, message_compare);
+		for (; msgs; msgs = g_list_delete_link(msgs, msgs)) {
+			PurpleConvMessage *msg = msgs->data;
+			pidgin_conv_write_conv(msg->conv, msg->who, msg->alias, msg->what, msg->flags, msg->when);
+		}
+		gtk_imhtml_append_text(GTK_IMHTML(gtkconv->imhtml), "<BR><HR>", 0);
+		g_object_set_data(G_OBJECT(gtkconv->entry), "attach-start-time", NULL);
+	}
+
+	g_object_set_data(G_OBJECT(gtkconv->entry), "attach-start-time", NULL);
+	purple_signal_emit(pidgin_conversations_get_handle(),
+			"conversation-displayed", gtkconv);
+	return FALSE;
+}
+
+static void
+pidgin_conv_attach(PurpleConversation *conv)
+{
+	int timer;
+	purple_conversation_set_data(conv, "unseen-count", NULL);
+	purple_conversation_set_data(conv, "unseen-state", NULL);
+	purple_conversation_set_ui_ops(conv, pidgin_conversations_get_conv_ui_ops());
+	if (!PIDGIN_CONVERSATION(conv))
+		private_gtkconv_new(conv, FALSE);
+	timer = GPOINTER_TO_INT(purple_conversation_get_data(conv, "close-timer"));
+	if (timer) {
+		purple_timeout_remove(timer);
+		purple_conversation_set_data(conv, "close-timer", NULL);
+	}
+}
+
+gboolean pidgin_conv_attach_to_conversation(PurpleConversation *conv)
+{
+	GList *list;
+	PidginConversation *gtkconv;
+
+	if (PIDGIN_IS_PIDGIN_CONVERSATION(conv)) {
+		/* This is pretty much always the case now. */
+		gtkconv = PIDGIN_CONVERSATION(conv);
+		if (gtkconv->win != hidden_convwin)
+			return FALSE;
+		pidgin_conv_window_remove_gtkconv(hidden_convwin, gtkconv);
+		pidgin_conv_placement_place(gtkconv);
+		purple_signal_emit(pidgin_conversations_get_handle(),
+				"conversation-displayed", gtkconv);
+		list = gtkconv->convs;
+		while (list) {
+			pidgin_conv_attach(list->data);
+			list = list->next;
+		}
+		return TRUE;
+	}
+
+	pidgin_conv_attach(conv);
+	gtkconv = PIDGIN_CONVERSATION(conv);
+
+	list = purple_conversation_get_message_history(conv);
+	if (list) {
+		switch (purple_conversation_get_type(conv)) {
+			case PURPLE_CONV_TYPE_IM:
+			{
+				GList *convs;
+				list = g_list_copy(list);
+				for (convs = purple_get_ims(); convs; convs = convs->next)
+					if (convs->data != conv &&
+							pidgin_conv_find_gtkconv(convs->data) == gtkconv) {
+						pidgin_conv_attach(convs->data);
+						list = g_list_concat(list, g_list_copy(purple_conversation_get_message_history(convs->data)));
+					}
+				list = g_list_sort(list, message_compare);
+				gtkconv->attach.current = list;
+				list = g_list_last(list);
+				break;
+			}
+			case PURPLE_CONV_TYPE_CHAT:
+				gtkconv->attach.current = g_list_last(list);
+				break;
+			default:
+				g_return_val_if_reached(TRUE);
+		}
+		g_object_set_data(G_OBJECT(gtkconv->entry), "attach-start-time",
+				GINT_TO_POINTER(((PurpleConvMessage*)(list->data))->when));
+		gtkconv->attach.timer = g_idle_add(add_message_history_to_gtkconv, gtkconv);
+	} else {
+		purple_signal_emit(pidgin_conversations_get_handle(),
+				"conversation-displayed", gtkconv);
+	}
+
+	if (conv->type == PURPLE_CONV_TYPE_CHAT) {
+		pidgin_conv_update_fields(conv, PIDGIN_CONV_TOPIC);
+		pidgin_conv_chat_add_users(conv, PURPLE_CONV_CHAT(conv)->in_room, TRUE);
+	}
+
+	return TRUE;
+}
+
+void *
+pidgin_conversations_get_handle(void)
+{
+	static int handle;
+
+	return &handle;
+}
+
+void
+pidgin_conversations_init(void)
+{
+	void *handle = pidgin_conversations_get_handle();
+	void *blist_handle = purple_blist_get_handle();
+
+	/* Conversations */
+	purple_prefs_add_none(PIDGIN_PREFS_ROOT "/conversations");
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/use_smooth_scrolling", TRUE);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/close_on_tabs", TRUE);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/send_bold", FALSE);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/send_italic", FALSE);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/send_underline", FALSE);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/spellcheck", TRUE);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/show_incoming_formatting", TRUE);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/resize_custom_smileys", TRUE);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/custom_smileys_size", 96);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/minimum_entry_lines", 2);
+
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/show_timestamps", TRUE);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/show_formatting_toolbar", TRUE);
+
+	purple_prefs_add_string(PIDGIN_PREFS_ROOT "/conversations/placement", "last");
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/placement_number", 1);
+	purple_prefs_add_string(PIDGIN_PREFS_ROOT "/conversations/bgcolor", "");
+	purple_prefs_add_string(PIDGIN_PREFS_ROOT "/conversations/fgcolor", "");
+	purple_prefs_add_string(PIDGIN_PREFS_ROOT "/conversations/font_face", "");
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/font_size", 3);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/tabs", TRUE);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/tab_side", GTK_POS_TOP);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/scrollback_lines", 4000);
+
+#ifdef _WIN32
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/use_theme_font", TRUE);
+	purple_prefs_add_string(PIDGIN_PREFS_ROOT "/conversations/custom_font", "");
+#endif
+
+	/* Conversations -> Chat */
+	purple_prefs_add_none(PIDGIN_PREFS_ROOT "/conversations/chat");
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/chat/entry_height", 54);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/chat/userlist_width", 80);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/chat/x", 0);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/chat/y", 0);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/chat/width", 340);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/chat/height", 390);
+
+	/* Conversations -> IM */
+	purple_prefs_add_none(PIDGIN_PREFS_ROOT "/conversations/im");
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/im/x", 0);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/im/y", 0);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/im/width", 340);
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/im/height", 390);
+
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/im/animate_buddy_icons", TRUE);
+
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/conversations/im/entry_height", 54);
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/im/show_buddy_icons", TRUE);
+
+	purple_prefs_add_string(PIDGIN_PREFS_ROOT "/conversations/im/hide_new", "never");
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/conversations/im/close_immediately", TRUE);
+
+#ifdef _WIN32
+	purple_prefs_add_bool(PIDGIN_PREFS_ROOT "/win32/minimize_new_convs", FALSE);
+#endif
+
+	/* Connect callbacks. */
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/close_on_tabs",
+								close_on_tabs_pref_cb, NULL);
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/show_timestamps",
+								show_timestamps_pref_cb, NULL);
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/show_formatting_toolbar",
+								show_formatting_toolbar_pref_cb, NULL);
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/spellcheck",
+								spellcheck_pref_cb, NULL);
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/tab_side",
+								tab_side_pref_cb, NULL);
+
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/tabs",
+								conv_placement_usetabs_cb, NULL);
+
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/placement",
+								conv_placement_pref_cb, NULL);
+	purple_prefs_trigger_callback(PIDGIN_PREFS_ROOT "/conversations/placement");
+
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/minimum_entry_lines",
+		minimum_entry_lines_pref_cb, NULL);
+
+	/* IM callbacks */
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/im/animate_buddy_icons",
+								animate_buddy_icons_pref_cb, NULL);
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/im/show_buddy_icons",
+								show_buddy_icons_pref_cb, NULL);
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/blist/show_protocol_icons",
+								show_protocol_icons_pref_cb, NULL);
+	purple_prefs_connect_callback(handle, PIDGIN_PREFS_ROOT "/conversations/im/hide_new",
+                                hide_new_pref_cb, NULL);
+
+
+
+	/**********************************************************************
+	 * Register signals
+	 **********************************************************************/
+	purple_signal_register(handle, "conversation-dragging",
+	                     purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+	                     purple_value_new(PURPLE_TYPE_BOXED,
+	                                    "PidginWindow *"),
+	                     purple_value_new(PURPLE_TYPE_BOXED,
+	                                    "PidginWindow *"));
+
+	purple_signal_register(handle, "conversation-timestamp",
+#if SIZEOF_TIME_T == 4
+	                     purple_marshal_POINTER__POINTER_INT_BOOLEAN,
+#elif SIZEOF_TIME_T == 8
+			     purple_marshal_POINTER__POINTER_INT64_BOOLEAN,
+#else
+#error Unkown size of time_t
+#endif
+	                     purple_value_new(PURPLE_TYPE_STRING), 3,
+	                     purple_value_new(PURPLE_TYPE_SUBTYPE,
+	                                    PURPLE_SUBTYPE_CONVERSATION),
+#if SIZEOF_TIME_T == 4
+	                     purple_value_new(PURPLE_TYPE_INT),
+#elif SIZEOF_TIME_T == 8
+	                     purple_value_new(PURPLE_TYPE_INT64),
+#else
+# error Unknown size of time_t
+#endif
+	                     purple_value_new(PURPLE_TYPE_BOOLEAN));
+
+	purple_signal_register(handle, "displaying-im-msg",
+						 purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_POINTER,
+						 purple_value_new(PURPLE_TYPE_BOOLEAN), 5,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_ACCOUNT),
+						 purple_value_new(PURPLE_TYPE_STRING),
+						 purple_value_new_outgoing(PURPLE_TYPE_STRING),
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_CONVERSATION),
+						 purple_value_new(PURPLE_TYPE_INT));
+
+	purple_signal_register(handle, "displayed-im-msg",
+						 purple_marshal_VOID__POINTER_POINTER_POINTER_POINTER_UINT,
+						 NULL, 5,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_ACCOUNT),
+						 purple_value_new(PURPLE_TYPE_STRING),
+						 purple_value_new(PURPLE_TYPE_STRING),
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_CONVERSATION),
+						 purple_value_new(PURPLE_TYPE_INT));
+
+	purple_signal_register(handle, "displaying-chat-msg",
+						 purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_POINTER,
+						 purple_value_new(PURPLE_TYPE_BOOLEAN), 5,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_ACCOUNT),
+						 purple_value_new(PURPLE_TYPE_STRING),
+						 purple_value_new_outgoing(PURPLE_TYPE_STRING),
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_CONVERSATION),
+						 purple_value_new(PURPLE_TYPE_INT));
+
+	purple_signal_register(handle, "displayed-chat-msg",
+						 purple_marshal_VOID__POINTER_POINTER_POINTER_POINTER_UINT,
+						 NULL, 5,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_ACCOUNT),
+						 purple_value_new(PURPLE_TYPE_STRING),
+						 purple_value_new(PURPLE_TYPE_STRING),
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_CONVERSATION),
+						 purple_value_new(PURPLE_TYPE_INT));
+
+	purple_signal_register(handle, "conversation-switched",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_CONVERSATION));
+
+	purple_signal_register(handle, "conversation-hiding",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_BOXED,
+										"PidginConversation *"));
+
+	purple_signal_register(handle, "conversation-displayed",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_BOXED,
+										"PidginConversation *"));
+
+	purple_signal_register(handle, "chat-nick-autocomplete",
+						 purple_marshal_BOOLEAN__POINTER_BOOLEAN,
+						 purple_value_new(PURPLE_TYPE_BOOLEAN), 1,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+							 			PURPLE_SUBTYPE_CONVERSATION));
+
+	purple_signal_register(handle, "chat-nick-clicked",
+						 purple_marshal_BOOLEAN__POINTER_POINTER_UINT,
+						 purple_value_new(PURPLE_TYPE_BOOLEAN), 3,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+							 			PURPLE_SUBTYPE_CONVERSATION),
+						 purple_value_new(PURPLE_TYPE_STRING),
+						 purple_value_new(PURPLE_TYPE_UINT));
+
+
+	/**********************************************************************
+	 * Register commands
+	 **********************************************************************/
+	purple_cmd_register("say", "S", PURPLE_CMD_P_DEFAULT,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_IM, NULL,
+	                  say_command_cb, _("say &lt;message&gt;:  Send a message normally as if you weren't using a command."), NULL);
+	purple_cmd_register("me", "S", PURPLE_CMD_P_DEFAULT,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_IM, NULL,
+	                  me_command_cb, _("me &lt;action&gt;:  Send an IRC style action to a buddy or chat."), NULL);
+	purple_cmd_register("debug", "w", PURPLE_CMD_P_DEFAULT,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_IM, NULL,
+	                  debug_command_cb, _("debug &lt;option&gt;:  Send various debug information to the current conversation."), NULL);
+	purple_cmd_register("clear", "", PURPLE_CMD_P_DEFAULT,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_IM, NULL,
+	                  clear_command_cb, _("clear: Clears the conversation scrollback."), NULL);
+	purple_cmd_register("clearall", "", PURPLE_CMD_P_DEFAULT,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_IM, NULL,
+	                  clearall_command_cb, _("clear: Clears all conversation scrollbacks."), NULL);
+	purple_cmd_register("help", "w", PURPLE_CMD_P_DEFAULT,
+	                  PURPLE_CMD_FLAG_CHAT | PURPLE_CMD_FLAG_IM | PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS, NULL,
+	                  help_command_cb, _("help &lt;command&gt;:  Help on a specific command."), NULL);
+
+	/**********************************************************************
+	 * UI operations
+	 **********************************************************************/
+
+	purple_signal_connect(purple_connections_get_handle(), "signed-on", handle,
+						G_CALLBACK(account_signed_off_cb),
+						GINT_TO_POINTER(PURPLE_CONV_ACCOUNT_ONLINE));
+	purple_signal_connect(purple_connections_get_handle(), "signed-off", handle,
+						G_CALLBACK(account_signed_off_cb),
+						GINT_TO_POINTER(PURPLE_CONV_ACCOUNT_OFFLINE));
+	purple_signal_connect(purple_connections_get_handle(), "signing-off", handle,
+						G_CALLBACK(account_signing_off), NULL);
+
+	purple_signal_connect(purple_conversations_get_handle(), "received-im-msg",
+						handle, G_CALLBACK(received_im_msg_cb), NULL);
+	purple_signal_connect(purple_conversations_get_handle(), "cleared-message-history",
+	                      handle, G_CALLBACK(clear_conversation_scrollback_cb), NULL);
+
+	purple_signal_connect(purple_conversations_get_handle(), "deleting-chat-buddy",
+	                      handle, G_CALLBACK(deleting_chat_buddy_cb), NULL);
+
+	purple_conversations_set_ui_ops(&conversation_ui_ops);
+
+	hidden_convwin = pidgin_conv_window_new();
+	window_list = g_list_remove(window_list, hidden_convwin);
+
+	purple_signal_connect(purple_accounts_get_handle(), "account-status-changed",
+                        handle, PURPLE_CALLBACK(account_status_changed_cb), NULL);
+
+	/* Callbacks to update a conversation */
+	purple_signal_connect(blist_handle, "blist-node-added", handle,
+						G_CALLBACK(buddy_update_cb), NULL);
+	purple_signal_connect(blist_handle, "blist-node-removed", handle,
+						G_CALLBACK(buddy_update_cb), NULL);
+	purple_signal_connect(blist_handle, "buddy-signed-on",
+						handle, PURPLE_CALLBACK(update_buddy_sign), "on");
+	purple_signal_connect(blist_handle, "buddy-signed-off",
+						handle, PURPLE_CALLBACK(update_buddy_sign), "off");
+	purple_signal_connect(blist_handle, "buddy-status-changed",
+						handle, PURPLE_CALLBACK(update_buddy_status_changed), NULL);
+	purple_signal_connect(blist_handle, "buddy-privacy-changed",
+						handle, PURPLE_CALLBACK(update_buddy_privacy_changed), NULL);
+	purple_signal_connect(blist_handle, "buddy-idle-changed",
+						handle, PURPLE_CALLBACK(update_buddy_idle_changed), NULL);
+	purple_signal_connect(blist_handle, "buddy-icon-changed",
+						handle, PURPLE_CALLBACK(update_buddy_icon), NULL);
+	purple_signal_connect(purple_conversations_get_handle(), "buddy-typing",
+						handle, PURPLE_CALLBACK(update_buddy_typing), NULL);
+	purple_signal_connect(purple_conversations_get_handle(), "buddy-typing-stopped",
+						handle, PURPLE_CALLBACK(update_buddy_typing), NULL);
+	purple_signal_connect(pidgin_conversations_get_handle(), "conversation-switched",
+						handle, PURPLE_CALLBACK(update_conversation_switched), NULL);
+	purple_signal_connect(purple_conversations_get_handle(), "chat-left", handle,
+						PURPLE_CALLBACK(update_chat), NULL);
+	purple_signal_connect(purple_conversations_get_handle(), "chat-joined", handle,
+						PURPLE_CALLBACK(update_chat), NULL);
+	purple_signal_connect(purple_conversations_get_handle(), "chat-topic-changed", handle,
+						PURPLE_CALLBACK(update_chat_topic), NULL);
+	purple_signal_connect_priority(purple_conversations_get_handle(), "conversation-updated", handle,
+						PURPLE_CALLBACK(pidgin_conv_updated), NULL,
+						PURPLE_SIGNAL_PRIORITY_LOWEST);
+	purple_signal_connect(purple_conversations_get_handle(), "wrote-im-msg", handle,
+			PURPLE_CALLBACK(wrote_msg_update_unseen_cb), NULL);
+	purple_signal_connect(purple_conversations_get_handle(), "wrote-chat-msg", handle,
+			PURPLE_CALLBACK(wrote_msg_update_unseen_cb), NULL);
+
+	{
+		/* Set default tab colors */
+		GString *str = g_string_new(NULL);
+		GtkSettings *settings = gtk_settings_get_default();
+		GtkStyle *parent = gtk_rc_get_style_by_paths(settings, "tab-container.tab-label*", NULL, G_TYPE_NONE), *now;
+		struct {
+			const char *stylename;
+			const char *labelname;
+			const char *color;
+		} styles[] = {
+			{"pidgin_tab_label_typing_default", "tab-label-typing", "#4e9a06"},
+			{"pidgin_tab_label_typed_default", "tab-label-typed", "#c4a000"},
+			{"pidgin_tab_label_attention_default", "tab-label-attention", "#006aff"},
+			{"pidgin_tab_label_unreadchat_default", "tab-label-unreadchat", "#cc0000"},
+			{"pidgin_tab_label_event_default", "tab-label-event", "#888a85"},
+			{NULL, NULL, NULL}
+		};
+		int iter;
+		for (iter = 0; styles[iter].stylename; iter++) {
+			now = gtk_rc_get_style_by_paths(settings, styles[iter].labelname, NULL, G_TYPE_NONE);
+			if (parent == now ||
+					(parent && now && parent->rc_style == now->rc_style)) {
+				g_string_append_printf(str, "style \"%s\" {\n"
+						"fg[ACTIVE] = \"%s\"\n"
+						"}\n"
+						"widget \"*%s\" style \"%s\"\n",
+						styles[iter].stylename,
+						styles[iter].color,
+						styles[iter].labelname, styles[iter].stylename);
+			}
+		}
+		gtk_rc_parse_string(str->str);
+		g_string_free(str, TRUE);
+		gtk_rc_reset_styles(settings);
+	}
+}
+
+void
+pidgin_conversations_uninit(void)
+{
+	purple_prefs_disconnect_by_handle(pidgin_conversations_get_handle());
+	purple_signals_disconnect_by_handle(pidgin_conversations_get_handle());
+	purple_signals_unregister_by_instance(pidgin_conversations_get_handle());
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/* down here is where gtkconvwin.c ought to start. except they share like every freaking function,
+ * and touch each others' private members all day long */
+
+/**
+ * @file gtkconvwin.c GTK+ Conversation Window API
+ * @ingroup pidgin
+ *
+ * pidgin
+ *
+ * Pidgin is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+#include "internal.h"
+#include "pidgin.h"
+
+
+#include <gdk/gdkkeysyms.h>
+
+#include "account.h"
+#include "cmds.h"
+#include "debug.h"
+#include "imgstore.h"
+#include "log.h"
+#include "notify.h"
+#include "prpl.h"
+#include "request.h"
+#include "util.h"
+
+#include "gtkdnd-hints.h"
+#include "gtkblist.h"
+#include "gtkconv.h"
+#include "gtkdialogs.h"
+#include "gtkmenutray.h"
+#include "gtkpounce.h"
+#include "gtkprefs.h"
+#include "gtkprivacy.h"
+#include "gtkutils.h"
+#include "pidginstock.h"
+#include "gtkimhtml.h"
+#include "gtkimhtmltoolbar.h"
+
+static void
+do_close(GtkWidget *w, int resp, PidginWindow *win)
+{
+	gtk_widget_destroy(warn_close_dialog);
+	warn_close_dialog = NULL;
+
+	if (resp == GTK_RESPONSE_OK)
+		pidgin_conv_window_destroy(win);
+}
+
+static void
+build_warn_close_dialog(PidginWindow *gtkwin)
+{
+	GtkWidget *label, *vbox, *hbox, *img;
+
+	g_return_if_fail(warn_close_dialog == NULL);
+
+	warn_close_dialog = gtk_dialog_new_with_buttons(_("Confirm close"),
+							GTK_WINDOW(gtkwin->window), GTK_DIALOG_MODAL,
+							GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+							GTK_STOCK_CLOSE, GTK_RESPONSE_OK, NULL);
+
+	gtk_dialog_set_default_response(GTK_DIALOG(warn_close_dialog),
+	                                GTK_RESPONSE_OK);
+
+	gtk_container_set_border_width(GTK_CONTAINER(warn_close_dialog),
+	                               6);
+	gtk_window_set_resizable(GTK_WINDOW(warn_close_dialog), FALSE);
+	gtk_dialog_set_has_separator(GTK_DIALOG(warn_close_dialog),
+	                             FALSE);
+
+	/* Setup the outside spacing. */
+	vbox = GTK_DIALOG(warn_close_dialog)->vbox;
+
+	gtk_box_set_spacing(GTK_BOX(vbox), 12);
+	gtk_container_set_border_width(GTK_CONTAINER(vbox), 6);
+
+	img = gtk_image_new_from_stock(PIDGIN_STOCK_DIALOG_WARNING,
+	                               gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_HUGE));
+	/* Setup the inner hbox and put the dialog's icon in it. */
+	hbox = gtk_hbox_new(FALSE, 12);
+	gtk_container_add(GTK_CONTAINER(vbox), hbox);
+	gtk_box_pack_start(GTK_BOX(hbox), img, FALSE, FALSE, 0);
+	gtk_misc_set_alignment(GTK_MISC(img), 0, 0);
+
+	/* Setup the right vbox. */
+	vbox = gtk_vbox_new(FALSE, 12);
+	gtk_container_add(GTK_CONTAINER(hbox), vbox);
+
+	label = gtk_label_new(_("You have unread messages. Are you sure you want to close the window?"));
+	gtk_widget_set_size_request(label, 350, -1);
+	gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);
+	gtk_misc_set_alignment(GTK_MISC(label), 0, 0);
+	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);
+
+	/* Connect the signals. */
+	g_signal_connect(G_OBJECT(warn_close_dialog), "response",
+	                 G_CALLBACK(do_close), gtkwin);
+
+}
+
+/**************************************************************************
+ * Callbacks
+ **************************************************************************/
+
+static gboolean
+close_win_cb(GtkWidget *w, GdkEventAny *e, gpointer d)
+{
+	PidginWindow *win = d;
+	GList *l;
+
+	/* If there are unread messages then show a warning dialog */
+	for (l = pidgin_conv_window_get_gtkconvs(win);
+	     l != NULL; l = l->next)
+	{
+		PidginConversation *gtkconv = l->data;
+		if (purple_conversation_get_type(gtkconv->active_conv) == PURPLE_CONV_TYPE_IM &&
+				gtkconv->unseen_state >= PIDGIN_UNSEEN_TEXT)
+		{
+			build_warn_close_dialog(win);
+			gtk_widget_show_all(warn_close_dialog);
+
+			return TRUE;
+		}
+	}
+
+	pidgin_conv_window_destroy(win);
+
+	return TRUE;
+}
+
+static void
+conv_set_unseen(PurpleConversation *conv, PidginUnseenState state)
+{
+	int unseen_count = 0;
+	PidginUnseenState unseen_state = PIDGIN_UNSEEN_NONE;
+
+	if(purple_conversation_get_data(conv, "unseen-count"))
+		unseen_count = GPOINTER_TO_INT(purple_conversation_get_data(conv, "unseen-count"));
+
+	if(purple_conversation_get_data(conv, "unseen-state"))
+		unseen_state = GPOINTER_TO_INT(purple_conversation_get_data(conv, "unseen-state"));
+
+	if (state == PIDGIN_UNSEEN_NONE)
+	{
+		unseen_count = 0;
+		unseen_state = PIDGIN_UNSEEN_NONE;
+	}
+	else
+	{
+		if (state >= PIDGIN_UNSEEN_TEXT)
+			unseen_count++;
+
+		if (state > unseen_state)
+			unseen_state = state;
+	}
+
+	purple_conversation_set_data(conv, "unseen-count", GINT_TO_POINTER(unseen_count));
+	purple_conversation_set_data(conv, "unseen-state", GINT_TO_POINTER(unseen_state));
+
+	purple_conversation_update(conv, PURPLE_CONV_UPDATE_UNSEEN);
+}
+
+static void
+gtkconv_set_unseen(PidginConversation *gtkconv, PidginUnseenState state)
+{
+	if (state == PIDGIN_UNSEEN_NONE)
+	{
+		gtkconv->unseen_count = 0;
+		gtkconv->unseen_state = PIDGIN_UNSEEN_NONE;
+	}
+	else
+	{
+		if (state >= PIDGIN_UNSEEN_TEXT)
+			gtkconv->unseen_count++;
+
+		if (state > gtkconv->unseen_state)
+			gtkconv->unseen_state = state;
+	}
+
+	purple_conversation_set_data(gtkconv->active_conv, "unseen-count", GINT_TO_POINTER(gtkconv->unseen_count));
+	purple_conversation_set_data(gtkconv->active_conv, "unseen-state", GINT_TO_POINTER(gtkconv->unseen_state));
+
+	purple_conversation_update(gtkconv->active_conv, PURPLE_CONV_UPDATE_UNSEEN);
+}
+
+/*
+ * When a conversation window is focused, we know the user
+ * has looked at it so we know there are no longer unseen
+ * messages.
+ */
+static gboolean
+focus_win_cb(GtkWidget *w, GdkEventFocus *e, gpointer d)
+{
+	PidginWindow *win = d;
+	PidginConversation *gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+
+	if (gtkconv)
+		gtkconv_set_unseen(gtkconv, PIDGIN_UNSEEN_NONE);
+
+	return FALSE;
+}
+
+static void
+notebook_init_grab(PidginWindow *gtkwin, GtkWidget *widget)
+{
+	static GdkCursor *cursor = NULL;
+
+	gtkwin->in_drag = TRUE;
+
+	if (gtkwin->drag_leave_signal) {
+		g_signal_handler_disconnect(G_OBJECT(widget),
+		                            gtkwin->drag_leave_signal);
+		gtkwin->drag_leave_signal = 0;
+	}
+
+	if (cursor == NULL)
+		cursor = gdk_cursor_new(GDK_FLEUR);
+
+	/* Grab the pointer */
+	gtk_grab_add(gtkwin->notebook);
+#ifndef _WIN32
+	/* Currently for win32 GTK+ (as of 2.2.1), gdk_pointer_is_grabbed will
+	   always be true after a button press. */
+	if (!gdk_pointer_is_grabbed())
+#endif
+		gdk_pointer_grab(gtkwin->notebook->window, FALSE,
+		                 GDK_BUTTON1_MOTION_MASK | GDK_BUTTON_RELEASE_MASK,
+		                 NULL, cursor, GDK_CURRENT_TIME);
+}
+
+static gboolean
+notebook_motion_cb(GtkWidget *widget, GdkEventButton *e, PidginWindow *win)
+{
+
+	/*
+	* Make sure the user moved the mouse far enough for the
+	* drag to be initiated.
+	*/
+	if (win->in_predrag) {
+		if (e->x_root <  win->drag_min_x ||
+		    e->x_root >= win->drag_max_x ||
+		    e->y_root <  win->drag_min_y ||
+		    e->y_root >= win->drag_max_y) {
+
+			    win->in_predrag = FALSE;
+			    notebook_init_grab(win, widget);
+		    }
+	}
+	else { /* Otherwise, draw the arrows. */
+		PidginWindow *dest_win;
+		GtkNotebook *dest_notebook;
+		GtkWidget *tab;
+		gint page_num;
+		gboolean horiz_tabs = FALSE;
+		gboolean to_right = FALSE;
+
+		/* Get the window that the cursor is over. */
+		dest_win = pidgin_conv_window_get_at_xy(e->x_root, e->y_root);
+
+		if (dest_win == NULL) {
+			dnd_hints_hide_all();
+
+			return TRUE;
+		}
+
+		dest_notebook = GTK_NOTEBOOK(dest_win->notebook);
+
+		if (gtk_notebook_get_show_tabs(dest_notebook)) {
+			page_num = pidgin_conv_get_tab_at_xy(dest_win,
+			                                      e->x_root, e->y_root, &to_right);
+			to_right = to_right && (win != dest_win);
+			tab = pidgin_conv_window_get_gtkconv_at_index(dest_win, page_num)->tabby;
+		} else {
+			page_num = 0;
+			to_right = pidgin_conv_xy_to_right_infopane(dest_win, e->x_root, e->y_root);
+			tab = pidgin_conv_window_get_gtkconv_at_index(dest_win, page_num)->infopane_hbox;
+		}
+
+		if (gtk_notebook_get_tab_pos(dest_notebook) == GTK_POS_TOP ||
+				gtk_notebook_get_tab_pos(dest_notebook) == GTK_POS_BOTTOM) {
+			horiz_tabs = TRUE;
+		}
+
+		if (gtk_notebook_get_show_tabs(dest_notebook) == FALSE && win == dest_win)
+		{
+			/* dragging a tab from a single-tabbed window over its own window */
+			dnd_hints_hide_all();
+			return TRUE;
+		} else if (horiz_tabs) {
+			if (((gpointer)win == (gpointer)dest_win && win->drag_tab < page_num) || to_right) {
+				dnd_hints_show_relative(HINT_ARROW_DOWN, tab, HINT_POSITION_RIGHT, HINT_POSITION_TOP);
+				dnd_hints_show_relative(HINT_ARROW_UP, tab, HINT_POSITION_RIGHT, HINT_POSITION_BOTTOM);
+			} else {
+				dnd_hints_show_relative(HINT_ARROW_DOWN, tab, HINT_POSITION_LEFT, HINT_POSITION_TOP);
+				dnd_hints_show_relative(HINT_ARROW_UP, tab, HINT_POSITION_LEFT, HINT_POSITION_BOTTOM);
+			}
+		} else {
+			if (((gpointer)win == (gpointer)dest_win && win->drag_tab < page_num) || to_right) {
+				dnd_hints_show_relative(HINT_ARROW_RIGHT, tab, HINT_POSITION_LEFT, HINT_POSITION_BOTTOM);
+				dnd_hints_show_relative(HINT_ARROW_LEFT, tab, HINT_POSITION_RIGHT, HINT_POSITION_BOTTOM);
+			} else {
+				dnd_hints_show_relative(HINT_ARROW_RIGHT, tab, HINT_POSITION_LEFT, HINT_POSITION_TOP);
+				dnd_hints_show_relative(HINT_ARROW_LEFT, tab, HINT_POSITION_RIGHT, HINT_POSITION_TOP);
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+static gboolean
+notebook_leave_cb(GtkWidget *widget, GdkEventCrossing *e, PidginWindow *win)
+{
+	if (win->in_drag)
+		return FALSE;
+
+	if (e->x_root <  win->drag_min_x ||
+	    e->x_root >= win->drag_max_x ||
+	    e->y_root <  win->drag_min_y ||
+	    e->y_root >= win->drag_max_y) {
+
+		    win->in_predrag = FALSE;
+		    notebook_init_grab(win, widget);
+	    }
+
+	return TRUE;
+}
+
+/*
+ * THANK YOU GALEON!
+ */
+
+static gboolean
+infopane_press_cb(GtkWidget *widget, GdkEventButton *e, PidginConversation *gtkconv)
+{
+	if (e->type == GDK_2BUTTON_PRESS && e->button == 1) {
+		if (infopane_entry_activate(gtkconv))
+			return TRUE;
+	}
+
+	if (e->type != GDK_BUTTON_PRESS)
+		return FALSE;
+
+	if (e->button == 1) {
+		int nb_x, nb_y;
+
+		if (gtkconv->win->in_drag)
+			return TRUE;
+
+		gtkconv->win->in_predrag = TRUE;
+		gtkconv->win->drag_tab = gtk_notebook_page_num(GTK_NOTEBOOK(gtkconv->win->notebook), gtkconv->tab_cont);
+
+		gdk_window_get_origin(gtkconv->infopane_hbox->window, &nb_x, &nb_y);
+
+		gtkconv->win->drag_min_x = gtkconv->infopane_hbox->allocation.x + nb_x;
+		gtkconv->win->drag_min_y = gtkconv->infopane_hbox->allocation.y + nb_y;
+		gtkconv->win->drag_max_x = gtkconv->infopane_hbox->allocation.width + gtkconv->win->drag_min_x;
+		gtkconv->win->drag_max_y = gtkconv->infopane_hbox->allocation.height + gtkconv->win->drag_min_y;
+
+		gtkconv->win->drag_motion_signal = g_signal_connect(G_OBJECT(gtkconv->win->notebook), "motion_notify_event",
+								    G_CALLBACK(notebook_motion_cb), gtkconv->win);
+		gtkconv->win->drag_leave_signal = g_signal_connect(G_OBJECT(gtkconv->win->notebook), "leave_notify_event",
+								    G_CALLBACK(notebook_leave_cb), gtkconv->win);
+		return FALSE;
+	}
+
+	if (e->button == 3) {
+		/* Right click was pressed. Popup the context menu. */
+		GtkWidget *menu = gtk_menu_new(), *sub;
+		gboolean populated = populate_menu_with_options(menu, gtkconv, TRUE);
+		sub = gtk_menu_item_get_submenu(GTK_MENU_ITEM(gtkconv->win->menu.send_to));
+
+		if (sub && GTK_WIDGET_IS_SENSITIVE(gtkconv->win->menu.send_to)) {
+			GtkWidget *item = gtk_menu_item_new_with_mnemonic(_("S_end To"));
+			if (populated)
+				pidgin_separator(menu);
+			gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+			gtk_menu_item_set_submenu(GTK_MENU_ITEM(item), sub);
+			gtk_widget_show(item);
+			gtk_widget_show_all(sub);
+		} else if (!populated) {
+			gtk_widget_destroy(menu);
+			return FALSE;
+		}
+
+		gtk_widget_show_all(menu);
+		gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, e->button, e->time);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static gboolean
+notebook_press_cb(GtkWidget *widget, GdkEventButton *e, PidginWindow *win)
+{
+	gint nb_x, nb_y;
+	int tab_clicked;
+	GtkWidget *page;
+	GtkWidget *tab;
+
+	if (e->button == 2 && e->type == GDK_BUTTON_PRESS) {
+		PidginConversation *gtkconv;
+		tab_clicked = pidgin_conv_get_tab_at_xy(win, e->x_root, e->y_root, NULL);
+
+		if (tab_clicked == -1)
+			return FALSE;
+
+		gtkconv = pidgin_conv_window_get_gtkconv_at_index(win, tab_clicked);
+		close_conv_cb(NULL, gtkconv);
+		return TRUE;
+	}
+
+
+	if (e->button != 1 || e->type != GDK_BUTTON_PRESS)
+		return FALSE;
+
+
+	if (win->in_drag) {
+		purple_debug(PURPLE_DEBUG_WARNING, "gtkconv",
+		           "Already in the middle of a window drag at tab_press_cb\n");
+		return TRUE;
+	}
+
+	/*
+	* Make sure a tab was actually clicked. The arrow buttons
+	* mess things up.
+	*/
+	tab_clicked = pidgin_conv_get_tab_at_xy(win, e->x_root, e->y_root, NULL);
+
+	if (tab_clicked == -1)
+		return FALSE;
+
+	/*
+	* Get the relative position of the press event, with regards to
+	* the position of the notebook.
+	*/
+	gdk_window_get_origin(win->notebook->window, &nb_x, &nb_y);
+
+	/* Reset the min/max x/y */
+	win->drag_min_x = 0;
+	win->drag_min_y = 0;
+	win->drag_max_x = 0;
+	win->drag_max_y = 0;
+
+	/* Find out which tab was dragged. */
+	page = gtk_notebook_get_nth_page(GTK_NOTEBOOK(win->notebook), tab_clicked);
+	tab = gtk_notebook_get_tab_label(GTK_NOTEBOOK(win->notebook), page);
+
+	win->drag_min_x = tab->allocation.x      + nb_x;
+	win->drag_min_y = tab->allocation.y      + nb_y;
+	win->drag_max_x = tab->allocation.width  + win->drag_min_x;
+	win->drag_max_y = tab->allocation.height + win->drag_min_y;
+
+	/* Make sure the click occurred in the tab. */
+	if (e->x_root <  win->drag_min_x ||
+	    e->x_root >= win->drag_max_x ||
+	    e->y_root <  win->drag_min_y ||
+	    e->y_root >= win->drag_max_y) {
+
+		    return FALSE;
+	    }
+
+	win->in_predrag = TRUE;
+	win->drag_tab = tab_clicked;
+
+	/* Connect the new motion signals. */
+	win->drag_motion_signal =
+		g_signal_connect(G_OBJECT(widget), "motion_notify_event",
+		                 G_CALLBACK(notebook_motion_cb), win);
+
+	win->drag_leave_signal =
+		g_signal_connect(G_OBJECT(widget), "leave_notify_event",
+		                 G_CALLBACK(notebook_leave_cb), win);
+
+	return FALSE;
+}
+
+static gboolean
+notebook_release_cb(GtkWidget *widget, GdkEventButton *e, PidginWindow *win)
+{
+	PidginWindow *dest_win;
+	GtkNotebook *dest_notebook;
+	PidginConversation *active_gtkconv;
+	PidginConversation *gtkconv;
+	gint dest_page_num = 0;
+	gboolean new_window = FALSE;
+	gboolean to_right = FALSE;
+
+	/*
+	* Don't check to make sure that the event's window matches the
+	* widget's, because we may be getting an event passed on from the
+	* close button.
+	*/
+	if (e->button != 1 && e->type != GDK_BUTTON_RELEASE)
+		return FALSE;
+
+	if (gdk_pointer_is_grabbed()) {
+		gdk_pointer_ungrab(GDK_CURRENT_TIME);
+		gtk_grab_remove(widget);
+	}
+
+	if (!win->in_predrag && !win->in_drag)
+		return FALSE;
+
+	/* Disconnect the motion signal. */
+	if (win->drag_motion_signal) {
+		g_signal_handler_disconnect(G_OBJECT(widget),
+		                            win->drag_motion_signal);
+
+		win->drag_motion_signal = 0;
+	}
+
+	/*
+	* If we're in a pre-drag, we'll also need to disconnect the leave
+	* signal.
+	*/
+	if (win->in_predrag) {
+		win->in_predrag = FALSE;
+
+		if (win->drag_leave_signal) {
+			g_signal_handler_disconnect(G_OBJECT(widget),
+			                            win->drag_leave_signal);
+
+			win->drag_leave_signal = 0;
+		}
+	}
+
+	/* If we're not in drag...        */
+	/* We're perfectly normal people! */
+	if (!win->in_drag)
+		return FALSE;
+
+	win->in_drag = FALSE;
+
+	dnd_hints_hide_all();
+
+	dest_win = pidgin_conv_window_get_at_xy(e->x_root, e->y_root);
+
+	active_gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+
+	if (dest_win == NULL) {
+		/* If the current window doesn't have any other conversations,
+		* there isn't much point transferring the conv to a new window. */
+		if (pidgin_conv_window_get_gtkconv_count(win) > 1) {
+			/* Make a new window to stick this to. */
+			dest_win = pidgin_conv_window_new();
+			new_window = TRUE;
+		}
+	}
+
+	if (dest_win == NULL)
+		return FALSE;
+
+	purple_signal_emit(pidgin_conversations_get_handle(),
+	                 "conversation-dragging", win, dest_win);
+
+	/* Get the destination page number. */
+	if (!new_window) {
+		dest_notebook = GTK_NOTEBOOK(dest_win->notebook);
+		if (gtk_notebook_get_show_tabs(dest_notebook)) {
+			dest_page_num = pidgin_conv_get_tab_at_xy(dest_win,
+			                                           e->x_root, e->y_root, &to_right);
+		} else {
+			dest_page_num = 0;
+			to_right = pidgin_conv_xy_to_right_infopane(dest_win, e->x_root, e->y_root);
+		}
+	}
+
+	gtkconv = pidgin_conv_window_get_gtkconv_at_index(win, win->drag_tab);
+
+	if (win == dest_win) {
+		gtk_notebook_reorder_child(GTK_NOTEBOOK(win->notebook), gtkconv->tab_cont, dest_page_num);
+	} else {
+		pidgin_conv_window_remove_gtkconv(win, gtkconv);
+		pidgin_conv_window_add_gtkconv(dest_win, gtkconv);
+		gtk_notebook_reorder_child(GTK_NOTEBOOK(dest_win->notebook), gtkconv->tab_cont, dest_page_num + to_right);
+		pidgin_conv_window_switch_gtkconv(dest_win, gtkconv);
+		if (new_window) {
+			gint win_width, win_height;
+
+			gtk_window_get_size(GTK_WINDOW(dest_win->window),
+			                    &win_width, &win_height);
+#ifdef _WIN32  /* only override window manager placement on Windows */
+			gtk_window_move(GTK_WINDOW(dest_win->window),
+			                e->x_root - (win_width  / 2),
+			                e->y_root - (win_height / 2));
+#endif
+
+			pidgin_conv_window_show(dest_win);
+		}
+	}
+
+	gtk_widget_grab_focus(active_gtkconv->entry);
+
+	return TRUE;
+}
+
+
+static void
+before_switch_conv_cb(GtkNotebook *notebook, GtkWidget *page, gint page_num,
+                      gpointer user_data)
+{
+	PidginWindow *win;
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+
+	win = user_data;
+	conv = pidgin_conv_window_get_active_conversation(win);
+
+	g_return_if_fail(conv != NULL);
+
+	if (purple_conversation_get_type(conv) != PURPLE_CONV_TYPE_IM)
+		return;
+
+	gtkconv = PIDGIN_CONVERSATION(conv);
+
+	if (gtkconv->u.im->typing_timer != 0) {
+		g_source_remove(gtkconv->u.im->typing_timer);
+		gtkconv->u.im->typing_timer = 0;
+	}
+
+	stop_anim(NULL, gtkconv);
+}
+static void
+close_window(GtkWidget *w, PidginWindow *win)
+{
+	close_win_cb(w, NULL, win);
+}
+
+static void
+detach_tab_cb(GtkWidget *w, GObject *menu)
+{
+	PidginWindow *win, *new_window;
+	PidginConversation *gtkconv;
+
+	gtkconv = g_object_get_data(menu, "clicked_tab");
+
+	if (!gtkconv)
+		return;
+
+	win = pidgin_conv_get_window(gtkconv);
+	/* Nothing to do if there's only one tab in the window */
+	if (pidgin_conv_window_get_gtkconv_count(win) == 1)
+		return;
+
+	pidgin_conv_window_remove_gtkconv(win, gtkconv);
+
+	new_window = pidgin_conv_window_new();
+	pidgin_conv_window_add_gtkconv(new_window, gtkconv);
+	pidgin_conv_window_show(new_window);
+}
+
+static void
+close_others_cb(GtkWidget *w, GObject *menu)
+{
+	GList *iter;
+	PidginConversation *gtkconv;
+	PidginWindow *win;
+
+	gtkconv = g_object_get_data(menu, "clicked_tab");
+
+	if (!gtkconv)
+		return;
+
+	win = pidgin_conv_get_window(gtkconv);
+
+	for (iter = pidgin_conv_window_get_gtkconvs(win); iter; )
+	{
+		PidginConversation *gconv = iter->data;
+		iter = iter->next;
+
+		if (gconv != gtkconv)
+		{
+			close_conv_cb(NULL, gconv);
+		}
+	}
+}
+
+static void close_tab_cb(GtkWidget *w, GObject *menu)
+{
+	PidginConversation *gtkconv;
+
+	gtkconv = g_object_get_data(menu, "clicked_tab");
+
+	if (gtkconv)
+		close_conv_cb(NULL, gtkconv);
+}
+
+static gboolean
+right_click_menu_cb(GtkNotebook *notebook, GdkEventButton *event, PidginWindow *win)
+{
+	GtkWidget *item, *menu;
+	PidginConversation *gtkconv;
+
+	if (event->type != GDK_BUTTON_PRESS || event->button != 3)
+		return FALSE;
+
+	gtkconv = pidgin_conv_window_get_gtkconv_at_index(win,
+			pidgin_conv_get_tab_at_xy(win, event->x_root, event->y_root, NULL));
+
+	if (g_object_get_data(G_OBJECT(notebook->menu), "clicked_tab"))
+	{
+		g_object_set_data(G_OBJECT(notebook->menu), "clicked_tab", gtkconv);
+		return FALSE;
+	}
+
+	g_object_set_data(G_OBJECT(notebook->menu), "clicked_tab", gtkconv);
+
+	menu = notebook->menu;
+	pidgin_separator(GTK_WIDGET(menu));
+
+	item = gtk_menu_item_new_with_label(_("Close other tabs"));
+	gtk_widget_show(item);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+	g_signal_connect(G_OBJECT(item), "activate",
+					G_CALLBACK(close_others_cb), menu);
+
+	item = gtk_menu_item_new_with_label(_("Close all tabs"));
+	gtk_widget_show(item);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+	g_signal_connect(G_OBJECT(item), "activate",
+					G_CALLBACK(close_window), win);
+
+	pidgin_separator(menu);
+
+	item = gtk_menu_item_new_with_label(_("Detach this tab"));
+	gtk_widget_show(item);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+	g_signal_connect(G_OBJECT(item), "activate",
+					G_CALLBACK(detach_tab_cb), menu);
+
+	item = gtk_menu_item_new_with_label(_("Close this tab"));
+	gtk_widget_show(item);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+	g_signal_connect(G_OBJECT(item), "activate",
+					G_CALLBACK(close_tab_cb), menu);
+
+	return FALSE;
+}
+
+static void
+remove_edit_entry(PidginConversation *gtkconv, GtkWidget *entry)
+{
+	g_signal_handlers_disconnect_matched(G_OBJECT(entry), G_SIGNAL_MATCH_DATA,
+				0, 0, NULL, NULL, gtkconv);
+	gtk_widget_show(gtkconv->infopane);
+	gtk_widget_grab_focus(gtkconv->entry);
+	gtk_widget_destroy(entry);
+}
+
+static gboolean
+alias_focus_cb(GtkWidget *widget, GdkEventFocus *event, gpointer user_data)
+{
+	remove_edit_entry(user_data, widget);
+	return FALSE;
+}
+
+static gboolean
+alias_key_press_cb(GtkWidget *widget, GdkEventKey *event, gpointer user_data)
+{
+	if (event->keyval == GDK_Escape) {
+		remove_edit_entry(user_data, widget);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static void
+alias_cb(GtkEntry *entry, gpointer user_data)
+{
+	PidginConversation *gtkconv;
+	PurpleConversation *conv;
+	PurpleAccount *account;
+	const char *name;
+
+	gtkconv = (PidginConversation *)user_data;
+	if (gtkconv == NULL) {
+		return;
+	}
+	conv    = gtkconv->active_conv;
+	account = purple_conversation_get_account(conv);
+	name    = purple_conversation_get_name(conv);
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		PurpleBuddy *buddy;
+		buddy = purple_find_buddy(account, name);
+		if (buddy != NULL) {
+			purple_blist_alias_buddy(buddy,
+                                                 gtk_entry_get_text(entry));
+		}
+		serv_alias_buddy(buddy);
+	} else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+		gtk_entry_set_text(GTK_ENTRY(gtkconv->u.chat->topic_text), gtk_entry_get_text(entry));
+		topic_callback(NULL, gtkconv);
+	}
+	remove_edit_entry(user_data, GTK_WIDGET(entry));
+}
+
+static gboolean
+infopane_entry_activate(PidginConversation *gtkconv)
+{
+	GtkWidget *entry = NULL;
+	PurpleConversation *conv = gtkconv->active_conv;
+	const char *text = NULL;
+
+	if (!GTK_WIDGET_VISIBLE(gtkconv->infopane)) {
+		/* There's already an entry for alias. Let's not create another one. */
+		return FALSE;
+	}
+
+	if (!purple_account_is_connected(gtkconv->active_conv->account)) {
+		/* Do not allow aliasing someone on a disconnected account. */
+		return FALSE;
+	}
+
+	if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) {
+		PurpleBuddy *buddy = purple_find_buddy(gtkconv->active_conv->account, gtkconv->active_conv->name);
+		if (!buddy)
+			/* This buddy isn't in your buddy list, so we can't alias him */
+			return FALSE;
+
+		text = purple_buddy_get_contact_alias(buddy);
+	} else if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_CHAT) {
+		PurpleConnection *gc;
+		PurplePluginProtocolInfo *prpl_info = NULL;
+
+		gc = purple_conversation_get_gc(conv);
+		if (gc != NULL)
+			prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+		if (prpl_info && prpl_info->set_chat_topic == NULL)
+			/* This protocol doesn't support setting the chat room topic */
+			return FALSE;
+
+		text = purple_conv_chat_get_topic(PURPLE_CONV_CHAT(conv));
+	}
+
+	/* alias label */
+	entry = gtk_entry_new();
+	gtk_entry_set_has_frame(GTK_ENTRY(entry), FALSE);
+	gtk_entry_set_width_chars(GTK_ENTRY(entry), 10);
+	gtk_entry_set_alignment(GTK_ENTRY(entry), 0.5);
+
+	gtk_box_pack_start(GTK_BOX(gtkconv->infopane_hbox), entry, TRUE, TRUE, 0);
+	/* after the tab label */
+	gtk_box_reorder_child(GTK_BOX(gtkconv->infopane_hbox), entry, 0);
+
+	g_signal_connect(G_OBJECT(entry), "activate", G_CALLBACK(alias_cb), gtkconv);
+	g_signal_connect(G_OBJECT(entry), "focus-out-event", G_CALLBACK(alias_focus_cb), gtkconv);
+	g_signal_connect(G_OBJECT(entry), "key-press-event", G_CALLBACK(alias_key_press_cb), gtkconv);
+
+	if (text != NULL)
+		gtk_entry_set_text(GTK_ENTRY(entry), text);
+	gtk_widget_show(entry);
+	gtk_widget_hide(gtkconv->infopane);
+	gtk_widget_grab_focus(entry);
+
+	return TRUE;
+}
+
+static gboolean
+window_keypress_cb(GtkWidget *widget, GdkEventKey *event, PidginWindow *win)
+{
+	PidginConversation *gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+
+	return conv_keypress_common(gtkconv, event);
+}
+
+static void
+switch_conv_cb(GtkNotebook *notebook, GtkWidget *page, gint page_num,
+               gpointer user_data)
+{
+	PidginWindow *win;
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+	const char *sound_method;
+
+	win = user_data;
+	gtkconv = pidgin_conv_window_get_gtkconv_at_index(win, page_num);
+	conv = gtkconv->active_conv;
+
+	g_return_if_fail(conv != NULL);
+
+	/* clear unseen flag if conversation is not hidden */
+	if(!pidgin_conv_is_hidden(gtkconv)) {
+		gtkconv_set_unseen(gtkconv, PIDGIN_UNSEEN_NONE);
+	}
+
+	/* Update the menubar */
+
+	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(gtkconv->win->menu.logging),
+	                               purple_conversation_is_logging(conv));
+
+	generate_send_to_items(win);
+	regenerate_options_items(win);
+	regenerate_plugins_items(win);
+
+	pidgin_conv_switch_active_conversation(conv);
+
+	sound_method = purple_prefs_get_string(PIDGIN_PREFS_ROOT "/sound/method");
+	if (strcmp(sound_method, "none") != 0)
+		gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(win->menu.sounds),
+		                               gtkconv->make_sound);
+
+	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(win->menu.show_formatting_toolbar),
+	                               purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/show_formatting_toolbar"));
+
+	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(win->menu.show_timestamps),
+	                               purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/show_timestamps"));
+
+	/*
+	 * We pause icons when they are not visible.  If this icon should
+	 * be animated then start it back up again.
+	 */
+	if ((purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM) &&
+	    (gtkconv->u.im->animate))
+		start_anim(NULL, gtkconv);
+
+	purple_signal_emit(pidgin_conversations_get_handle(), "conversation-switched", conv);
+}
+
+/**************************************************************************
+ * GTK+ window ops
+ **************************************************************************/
+
+GList *
+pidgin_conv_windows_get_list()
+{
+	return window_list;
+}
+
+static GList*
+make_status_icon_list(const char *stock, GtkWidget *w)
+{
+	GList *l = NULL;
+	l = g_list_append(l, gtk_widget_render_icon (w, stock,
+                                       gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_EXTRA_SMALL), "GtkWindow"));
+	l = g_list_append(l, gtk_widget_render_icon (w, stock,
+                                       gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_SMALL), "GtkWindow"));
+	l = g_list_append(l, gtk_widget_render_icon (w, stock,
+                                       gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_MEDIUM), "GtkWindow"));
+	l = g_list_append(l, gtk_widget_render_icon (w, stock,
+                                       gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_LARGE), "GtkWindow"));
+	return l;
+}
+
+static void
+create_icon_lists(GtkWidget *w)
+{
+	available_list = make_status_icon_list(PIDGIN_STOCK_STATUS_AVAILABLE, w);
+	busy_list = make_status_icon_list(PIDGIN_STOCK_STATUS_BUSY, w);
+	xa_list = make_status_icon_list(PIDGIN_STOCK_STATUS_XA, w);
+	offline_list = make_status_icon_list(PIDGIN_STOCK_STATUS_OFFLINE, w);
+	away_list = make_status_icon_list(PIDGIN_STOCK_STATUS_AWAY, w);
+	prpl_lists = g_hash_table_new(g_str_hash, g_str_equal);
+}
+
+static void
+plugin_changed_cb(PurplePlugin *p, gpointer data)
+{
+	regenerate_plugins_items(data);
+}
+
+static gboolean gtk_conv_configure_cb(GtkWidget *w, GdkEventConfigure *event, gpointer data) {
+	int x, y;
+
+	if (GTK_WIDGET_VISIBLE(w))
+		gtk_window_get_position(GTK_WINDOW(w), &x, &y);
+	else
+		return FALSE; /* carry on normally */
+
+	/* Workaround for GTK+ bug # 169811 - "configure_event" is fired
+	* when the window is being maximized */
+	if (gdk_window_get_state(w->window) & GDK_WINDOW_STATE_MAXIMIZED)
+		return FALSE;
+
+	/* don't save off-screen positioning */
+	if (x + event->width < 0 ||
+	    y + event->height < 0 ||
+	    x > gdk_screen_width() ||
+	    y > gdk_screen_height())
+		return FALSE; /* carry on normally */
+
+	/* store the position */
+	purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/im/x", x);
+	purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/im/y", y);
+	purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/im/width",  event->width);
+	purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/im/height", event->height);
+
+	/* continue to handle event normally */
+	return FALSE;
+
+}
+
+static void
+pidgin_conv_set_position_size(PidginWindow *win, int conv_x, int conv_y,
+		int conv_width, int conv_height)
+{
+	 /* if the window exists, is hidden, we're saving positions, and the
+          * position is sane... */
+	if (win && win->window &&
+			!GTK_WIDGET_VISIBLE(win->window) && conv_width != 0) {
+
+#ifdef _WIN32  /* only override window manager placement on Windows */
+		/* ...check position is on screen... */
+		if (conv_x >= gdk_screen_width())
+			conv_x = gdk_screen_width() - 100;
+		else if (conv_x + conv_width < 0)
+			conv_x = 100;
+
+		if (conv_y >= gdk_screen_height())
+			conv_y = gdk_screen_height() - 100;
+		else if (conv_y + conv_height < 0)
+			conv_y = 100;
+
+		/* ...and move it back. */
+		gtk_window_move(GTK_WINDOW(win->window), conv_x, conv_y);
+#endif
+		gtk_window_resize(GTK_WINDOW(win->window), conv_width, conv_height);
+	}
+}
+
+static void
+pidgin_conv_restore_position(PidginWindow *win) {
+	pidgin_conv_set_position_size(win,
+		purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/im/x"),
+		purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/im/y"),
+		purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/im/width"),
+		purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/im/height"));
+}
+
+PidginWindow *
+pidgin_conv_window_new()
+{
+	PidginWindow *win;
+	GtkPositionType pos;
+	GtkWidget *testidea;
+	GtkWidget *menubar;
+	GdkModifierType state;
+
+	win = g_malloc0(sizeof(PidginWindow));
+
+	window_list = g_list_append(window_list, win);
+
+	/* Create the window. */
+	win->window = pidgin_create_window(NULL, 0, "conversation", TRUE);
+	if (!gtk_get_current_event_state(&state))
+		gtk_window_set_focus_on_map(GTK_WINDOW(win->window), FALSE);
+
+	/* Etan: I really think this entire function call should happen only
+	 * when we are on Windows but I was informed that back before we used
+	 * to save the window position we stored the window size, so I'm
+	 * leaving it for now. */
+#if TRUE || defined(_WIN32)
+	pidgin_conv_restore_position(win);
+#endif
+
+	if (available_list == NULL) {
+		create_icon_lists(win->window);
+	}
+
+	g_signal_connect(G_OBJECT(win->window), "delete_event",
+	                 G_CALLBACK(close_win_cb), win);
+	g_signal_connect(G_OBJECT(win->window), "focus_in_event",
+	                 G_CALLBACK(focus_win_cb), win);
+
+	/* Intercept keystrokes from the menu items */
+	g_signal_connect(G_OBJECT(win->window), "key_press_event",
+					 G_CALLBACK(window_keypress_cb), win);
+
+
+	/* Create the notebook. */
+	win->notebook = gtk_notebook_new();
+
+	pos = purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/tab_side");
+
+#if 0
+	gtk_notebook_set_tab_hborder(GTK_NOTEBOOK(win->notebook), 0);
+	gtk_notebook_set_tab_vborder(GTK_NOTEBOOK(win->notebook), 0);
+#endif
+	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(win->notebook), pos);
+	gtk_notebook_set_scrollable(GTK_NOTEBOOK(win->notebook), TRUE);
+	gtk_notebook_popup_enable(GTK_NOTEBOOK(win->notebook));
+	gtk_notebook_set_show_tabs(GTK_NOTEBOOK(win->notebook), FALSE);
+	gtk_notebook_set_show_border(GTK_NOTEBOOK(win->notebook), TRUE);
+
+	g_signal_connect(G_OBJECT(win->notebook), "button-press-event",
+					G_CALLBACK(right_click_menu_cb), win);
+
+	gtk_widget_show(win->notebook);
+
+	g_signal_connect(G_OBJECT(win->notebook), "switch_page",
+	                 G_CALLBACK(before_switch_conv_cb), win);
+	g_signal_connect_after(G_OBJECT(win->notebook), "switch_page",
+	                       G_CALLBACK(switch_conv_cb), win);
+
+	/* Setup the tab drag and drop signals. */
+	gtk_widget_add_events(win->notebook,
+	                      GDK_BUTTON1_MOTION_MASK | GDK_LEAVE_NOTIFY_MASK);
+	g_signal_connect(G_OBJECT(win->notebook), "button_press_event",
+	                 G_CALLBACK(notebook_press_cb), win);
+	g_signal_connect(G_OBJECT(win->notebook), "button_release_event",
+	                 G_CALLBACK(notebook_release_cb), win);
+
+	testidea = gtk_vbox_new(FALSE, 0);
+
+	/* Setup the menubar. */
+	menubar = setup_menubar(win);
+	gtk_box_pack_start(GTK_BOX(testidea), menubar, FALSE, TRUE, 0);
+
+	gtk_box_pack_start(GTK_BOX(testidea), win->notebook, TRUE, TRUE, 0);
+
+	gtk_container_add(GTK_CONTAINER(win->window), testidea);
+
+	gtk_widget_show(testidea);
+
+	/* Update the plugin actions when plugins are (un)loaded */
+	purple_signal_connect(purple_plugins_get_handle(), "plugin-load",
+			win, PURPLE_CALLBACK(plugin_changed_cb), win);
+	purple_signal_connect(purple_plugins_get_handle(), "plugin-unload",
+			win, PURPLE_CALLBACK(plugin_changed_cb), win);
+
+
+#ifdef _WIN32
+	g_signal_connect(G_OBJECT(win->window), "show",
+	                 G_CALLBACK(winpidgin_ensure_onscreen), win->window);
+
+	if (purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/win32/minimize_new_convs")
+			&& !gtk_get_current_event_state(&state))
+		gtk_window_iconify(GTK_WINDOW(win->window));
+#endif
+
+	return win;
+}
+
+void
+pidgin_conv_window_destroy(PidginWindow *win)
+{
+	if (win->gtkconvs) {
+		GList *iter = win->gtkconvs;
+		while (iter)
+		{
+			PidginConversation *gtkconv = iter->data;
+			iter = iter->next;
+			close_conv_cb(NULL, gtkconv);
+		}
+		return;
+	}
+
+	purple_prefs_disconnect_by_handle(win);
+	window_list = g_list_remove(window_list, win);
+
+	/* Close the "Find" dialog if it's open */
+	if (win->dialogs.search)
+		gtk_widget_destroy(win->dialogs.search);
+
+	gtk_widget_destroy(win->window);
+
+	g_object_unref(G_OBJECT(win->menu.item_factory));
+
+	purple_notify_close_with_handle(win);
+	purple_signals_disconnect_by_handle(win);
+
+	g_free(win);
+}
+
+void
+pidgin_conv_window_show(PidginWindow *win)
+{
+	gtk_widget_show(win->window);
+}
+
+void
+pidgin_conv_window_hide(PidginWindow *win)
+{
+	gtk_widget_hide(win->window);
+}
+
+void
+pidgin_conv_window_raise(PidginWindow *win)
+{
+	gdk_window_raise(GDK_WINDOW(win->window->window));
+}
+
+void
+pidgin_conv_window_switch_gtkconv(PidginWindow *win, PidginConversation *gtkconv)
+{
+	gtk_notebook_set_current_page(GTK_NOTEBOOK(win->notebook),
+	                              gtk_notebook_page_num(GTK_NOTEBOOK(win->notebook),
+		                              gtkconv->tab_cont));
+}
+
+static gboolean
+gtkconv_tab_set_tip(GtkWidget *widget, GdkEventCrossing *event, PidginConversation *gtkconv)
+{
+#if GTK_CHECK_VERSION(2, 12, 0)
+#define gtk_tooltips_set_tip(tips, w, l, p)  gtk_widget_set_tooltip_text(w, l)
+#endif
+/* PANGO_VERSION_CHECK macro was introduced in 1.15. So we need this double check. */
+#ifndef PANGO_VERSION_CHECK
+#define pango_layout_is_ellipsized(l) TRUE
+#elif !PANGO_VERSION_CHECK(1,16,0)
+#define pango_layout_is_ellipsized(l) TRUE
+#endif
+	PangoLayout *layout;
+
+	layout = gtk_label_get_layout(GTK_LABEL(gtkconv->tab_label));
+	gtk_tooltips_set_tip(gtkconv->tooltips, widget,
+			pango_layout_is_ellipsized(layout) ? gtk_label_get_text(GTK_LABEL(gtkconv->tab_label)) : NULL,
+			NULL);
+	return FALSE;
+#if GTK_CHECK_VERSION(2, 12, 0)
+#undef gtk_tooltips_set_tip
+#endif
+}
+
+void
+pidgin_conv_window_add_gtkconv(PidginWindow *win, PidginConversation *gtkconv)
+{
+	PurpleConversation *conv = gtkconv->active_conv;
+	PidginConversation *focus_gtkconv;
+	GtkWidget *tab_cont = gtkconv->tab_cont;
+	PurpleConversationType conv_type;
+	const gchar *tmp_lab;
+
+	conv_type = purple_conversation_get_type(conv);
+
+	win->gtkconvs = g_list_append(win->gtkconvs, gtkconv);
+	gtkconv->win = win;
+
+	if (win->gtkconvs && win->gtkconvs->next && win->gtkconvs->next->next == NULL)
+		pidgin_conv_tab_pack(win, ((PidginConversation*)win->gtkconvs->data));
+
+
+	/* Close button. */
+	gtkconv->close = pidgin_create_small_button(gtk_label_new("×"));
+	gtk_tooltips_set_tip(gtkconv->tooltips, gtkconv->close,
+	                     _("Close conversation"), NULL);
+
+	g_signal_connect(gtkconv->close, "clicked", G_CALLBACK (close_conv_cb), gtkconv);
+
+	/* Status icon. */
+	gtkconv->icon = gtk_image_new();
+	gtkconv->menu_icon = gtk_image_new();
+	g_object_set(G_OBJECT(gtkconv->icon),
+			"icon-size", gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_MICROSCOPIC),
+			NULL);
+	g_object_set(G_OBJECT(gtkconv->menu_icon),
+			"icon-size", gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_MICROSCOPIC),
+			NULL);
+	gtk_widget_show(gtkconv->icon);
+	update_tab_icon(conv);
+
+	/* Tab label. */
+	gtkconv->tab_label = gtk_label_new(tmp_lab = purple_conversation_get_title(conv));
+	gtk_widget_set_name(gtkconv->tab_label, "tab-label");
+
+	gtkconv->menu_tabby = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtkconv->menu_label = gtk_label_new(tmp_lab);
+	gtk_box_pack_start(GTK_BOX(gtkconv->menu_tabby), gtkconv->menu_icon, FALSE, FALSE, 0);
+
+	gtk_widget_show_all(gtkconv->menu_icon);
+
+	gtk_box_pack_start(GTK_BOX(gtkconv->menu_tabby), gtkconv->menu_label, TRUE, TRUE, 0);
+	gtk_widget_show(gtkconv->menu_label);
+	gtk_misc_set_alignment(GTK_MISC(gtkconv->menu_label), 0, 0);
+
+	gtk_widget_show(gtkconv->menu_tabby);
+
+	if (conv_type == PURPLE_CONV_TYPE_IM)
+		pidgin_conv_update_buddy_icon(conv);
+
+	/* Build and set conversations tab */
+	pidgin_conv_tab_pack(win, gtkconv);
+
+	gtk_notebook_set_menu_label(GTK_NOTEBOOK(win->notebook), tab_cont, gtkconv->menu_tabby);
+
+	gtk_widget_show(tab_cont);
+
+	if (pidgin_conv_window_get_gtkconv_count(win) == 1) {
+		/* Er, bug in notebooks? Switch to the page manually. */
+		gtk_notebook_set_current_page(GTK_NOTEBOOK(win->notebook), 0);
+	} else {
+		gtk_notebook_set_show_tabs(GTK_NOTEBOOK(win->notebook), TRUE);
+	}
+
+	focus_gtkconv = g_list_nth_data(pidgin_conv_window_get_gtkconvs(win),
+	                             gtk_notebook_get_current_page(GTK_NOTEBOOK(win->notebook)));
+	gtk_widget_grab_focus(focus_gtkconv->entry);
+
+	if (pidgin_conv_window_get_gtkconv_count(win) == 1)
+		update_send_to_selection(win);
+}
+
+static void
+pidgin_conv_tab_pack(PidginWindow *win, PidginConversation *gtkconv)
+{
+	gboolean tabs_side = FALSE;
+	gint angle = 0;
+	GtkWidget *first, *third, *ebox;
+
+	if (purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/tab_side") == GTK_POS_LEFT ||
+	    purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/tab_side") == GTK_POS_RIGHT)
+		tabs_side = TRUE;
+	else if (purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/tab_side") == (GTK_POS_LEFT|8))
+		angle = 90;
+	else if (purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/tab_side") == (GTK_POS_RIGHT|8))
+		angle = 270;
+
+	if (!angle) {
+		g_object_set(G_OBJECT(gtkconv->tab_label), "ellipsize", PANGO_ELLIPSIZE_END,  NULL);
+		gtk_label_set_width_chars(GTK_LABEL(gtkconv->tab_label), 4);
+	} else {
+		g_object_set(G_OBJECT(gtkconv->tab_label), "ellipsize", PANGO_ELLIPSIZE_NONE, NULL);
+		gtk_label_set_width_chars(GTK_LABEL(gtkconv->tab_label), -1);
+	}
+
+	if (tabs_side) {
+		gtk_label_set_width_chars(
+			GTK_LABEL(gtkconv->tab_label),
+			MIN(g_utf8_strlen(gtk_label_get_text(GTK_LABEL(gtkconv->tab_label)), -1), 12)
+		);
+	}
+
+	gtk_label_set_angle(GTK_LABEL(gtkconv->tab_label), angle);
+
+#if 0
+	gtk_misc_set_alignment(GTK_MISC(gtkconv->tab_label), 0.00, 0.5);
+	gtk_misc_set_padding(GTK_MISC(gtkconv->tab_label), 4, 0);
+#endif
+
+	if (angle)
+		gtkconv->tabby = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	else
+		gtkconv->tabby = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_widget_set_name(gtkconv->tabby, "tab-container");
+
+	/* select the correct ordering for verticle tabs */
+	if (angle == 90) {
+		first = gtkconv->close;
+		third = gtkconv->icon;
+	} else {
+		first = gtkconv->icon;
+		third = gtkconv->close;
+	}
+
+	ebox = gtk_event_box_new();
+	gtk_event_box_set_visible_window(GTK_EVENT_BOX(ebox), FALSE);
+	gtk_container_add(GTK_CONTAINER(ebox), gtkconv->tabby);
+	g_signal_connect(G_OBJECT(ebox), "enter-notify-event",
+			G_CALLBACK(gtkconv_tab_set_tip), gtkconv);
+
+	if (gtkconv->tab_label->parent == NULL) {
+		/* Pack if it's a new widget */
+		gtk_box_pack_start(GTK_BOX(gtkconv->tabby), first,              FALSE, FALSE, 0);
+		gtk_box_pack_start(GTK_BOX(gtkconv->tabby), gtkconv->tab_label, TRUE,  TRUE,  0);
+		gtk_box_pack_start(GTK_BOX(gtkconv->tabby), third,              FALSE, FALSE, 0);
+
+		/* Add this pane to the conversation's notebook. */
+		gtk_notebook_append_page(GTK_NOTEBOOK(win->notebook), gtkconv->tab_cont, ebox);
+	} else {
+		/* reparent old widgets on preference changes */
+		gtk_widget_reparent(first,              gtkconv->tabby);
+		gtk_widget_reparent(gtkconv->tab_label, gtkconv->tabby);
+		gtk_widget_reparent(third,              gtkconv->tabby);
+		gtk_box_set_child_packing(GTK_BOX(gtkconv->tabby), first,              FALSE, FALSE, 0, GTK_PACK_START);
+		gtk_box_set_child_packing(GTK_BOX(gtkconv->tabby), gtkconv->tab_label, TRUE,  TRUE,  0, GTK_PACK_START);
+		gtk_box_set_child_packing(GTK_BOX(gtkconv->tabby), third,              FALSE, FALSE, 0, GTK_PACK_START);
+
+		/* Reset the tabs label to the new version */
+		gtk_notebook_set_tab_label(GTK_NOTEBOOK(win->notebook), gtkconv->tab_cont, ebox);
+	}
+
+	gtk_notebook_set_tab_label_packing(GTK_NOTEBOOK(win->notebook), gtkconv->tab_cont,
+					   !tabs_side && !angle,
+					   TRUE, GTK_PACK_START);
+
+	if (pidgin_conv_window_get_gtkconv_count(win) == 1)
+		gtk_notebook_set_show_tabs(GTK_NOTEBOOK(win->notebook),
+					   purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/tabs") &&
+                                           (!purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/im/show_buddy_icons") ||
+                                           purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/tab_side") != GTK_POS_TOP));
+
+	/* show the widgets */
+/*	gtk_widget_show(gtkconv->icon); */
+	gtk_widget_show(gtkconv->tab_label);
+	if (purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/close_on_tabs"))
+		gtk_widget_show(gtkconv->close);
+	gtk_widget_show(gtkconv->tabby);
+	gtk_widget_show(ebox);
+}
+
+void
+pidgin_conv_window_remove_gtkconv(PidginWindow *win, PidginConversation *gtkconv)
+{
+	unsigned int index;
+
+	index = gtk_notebook_page_num(GTK_NOTEBOOK(win->notebook), gtkconv->tab_cont);
+
+	g_object_ref(gtkconv->tab_cont);
+	gtk_object_sink(GTK_OBJECT(gtkconv->tab_cont));
+
+	gtk_notebook_remove_page(GTK_NOTEBOOK(win->notebook), index);
+
+	win->gtkconvs = g_list_remove(win->gtkconvs, gtkconv);
+
+	g_signal_handlers_disconnect_matched(win->window, G_SIGNAL_MATCH_DATA,
+			0, 0, NULL, NULL, gtkconv);
+
+	if (win->gtkconvs && win->gtkconvs->next == NULL)
+		pidgin_conv_tab_pack(win, win->gtkconvs->data);
+
+	if (!win->gtkconvs && win != hidden_convwin)
+		pidgin_conv_window_destroy(win);
+}
+
+PidginConversation *
+pidgin_conv_window_get_gtkconv_at_index(const PidginWindow *win, int index)
+{
+	GtkWidget *tab_cont;
+
+	if (index == -1)
+		index = 0;
+	tab_cont = gtk_notebook_get_nth_page(GTK_NOTEBOOK(win->notebook), index);
+	return tab_cont ? g_object_get_data(G_OBJECT(tab_cont), "PidginConversation") : NULL;
+}
+
+PidginConversation *
+pidgin_conv_window_get_active_gtkconv(const PidginWindow *win)
+{
+	int index;
+	GtkWidget *tab_cont;
+
+	index = gtk_notebook_get_current_page(GTK_NOTEBOOK(win->notebook));
+	if (index == -1)
+		index = 0;
+	tab_cont = gtk_notebook_get_nth_page(GTK_NOTEBOOK(win->notebook), index);
+	if (!tab_cont)
+		return NULL;
+	return g_object_get_data(G_OBJECT(tab_cont), "PidginConversation");
+}
+
+
+PurpleConversation *
+pidgin_conv_window_get_active_conversation(const PidginWindow *win)
+{
+	PidginConversation *gtkconv;
+
+	gtkconv = pidgin_conv_window_get_active_gtkconv(win);
+	return gtkconv ? gtkconv->active_conv : NULL;
+}
+
+gboolean
+pidgin_conv_window_is_active_conversation(const PurpleConversation *conv)
+{
+	return conv == pidgin_conv_window_get_active_conversation(PIDGIN_CONVERSATION(conv)->win);
+}
+
+gboolean
+pidgin_conv_window_has_focus(PidginWindow *win)
+{
+	gboolean has_focus = FALSE;
+
+	g_object_get(G_OBJECT(win->window), "has-toplevel-focus", &has_focus, NULL);
+
+	return has_focus;
+}
+
+PidginWindow *
+pidgin_conv_window_get_at_xy(int x, int y)
+{
+	PidginWindow *win;
+	GdkWindow *gdkwin;
+	GList *l;
+
+	gdkwin = gdk_window_at_pointer(&x, &y);
+
+	if (gdkwin)
+		gdkwin = gdk_window_get_toplevel(gdkwin);
+
+	for (l = pidgin_conv_windows_get_list(); l != NULL; l = l->next) {
+		win = l->data;
+
+		if (gdkwin == win->window->window)
+			return win;
+	}
+
+	return NULL;
+}
+
+GList *
+pidgin_conv_window_get_gtkconvs(PidginWindow *win)
+{
+	return win->gtkconvs;
+}
+
+guint
+pidgin_conv_window_get_gtkconv_count(PidginWindow *win)
+{
+	return g_list_length(win->gtkconvs);
+}
+
+PidginWindow *
+pidgin_conv_window_first_with_type(PurpleConversationType type)
+{
+	GList *wins, *convs;
+	PidginWindow *win;
+	PidginConversation *conv;
+
+	if (type == PURPLE_CONV_TYPE_UNKNOWN)
+		return NULL;
+
+	for (wins = pidgin_conv_windows_get_list(); wins != NULL; wins = wins->next) {
+		win = wins->data;
+
+		for (convs = win->gtkconvs;
+		     convs != NULL;
+		     convs = convs->next) {
+
+			conv = convs->data;
+
+			if (purple_conversation_get_type(conv->active_conv) == type)
+				return win;
+		}
+	}
+
+	return NULL;
+}
+
+PidginWindow *
+pidgin_conv_window_last_with_type(PurpleConversationType type)
+{
+	GList *wins, *convs;
+	PidginWindow *win;
+	PidginConversation *conv;
+
+	if (type == PURPLE_CONV_TYPE_UNKNOWN)
+		return NULL;
+
+	for (wins = g_list_last(pidgin_conv_windows_get_list());
+	     wins != NULL;
+	     wins = wins->prev) {
+
+		win = wins->data;
+
+		for (convs = win->gtkconvs;
+		     convs != NULL;
+		     convs = convs->next) {
+
+			conv = convs->data;
+
+			if (purple_conversation_get_type(conv->active_conv) == type)
+				return win;
+		}
+	}
+
+	return NULL;
+}
+
+
+/**************************************************************************
+ * Conversation placement functions
+ **************************************************************************/
+typedef struct
+{
+	char *id;
+	char *name;
+	PidginConvPlacementFunc fnc;
+
+} ConvPlacementData;
+
+static GList *conv_placement_fncs = NULL;
+static PidginConvPlacementFunc place_conv = NULL;
+
+/* This one places conversations in the last made window. */
+static void
+conv_placement_last_created_win(PidginConversation *conv)
+{
+	PidginWindow *win;
+
+	GList *l = g_list_last(pidgin_conv_windows_get_list());
+	win = l ? l->data : NULL;;
+
+	if (win == NULL) {
+		win = pidgin_conv_window_new();
+
+		g_signal_connect(G_OBJECT(win->window), "configure_event",
+				G_CALLBACK(gtk_conv_configure_cb), NULL);
+
+		pidgin_conv_window_add_gtkconv(win, conv);
+		pidgin_conv_window_show(win);
+	} else {
+		pidgin_conv_window_add_gtkconv(win, conv);
+	}
+}
+
+/* This one places conversations in the last made window of the same type. */
+static gboolean
+conv_placement_last_created_win_type_configured_cb(GtkWidget *w,
+		GdkEventConfigure *event, PidginConversation *conv)
+{
+	int x, y;
+	PurpleConversationType type = purple_conversation_get_type(conv->active_conv);
+	GList *all;
+
+	if (GTK_WIDGET_VISIBLE(w))
+		gtk_window_get_position(GTK_WINDOW(w), &x, &y);
+	else
+		return FALSE; /* carry on normally */
+
+	/* Workaround for GTK+ bug # 169811 - "configure_event" is fired
+	* when the window is being maximized */
+	if (gdk_window_get_state(w->window) & GDK_WINDOW_STATE_MAXIMIZED)
+		return FALSE;
+
+	/* don't save off-screen positioning */
+	if (x + event->width < 0 ||
+	    y + event->height < 0 ||
+	    x > gdk_screen_width() ||
+	    y > gdk_screen_height())
+		return FALSE; /* carry on normally */
+
+	for (all = conv->convs; all != NULL; all = all->next) {
+		if (type != purple_conversation_get_type(all->data)) {
+			/* this window has different types of conversation, don't save */
+			return FALSE;
+		}
+	}
+
+	if (type == PURPLE_CONV_TYPE_IM) {
+		purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/im/x", x);
+		purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/im/y", y);
+		purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/im/width",  event->width);
+		purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/im/height", event->height);
+	} else if (type == PURPLE_CONV_TYPE_CHAT) {
+		purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/chat/x", x);
+		purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/chat/y", y);
+		purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/chat/width",  event->width);
+		purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/chat/height", event->height);
+	}
+
+	return FALSE;
+}
+
+static void
+conv_placement_last_created_win_type(PidginConversation *conv)
+{
+	PidginWindow *win;
+
+	win = pidgin_conv_window_last_with_type(purple_conversation_get_type(conv->active_conv));
+
+	if (win == NULL) {
+		win = pidgin_conv_window_new();
+
+		if (PURPLE_CONV_TYPE_IM == purple_conversation_get_type(conv->active_conv) ||
+				purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/chat/width") == 0) {
+			pidgin_conv_set_position_size(win,
+				purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/im/x"),
+				purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/im/y"),
+				purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/im/width"),
+				purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/im/height"));
+		} else if (PURPLE_CONV_TYPE_CHAT == purple_conversation_get_type(conv->active_conv)) {
+			pidgin_conv_set_position_size(win,
+				purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/chat/x"),
+				purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/chat/y"),
+				purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/chat/width"),
+				purple_prefs_get_int(PIDGIN_PREFS_ROOT "/conversations/chat/height"));
+		}
+
+		pidgin_conv_window_add_gtkconv(win, conv);
+		pidgin_conv_window_show(win);
+
+		g_signal_connect(G_OBJECT(win->window), "configure_event",
+				G_CALLBACK(conv_placement_last_created_win_type_configured_cb), conv);
+	} else
+		pidgin_conv_window_add_gtkconv(win, conv);
+}
+
+/* This one places each conversation in its own window. */
+static void
+conv_placement_new_window(PidginConversation *conv)
+{
+	PidginWindow *win;
+
+	win = pidgin_conv_window_new();
+
+	g_signal_connect(G_OBJECT(win->window), "configure_event",
+			G_CALLBACK(gtk_conv_configure_cb), NULL);
+
+	pidgin_conv_window_add_gtkconv(win, conv);
+
+	pidgin_conv_window_show(win);
+}
+
+static PurpleGroup *
+conv_get_group(PidginConversation *conv)
+{
+	PurpleGroup *group = NULL;
+
+	if (purple_conversation_get_type(conv->active_conv) == PURPLE_CONV_TYPE_IM) {
+		PurpleBuddy *buddy;
+
+		buddy = purple_find_buddy(purple_conversation_get_account(conv->active_conv),
+		                        purple_conversation_get_name(conv->active_conv));
+
+		if (buddy != NULL)
+			group = purple_buddy_get_group(buddy);
+
+	} else if (purple_conversation_get_type(conv->active_conv) == PURPLE_CONV_TYPE_CHAT) {
+		PurpleChat *chat;
+
+		chat = purple_blist_find_chat(purple_conversation_get_account(conv->active_conv),
+		                            purple_conversation_get_name(conv->active_conv));
+
+		if (chat != NULL)
+			group = purple_chat_get_group(chat);
+	}
+
+	return group;
+}
+
+/*
+ * This groups things by, well, group. Buddies from groups will always be
+ * grouped together, and a buddy from a group not belonging to any currently
+ * open windows will get a new window.
+ */
+static void
+conv_placement_by_group(PidginConversation *conv)
+{
+	PurpleGroup *group = NULL;
+	GList *wl, *cl;
+
+	group = conv_get_group(conv);
+
+	/* Go through the list of IMs and find one with this group. */
+	for (wl = pidgin_conv_windows_get_list(); wl != NULL; wl = wl->next) {
+		PidginWindow *win2;
+		PidginConversation *conv2;
+		PurpleGroup *group2 = NULL;
+
+		win2 = wl->data;
+
+		for (cl = win2->gtkconvs;
+		     cl != NULL;
+		     cl = cl->next) {
+			conv2 = cl->data;
+
+			group2 = conv_get_group(conv2);
+
+			if (group == group2) {
+				pidgin_conv_window_add_gtkconv(win2, conv);
+
+				return;
+			}
+		}
+	}
+
+	/* Make a new window. */
+	conv_placement_new_window(conv);
+}
+
+/* This groups things by account.  Otherwise, the same semantics as above */
+static void
+conv_placement_by_account(PidginConversation *conv)
+{
+	GList *wins, *convs;
+	PurpleAccount *account;
+
+	account = purple_conversation_get_account(conv->active_conv);
+
+	/* Go through the list of IMs and find one with this group. */
+	for (wins = pidgin_conv_windows_get_list(); wins != NULL; wins = wins->next) {
+		PidginWindow *win2;
+		PidginConversation *conv2;
+
+		win2 = wins->data;
+
+		for (convs = win2->gtkconvs;
+		     convs != NULL;
+		     convs = convs->next) {
+			conv2 = convs->data;
+
+			if (account == purple_conversation_get_account(conv2->active_conv)) {
+				pidgin_conv_window_add_gtkconv(win2, conv);
+				return;
+			}
+		}
+	}
+
+	/* Make a new window. */
+	conv_placement_new_window(conv);
+}
+
+static ConvPlacementData *
+get_conv_placement_data(const char *id)
+{
+	ConvPlacementData *data = NULL;
+	GList *n;
+
+	for (n = conv_placement_fncs; n; n = n->next) {
+		data = n->data;
+		if (!strcmp(data->id, id))
+			return data;
+	}
+
+	return NULL;
+}
+
+static void
+add_conv_placement_fnc(const char *id, const char *name,
+                       PidginConvPlacementFunc fnc)
+{
+	ConvPlacementData *data;
+
+	data = g_new(ConvPlacementData, 1);
+
+	data->id = g_strdup(id);
+	data->name = g_strdup(name);
+	data->fnc  = fnc;
+
+	conv_placement_fncs = g_list_append(conv_placement_fncs, data);
+}
+
+static void
+ensure_default_funcs(void)
+{
+	if (conv_placement_fncs == NULL) {
+		add_conv_placement_fnc("last", _("Last created window"),
+		                       conv_placement_last_created_win);
+		add_conv_placement_fnc("im_chat", _("Separate IM and Chat windows"),
+		                       conv_placement_last_created_win_type);
+		add_conv_placement_fnc("new", _("New window"),
+		                       conv_placement_new_window);
+		add_conv_placement_fnc("group", _("By group"),
+		                       conv_placement_by_group);
+		add_conv_placement_fnc("account", _("By account"),
+		                       conv_placement_by_account);
+	}
+}
+
+GList *
+pidgin_conv_placement_get_options(void)
+{
+	GList *n, *list = NULL;
+	ConvPlacementData *data;
+
+	ensure_default_funcs();
+
+	for (n = conv_placement_fncs; n; n = n->next) {
+		data = n->data;
+		list = g_list_append(list, data->name);
+		list = g_list_append(list, data->id);
+	}
+
+	return list;
+}
+
+
+void
+pidgin_conv_placement_add_fnc(const char *id, const char *name,
+                            PidginConvPlacementFunc fnc)
+{
+	g_return_if_fail(id   != NULL);
+	g_return_if_fail(name != NULL);
+	g_return_if_fail(fnc  != NULL);
+
+	ensure_default_funcs();
+
+	add_conv_placement_fnc(id, name, fnc);
+}
+
+void
+pidgin_conv_placement_remove_fnc(const char *id)
+{
+	ConvPlacementData *data = get_conv_placement_data(id);
+
+	if (data == NULL)
+		return;
+
+	conv_placement_fncs = g_list_remove(conv_placement_fncs, data);
+
+	g_free(data->id);
+	g_free(data->name);
+	g_free(data);
+}
+
+const char *
+pidgin_conv_placement_get_name(const char *id)
+{
+	ConvPlacementData *data;
+
+	ensure_default_funcs();
+
+	data = get_conv_placement_data(id);
+
+	if (data == NULL)
+		return NULL;
+
+	return data->name;
+}
+
+PidginConvPlacementFunc
+pidgin_conv_placement_get_fnc(const char *id)
+{
+	ConvPlacementData *data;
+
+	ensure_default_funcs();
+
+	data = get_conv_placement_data(id);
+
+	if (data == NULL)
+		return NULL;
+
+	return data->fnc;
+}
+
+void
+pidgin_conv_placement_set_current_func(PidginConvPlacementFunc func)
+{
+	g_return_if_fail(func != NULL);
+
+	/* If tabs are enabled, set the function, otherwise, NULL it out. */
+	if (purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/tabs"))
+		place_conv = func;
+	else
+		place_conv = NULL;
+}
+
+PidginConvPlacementFunc
+pidgin_conv_placement_get_current_func(void)
+{
+	return place_conv;
+}
+
+void
+pidgin_conv_placement_place(PidginConversation *gtkconv)
+{
+	if (place_conv)
+		place_conv(gtkconv);
+	else
+		conv_placement_new_window(gtkconv);
+}
+
+gboolean
+pidgin_conv_is_hidden(PidginConversation *gtkconv)
+{
+	g_return_val_if_fail(gtkconv != NULL, FALSE);
+
+	return (gtkconv->win == hidden_convwin);
+}
+
+
+/* Algorithm from http://www.w3.org/TR/AERT#color-contrast */
+static gboolean
+color_is_visible(GdkColor foreground, GdkColor background, guint color_contrast, guint brightness_contrast)
+{
+	gulong fg_brightness;
+	gulong bg_brightness;
+	gulong br_diff;
+	gulong col_diff;
+	int fred, fgreen, fblue, bred, bgreen, bblue;
+
+	/* this algorithm expects colors between 0 and 255 for each of red green and blue.
+	 * GTK on the other hand has values between 0 and 65535
+	 * Err suggested I >> 8, which grabbed the high bits.
+	 */
+
+	fred = foreground.red >> 8 ;
+	fgreen = foreground.green >> 8 ;
+	fblue = foreground.blue >> 8 ;
+
+
+	bred = background.red >> 8 ;
+	bgreen = background.green >> 8 ;
+	bblue = background.blue >> 8 ;
+
+	fg_brightness = (fred * 299 + fgreen * 587 + fblue * 114) / 1000;
+	bg_brightness = (bred * 299 + bgreen * 587 + bblue * 114) / 1000;
+	br_diff = abs(fg_brightness - bg_brightness);
+
+	col_diff = abs(fred - bred) + abs(fgreen - bgreen) + abs(fblue - bblue);
+
+	return ((col_diff > color_contrast) && (br_diff > brightness_contrast));
+}
+
+
+static GdkColor*
+generate_nick_colors(guint *color_count, GdkColor background)
+{
+	guint numcolors = *color_count;
+	guint i = 0, j = 0;
+	GdkColor *colors = g_new(GdkColor, numcolors);
+	GdkColor nick_highlight;
+	GdkColor send_color;
+	time_t breakout_time;
+
+	gdk_color_parse(DEFAULT_HIGHLIGHT_COLOR, &nick_highlight);
+	gdk_color_parse(DEFAULT_SEND_COLOR, &send_color);
+
+	srand(background.red + background.green + background.blue + 1);
+
+	breakout_time = time(NULL) + 3;
+
+	/* first we look through the list of "good" colors: colors that differ from every other color in the
+	 * list.  only some of them will differ from the background color though. lets see if we can find
+	 * numcolors of them that do
+	 */
+	while (i < numcolors && j < NUM_NICK_SEED_COLORS && time(NULL) < breakout_time)
+	{
+		GdkColor color = nick_seed_colors[j];
+
+		if (color_is_visible(color, background,     MIN_COLOR_CONTRAST,     MIN_BRIGHTNESS_CONTRAST) &&
+			color_is_visible(color, nick_highlight, MIN_COLOR_CONTRAST / 2, 0) &&
+			color_is_visible(color, send_color,     MIN_COLOR_CONTRAST / 4, 0))
+		{
+			colors[i] = color;
+			i++;
+		}
+		j++;
+	}
+
+	/* we might not have found numcolors in the last loop.  if we did, we'll never enter this one.
+	 * if we did not, lets just find some colors that don't conflict with the background.  its
+	 * expensive to find colors that not only don't conflict with the background, but also do not
+	 * conflict with each other.
+	 */
+	while(i < numcolors && time(NULL) < breakout_time)
+	{
+		GdkColor color = { 0, rand() % 65536, rand() % 65536, rand() % 65536 };
+
+		if (color_is_visible(color, background,     MIN_COLOR_CONTRAST,     MIN_BRIGHTNESS_CONTRAST) &&
+			color_is_visible(color, nick_highlight, MIN_COLOR_CONTRAST / 2, 0) &&
+			color_is_visible(color, send_color,     MIN_COLOR_CONTRAST / 4, 0))
+		{
+			colors[i] = color;
+			i++;
+		}
+	}
+
+	if (i < numcolors) {
+		GdkColor *c = colors;
+		purple_debug_warning("gtkconv", "Unable to generate enough random colors before timeout. %u colors found.\n", i);
+		colors = g_memdup(c, i * sizeof(GdkColor));
+		g_free(c);
+		*color_count = i;
+	}
+
+	return colors;
+}
diff -uNr pidgin-2.10.11.orig/pidgin/gtkdocklet-gtk.c pidgin-2.10.11/pidgin/gtkdocklet-gtk.c
--- pidgin-2.10.11.orig/pidgin/gtkdocklet-gtk.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkdocklet-gtk.c	2015-02-10 14:28:16.417353357 +0900
@@ -165,7 +165,7 @@
 		icon_name = PIDGIN_STOCK_TRAY_CONNECT;
 
 	if (icon_name) {
-		gtk_status_icon_set_from_icon_name(docklet, icon_name);
+		gtk_status_icon_set_from_stock(docklet, icon_name);
 	}
 
 	if (purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/docklet/blink")) {
diff -uNr pidgin-2.10.11.orig/pidgin/gtkimhtml.c pidgin-2.10.11/pidgin/gtkimhtml.c
--- pidgin-2.10.11.orig/pidgin/gtkimhtml.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkimhtml.c	2015-02-10 14:28:16.417353357 +0900
@@ -118,6 +118,10 @@
                            gint              y,
                            guint             time);
 
+/* yaz. If you want to use shortcut keys that may conflict with
+   inputmethods, change this to 1. */
+#define ENABLE_SHORTCUT 0
+
 static void preinsert_cb(GtkTextBuffer *buffer, GtkTextIter *iter, gchar *text, gint len, GtkIMHtml *imhtml);
 static void insert_cb(GtkTextBuffer *buffer, GtkTextIter *iter, gchar *text, gint len, GtkIMHtml *imhtml);
 static void delete_cb(GtkTextBuffer *buffer, GtkTextIter *iter, GtkTextIter *end, GtkIMHtml *imhtml);
@@ -536,10 +540,11 @@
 static gint
 gtk_imhtml_tip (gpointer data)
 {
-	GtkIMHtml *imhtml = data;
+	GtkIMHtml *imhtml = (GtkIMHtml *)data;
 	PangoFontMetrics *font_metrics;
 	PangoLayout *layout;
 	PangoFont *font;
+	PangoLanguage *lang;
 
 	gint gap, x, y, h, w, scr_w, baseline_skip;
 
@@ -592,7 +597,9 @@
 		return FALSE;
 	}
 
-	font_metrics = pango_font_get_metrics(font, NULL);
+	lang = pango_context_get_language (pango_layout_get_context(layout));
+	font_metrics = pango_font_get_metrics(font, lang); //it's ok.
+//	font_metrics = pango_font_get_metrics(font, NULL); //crash!
 
 	pango_layout_get_pixel_size(layout, &scr_w, NULL);
 	gap = PANGO_PIXELS((pango_font_metrics_get_ascent(font_metrics) +
@@ -706,7 +713,6 @@
 		tip = g_object_get_data(G_OBJECT(anchor), "gtkimhtml_tiptext");
 		hand = FALSE;
 	}
-
 	if (tip && *tip) {
 		GTK_IMHTML(imhtml)->tip_timer = g_timeout_add (TOOLTIP_TIMEOUT,
 							       gtk_imhtml_tip, imhtml);
@@ -1056,18 +1062,25 @@
 	if (info == TARGET_HTML) {
 		char *selection;
 #ifndef _WIN32
-		gsize len;
 		if (primary) {
 			text = gtk_imhtml_get_markup_range(imhtml, &start, &end);
 		} else
 			text = html_clipboard;
 
-		/* Mozilla asks that we start our text/html with the Unicode byte order mark */
-		selection = g_convert(text, -1, "UTF-16", "UTF-8", NULL, &len, NULL);
-		gtk_selection_data_set(selection_data, gdk_atom_intern("text/html", FALSE), 16, (const guchar *)selection, len);
-#else
+		selection = NULL;
+		if (primary) {
+			text = gtk_imhtml_get_markup_range(imhtml, &start, &end);
+		} else {
+			text = html_clipboard;
+		}
+		/* xxx should remove following line --yaz */
+		purple_debug_info("imhtml clipboard", "html_clipboard: %s len = %d\n", text, strlen(text));
+		gtk_selection_data_set(selection_data, gdk_atom_intern("text/html", FALSE),
+				       8, (const guchar *)text, strlen(text)+1); // include trailing '\0' --yaz
+#else /*_WIN32 */
 		selection = clipboard_html_to_win32(html_clipboard);
-		gtk_selection_data_set(selection_data, gdk_atom_intern("HTML Format", FALSE), 8, (const guchar *)selection, strlen(selection));
+		gtk_selection_data_set(selection_data, gdk_atom_intern("HTML Format", FALSE),
+				       8, (const guchar *)selection, strlen(selection));
 #endif
 		g_free(selection);
 	} else {
@@ -1232,7 +1245,8 @@
 	if (selection_data->length >= 2 &&
 		(*(guint16 *)text == 0xfeff || *(guint16 *)text == 0xfffe)) {
 		/* This is UTF-16 */
-		char *utf8 = utf16_to_utf8_with_bom_check(text, selection_data->length);
+//		char *utf8 = utf16_to_utf8_with_bom_check(text, selection_data->length);
+		char *utf8 = g_convert(text, selection_data->length, "UTF-8", "UTF-16", NULL, NULL, NULL);
 		g_free(text);
 		text = utf8;
 		if (!text) {
@@ -1986,7 +2000,8 @@
 			 * http://mail.gnome.org/archives/gtk-devel-list/2001-September/msg00114.html
 			 */
 			if (sd->length >= 2 && !g_utf8_validate(text, sd->length - 1, NULL)) {
-				utf8 = utf16_to_utf8_with_bom_check(text, sd->length);
+//				utf8 = utf16_to_utf8_with_bom_check(text, sd->length);
+				utf8 = g_convert(text, sd->length, "UTF-8", "UTF-16", NULL, NULL, NULL);
 
 				if (!utf8) {
 					purple_debug_warning("gtkimhtml", "g_convert from UTF-16 failed in drag_rcv_cb\n");
@@ -3448,6 +3463,7 @@
 			break;
 		}
 	}
+	ws[wpos] = '\0'; // chop ws at wpos. due to bug of gtk_text_buffer_insert() --yaz
 	gtk_text_buffer_insert(imhtml->text_buffer, iter, ws, wpos);
 	ws[0] = '\0'; wpos = 0;
 
diff -uNr pidgin-2.10.11.orig/pidgin/gtkimhtmltoolbar.c pidgin-2.10.11/pidgin/gtkimhtmltoolbar.c
--- pidgin-2.10.11.orig/pidgin/gtkimhtmltoolbar.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkimhtmltoolbar.c	2015-02-10 14:28:16.417353357 +0900
@@ -1465,7 +1465,7 @@
 	gtk_container_add(GTK_CONTAINER(smiley_button), bbox);
 	image = gtk_image_new_from_stock(PIDGIN_STOCK_TOOLBAR_SMILEY, gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_EXTRA_SMALL));
 	gtk_box_pack_start(GTK_BOX(bbox), image, FALSE, FALSE, 0);
-	label = gtk_label_new_with_mnemonic(_("_Smile!"));
+	label = gtk_label_new_with_mnemonic(_("Smile!"));
 	gtk_box_pack_start(GTK_BOX(bbox), label, FALSE, FALSE, 0);
 	gtk_box_pack_start(GTK_BOX(box), smiley_button, FALSE, FALSE, 0);
 	g_signal_connect(G_OBJECT(smiley_button), "button-press-event", G_CALLBACK(gtk_imhtmltoolbar_popup_menu), toolbar);
diff -uNr pidgin-2.10.11.orig/pidgin/gtkimhtmltoolbar.h pidgin-2.10.11/pidgin/gtkimhtmltoolbar.h
--- pidgin-2.10.11.orig/pidgin/gtkimhtmltoolbar.h	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkimhtmltoolbar.h	2015-02-10 14:28:16.417353357 +0900
@@ -30,7 +30,7 @@
 extern "C" {
 #endif
 
-#define DEFAULT_FONT_FACE "Helvetica 12"
+#define DEFAULT_FONT_FACE "Sans 12"
 
 #define GTK_TYPE_IMHTMLTOOLBAR            (gtk_imhtmltoolbar_get_type())
 #define GTK_IMHTMLTOOLBAR(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj), GTK_TYPE_IMHTMLTOOLBAR, GtkIMHtmlToolbar))
diff -uNr pidgin-2.10.11.orig/pidgin/gtkprefs.c pidgin-2.10.11/pidgin/gtkprefs.c
--- pidgin-2.10.11.orig/pidgin/gtkprefs.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkprefs.c	2015-02-10 14:28:16.417353357 +0900
@@ -1390,6 +1390,9 @@
 	pidgin_prefs_checkbox(_("Show close b_utton on tabs"),
 				PIDGIN_PREFS_ROOT "/conversations/close_on_tabs", vbox2);
 
+	pidgin_prefs_checkbox(_("Trim names on vertical tabs"),
+				PIDGIN_PREFS_ROOT "/conversations/trim_vertical_tabs", vbox2);
+
 	label = pidgin_prefs_dropdown(vbox2, _("_Placement:"), PURPLE_PREF_INT,
 					PIDGIN_PREFS_ROOT "/conversations/tab_side",
 					_("Top"), GTK_POS_TOP,
@@ -1485,7 +1488,7 @@
 #endif
 
 	pidgin_prefs_checkbox(_("Use smooth-scrolling"), PIDGIN_PREFS_ROOT "/conversations/use_smooth_scrolling", vbox);
-
+	pidgin_prefs_checkbox(_("Use msn messenger style"), "/purple/conversations/msnstyle", vbox);//yaz
 #ifdef _WIN32
 	pidgin_prefs_checkbox(_("F_lash window when IMs are received"), PIDGIN_PREFS_ROOT "/win32/blink_im", vbox);
 #endif
diff -uNr pidgin-2.10.11.orig/pidgin/gtkprefs.c.orig pidgin-2.10.11/pidgin/gtkprefs.c.orig
--- pidgin-2.10.11.orig/pidgin/gtkprefs.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkprefs.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,2995 @@
+/**
+ * @file gtkprefs.c GTK+ Preferences
+ * @ingroup pidgin
+ */
+
+/* pidgin
+ *
+ * Pidgin is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+#include "internal.h"
+#include "pidgin.h"
+
+#include "debug.h"
+#include "nat-pmp.h"
+#include "notify.h"
+#include "prefs.h"
+#include "proxy.h"
+#include "prpl.h"
+#include "request.h"
+#include "savedstatuses.h"
+#include "sound.h"
+#include "sound-theme.h"
+#include "stun.h"
+#include "theme-manager.h"
+#include "upnp.h"
+#include "util.h"
+#include "network.h"
+
+#include "gtkblist.h"
+#include "gtkconv.h"
+#include "gtkdebug.h"
+#include "gtkdialogs.h"
+#include "gtkimhtml.h"
+#include "gtkimhtmltoolbar.h"
+#include "gtkprefs.h"
+#include "gtksavedstatuses.h"
+#include "gtksound.h"
+#include "gtkstatus-icon-theme.h"
+#include "gtkthemes.h"
+#include "gtkutils.h"
+#include "pidginstock.h"
+
+#define PROXYHOST 0
+#define PROXYPORT 1
+#define PROXYUSER 2
+#define PROXYPASS 3
+
+#define PREFS_OPTIMAL_ICON_SIZE 32
+
+struct theme_info {
+	gchar *type;
+	gchar *extension;
+	gchar *original_name;
+};
+
+/* Main dialog */
+static GtkWidget *prefs = NULL;
+
+/* Notebook */
+static GtkWidget *prefsnotebook = NULL;
+static int notebook_page = 0;
+
+/* Conversations page */
+static GtkWidget *sample_imhtml = NULL;
+
+/* Themes page */
+static GtkWidget *prefs_sound_themes_combo_box;
+static GtkWidget *prefs_blist_themes_combo_box;
+static GtkWidget *prefs_status_themes_combo_box;
+static GtkWidget *prefs_smiley_themes_combo_box;
+
+/* Sound theme specific */
+static GtkWidget *sound_entry = NULL;
+static int sound_row_sel = 0;
+static gboolean prefs_sound_themes_loading;
+
+/* These exist outside the lifetime of the prefs dialog */
+static GtkListStore *prefs_sound_themes;
+static GtkListStore *prefs_blist_themes;
+static GtkListStore *prefs_status_icon_themes;
+static GtkListStore *prefs_smiley_themes;
+
+/*
+ * PROTOTYPES
+ */
+static void delete_prefs(GtkWidget *, void *);
+
+static void
+update_spin_value(GtkWidget *w, GtkWidget *spin)
+{
+	const char *key = g_object_get_data(G_OBJECT(spin), "val");
+	int value;
+
+	value = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(spin));
+
+	purple_prefs_set_int(key, value);
+}
+
+GtkWidget *
+pidgin_prefs_labeled_spin_button(GtkWidget *box, const gchar *title,
+		const char *key, int min, int max, GtkSizeGroup *sg)
+{
+	GtkWidget *spin;
+	GtkObject *adjust;
+	int val;
+
+	val = purple_prefs_get_int(key);
+
+	adjust = gtk_adjustment_new(val, min, max, 1, 1, 0);
+	spin = gtk_spin_button_new(GTK_ADJUSTMENT(adjust), 1, 0);
+	g_object_set_data(G_OBJECT(spin), "val", (char *)key);
+	if (max < 10000)
+		gtk_widget_set_size_request(spin, 50, -1);
+	else
+		gtk_widget_set_size_request(spin, 60, -1);
+	g_signal_connect(G_OBJECT(adjust), "value-changed",
+					 G_CALLBACK(update_spin_value), GTK_WIDGET(spin));
+	gtk_widget_show(spin);
+
+	return pidgin_add_widget_to_vbox(GTK_BOX(box), title, sg, spin, FALSE, NULL);
+}
+
+static void
+entry_set(GtkEntry *entry, gpointer data)
+{
+	const char *key = (const char*)data;
+
+	purple_prefs_set_string(key, gtk_entry_get_text(entry));
+}
+
+GtkWidget *
+pidgin_prefs_labeled_entry(GtkWidget *page, const gchar *title,
+							 const char *key, GtkSizeGroup *sg)
+{
+	GtkWidget *entry;
+	const gchar *value;
+
+	value = purple_prefs_get_string(key);
+
+	entry = gtk_entry_new();
+	gtk_entry_set_text(GTK_ENTRY(entry), value);
+	g_signal_connect(G_OBJECT(entry), "changed",
+					 G_CALLBACK(entry_set), (char*)key);
+	gtk_widget_show(entry);
+
+	return pidgin_add_widget_to_vbox(GTK_BOX(page), title, sg, entry, TRUE, NULL);
+}
+
+GtkWidget *
+pidgin_prefs_labeled_password(GtkWidget *page, const gchar *title,
+							 const char *key, GtkSizeGroup *sg)
+{
+	GtkWidget *entry;
+	const gchar *value;
+
+	value = purple_prefs_get_string(key);
+
+	entry = gtk_entry_new();
+	gtk_entry_set_visibility(GTK_ENTRY(entry), FALSE);
+	gtk_entry_set_text(GTK_ENTRY(entry), value);
+	g_signal_connect(G_OBJECT(entry), "changed",
+					 G_CALLBACK(entry_set), (char*)key);
+	gtk_widget_show(entry);
+
+	return pidgin_add_widget_to_vbox(GTK_BOX(page), title, sg, entry, TRUE, NULL);
+}
+
+
+static void
+dropdown_set(GObject *w, const char *key)
+{
+	const char *str_value;
+	int int_value;
+	PurplePrefType type;
+
+	type = GPOINTER_TO_INT(g_object_get_data(w, "type"));
+
+	if (type == PURPLE_PREF_INT) {
+		int_value = GPOINTER_TO_INT(g_object_get_data(w, "value"));
+
+		purple_prefs_set_int(key, int_value);
+	}
+	else if (type == PURPLE_PREF_STRING) {
+		str_value = (const char *)g_object_get_data(w, "value");
+
+		purple_prefs_set_string(key, str_value);
+	}
+	else if (type == PURPLE_PREF_BOOLEAN) {
+		purple_prefs_set_bool(key,
+				GPOINTER_TO_INT(g_object_get_data(w, "value")));
+	}
+}
+
+GtkWidget *
+pidgin_prefs_dropdown_from_list(GtkWidget *box, const gchar *title,
+		PurplePrefType type, const char *key, GList *menuitems)
+{
+	GtkWidget  *dropdown, *opt, *menu;
+	GtkWidget  *label = NULL;
+	gchar      *text;
+	const char *stored_str = NULL;
+	int         stored_int = 0;
+	int         int_value  = 0;
+	const char *str_value  = NULL;
+	int         o = 0;
+
+	g_return_val_if_fail(menuitems != NULL, NULL);
+
+	dropdown = gtk_option_menu_new();
+	menu = gtk_menu_new();
+
+	if (type == PURPLE_PREF_INT)
+		stored_int = purple_prefs_get_int(key);
+	else if (type == PURPLE_PREF_STRING)
+		stored_str = purple_prefs_get_string(key);
+
+	while (menuitems != NULL && (text = (char *) menuitems->data) != NULL) {
+		menuitems = g_list_next(menuitems);
+		g_return_val_if_fail(menuitems != NULL, NULL);
+
+		opt = gtk_menu_item_new_with_label(text);
+
+		g_object_set_data(G_OBJECT(opt), "type", GINT_TO_POINTER(type));
+
+		if (type == PURPLE_PREF_INT) {
+			int_value = GPOINTER_TO_INT(menuitems->data);
+			g_object_set_data(G_OBJECT(opt), "value",
+							  GINT_TO_POINTER(int_value));
+		}
+		else if (type == PURPLE_PREF_STRING) {
+			str_value = (const char *)menuitems->data;
+
+			g_object_set_data(G_OBJECT(opt), "value", (char *)str_value);
+		}
+		else if (type == PURPLE_PREF_BOOLEAN) {
+			g_object_set_data(G_OBJECT(opt), "value",
+					menuitems->data);
+		}
+
+		g_signal_connect(G_OBJECT(opt), "activate",
+						 G_CALLBACK(dropdown_set), (char *)key);
+
+		gtk_widget_show(opt);
+		gtk_menu_shell_append(GTK_MENU_SHELL(menu), opt);
+
+		if ((type == PURPLE_PREF_INT && stored_int == int_value) ||
+			(type == PURPLE_PREF_STRING && stored_str != NULL &&
+			 !strcmp(stored_str, str_value)) ||
+			(type == PURPLE_PREF_BOOLEAN &&
+			 (purple_prefs_get_bool(key) == GPOINTER_TO_INT(menuitems->data)))) {
+
+			gtk_menu_set_active(GTK_MENU(menu), o);
+		}
+
+		menuitems = g_list_next(menuitems);
+
+		o++;
+	}
+
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(dropdown), menu);
+
+	pidgin_add_widget_to_vbox(GTK_BOX(box), title, NULL, dropdown, FALSE, &label);
+
+	return label;
+}
+
+GtkWidget *
+pidgin_prefs_dropdown(GtkWidget *box, const gchar *title, PurplePrefType type,
+			   const char *key, ...)
+{
+	va_list ap;
+	GList *menuitems = NULL;
+	GtkWidget *dropdown = NULL;
+	char *name;
+	int int_value;
+	const char *str_value;
+
+	g_return_val_if_fail(type == PURPLE_PREF_BOOLEAN || type == PURPLE_PREF_INT ||
+			type == PURPLE_PREF_STRING, NULL);
+
+	va_start(ap, key);
+	while ((name = va_arg(ap, char *)) != NULL) {
+
+		menuitems = g_list_prepend(menuitems, name);
+
+		if (type == PURPLE_PREF_INT || type == PURPLE_PREF_BOOLEAN) {
+			int_value = va_arg(ap, int);
+			menuitems = g_list_prepend(menuitems, GINT_TO_POINTER(int_value));
+		}
+		else {
+			str_value = va_arg(ap, const char *);
+			menuitems = g_list_prepend(menuitems, (char *)str_value);
+		}
+	}
+	va_end(ap);
+
+	g_return_val_if_fail(menuitems != NULL, NULL);
+
+	menuitems = g_list_reverse(menuitems);
+
+	dropdown = pidgin_prefs_dropdown_from_list(box, title, type, key,
+			menuitems);
+
+	g_list_free(menuitems);
+
+	return dropdown;
+}
+
+static void
+delete_prefs(GtkWidget *asdf, void *gdsa)
+{
+	/* Close any "select sound" request dialogs */
+	purple_request_close_with_handle(prefs);
+
+	/* Unregister callbacks. */
+	purple_prefs_disconnect_by_handle(prefs);
+
+	/* NULL-ify globals */
+	sound_entry = NULL;
+	sound_row_sel = 0;
+	prefs_sound_themes_loading = FALSE;
+
+	prefs_sound_themes_combo_box = NULL;
+	prefs_blist_themes_combo_box = NULL;
+	prefs_status_themes_combo_box = NULL;
+	prefs_smiley_themes_combo_box = NULL;
+
+	sample_imhtml = NULL;
+
+	notebook_page = 0;
+	prefsnotebook = NULL;
+	prefs = NULL;
+}
+
+static gchar *
+get_theme_markup(const char *name, gboolean custom, const char *author,
+				 const char *description)
+{
+
+	return g_strdup_printf("<b>%s</b>%s%s%s%s\n<span foreground='dim grey'>%s</span>",
+						   name, custom ? " " : "", custom ? _("(Custom)") : "",
+						   author != NULL ? " - " : "", author != NULL ? author : "",
+						   description != NULL ? description : "");
+}
+
+static void
+smileys_refresh_theme_list(void)
+{
+	GdkPixbuf *pixbuf;
+	GSList *themes;
+	GtkTreeIter iter;
+
+	pidgin_themes_smiley_theme_probe();
+
+	if (!(themes = smiley_themes))
+		return;
+
+	while (themes) {
+		struct smiley_theme *theme = themes->data;
+		char *description = get_theme_markup(_(theme->name), FALSE,
+		                                     _(theme->author), _(theme->desc));
+		gtk_list_store_append(prefs_smiley_themes, &iter);
+
+		/*
+		 * LEAK - Gentoo memprof thinks pixbuf is leaking here... but it
+		 * looks like it should be ok to me.  Anyone know what's up?  --Mark
+		 */
+		pixbuf = (theme->icon ? pidgin_pixbuf_new_from_file(theme->icon) : NULL);
+
+		gtk_list_store_set(prefs_smiley_themes, &iter,
+				   0, pixbuf,
+				   1, description,
+				   2, theme->name,
+				   -1);
+
+		if (pixbuf != NULL)
+			g_object_unref(G_OBJECT(pixbuf));
+
+		g_free(description);
+		themes = themes->next;
+	}
+}
+
+/* Rebuild the markup for the sound theme selection for "(Custom)" themes */
+static void
+pref_sound_generate_markup(void)
+{
+	gboolean print_custom, customized;
+	const gchar *author, *description, *current_theme;
+	gchar *name, *markup;
+	PurpleSoundTheme *theme;
+	GtkTreeIter iter;
+
+	customized = pidgin_sound_is_customized();
+	current_theme = purple_prefs_get_string(PIDGIN_PREFS_ROOT "/sound/theme");
+
+	if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(prefs_sound_themes), &iter)) {
+		do {
+			gtk_tree_model_get(GTK_TREE_MODEL(prefs_sound_themes), &iter, 2, &name, -1);
+
+			print_custom = customized && name && g_str_equal(current_theme, name);
+
+			if (!name || *name == '\0') {
+				g_free(name);
+				name = g_strdup(_("Default"));
+				author = _("Penguin Pimps");
+				description = _("The default Pidgin sound theme");
+			} else {
+				theme = PURPLE_SOUND_THEME(purple_theme_manager_find_theme(name, "sound"));
+				author = purple_theme_get_author(PURPLE_THEME(theme));
+				description = purple_theme_get_description(PURPLE_THEME(theme));
+			}
+
+			markup = get_theme_markup(name, print_custom, author, description);
+
+			gtk_list_store_set(prefs_sound_themes, &iter, 1, markup, -1);
+
+			g_free(name);
+			g_free(markup);
+
+		} while (gtk_tree_model_iter_next(GTK_TREE_MODEL(prefs_sound_themes), &iter));
+	}
+}
+
+/* adds the themes to the theme list from the manager so they can be displayed in prefs */
+static void
+prefs_themes_sort(PurpleTheme *theme)
+{
+	GdkPixbuf *pixbuf = NULL;
+	GtkTreeIter iter;
+	gchar *image_full = NULL, *markup;
+	const gchar *name, *author, *description;
+
+	if (PURPLE_IS_SOUND_THEME(theme)){
+
+		image_full = purple_theme_get_image_full(theme);
+		if (image_full != NULL){
+			pixbuf = pidgin_pixbuf_new_from_file_at_scale(image_full, PREFS_OPTIMAL_ICON_SIZE, PREFS_OPTIMAL_ICON_SIZE, TRUE);
+			g_free(image_full);
+		} else
+			pixbuf = NULL;
+
+		gtk_list_store_append(prefs_sound_themes, &iter);
+		gtk_list_store_set(prefs_sound_themes, &iter, 0, pixbuf, 2, purple_theme_get_name(theme), -1);
+
+		if (pixbuf != NULL)
+			g_object_unref(G_OBJECT(pixbuf));
+
+	} else if (PIDGIN_IS_BLIST_THEME(theme) || PIDGIN_IS_STATUS_ICON_THEME(theme)){
+		GtkListStore *store;
+
+		if (PIDGIN_IS_BLIST_THEME(theme))
+			store = prefs_blist_themes;
+		else
+			store = prefs_status_icon_themes;
+
+		image_full = purple_theme_get_image_full(theme);
+		if (image_full != NULL){
+			pixbuf = pidgin_pixbuf_new_from_file_at_scale(image_full, PREFS_OPTIMAL_ICON_SIZE, PREFS_OPTIMAL_ICON_SIZE, TRUE);
+			g_free(image_full);
+		} else
+			pixbuf = NULL;
+
+		name = purple_theme_get_name(theme);
+		author = purple_theme_get_author(theme);
+		description = purple_theme_get_description(theme);
+
+		markup = get_theme_markup(name, FALSE, author, description);
+
+		gtk_list_store_append(store, &iter);
+		gtk_list_store_set(store, &iter, 0, pixbuf, 1, markup, 2, name, -1);
+
+		g_free(markup);
+		if (pixbuf != NULL)
+			g_object_unref(G_OBJECT(pixbuf));
+	}
+}
+
+static void
+prefs_set_active_theme_combo(GtkWidget *combo_box, GtkListStore *store, const gchar *current_theme)
+{
+	GtkTreeIter iter;
+	gchar *theme = NULL;
+	gboolean unset = TRUE;
+
+	if (current_theme && *current_theme && gtk_tree_model_get_iter_first(GTK_TREE_MODEL(store), &iter)) {
+		do {
+			gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, 2, &theme, -1);
+
+			if (g_str_equal(current_theme, theme)) {
+				gtk_combo_box_set_active_iter(GTK_COMBO_BOX(combo_box), &iter);
+				unset = FALSE;
+			}
+
+			g_free(theme);
+		} while (gtk_tree_model_iter_next(GTK_TREE_MODEL(store), &iter));
+	}
+
+	if (unset)
+		gtk_combo_box_set_active(GTK_COMBO_BOX(combo_box), 0);
+}
+
+static void
+prefs_themes_refresh(void)
+{
+	GdkPixbuf *pixbuf = NULL;
+	gchar *tmp;
+	GtkTreeIter iter;
+
+	prefs_sound_themes_loading = TRUE;
+	/* refresh the list of themes in the manager */
+	purple_theme_manager_refresh();
+
+	tmp = g_build_filename(DATADIR, "icons", "hicolor", "32x32", "apps", "pidgin.png", NULL);
+	pixbuf = pidgin_pixbuf_new_from_file_at_scale(tmp, PREFS_OPTIMAL_ICON_SIZE, PREFS_OPTIMAL_ICON_SIZE, TRUE);
+	g_free(tmp);
+
+	/* sound themes */
+	gtk_list_store_clear(prefs_sound_themes);
+	gtk_list_store_append(prefs_sound_themes, &iter);
+	gtk_list_store_set(prefs_sound_themes, &iter, 0, pixbuf, 2, "", -1);
+
+	/* blist themes */
+	gtk_list_store_clear(prefs_blist_themes);
+	gtk_list_store_append(prefs_blist_themes, &iter);
+	tmp = get_theme_markup(_("Default"), FALSE, _("Penguin Pimps"),
+		_("The default Pidgin buddy list theme"));
+	gtk_list_store_set(prefs_blist_themes, &iter, 0, pixbuf, 1, tmp, 2, "", -1);
+	g_free(tmp);
+
+	/* status icon themes */
+	gtk_list_store_clear(prefs_status_icon_themes);
+	gtk_list_store_append(prefs_status_icon_themes, &iter);
+	tmp = get_theme_markup(_("Default"), FALSE, _("Penguin Pimps"),
+		_("The default Pidgin status icon theme"));
+	gtk_list_store_set(prefs_status_icon_themes, &iter, 0, pixbuf, 1, tmp, 2, "", -1);
+	g_free(tmp);
+	if (pixbuf)
+		g_object_unref(G_OBJECT(pixbuf));
+
+	/* smiley themes */
+	gtk_list_store_clear(prefs_smiley_themes);
+
+	purple_theme_manager_for_each_theme(prefs_themes_sort);
+	pref_sound_generate_markup();
+	smileys_refresh_theme_list();
+
+	/* set active */
+	prefs_set_active_theme_combo(prefs_sound_themes_combo_box, prefs_sound_themes, purple_prefs_get_string(PIDGIN_PREFS_ROOT "/sound/theme"));
+	prefs_set_active_theme_combo(prefs_blist_themes_combo_box, prefs_blist_themes, purple_prefs_get_string(PIDGIN_PREFS_ROOT "/blist/theme"));
+	prefs_set_active_theme_combo(prefs_status_themes_combo_box, prefs_status_icon_themes, purple_prefs_get_string(PIDGIN_PREFS_ROOT "/status/icon-theme"));
+	prefs_set_active_theme_combo(prefs_smiley_themes_combo_box, prefs_smiley_themes, purple_prefs_get_string(PIDGIN_PREFS_ROOT "/smileys/theme"));
+	prefs_sound_themes_loading = FALSE;
+}
+
+/* init all the theme variables so that the themes can be sorted later and used by pref pages */
+static void
+prefs_themes_init(void)
+{
+	prefs_sound_themes = gtk_list_store_new(3, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING);
+
+	prefs_blist_themes = gtk_list_store_new(3, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING);
+
+	prefs_status_icon_themes = gtk_list_store_new(3, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING);
+
+	prefs_smiley_themes = gtk_list_store_new(3, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING);
+}
+
+static PurpleTheme *
+prefs_theme_find_theme(const gchar *path, const gchar *type)
+{
+	PurpleTheme *theme = purple_theme_manager_load_theme(path, type);
+	GDir *dir = g_dir_open(path, 0, NULL);
+	const gchar *next;
+
+	while (!PURPLE_IS_THEME(theme) && (next = g_dir_read_name(dir))) {
+		gchar *next_path = g_build_filename(path, next, NULL);
+
+		if (g_file_test(next_path, G_FILE_TEST_IS_DIR))
+			theme = prefs_theme_find_theme(next_path, type);
+
+		g_free(next_path);
+	}
+
+	g_dir_close(dir);
+
+	return theme;
+}
+
+/* Eww. Seriously ewww. But thanks, grim! This is taken from guifications2 */
+static gboolean
+purple_theme_file_copy(const gchar *source, const gchar *destination)
+{
+	FILE *src, *dest;
+	gint chr = EOF;
+
+	if(!(src = g_fopen(source, "rb")))
+		return FALSE;
+	if(!(dest = g_fopen(destination, "wb"))) {
+		fclose(src);
+		return FALSE;
+	}
+
+	while((chr = fgetc(src)) != EOF) {
+		fputc(chr, dest);
+	}
+
+	fclose(dest);
+	fclose(src);
+
+	return TRUE;
+}
+
+static void
+free_theme_info(struct theme_info *info)
+{
+	if (info != NULL) {
+		g_free(info->type);
+		g_free(info->extension);
+		g_free(info->original_name);
+		g_free(info);
+	}
+}
+
+/* installs a theme, info is freed by function */
+static void
+theme_install_theme(char *path, struct theme_info *info)
+{
+#ifndef _WIN32
+	gchar *command;
+#endif
+	gchar *destdir;
+	const char *tail;
+	gboolean is_smiley_theme, is_archive;
+	PurpleTheme *theme = NULL;
+
+	if (info == NULL)
+		return;
+
+	/* check the extension */
+	tail = info->extension ? info->extension : strrchr(path, '.');
+
+	if (!tail) {
+		free_theme_info(info);
+		return;
+	}
+
+	is_archive = !g_ascii_strcasecmp(tail, ".gz") || !g_ascii_strcasecmp(tail, ".tgz");
+
+	/* Just to be safe */
+	g_strchomp(path);
+
+	if ((is_smiley_theme = g_str_equal(info->type, "smiley")))
+		destdir = g_build_filename(purple_user_dir(), "smileys", NULL);
+	else
+		destdir = g_build_filename(purple_user_dir(), "themes", "temp", NULL);
+
+	/* We'll check this just to make sure. This also lets us do something different on
+	 * other platforms, if need be */
+	if (is_archive) {
+#ifndef _WIN32
+		gchar *path_escaped = g_shell_quote(path);
+		gchar *destdir_escaped = g_shell_quote(destdir);
+
+		if (!g_file_test(destdir, G_FILE_TEST_IS_DIR))
+			purple_build_dir(destdir, S_IRUSR | S_IWUSR | S_IXUSR);
+
+		command = g_strdup_printf("tar > /dev/null xzf %s -C %s", path_escaped, destdir_escaped);
+		g_free(path_escaped);
+		g_free(destdir_escaped);
+
+		/* Fire! */
+		if (system(command)) {
+			purple_notify_error(NULL, NULL, _("Theme failed to unpack."), NULL);
+			g_free(command);
+			g_free(destdir);
+			free_theme_info(info);
+			return;
+		}
+#else
+		if (!winpidgin_gz_untar(path, destdir)) {
+			purple_notify_error(NULL, NULL, _("Theme failed to unpack."), NULL);
+			g_free(destdir);
+			free_theme_info(info);
+			return;
+		}
+#endif
+	}
+
+	if (is_smiley_theme) {
+		/* just extract the folder to the smiley directory */
+		prefs_themes_refresh();
+
+	} else if (is_archive) {
+		theme = prefs_theme_find_theme(destdir, info->type);
+
+		if (PURPLE_IS_THEME(theme)) {
+			/* create the location for the theme */
+			gchar *theme_dest = g_build_filename(purple_user_dir(), "themes",
+						 purple_theme_get_name(theme),
+						 "purple", info->type, NULL);
+
+			if (!g_file_test(theme_dest, G_FILE_TEST_IS_DIR))
+				purple_build_dir(theme_dest, S_IRUSR | S_IWUSR | S_IXUSR);
+
+			g_free(theme_dest);
+			theme_dest = g_build_filename(purple_user_dir(), "themes",
+						 purple_theme_get_name(theme),
+						 "purple", info->type, NULL);
+
+			/* move the entire directory to new location */
+			g_rename(purple_theme_get_dir(theme), theme_dest);
+
+			g_free(theme_dest);
+			if (g_remove(destdir) != 0) {
+				purple_debug_error("gtkprefs",
+					"couldn't remove temp (dest) path\n");
+			}
+			g_object_unref(theme);
+
+			prefs_themes_refresh();
+
+		} else {
+			/* something was wrong with the theme archive */
+			g_unlink(destdir);
+			purple_notify_error(NULL, NULL, _("Theme failed to load."), NULL);
+		}
+
+	} else { /* just a single file so copy it to a new temp directory and attempt to load it*/
+		gchar *temp_path, *temp_file;
+
+		temp_path = g_build_filename(purple_user_dir(), "themes", "temp", "sub_folder", NULL);
+
+		if (info->original_name != NULL) {
+			/* name was changed from the original (probably a dnd) change it back before loading */
+			temp_file = g_build_filename(temp_path, info->original_name, NULL);
+
+		} else {
+			gchar *source_name = g_path_get_basename(path);
+			temp_file = g_build_filename(temp_path, source_name, NULL);
+			g_free(source_name);
+		}
+
+		if (!g_file_test(temp_path, G_FILE_TEST_IS_DIR))
+			purple_build_dir(temp_path, S_IRUSR | S_IWUSR | S_IXUSR);
+
+		if (purple_theme_file_copy(path, temp_file)) {
+			/* find the theme, could be in subfolder */
+			theme = prefs_theme_find_theme(temp_path, info->type);
+
+			if (PURPLE_IS_THEME(theme)) {
+				gchar *theme_dest = g_build_filename(purple_user_dir(), "themes",
+							 purple_theme_get_name(theme),
+							 "purple", info->type, NULL);
+
+				if(!g_file_test(theme_dest, G_FILE_TEST_IS_DIR))
+					purple_build_dir(theme_dest, S_IRUSR | S_IWUSR | S_IXUSR);
+
+				g_rename(purple_theme_get_dir(theme), theme_dest);
+
+				g_free(theme_dest);
+				g_object_unref(theme);
+
+				prefs_themes_refresh();
+			} else {
+				if (g_remove(temp_path) != 0) {
+					purple_debug_error("gtkprefs",
+						"couldn't remove temp path\n");
+				}
+				purple_notify_error(NULL, NULL, _("Theme failed to load."), NULL);
+			}
+		} else {
+			purple_notify_error(NULL, NULL, _("Theme failed to copy."), NULL);
+		}
+
+		g_free(temp_file);
+		g_free(temp_path);
+	}
+
+	g_free(destdir);
+	free_theme_info(info);
+}
+
+static void
+theme_got_url(PurpleUtilFetchUrlData *url_data, gpointer user_data,
+		const gchar *themedata, size_t len, const gchar *error_message)
+{
+	FILE *f;
+	gchar *path;
+	size_t wc;
+
+	if ((error_message != NULL) || (len == 0)) {
+		free_theme_info(user_data);
+		return;
+	}
+
+	f = purple_mkstemp(&path, TRUE);
+	wc = fwrite(themedata, len, 1, f);
+	if (wc != 1) {
+		purple_debug_warning("theme_got_url", "Unable to write theme data.\n");
+		fclose(f);
+		g_unlink(path);
+		g_free(path);
+		free_theme_info(user_data);
+		return;
+	}
+	fclose(f);
+
+	theme_install_theme(path, user_data);
+
+	g_unlink(path);
+	g_free(path);
+}
+
+static void
+theme_dnd_recv(GtkWidget *widget, GdkDragContext *dc, guint x, guint y,
+		GtkSelectionData *sd, guint info, guint t, gpointer user_data)
+{
+	gchar *name = g_strchomp((gchar *)sd->data);
+
+	if ((sd->length >= 0) && (sd->format == 8)) {
+		/* Well, it looks like the drag event was cool.
+		 * Let's do something with it */
+		gchar *temp;
+		struct theme_info *info =  g_new0(struct theme_info, 1);
+		info->type = g_strdup((gchar *)user_data);
+		info->extension = g_strdup(g_strrstr(name,"."));
+		temp = g_strrstr(name, "/");
+		info->original_name = temp ? g_strdup(++temp) : NULL;
+
+		if (!g_ascii_strncasecmp(name, "file://", 7)) {
+			GError *converr = NULL;
+			gchar *tmp;
+			/* It looks like we're dealing with a local file. Let's
+			 * just untar it in the right place */
+			if(!(tmp = g_filename_from_uri(name, NULL, &converr))) {
+				purple_debug(PURPLE_DEBUG_ERROR, "theme dnd", "%s\n",
+						   (converr ? converr->message :
+							"g_filename_from_uri error"));
+				free_theme_info(info);
+				return;
+			}
+			theme_install_theme(tmp, info);
+			g_free(tmp);
+		} else if (!g_ascii_strncasecmp(name, "http://", 7)) {
+			/* Oo, a web drag and drop. This is where things
+			 * will start to get interesting */
+			purple_util_fetch_url(name, TRUE, NULL, FALSE, theme_got_url, info);
+		} else if (!g_ascii_strncasecmp(name, "https://", 8)) {
+			/* purple_util_fetch_url() doesn't support HTTPS, but we want users
+			 * to be able to drag and drop links from the SF trackers, so
+			 * we'll try it as an HTTP URL. */
+			char *tmp = g_strdup(name + 1);
+			tmp[0] = 'h';
+			tmp[1] = 't';
+			tmp[2] = 't';
+			tmp[3] = 'p';
+
+			purple_util_fetch_url(tmp, TRUE, NULL, FALSE, theme_got_url, info);
+			g_free(tmp);
+		} else
+			free_theme_info(info);
+
+		gtk_drag_finish(dc, TRUE, FALSE, t);
+	}
+
+	gtk_drag_finish(dc, FALSE, FALSE, t);
+}
+
+/* builds a theme combo box from a list store with colums: icon preview, markup, theme name */
+static GtkWidget *
+prefs_build_theme_combo_box(GtkListStore *store, const char *current_theme, const char *type)
+{
+	GtkCellRenderer *cell_rend;
+	GtkWidget *combo_box;
+	GtkTargetEntry te[3] = {
+		{"text/plain", 0, 0},
+		{"text/uri-list", 0, 1},
+		{"STRING", 0, 2}
+	};
+
+	g_return_val_if_fail(store != NULL && current_theme != NULL, NULL);
+
+	combo_box = gtk_combo_box_new_with_model(GTK_TREE_MODEL(store));
+
+	cell_rend = gtk_cell_renderer_pixbuf_new();
+	gtk_cell_renderer_set_fixed_size(cell_rend, PREFS_OPTIMAL_ICON_SIZE, PREFS_OPTIMAL_ICON_SIZE);
+	gtk_cell_layout_pack_start(GTK_CELL_LAYOUT (combo_box), cell_rend, FALSE);
+	gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(combo_box), cell_rend, "pixbuf", 0, NULL);
+
+	cell_rend = gtk_cell_renderer_text_new();
+	gtk_cell_layout_pack_start(GTK_CELL_LAYOUT (combo_box), cell_rend, TRUE);
+	gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(combo_box), cell_rend, "markup", 1, NULL);
+	g_object_set(cell_rend, "ellipsize", PANGO_ELLIPSIZE_END, NULL);
+
+	gtk_drag_dest_set(combo_box, GTK_DEST_DEFAULT_MOTION | GTK_DEST_DEFAULT_HIGHLIGHT | GTK_DEST_DEFAULT_DROP, te,
+					sizeof(te) / sizeof(GtkTargetEntry) , GDK_ACTION_COPY | GDK_ACTION_MOVE);
+
+	g_signal_connect(G_OBJECT(combo_box), "drag_data_received", G_CALLBACK(theme_dnd_recv), (gpointer) type);
+
+	return combo_box;
+}
+
+/* sets the current sound theme */
+static void
+prefs_set_sound_theme_cb(GtkComboBox *combo_box, gpointer user_data)
+{
+	gint i;
+	gchar *pref;
+	gchar *new_theme;
+	GtkTreeIter new_iter;
+
+	if(gtk_combo_box_get_active_iter(combo_box, &new_iter) && !prefs_sound_themes_loading) {
+
+		gtk_tree_model_get(GTK_TREE_MODEL(prefs_sound_themes), &new_iter, 2, &new_theme, -1);
+
+		purple_prefs_set_string(PIDGIN_PREFS_ROOT "/sound/theme", new_theme);
+
+		/* New theme removes all customization */
+		for(i = 0; i < PURPLE_NUM_SOUNDS; i++){
+			pref = g_strdup_printf(PIDGIN_PREFS_ROOT "/sound/file/%s",
+						pidgin_sound_get_event_option(i));
+			purple_prefs_set_path(pref, "");
+			g_free(pref);
+		}
+
+		/* gets rid of the "(Custom)" from the last selection */
+		pref_sound_generate_markup();
+
+		gtk_entry_set_text(GTK_ENTRY(sound_entry), _("(default)"));
+
+		g_free(new_theme);
+	}
+}
+
+/* sets the current smiley theme */
+static void
+prefs_set_smiley_theme_cb(GtkComboBox *combo_box, gpointer user_data)
+{
+	gchar *new_theme;
+	GtkTreeIter new_iter;
+
+	if (gtk_combo_box_get_active_iter(combo_box, &new_iter)) {
+
+		gtk_tree_model_get(GTK_TREE_MODEL(prefs_smiley_themes), &new_iter, 2, &new_theme, -1);
+
+		purple_prefs_set_string(PIDGIN_PREFS_ROOT "/smileys/theme", new_theme);
+		pidgin_themes_smiley_themeize(sample_imhtml);
+
+		g_free(new_theme);
+	}
+}
+
+
+/* Does same as normal sort, except "none" is sorted first */
+static gint pidgin_sort_smileys (GtkTreeModel	*model,
+						GtkTreeIter		*a,
+						GtkTreeIter		*b,
+						gpointer		userdata)
+{
+	gint ret = 0;
+	gchar *name1 = NULL, *name2 = NULL;
+
+	gtk_tree_model_get(model, a, 2, &name1, -1);
+	gtk_tree_model_get(model, b, 2, &name2, -1);
+
+	if (name1 == NULL || name2 == NULL) {
+		if (!(name1 == NULL && name2 == NULL))
+			ret = (name1 == NULL) ? -1: 1;
+	} else if (!g_ascii_strcasecmp(name1, "none")) {
+		if (!g_utf8_collate(name1, name2))
+			ret = 0;
+		else
+			/* Sort name1 first */
+			ret = -1;
+	} else if (!g_ascii_strcasecmp(name2, "none")) {
+		/* Sort name2 first */
+		ret = 1;
+	} else {
+		/* Neither string is "none", default to normal sort */
+		ret = purple_utf8_strcasecmp(name1, name2);
+	}
+
+	g_free(name1);
+	g_free(name2);
+
+	return ret;
+}
+
+/* sets the current buddy list theme */
+static void
+prefs_set_blist_theme_cb(GtkComboBox *combo_box, gpointer user_data)
+{
+	PidginBlistTheme *theme =  NULL;
+	GtkTreeIter iter;
+	gchar *name = NULL;
+
+	if(gtk_combo_box_get_active_iter(combo_box, &iter)) {
+
+		gtk_tree_model_get(GTK_TREE_MODEL(prefs_blist_themes), &iter, 2, &name, -1);
+
+		if(!name || !g_str_equal(name, ""))
+			theme = PIDGIN_BLIST_THEME(purple_theme_manager_find_theme(name, "blist"));
+
+		g_free(name);
+
+		pidgin_blist_set_theme(theme);
+	}
+}
+
+/* sets the current icon theme */
+static void
+prefs_set_status_icon_theme_cb(GtkComboBox *combo_box, gpointer user_data)
+{
+	PidginStatusIconTheme *theme = NULL;
+	GtkTreeIter iter;
+	gchar *name = NULL;
+
+	if(gtk_combo_box_get_active_iter(combo_box, &iter)) {
+
+		gtk_tree_model_get(GTK_TREE_MODEL(prefs_status_icon_themes), &iter, 2, &name, -1);
+
+		if(!name || !g_str_equal(name, ""))
+			theme = PIDGIN_STATUS_ICON_THEME(purple_theme_manager_find_theme(name, "status-icon"));
+
+		g_free(name);
+
+		pidgin_stock_load_status_icon_theme(theme);
+		pidgin_blist_refresh(purple_get_blist());
+	}
+}
+
+static GtkWidget *
+add_theme_prefs_combo(GtkWidget *vbox,
+                      GtkSizeGroup *combo_sg, GtkSizeGroup *label_sg,
+                      GtkListStore *theme_store,
+                      GCallback combo_box_cb, gpointer combo_box_cb_user_data,
+                      const char *label_str, const char *prefs_path,
+                      const char *theme_type)
+{
+	GtkWidget *label;
+	GtkWidget *combo_box = NULL;
+	GtkWidget *themesel_hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+
+	label = gtk_label_new(label_str);
+	gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
+	gtk_size_group_add_widget(label_sg, label);
+	gtk_box_pack_start(GTK_BOX(themesel_hbox), label, FALSE, FALSE, 0);
+
+	combo_box = prefs_build_theme_combo_box(theme_store,
+						purple_prefs_get_string(prefs_path),
+						theme_type);
+	g_signal_connect(G_OBJECT(combo_box), "changed",
+						(GCallback)combo_box_cb, combo_box_cb_user_data);
+	gtk_size_group_add_widget(combo_sg, combo_box);
+	gtk_box_pack_start(GTK_BOX(themesel_hbox), combo_box, TRUE, TRUE, 0);
+
+	gtk_box_pack_start(GTK_BOX(vbox), themesel_hbox, FALSE, FALSE, 0);
+
+	return combo_box;
+}
+
+static GtkWidget *
+theme_page(void)
+{
+	GtkWidget *label;
+	GtkWidget *ret, *vbox;
+	GtkSizeGroup *label_sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+	GtkSizeGroup *combo_sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+
+	ret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);
+	gtk_container_set_border_width (GTK_CONTAINER (ret), PIDGIN_HIG_BORDER);
+
+	vbox = pidgin_make_frame(ret, _("Theme Selections"));
+
+	/* Instructions */
+	label = gtk_label_new(_("Select a theme that you would like to use from "
+							"the lists below.\nNew themes can be installed by "
+							"dragging and dropping them onto the theme list."));
+
+	gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
+	gtk_label_set_justify(GTK_LABEL(label), GTK_JUSTIFY_LEFT);
+
+	gtk_box_pack_start(GTK_BOX(vbox), label, TRUE, FALSE, 0);
+	gtk_widget_show(label);
+
+	/* Buddy List Themes */
+	prefs_blist_themes_combo_box = add_theme_prefs_combo(
+		vbox, combo_sg, label_sg, prefs_blist_themes,
+		(GCallback)prefs_set_blist_theme_cb, NULL,
+		_("Buddy List Theme:"), PIDGIN_PREFS_ROOT "/blist/theme", "blist");
+
+	/* Status Icon Themes */
+	prefs_status_themes_combo_box = add_theme_prefs_combo(
+		vbox, combo_sg, label_sg, prefs_status_icon_themes,
+		(GCallback)prefs_set_status_icon_theme_cb, NULL,
+		_("Status Icon Theme:"), PIDGIN_PREFS_ROOT "/status/icon-theme", "icon");
+
+	/* Sound Themes */
+	prefs_sound_themes_combo_box = add_theme_prefs_combo(
+		vbox, combo_sg, label_sg, prefs_sound_themes,
+		(GCallback)prefs_set_sound_theme_cb, NULL,
+		_("Sound Theme:"), PIDGIN_PREFS_ROOT "/sound/theme", "sound");
+
+	/* Smiley Themes */
+	prefs_smiley_themes_combo_box = add_theme_prefs_combo(
+		vbox, combo_sg, label_sg, prefs_smiley_themes,
+		(GCallback)prefs_set_smiley_theme_cb, NULL,
+		_("Smiley Theme:"), PIDGIN_PREFS_ROOT "/smileys/theme", "smiley");
+
+	/* Custom sort so "none" theme is at top of list */
+	gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(prefs_smiley_themes),
+	                                2, pidgin_sort_smileys, NULL, NULL);
+	gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(prefs_smiley_themes),
+										 2, GTK_SORT_ASCENDING);
+
+	gtk_widget_show_all(ret);
+
+	return ret;
+}
+
+static void
+formatting_toggle_cb(GtkIMHtml *imhtml, GtkIMHtmlButtons buttons, void *toolbar)
+{
+	gboolean bold, italic, uline;
+
+	gtk_imhtml_get_current_format(GTK_IMHTML(imhtml),
+								  &bold, &italic, &uline);
+
+	if (buttons & GTK_IMHTML_BOLD)
+		purple_prefs_set_bool(PIDGIN_PREFS_ROOT "/conversations/send_bold", bold);
+	if (buttons & GTK_IMHTML_ITALIC)
+		purple_prefs_set_bool(PIDGIN_PREFS_ROOT "/conversations/send_italic", italic);
+	if (buttons & GTK_IMHTML_UNDERLINE)
+		purple_prefs_set_bool(PIDGIN_PREFS_ROOT "/conversations/send_underline", uline);
+
+	if (buttons & GTK_IMHTML_GROW || buttons & GTK_IMHTML_SHRINK)
+		purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/font_size",
+						   gtk_imhtml_get_current_fontsize(GTK_IMHTML(imhtml)));
+	if (buttons & GTK_IMHTML_FACE) {
+		char *face = gtk_imhtml_get_current_fontface(GTK_IMHTML(imhtml));
+		if (!face)
+			face = g_strdup("");
+
+		purple_prefs_set_string(PIDGIN_PREFS_ROOT "/conversations/font_face", face);
+		g_free(face);
+	}
+
+	if (buttons & GTK_IMHTML_FORECOLOR) {
+		char *color = gtk_imhtml_get_current_forecolor(GTK_IMHTML(imhtml));
+		if (!color)
+			color = g_strdup("");
+
+		purple_prefs_set_string(PIDGIN_PREFS_ROOT "/conversations/fgcolor", color);
+		g_free(color);
+	}
+
+	if (buttons & GTK_IMHTML_BACKCOLOR) {
+		char *color;
+		GObject *object;
+
+		color = gtk_imhtml_get_current_backcolor(GTK_IMHTML(imhtml));
+		if (!color)
+			color = g_strdup("");
+
+		/* Block the signal to prevent a loop. */
+		object = g_object_ref(G_OBJECT(imhtml));
+		g_signal_handlers_block_matched(object, G_SIGNAL_MATCH_DATA, 0, 0, NULL,
+										NULL, toolbar);
+		/* Clear the backcolor. */
+		gtk_imhtml_toggle_backcolor(GTK_IMHTML(imhtml), "");
+		/* Unblock the signal. */
+		g_signal_handlers_unblock_matched(object, G_SIGNAL_MATCH_DATA, 0, 0, NULL,
+										  NULL, toolbar);
+		g_object_unref(object);
+
+		/* This will fire a toggle signal and get saved below. */
+		gtk_imhtml_toggle_background(GTK_IMHTML(imhtml), color);
+
+		g_free(color);
+	}
+
+	if (buttons & GTK_IMHTML_BACKGROUND) {
+		char *color = gtk_imhtml_get_current_background(GTK_IMHTML(imhtml));
+		if (!color)
+			color = g_strdup("");
+
+		purple_prefs_set_string(PIDGIN_PREFS_ROOT "/conversations/bgcolor", color);
+		g_free(color);
+	}
+}
+
+static void
+formatting_clear_cb(GtkIMHtml *imhtml, void *data)
+{
+	purple_prefs_set_bool(PIDGIN_PREFS_ROOT "/conversations/send_bold", FALSE);
+	purple_prefs_set_bool(PIDGIN_PREFS_ROOT "/conversations/send_italic", FALSE);
+	purple_prefs_set_bool(PIDGIN_PREFS_ROOT "/conversations/send_underline", FALSE);
+
+	purple_prefs_set_int(PIDGIN_PREFS_ROOT "/conversations/font_size", 3);
+
+	purple_prefs_set_string(PIDGIN_PREFS_ROOT "/conversations/font_face", "");
+	purple_prefs_set_string(PIDGIN_PREFS_ROOT "/conversations/fgcolor", "");
+	purple_prefs_set_string(PIDGIN_PREFS_ROOT "/conversations/bgcolor", "");
+}
+
+static void
+conversation_usetabs_cb(const char *name, PurplePrefType type,
+						gconstpointer value, gpointer data)
+{
+	gboolean usetabs = GPOINTER_TO_INT(value);
+
+	if (usetabs)
+		gtk_widget_set_sensitive(GTK_WIDGET(data), TRUE);
+	else
+		gtk_widget_set_sensitive(GTK_WIDGET(data), FALSE);
+}
+
+
+#define CONVERSATION_CLOSE_ACCEL_PATH "<main>/Conversation/Close"
+
+/* Filled in in keyboard_shortcuts(). */
+static GtkAccelKey ctrl_w = { 0, 0, 0 };
+static GtkAccelKey escape = { 0, 0, 0 };
+
+static guint escape_closes_conversation_cb_id = 0;
+
+static gboolean
+accel_is_escape(GtkAccelKey *k)
+{
+	return (k->accel_key == escape.accel_key
+		&& k->accel_mods == escape.accel_mods);
+}
+
+/* Update the tickybox in Preferences when the keybinding for Conversation ->
+ * Close is changed via Gtk.
+ */
+static void
+conversation_close_accel_changed_cb (GtkAccelMap    *object,
+                                     gchar          *accel_path,
+                                     guint           accel_key,
+                                     GdkModifierType accel_mods,
+                                     gpointer        checkbox_)
+{
+	GtkToggleButton *checkbox = GTK_TOGGLE_BUTTON(checkbox_);
+	GtkAccelKey new = { accel_key, accel_mods, 0 };
+
+	g_signal_handler_block(checkbox, escape_closes_conversation_cb_id);
+	gtk_toggle_button_set_active(checkbox, accel_is_escape(&new));
+	g_signal_handler_unblock(checkbox, escape_closes_conversation_cb_id);
+}
+
+
+static void
+escape_closes_conversation_cb(GtkWidget *w,
+                              gpointer unused)
+{
+	gboolean active = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w));
+	gboolean changed;
+	GtkAccelKey *new_key = active ? &escape : &ctrl_w;
+
+	changed = gtk_accel_map_change_entry(CONVERSATION_CLOSE_ACCEL_PATH,
+		new_key->accel_key, new_key->accel_mods, TRUE);
+
+	/* If another path is already bound to the new accelerator,
+	 * _change_entry tries to delete that binding (because it was passed
+	 * replace=TRUE).  If that other path is locked, then _change_entry
+	 * will fail.  We don't ever lock any accelerator paths, so this case
+	 * should never arise.
+	 */
+	if(!changed)
+		purple_debug_warning("gtkprefs", "Escape accel failed to change\n");
+}
+
+
+/* Creates preferences for keyboard shortcuts that it's hard to change with the
+ * standard Gtk accelerator-changing mechanism.
+ */
+static void
+keyboard_shortcuts(GtkWidget *page)
+{
+	GtkWidget *vbox = pidgin_make_frame(page, _("Keyboard Shortcuts"));
+	GtkWidget *checkbox;
+	GtkAccelKey current = { 0, 0, 0 };
+	GtkAccelMap *map = gtk_accel_map_get();
+
+	/* Maybe it would be better just to hardcode the values?
+	 * -- resiak, 2007-04-30
+	 */
+	if (ctrl_w.accel_key == 0)
+	{
+		gtk_accelerator_parse ("<Control>w", &(ctrl_w.accel_key),
+			&(ctrl_w.accel_mods));
+		g_assert(ctrl_w.accel_key != 0);
+
+		gtk_accelerator_parse ("Escape", &(escape.accel_key),
+			&(escape.accel_mods));
+		g_assert(escape.accel_key != 0);
+	}
+
+	checkbox = gtk_check_button_new_with_mnemonic(
+		_("Cl_ose conversations with the Escape key"));
+	gtk_accel_map_lookup_entry(CONVERSATION_CLOSE_ACCEL_PATH, &current);
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(checkbox),
+		accel_is_escape(&current));
+
+	escape_closes_conversation_cb_id = g_signal_connect(checkbox,
+		"clicked", G_CALLBACK(escape_closes_conversation_cb), NULL);
+
+	g_signal_connect_object(map, "changed::" CONVERSATION_CLOSE_ACCEL_PATH,
+		G_CALLBACK(conversation_close_accel_changed_cb), checkbox, (GConnectFlags)0);
+
+	gtk_box_pack_start(GTK_BOX(vbox), checkbox, FALSE, FALSE, 0);
+}
+
+static GtkWidget *
+interface_page(void)
+{
+	GtkWidget *ret;
+	GtkWidget *vbox;
+	GtkWidget *vbox2;
+	GtkWidget *label;
+	GtkSizeGroup *sg;
+	GList *names = NULL;
+
+	ret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);
+	gtk_container_set_border_width(GTK_CONTAINER(ret), PIDGIN_HIG_BORDER);
+
+	sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+
+	/* System Tray */
+	vbox = pidgin_make_frame(ret, _("System Tray Icon"));
+	label = pidgin_prefs_dropdown(vbox, _("_Show system tray icon:"), PURPLE_PREF_STRING,
+					PIDGIN_PREFS_ROOT "/docklet/show",
+					_("Always"), "always",
+					_("On unread messages"), "pending",
+					_("Never"), "never",
+					NULL);
+	gtk_size_group_add_widget(sg, label);
+	gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
+
+	vbox = pidgin_make_frame(ret, _("Conversation Window"));
+	label = pidgin_prefs_dropdown(vbox, _("_Hide new IM conversations:"),
+					PURPLE_PREF_STRING, PIDGIN_PREFS_ROOT "/conversations/im/hide_new",
+					_("Never"), "never",
+					_("When away"), "away",
+					_("Always"), "always",
+					NULL);
+	gtk_size_group_add_widget(sg, label);
+	gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
+
+#ifdef _WIN32
+	pidgin_prefs_checkbox(_("Minimi_ze new conversation windows"), PIDGIN_PREFS_ROOT "/win32/minimize_new_convs", vbox);
+#endif
+
+	/* All the tab options! */
+	vbox = pidgin_make_frame(ret, _("Tabs"));
+
+	pidgin_prefs_checkbox(_("Show IMs and chats in _tabbed windows"),
+							PIDGIN_PREFS_ROOT "/conversations/tabs", vbox);
+
+	/*
+	 * Connect a signal to the above preference.  When conversations are not
+	 * shown in a tabbed window then all tabbing options should be disabled.
+	 */
+	vbox2 = gtk_vbox_new(FALSE, 9);
+	gtk_box_pack_start(GTK_BOX(vbox), vbox2, FALSE, FALSE, 0);
+	purple_prefs_connect_callback(prefs, PIDGIN_PREFS_ROOT "/conversations/tabs",
+	                            conversation_usetabs_cb, vbox2);
+	if (!purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/tabs"))
+		gtk_widget_set_sensitive(vbox2, FALSE);
+
+	pidgin_prefs_checkbox(_("Show close b_utton on tabs"),
+				PIDGIN_PREFS_ROOT "/conversations/close_on_tabs", vbox2);
+
+	label = pidgin_prefs_dropdown(vbox2, _("_Placement:"), PURPLE_PREF_INT,
+					PIDGIN_PREFS_ROOT "/conversations/tab_side",
+					_("Top"), GTK_POS_TOP,
+					_("Bottom"), GTK_POS_BOTTOM,
+					_("Left"), GTK_POS_LEFT,
+					_("Right"), GTK_POS_RIGHT,
+					_("Left Vertical"), GTK_POS_LEFT|8,
+					_("Right Vertical"), GTK_POS_RIGHT|8,
+					NULL);
+	gtk_size_group_add_widget(sg, label);
+	gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
+
+	names = pidgin_conv_placement_get_options();
+	label = pidgin_prefs_dropdown_from_list(vbox2, _("N_ew conversations:"),
+				PURPLE_PREF_STRING, PIDGIN_PREFS_ROOT "/conversations/placement", names);
+	gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
+
+	gtk_size_group_add_widget(sg, label);
+
+	g_list_free(names);
+
+	keyboard_shortcuts(ret);
+
+	gtk_widget_show_all(ret);
+	g_object_unref(sg);
+	return ret;
+}
+
+#ifdef _WIN32
+static void
+apply_custom_font(void)
+{
+	PangoFontDescription *desc = NULL;
+	if (!purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/use_theme_font")) {
+		const char *font = purple_prefs_get_string(PIDGIN_PREFS_ROOT "/conversations/custom_font");
+		desc = pango_font_description_from_string(font);
+	}
+
+	gtk_widget_modify_font(sample_imhtml, desc);
+	if (desc)
+		pango_font_description_free(desc);
+
+}
+static void
+pidgin_custom_font_set(GtkFontButton *font_button, gpointer nul)
+{
+
+	purple_prefs_set_string(PIDGIN_PREFS_ROOT "/conversations/custom_font",
+				gtk_font_button_get_font_name(font_button));
+
+	apply_custom_font();
+}
+#endif
+
+static GtkWidget *
+conv_page(void)
+{
+	GtkWidget *ret;
+	GtkWidget *vbox;
+	GtkWidget *toolbar;
+	GtkWidget *iconpref1;
+	GtkWidget *iconpref2;
+	GtkWidget *imhtml;
+	GtkWidget *frame;
+	GtkWidget *hbox;
+	GtkWidget *checkbox;
+	GtkWidget *spin_button;
+
+	ret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);
+	gtk_container_set_border_width(GTK_CONTAINER(ret), PIDGIN_HIG_BORDER);
+
+	vbox = pidgin_make_frame(ret, _("Conversations"));
+
+	pidgin_prefs_checkbox(_("Show _formatting on incoming messages"),
+				PIDGIN_PREFS_ROOT "/conversations/show_incoming_formatting", vbox);
+	pidgin_prefs_checkbox(_("Close IMs immediately when the tab is closed"),
+				PIDGIN_PREFS_ROOT "/conversations/im/close_immediately", vbox);
+
+	iconpref1 = pidgin_prefs_checkbox(_("Show _detailed information"),
+			PIDGIN_PREFS_ROOT "/conversations/im/show_buddy_icons", vbox);
+	iconpref2 = pidgin_prefs_checkbox(_("Enable buddy ic_on animation"),
+			PIDGIN_PREFS_ROOT "/conversations/im/animate_buddy_icons", vbox);
+	if (!purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/im/show_buddy_icons"))
+		gtk_widget_set_sensitive(iconpref2, FALSE);
+	g_signal_connect(G_OBJECT(iconpref1), "clicked",
+					 G_CALLBACK(pidgin_toggle_sensitive), iconpref2);
+
+	pidgin_prefs_checkbox(_("_Notify buddies that you are typing to them"),
+			"/purple/conversations/im/send_typing", vbox);
+#ifdef USE_GTKSPELL
+	pidgin_prefs_checkbox(_("Highlight _misspelled words"),
+			PIDGIN_PREFS_ROOT "/conversations/spellcheck", vbox);
+#endif
+
+	pidgin_prefs_checkbox(_("Use smooth-scrolling"), PIDGIN_PREFS_ROOT "/conversations/use_smooth_scrolling", vbox);
+
+#ifdef _WIN32
+	pidgin_prefs_checkbox(_("F_lash window when IMs are received"), PIDGIN_PREFS_ROOT "/win32/blink_im", vbox);
+#endif
+	hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+
+	checkbox = pidgin_prefs_checkbox(_("Resize incoming custom smileys"),
+			PIDGIN_PREFS_ROOT "/conversations/resize_custom_smileys", hbox);
+
+	spin_button = pidgin_prefs_labeled_spin_button(hbox,
+		_("Maximum size:"),
+		PIDGIN_PREFS_ROOT "/conversations/custom_smileys_size",
+		16, 512, NULL);
+
+	if (!purple_prefs_get_bool(
+				PIDGIN_PREFS_ROOT "/conversations/resize_custom_smileys"))
+		gtk_widget_set_sensitive(GTK_WIDGET(spin_button), FALSE);
+
+	g_signal_connect(G_OBJECT(checkbox), "clicked",
+					 G_CALLBACK(pidgin_toggle_sensitive), spin_button);
+
+	pidgin_add_widget_to_vbox(GTK_BOX(vbox), NULL, NULL, hbox, TRUE, NULL);
+
+	pidgin_prefs_labeled_spin_button(vbox,
+		_("Minimum input area height in lines:"),
+		PIDGIN_PREFS_ROOT "/conversations/minimum_entry_lines",
+		1, 8, NULL);
+
+#ifdef _WIN32
+	{
+	GtkWidget *fontpref, *font_button, *hbox;
+	const char *font_name;
+	vbox = pidgin_make_frame(ret, _("Font"));
+
+	fontpref = pidgin_prefs_checkbox(_("Use font from _theme"),
+									 PIDGIN_PREFS_ROOT "/conversations/use_theme_font", vbox);
+
+	font_name = purple_prefs_get_string(PIDGIN_PREFS_ROOT "/conversations/custom_font");
+	if ((font_name == NULL) || (*font_name == '\0')) {
+		font_button = gtk_font_button_new();
+	} else {
+		font_button = gtk_font_button_new_with_font(font_name);
+	}
+
+	gtk_font_button_set_show_style(GTK_FONT_BUTTON(font_button), TRUE);
+	hbox = pidgin_add_widget_to_vbox(GTK_BOX(vbox), _("Conversation _font:"), NULL, font_button, FALSE, NULL);
+	if (purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/use_theme_font"))
+		gtk_widget_set_sensitive(hbox, FALSE);
+	g_signal_connect(G_OBJECT(fontpref), "clicked", G_CALLBACK(pidgin_toggle_sensitive), hbox);
+	g_signal_connect(G_OBJECT(fontpref), "clicked", G_CALLBACK(apply_custom_font), hbox);
+	g_signal_connect(G_OBJECT(font_button), "font-set", G_CALLBACK(pidgin_custom_font_set), NULL);
+
+	}
+#endif
+
+	vbox = pidgin_make_frame(ret, _("Default Formatting"));
+
+	frame = pidgin_create_imhtml(TRUE, &imhtml, &toolbar, NULL);
+	gtk_widget_show(frame);
+	gtk_widget_set_name(imhtml, "pidgin_prefs_font_imhtml");
+	gtk_widget_set_size_request(frame, 450, -1);
+	gtk_imhtml_set_whole_buffer_formatting_only(GTK_IMHTML(imhtml), TRUE);
+	gtk_imhtml_set_format_functions(GTK_IMHTML(imhtml),
+									GTK_IMHTML_BOLD |
+									GTK_IMHTML_ITALIC |
+									GTK_IMHTML_UNDERLINE |
+									GTK_IMHTML_GROW |
+									GTK_IMHTML_SHRINK |
+									GTK_IMHTML_FACE |
+									GTK_IMHTML_FORECOLOR |
+									GTK_IMHTML_BACKCOLOR |
+									GTK_IMHTML_BACKGROUND);
+
+	gtk_imhtml_append_text(GTK_IMHTML(imhtml), _("This is how your outgoing message text will appear when you use protocols that support formatting."), 0);
+
+	gtk_box_pack_start(GTK_BOX(vbox), frame, TRUE, TRUE, 0);
+
+	gtk_imhtml_setup_entry(GTK_IMHTML(imhtml), PURPLE_CONNECTION_HTML | PURPLE_CONNECTION_FORMATTING_WBFO);
+
+	g_signal_connect_after(G_OBJECT(imhtml), "format_function_toggle",
+					 G_CALLBACK(formatting_toggle_cb), toolbar);
+	g_signal_connect_after(G_OBJECT(imhtml), "format_function_clear",
+					 G_CALLBACK(formatting_clear_cb), NULL);
+	sample_imhtml = imhtml;
+
+	gtk_widget_show(ret);
+
+	return ret;
+}
+
+static void
+network_ip_changed(GtkEntry *entry, gpointer data)
+{
+	const gchar *text = gtk_entry_get_text(entry);
+	GdkColor color;
+
+	if (text && *text) {
+		if (purple_ip_address_is_valid(text)) {
+			color.red = 0xAFFF;
+			color.green = 0xFFFF;
+			color.blue = 0xAFFF;
+
+			purple_network_set_public_ip(text);
+		} else {
+			color.red = 0xFFFF;
+			color.green = 0xAFFF;
+			color.blue = 0xAFFF;
+		}
+
+		gtk_widget_modify_base(GTK_WIDGET(entry), GTK_STATE_NORMAL, &color);
+
+	} else {
+		purple_network_set_public_ip("");
+		gtk_widget_modify_base(GTK_WIDGET(entry), GTK_STATE_NORMAL, NULL);
+	}
+}
+
+static gboolean
+network_stun_server_changed_cb(GtkWidget *widget,
+                               GdkEventFocus *event, gpointer data)
+{
+	GtkEntry *entry = GTK_ENTRY(widget);
+	purple_prefs_set_string("/purple/network/stun_server",
+		gtk_entry_get_text(entry));
+	purple_network_set_stun_server(gtk_entry_get_text(entry));
+
+	return FALSE;
+}
+
+static gboolean
+network_turn_server_changed_cb(GtkWidget *widget,
+                               GdkEventFocus *event, gpointer data)
+{
+	GtkEntry *entry = GTK_ENTRY(widget);
+	purple_prefs_set_string("/purple/network/turn_server",
+		gtk_entry_get_text(entry));
+	purple_network_set_turn_server(gtk_entry_get_text(entry));
+
+	return FALSE;
+}
+
+static void
+proxy_changed_cb(const char *name, PurplePrefType type,
+				 gconstpointer value, gpointer data)
+{
+	GtkWidget *frame = data;
+	const char *proxy = value;
+
+	if (strcmp(proxy, "none") && strcmp(proxy, "envvar"))
+		gtk_widget_show_all(frame);
+	else
+		gtk_widget_hide(frame);
+}
+
+static void
+proxy_print_option(GtkEntry *entry, int entrynum)
+{
+	if (entrynum == PROXYHOST)
+		purple_prefs_set_string("/purple/proxy/host", gtk_entry_get_text(entry));
+	else if (entrynum == PROXYPORT)
+		purple_prefs_set_int("/purple/proxy/port", atoi(gtk_entry_get_text(entry)));
+	else if (entrynum == PROXYUSER)
+		purple_prefs_set_string("/purple/proxy/username", gtk_entry_get_text(entry));
+	else if (entrynum == PROXYPASS)
+		purple_prefs_set_string("/purple/proxy/password", gtk_entry_get_text(entry));
+}
+
+static void
+proxy_button_clicked_cb(GtkWidget *button, gchar *program)
+{
+	GError *err = NULL;
+
+	if (g_spawn_command_line_async(program, &err))
+		return;
+
+	purple_notify_error(NULL, NULL, _("Cannot start proxy configuration program."), err->message);
+	g_error_free(err);
+}
+
+#ifndef _WIN32
+static void
+browser_button_clicked_cb(GtkWidget *button, gchar *path)
+{
+	GError *err = NULL;
+
+	if (g_spawn_command_line_async(path, &err))
+		return;
+
+	purple_notify_error(NULL, NULL, _("Cannot start browser configuration program."), err->message);
+	g_error_free(err);
+}
+#endif
+
+static void
+auto_ip_button_clicked_cb(GtkWidget *button, gpointer null)
+{
+	const char *ip;
+	PurpleStunNatDiscovery *stun;
+	char *auto_ip_text;
+
+	/* purple_network_get_my_ip will return the IP that was set by the user with
+	   purple_network_set_public_ip, so make a lookup for the auto-detected IP
+	   ourselves. */
+
+	if (purple_prefs_get_bool("/purple/network/auto_ip")) {
+		/* Check if STUN discovery was already done */
+		stun = purple_stun_discover(NULL);
+		if ((stun != NULL) && (stun->status == PURPLE_STUN_STATUS_DISCOVERED)) {
+			ip = stun->publicip;
+		} else {
+			/* Attempt to get the IP from a NAT device using UPnP */
+			ip = purple_upnp_get_public_ip();
+			if (ip == NULL) {
+				/* Attempt to get the IP from a NAT device using NAT-PMP */
+				ip = purple_pmp_get_public_ip();
+				if (ip == NULL) {
+					/* Just fetch the IP of the local system */
+					ip = purple_network_get_local_system_ip(-1);
+				}
+			}
+		}
+	}
+	else
+		ip = _("Disabled");
+
+	auto_ip_text = g_strdup_printf(_("Use _automatically detected IP address: %s"), ip);
+	gtk_button_set_label(GTK_BUTTON(button), auto_ip_text);
+	g_free(auto_ip_text);
+}
+
+static GtkWidget *
+network_page(void)
+{
+	GtkWidget *ret;
+	GtkWidget *vbox, *hbox, *entry;
+	GtkWidget *label, *auto_ip_checkbox, *ports_checkbox, *spin_button;
+	GtkSizeGroup *sg;
+
+	ret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);
+	gtk_container_set_border_width (GTK_CONTAINER (ret), PIDGIN_HIG_BORDER);
+
+	vbox = pidgin_make_frame (ret, _("IP Address"));
+	sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+
+	entry = gtk_entry_new();
+	gtk_entry_set_text(GTK_ENTRY(entry), purple_prefs_get_string(
+			"/purple/network/stun_server"));
+	g_signal_connect(G_OBJECT(entry), "focus-out-event",
+			G_CALLBACK(network_stun_server_changed_cb), NULL);
+	gtk_widget_show(entry);
+
+	pidgin_add_widget_to_vbox(GTK_BOX(vbox), _("ST_UN server:"),
+			sg, entry, TRUE, NULL);
+
+	hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_container_add(GTK_CONTAINER(vbox), hbox);
+
+	label = gtk_label_new(NULL);
+	gtk_container_add(GTK_CONTAINER(hbox), label);
+	gtk_size_group_add_widget(sg, label);
+
+	label = gtk_label_new(NULL);
+	gtk_label_set_markup(GTK_LABEL(label),
+			_("<span style=\"italic\">Example: stunserver.org</span>"));
+	gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
+	gtk_container_add(GTK_CONTAINER(hbox), label);
+
+	auto_ip_checkbox = pidgin_prefs_checkbox("Use _automatically detected IP address",
+	                                         "/purple/network/auto_ip", vbox);
+	g_signal_connect(G_OBJECT(auto_ip_checkbox), "clicked",
+	                 G_CALLBACK(auto_ip_button_clicked_cb), NULL);
+	auto_ip_button_clicked_cb(auto_ip_checkbox, NULL); /* Update label */
+
+	entry = gtk_entry_new();
+	gtk_entry_set_text(GTK_ENTRY(entry), purple_network_get_public_ip());
+	g_signal_connect(G_OBJECT(entry), "changed",
+					 G_CALLBACK(network_ip_changed), NULL);
+
+	hbox = pidgin_add_widget_to_vbox(GTK_BOX(vbox), _("Public _IP:"),
+			sg, entry, TRUE, NULL);
+
+	if (purple_prefs_get_bool("/purple/network/auto_ip")) {
+		gtk_widget_set_sensitive(GTK_WIDGET(hbox), FALSE);
+	}
+
+	g_signal_connect(G_OBJECT(auto_ip_checkbox), "clicked",
+					 G_CALLBACK(pidgin_toggle_sensitive), hbox);
+
+	g_object_unref(sg);
+
+	vbox = pidgin_make_frame (ret, _("Ports"));
+	sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+
+	pidgin_prefs_checkbox(_("_Enable automatic router port forwarding"),
+			"/purple/network/map_ports", vbox);
+
+	hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+
+	ports_checkbox = pidgin_prefs_checkbox(_("_Manually specify range of ports to listen on:"),
+			"/purple/network/ports_range_use", hbox);
+
+	spin_button = pidgin_prefs_labeled_spin_button(hbox, _("_Start:"),
+			"/purple/network/ports_range_start", 0, 65535, sg);
+	if (!purple_prefs_get_bool("/purple/network/ports_range_use"))
+		gtk_widget_set_sensitive(GTK_WIDGET(spin_button), FALSE);
+	g_signal_connect(G_OBJECT(ports_checkbox), "clicked",
+					 G_CALLBACK(pidgin_toggle_sensitive), spin_button);
+
+	spin_button = pidgin_prefs_labeled_spin_button(hbox, _("_End:"),
+			"/purple/network/ports_range_end", 0, 65535, sg);
+	if (!purple_prefs_get_bool("/purple/network/ports_range_use"))
+		gtk_widget_set_sensitive(GTK_WIDGET(spin_button), FALSE);
+	g_signal_connect(G_OBJECT(ports_checkbox), "clicked",
+					 G_CALLBACK(pidgin_toggle_sensitive), spin_button);
+
+	pidgin_add_widget_to_vbox(GTK_BOX(vbox), NULL, NULL, hbox, TRUE, NULL);
+
+	g_object_unref(sg);
+
+	/* TURN server */
+	vbox = pidgin_make_frame(ret, _("Relay Server (TURN)"));
+	sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+
+	entry = gtk_entry_new();
+	gtk_entry_set_text(GTK_ENTRY(entry), purple_prefs_get_string(
+			"/purple/network/turn_server"));
+	g_signal_connect(G_OBJECT(entry), "focus-out-event",
+			G_CALLBACK(network_turn_server_changed_cb), NULL);
+	gtk_widget_show(entry);
+
+	hbox = pidgin_add_widget_to_vbox(GTK_BOX(vbox), _("_TURN server:"),
+			sg, entry, TRUE, NULL);
+
+	pidgin_prefs_labeled_spin_button(hbox, _("_UDP Port:"),
+		"/purple/network/turn_port", 0, 65535, NULL);
+
+	pidgin_prefs_labeled_spin_button(hbox, _("T_CP Port:"),
+		"/purple/network/turn_port_tcp", 0, 65535, NULL);
+
+	hbox = pidgin_prefs_labeled_entry(vbox, _("Use_rname:"),
+		"/purple/network/turn_username", sg);
+	pidgin_prefs_labeled_password(hbox, _("Pass_word:"),
+		"/purple/network/turn_password", NULL);
+
+	gtk_widget_show_all(ret);
+	g_object_unref(sg);
+
+	return ret;
+}
+
+#ifndef _WIN32
+static gboolean
+manual_browser_set(GtkWidget *entry, GdkEventFocus *event, gpointer data)
+{
+	const char *program = gtk_entry_get_text(GTK_ENTRY(entry));
+
+	purple_prefs_set_string(PIDGIN_PREFS_ROOT "/browsers/manual_command", program);
+
+	/* carry on normally */
+	return FALSE;
+}
+
+static GList *
+get_available_browsers(void)
+{
+	struct browser {
+		char *name;
+		char *command;
+	};
+
+	/* Sorted reverse alphabetically */
+	static const struct browser possible_browsers[] = {
+		{N_("Seamonkey"), "seamonkey"},
+		{N_("Opera"), "opera"},
+		{N_("Netscape"), "netscape"},
+		{N_("Mozilla"), "mozilla"},
+		{N_("Konqueror"), "kfmclient"},
+		{N_("Google Chrome"), "google-chrome"},
+		/* Do not move the line below.  Code below expects gnome-open to be in
+		 * this list immediately after xdg-open! */
+		{N_("Desktop Default"), "xdg-open"},
+		{N_("GNOME Default"), "gnome-open"},
+		{N_("Galeon"), "galeon"},
+		{N_("Firefox"), "firefox"},
+		{N_("Firebird"), "mozilla-firebird"},
+		{N_("Epiphany"), "epiphany"},
+		/* Translators: please do not translate "chromium-browser" here! */
+		{N_("Chromium (chromium-browser)"), "chromium-browser"},
+		/* Translators: please do not translate "chrome" here! */
+		{N_("Chromium (chrome)"), "chrome"}
+	};
+	static const int num_possible_browsers = G_N_ELEMENTS(possible_browsers);
+
+	GList *browsers = NULL;
+	int i = 0;
+	char *browser_setting = (char *)purple_prefs_get_string(PIDGIN_PREFS_ROOT "/browsers/browser");
+
+	browsers = g_list_prepend(browsers, (gpointer)"custom");
+	browsers = g_list_prepend(browsers, (gpointer)_("Manual"));
+
+	for (i = 0; i < num_possible_browsers; i++) {
+		if (purple_program_is_valid(possible_browsers[i].command)) {
+			browsers = g_list_prepend(browsers,
+									  possible_browsers[i].command);
+			browsers = g_list_prepend(browsers, (gpointer)_(possible_browsers[i].name));
+			if(browser_setting && !strcmp(possible_browsers[i].command, browser_setting))
+				browser_setting = NULL;
+			/* If xdg-open is valid, prefer it over gnome-open and skip forward */
+			if(!strcmp(possible_browsers[i].command, "xdg-open")) {
+				if (browser_setting && !strcmp("gnome-open", browser_setting)) {
+					purple_prefs_set_string(PIDGIN_PREFS_ROOT "/browsers/browser", possible_browsers[i].command);
+					browser_setting = NULL;
+				}
+				i++;
+			}
+		}
+	}
+
+	if(browser_setting)
+		purple_prefs_set_string(PIDGIN_PREFS_ROOT "/browsers/browser", "custom");
+
+	return browsers;
+}
+
+static void
+browser_changed1_cb(const char *name, PurplePrefType type,
+					gconstpointer value, gpointer data)
+{
+	GtkWidget *hbox = data;
+	const char *browser = value;
+
+	gtk_widget_set_sensitive(hbox, strcmp(browser, "custom"));
+}
+
+static void
+browser_changed2_cb(const char *name, PurplePrefType type,
+					gconstpointer value, gpointer data)
+{
+	GtkWidget *hbox = data;
+	const char *browser = value;
+
+	gtk_widget_set_sensitive(hbox, !strcmp(browser, "custom"));
+}
+
+static GtkWidget *
+browser_page(void)
+{
+	GtkWidget *ret, *vbox, *hbox, *label, *entry, *browser_button;
+	GtkSizeGroup *sg;
+	GList *browsers = NULL;
+
+	ret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);
+	gtk_container_set_border_width (GTK_CONTAINER (ret), PIDGIN_HIG_BORDER);
+
+	vbox = pidgin_make_frame (ret, _("Browser Selection"));
+
+	if (purple_running_gnome()) {
+		gchar *path;
+
+		hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+		label = gtk_label_new(_("Browser preferences are configured in GNOME preferences"));
+		gtk_container_add(GTK_CONTAINER(vbox), hbox);
+		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
+
+		hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+		gtk_container_add(GTK_CONTAINER(vbox), hbox);
+
+		path = g_find_program_in_path("gnome-control-center");
+		if (path != NULL) {
+			gchar *tmp = g_strdup_printf("%s info", path);
+			g_free(path);
+			path = tmp;
+		} else {
+			path = g_find_program_in_path("gnome-default-applications-properties");
+		}
+
+		if (path == NULL) {
+			label = gtk_label_new(NULL);
+			gtk_label_set_markup(GTK_LABEL(label),
+								 _("<b>Browser configuration program was not found.</b>"));
+			gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
+		} else {
+			browser_button = gtk_button_new_with_mnemonic(_("Configure _Browser"));
+			g_signal_connect_data(G_OBJECT(browser_button), "clicked",
+			                      G_CALLBACK(browser_button_clicked_cb), path,
+			                      (GClosureNotify)g_free, 0);
+			gtk_box_pack_start(GTK_BOX(hbox), browser_button, FALSE, FALSE, 0);
+		}
+
+		gtk_widget_show_all(ret);
+	} else {
+		sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+
+		browsers = get_available_browsers();
+		if (browsers != NULL) {
+			label = pidgin_prefs_dropdown_from_list(vbox,_("_Browser:"), PURPLE_PREF_STRING,
+											 PIDGIN_PREFS_ROOT "/browsers/browser",
+											 browsers);
+			g_list_free(browsers);
+			gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
+			gtk_size_group_add_widget(sg, label);
+
+			hbox = gtk_hbox_new(FALSE, 0);
+			label = pidgin_prefs_dropdown(hbox, _("_Open link in:"), PURPLE_PREF_INT,
+				PIDGIN_PREFS_ROOT "/browsers/place",
+				_("Browser default"), PIDGIN_BROWSER_DEFAULT,
+				_("Existing window"), PIDGIN_BROWSER_CURRENT,
+				_("New window"), PIDGIN_BROWSER_NEW_WINDOW,
+				_("New tab"), PIDGIN_BROWSER_NEW_TAB,
+				NULL);
+			gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
+			gtk_size_group_add_widget(sg, label);
+			gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+
+			if (!strcmp(purple_prefs_get_string(PIDGIN_PREFS_ROOT "/browsers/browser"), "custom"))
+				gtk_widget_set_sensitive(hbox, FALSE);
+			purple_prefs_connect_callback(prefs, PIDGIN_PREFS_ROOT "/browsers/browser",
+										browser_changed1_cb, hbox);
+		}
+
+		entry = gtk_entry_new();
+		gtk_entry_set_text(GTK_ENTRY(entry),
+						   purple_prefs_get_string(PIDGIN_PREFS_ROOT "/browsers/manual_command"));
+		g_signal_connect(G_OBJECT(entry), "focus-out-event",
+						 G_CALLBACK(manual_browser_set), NULL);
+		hbox = pidgin_add_widget_to_vbox(GTK_BOX(vbox), _("_Manual:\n(%s for URL)"), sg, entry, TRUE, NULL);
+		if (strcmp(purple_prefs_get_string(PIDGIN_PREFS_ROOT "/browsers/browser"), "custom"))
+			gtk_widget_set_sensitive(hbox, FALSE);
+		purple_prefs_connect_callback(prefs, PIDGIN_PREFS_ROOT "/browsers/browser",
+				browser_changed2_cb, hbox);
+
+		gtk_widget_show_all(ret);
+		g_object_unref(sg);
+	}
+
+	return ret;
+}
+#endif /*_WIN32*/
+
+static GtkWidget *
+proxy_page(void)
+{
+	GtkWidget *ret = NULL, *vbox = NULL, *hbox = NULL;
+	GtkWidget *table = NULL, *entry = NULL, *label = NULL, *proxy_button = NULL;
+	GtkWidget *prefs_proxy_frame = NULL;
+	PurpleProxyInfo *proxy_info;
+
+	ret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);
+	gtk_container_set_border_width(GTK_CONTAINER(ret), PIDGIN_HIG_BORDER);
+	vbox = pidgin_make_frame(ret, _("Proxy Server"));
+	prefs_proxy_frame = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+
+	if(purple_running_gnome()) {
+		gchar *path = NULL;
+
+		hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+		label = gtk_label_new(_("Proxy preferences are configured in GNOME preferences"));
+		gtk_container_add(GTK_CONTAINER(vbox), hbox);
+		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
+
+		hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+		gtk_container_add(GTK_CONTAINER(vbox), hbox);
+
+		path = g_find_program_in_path("gnome-network-properties");
+		if (path == NULL)
+			path = g_find_program_in_path("gnome-network-preferences");
+		if (path == NULL) {
+			path = g_find_program_in_path("gnome-control-center");
+			if (path != NULL) {
+				char *tmp = g_strdup_printf("%s network", path);
+				g_free(path);
+				path = tmp;
+			}
+		}
+
+		if (path == NULL) {
+			label = gtk_label_new(NULL);
+			gtk_label_set_markup(GTK_LABEL(label),
+								 _("<b>Proxy configuration program was not found.</b>"));
+			gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
+		} else {
+			proxy_button = gtk_button_new_with_mnemonic(_("Configure _Proxy"));
+			g_signal_connect(G_OBJECT(proxy_button), "clicked",
+							 G_CALLBACK(proxy_button_clicked_cb),
+							 path);
+			gtk_box_pack_start(GTK_BOX(hbox), proxy_button, FALSE, FALSE, 0);
+		}
+
+		/* NOTE: path leaks, but only when the prefs window is destroyed,
+		         which is never */
+		gtk_widget_show_all(ret);
+	} else {
+		GtkWidget *prefs_proxy_subframe = gtk_vbox_new(FALSE, 0);
+
+		/* This is a global option that affects SOCKS4 usage even with
+		 * account-specific proxy settings */
+		pidgin_prefs_checkbox(_("Use remote _DNS with SOCKS4 proxies"),
+							  "/purple/proxy/socks4_remotedns", prefs_proxy_frame);
+		gtk_box_pack_start(GTK_BOX(vbox), prefs_proxy_frame, 0, 0, 0);
+
+		pidgin_prefs_dropdown(prefs_proxy_frame, _("Proxy t_ype:"), PURPLE_PREF_STRING,
+					"/purple/proxy/type",
+					_("No proxy"), "none",
+					_("SOCKS 4"), "socks4",
+					_("SOCKS 5"), "socks5",
+					_("Tor/Privacy (SOCKS5)"), "tor",
+					_("HTTP"), "http",
+					_("Use Environmental Settings"), "envvar",
+					NULL);
+		gtk_box_pack_start(GTK_BOX(prefs_proxy_frame), prefs_proxy_subframe, 0, 0, 0);
+		proxy_info = purple_global_proxy_get_info();
+
+		gtk_widget_show_all(ret);
+
+		purple_prefs_connect_callback(prefs, "/purple/proxy/type",
+					    proxy_changed_cb, prefs_proxy_subframe);
+
+		table = gtk_table_new(4, 2, FALSE);
+		gtk_container_set_border_width(GTK_CONTAINER(table), 0);
+		gtk_table_set_col_spacings(GTK_TABLE(table), 5);
+		gtk_table_set_row_spacings(GTK_TABLE(table), 10);
+		gtk_container_add(GTK_CONTAINER(prefs_proxy_subframe), table);
+
+		label = gtk_label_new_with_mnemonic(_("_Host:"));
+		gtk_misc_set_alignment(GTK_MISC(label), 1.0, 0.5);
+		gtk_table_attach(GTK_TABLE(table), label, 0, 1, 0, 1, GTK_FILL, 0, 0, 0);
+
+		entry = gtk_entry_new();
+		gtk_label_set_mnemonic_widget(GTK_LABEL(label), entry);
+		gtk_table_attach(GTK_TABLE(table), entry, 1, 2, 0, 1, GTK_FILL, 0, 0, 0);
+		g_signal_connect(G_OBJECT(entry), "changed",
+				 G_CALLBACK(proxy_print_option), (void *)PROXYHOST);
+
+		if (proxy_info != NULL && purple_proxy_info_get_host(proxy_info))
+			gtk_entry_set_text(GTK_ENTRY(entry),
+					   purple_proxy_info_get_host(proxy_info));
+
+		hbox = gtk_hbox_new(TRUE, 5);
+		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+		pidgin_set_accessible_label (entry, label);
+
+		label = gtk_label_new_with_mnemonic(_("P_ort:"));
+		gtk_misc_set_alignment(GTK_MISC(label), 1.0, 0.5);
+		gtk_table_attach(GTK_TABLE(table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
+
+		entry = gtk_spin_button_new_with_range(0, 65535, 1);
+		gtk_label_set_mnemonic_widget(GTK_LABEL(label), entry);
+		gtk_table_attach(GTK_TABLE(table), entry, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
+		g_signal_connect(G_OBJECT(entry), "changed",
+				 G_CALLBACK(proxy_print_option), (void *)PROXYPORT);
+
+		if (proxy_info != NULL && purple_proxy_info_get_port(proxy_info) != 0) {
+			gtk_spin_button_set_value(GTK_SPIN_BUTTON(entry),
+				purple_proxy_info_get_port(proxy_info));
+		}
+		pidgin_set_accessible_label (entry, label);
+
+		label = gtk_label_new_with_mnemonic(_("User_name:"));
+		gtk_misc_set_alignment(GTK_MISC(label), 1.0, 0.5);
+		gtk_table_attach(GTK_TABLE(table), label, 0, 1, 1, 2, GTK_FILL, 0, 0, 0);
+
+		entry = gtk_entry_new();
+		gtk_label_set_mnemonic_widget(GTK_LABEL(label), entry);
+		gtk_table_attach(GTK_TABLE(table), entry, 1, 2, 1, 2, GTK_FILL, 0, 0, 0);
+		g_signal_connect(G_OBJECT(entry), "changed",
+				 G_CALLBACK(proxy_print_option), (void *)PROXYUSER);
+
+		if (proxy_info != NULL && purple_proxy_info_get_username(proxy_info) != NULL)
+			gtk_entry_set_text(GTK_ENTRY(entry),
+						   purple_proxy_info_get_username(proxy_info));
+
+		hbox = gtk_hbox_new(TRUE, 5);
+		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+		pidgin_set_accessible_label (entry, label);
+
+		label = gtk_label_new_with_mnemonic(_("Pa_ssword:"));
+		gtk_misc_set_alignment(GTK_MISC(label), 1.0, 0.5);
+		gtk_table_attach(GTK_TABLE(table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+
+		entry = gtk_entry_new();
+		gtk_label_set_mnemonic_widget(GTK_LABEL(label), entry);
+		gtk_table_attach(GTK_TABLE(table), entry, 3, 4, 1, 2, GTK_FILL , 0, 0, 0);
+		gtk_entry_set_visibility(GTK_ENTRY(entry), FALSE);
+#if !GTK_CHECK_VERSION(2,16,0)
+		if (gtk_entry_get_invisible_char(GTK_ENTRY(entry)) == '*')
+			gtk_entry_set_invisible_char(GTK_ENTRY(entry), PIDGIN_INVISIBLE_CHAR);
+#endif /* Less than GTK+ 2.16 */
+		g_signal_connect(G_OBJECT(entry), "changed",
+				 G_CALLBACK(proxy_print_option), (void *)PROXYPASS);
+
+		if (proxy_info != NULL && purple_proxy_info_get_password(proxy_info) != NULL)
+			gtk_entry_set_text(GTK_ENTRY(entry),
+					   purple_proxy_info_get_password(proxy_info));
+		pidgin_set_accessible_label (entry, label);
+
+		proxy_changed_cb("/purple/proxy/type", PURPLE_PREF_STRING,
+			purple_prefs_get_string("/purple/proxy/type"),
+			prefs_proxy_subframe);
+
+	}
+
+	return ret;
+}
+
+static GtkWidget *
+logging_page(void)
+{
+	GtkWidget *ret;
+	GtkWidget *vbox;
+	GList *names;
+
+	ret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);
+	gtk_container_set_border_width (GTK_CONTAINER (ret), PIDGIN_HIG_BORDER);
+
+
+	vbox = pidgin_make_frame (ret, _("Logging"));
+	names = purple_log_logger_get_options();
+
+	pidgin_prefs_dropdown_from_list(vbox, _("Log _format:"), PURPLE_PREF_STRING,
+				 "/purple/logging/format", names);
+
+	g_list_free(names);
+
+	pidgin_prefs_checkbox(_("Log all _instant messages"),
+				  "/purple/logging/log_ims", vbox);
+	pidgin_prefs_checkbox(_("Log all c_hats"),
+				  "/purple/logging/log_chats", vbox);
+	pidgin_prefs_checkbox(_("Log all _status changes to system log"),
+				  "/purple/logging/log_system", vbox);
+
+	gtk_widget_show_all(ret);
+
+	return ret;
+}
+
+#ifndef _WIN32
+static gint
+sound_cmd_yeah(GtkEntry *entry, gpointer d)
+{
+	purple_prefs_set_path(PIDGIN_PREFS_ROOT "/sound/command",
+			gtk_entry_get_text(GTK_ENTRY(entry)));
+	return TRUE;
+}
+
+static void
+sound_changed1_cb(const char *name, PurplePrefType type,
+				  gconstpointer value, gpointer data)
+{
+	GtkWidget *hbox = data;
+	const char *method = value;
+
+	gtk_widget_set_sensitive(hbox, !strcmp(method, "custom"));
+}
+
+static void
+sound_changed2_cb(const char *name, PurplePrefType type,
+				  gconstpointer value, gpointer data)
+{
+	GtkWidget *vbox = data;
+	const char *method = value;
+
+	gtk_widget_set_sensitive(vbox, strcmp(method, "none"));
+}
+#endif /* !_WIN32 */
+
+#ifdef USE_GSTREAMER
+static void
+sound_changed3_cb(const char *name, PurplePrefType type,
+				  gconstpointer value, gpointer data)
+{
+	GtkWidget *hbox = data;
+	const char *method = value;
+
+	gtk_widget_set_sensitive(hbox,
+			!strcmp(method, "automatic") ||
+			!strcmp(method, "alsa") ||
+			!strcmp(method, "esd"));
+}
+#endif /* USE_GSTREAMER */
+
+
+static void
+event_toggled(GtkCellRendererToggle *cell, gchar *pth, gpointer data)
+{
+	GtkTreeModel *model = (GtkTreeModel *)data;
+	GtkTreeIter iter;
+	GtkTreePath *path = gtk_tree_path_new_from_string(pth);
+	char *pref;
+
+	gtk_tree_model_get_iter (model, &iter, path);
+	gtk_tree_model_get (model, &iter,
+						2, &pref,
+						-1);
+
+	purple_prefs_set_bool(pref, !gtk_cell_renderer_toggle_get_active(cell));
+	g_free(pref);
+
+	gtk_list_store_set(GTK_LIST_STORE (model), &iter,
+					   0, !gtk_cell_renderer_toggle_get_active(cell),
+					   -1);
+
+	gtk_tree_path_free(path);
+}
+
+static void
+test_sound(GtkWidget *button, gpointer i_am_NULL)
+{
+	char *pref;
+	gboolean temp_enabled;
+	gboolean temp_mute;
+
+	pref = g_strdup_printf(PIDGIN_PREFS_ROOT "/sound/enabled/%s",
+			pidgin_sound_get_event_option(sound_row_sel));
+
+	temp_enabled = purple_prefs_get_bool(pref);
+	temp_mute = purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/sound/mute");
+
+	if (!temp_enabled) purple_prefs_set_bool(pref, TRUE);
+	if (temp_mute) purple_prefs_set_bool(PIDGIN_PREFS_ROOT "/sound/mute", FALSE);
+
+	purple_sound_play_event(sound_row_sel, NULL);
+
+	if (!temp_enabled) purple_prefs_set_bool(pref, FALSE);
+	if (temp_mute) purple_prefs_set_bool(PIDGIN_PREFS_ROOT "/sound/mute", TRUE);
+
+	g_free(pref);
+}
+
+/*
+ * Resets a sound file back to default.
+ */
+static void
+reset_sound(GtkWidget *button, gpointer i_am_also_NULL)
+{
+	gchar *pref;
+
+	pref = g_strdup_printf(PIDGIN_PREFS_ROOT "/sound/file/%s",
+						   pidgin_sound_get_event_option(sound_row_sel));
+	purple_prefs_set_path(pref, "");
+	g_free(pref);
+
+	gtk_entry_set_text(GTK_ENTRY(sound_entry), _("(default)"));
+
+	pref_sound_generate_markup();
+}
+
+static void
+sound_chosen_cb(void *user_data, const char *filename)
+{
+	gchar *pref;
+	int sound;
+
+	sound = GPOINTER_TO_INT(user_data);
+
+	/* Set it -- and forget it */
+	pref = g_strdup_printf(PIDGIN_PREFS_ROOT "/sound/file/%s",
+						   pidgin_sound_get_event_option(sound));
+	purple_prefs_set_path(pref, filename);
+	g_free(pref);
+
+	/*
+	 * If the sound we just changed is still the currently selected
+	 * sound, then update the box showing the file name.
+	 */
+	if (sound == sound_row_sel)
+		gtk_entry_set_text(GTK_ENTRY(sound_entry), filename);
+
+	pref_sound_generate_markup();
+}
+
+static void
+select_sound(GtkWidget *button, gpointer being_NULL_is_fun)
+{
+	gchar *pref;
+	const char *filename;
+
+	pref = g_strdup_printf(PIDGIN_PREFS_ROOT "/sound/file/%s",
+						   pidgin_sound_get_event_option(sound_row_sel));
+	filename = purple_prefs_get_path(pref);
+	g_free(pref);
+
+	if (*filename == '\0')
+		filename = NULL;
+
+	purple_request_file(prefs, _("Sound Selection"), filename, FALSE,
+					  G_CALLBACK(sound_chosen_cb), NULL,
+					  NULL, NULL, NULL,
+					  GINT_TO_POINTER(sound_row_sel));
+}
+
+#ifdef USE_GSTREAMER
+static gchar *
+prefs_sound_volume_format(GtkScale *scale, gdouble val)
+{
+	if(val < 15) {
+		return g_strdup_printf(_("Quietest"));
+	} else if(val < 30) {
+		return g_strdup_printf(_("Quieter"));
+	} else if(val < 45) {
+		return g_strdup_printf(_("Quiet"));
+	} else if(val < 55) {
+		return g_strdup_printf(_("Normal"));
+	} else if(val < 70) {
+		return g_strdup_printf(_("Loud"));
+	} else if(val < 85) {
+		return g_strdup_printf(_("Louder"));
+	} else {
+		return g_strdup_printf(_("Loudest"));
+	}
+}
+
+static void
+prefs_sound_volume_changed(GtkRange *range)
+{
+	int val = (int)gtk_range_get_value(GTK_RANGE(range));
+	purple_prefs_set_int(PIDGIN_PREFS_ROOT "/sound/volume", val);
+}
+#endif
+
+static void
+prefs_sound_sel(GtkTreeSelection *sel, GtkTreeModel *model)
+{
+	GtkTreeIter  iter;
+	GValue val;
+	const char *file;
+	char *pref;
+
+	if (! gtk_tree_selection_get_selected (sel, &model, &iter))
+		return;
+
+	val.g_type = 0;
+	gtk_tree_model_get_value (model, &iter, 3, &val);
+	sound_row_sel = g_value_get_uint(&val);
+
+	pref = g_strdup_printf(PIDGIN_PREFS_ROOT "/sound/file/%s",
+			pidgin_sound_get_event_option(sound_row_sel));
+	file = purple_prefs_get_path(pref);
+	g_free(pref);
+	if (sound_entry)
+		gtk_entry_set_text(GTK_ENTRY(sound_entry), (file && *file != '\0') ? file : _("(default)"));
+	g_value_unset (&val);
+
+	pref_sound_generate_markup();
+}
+
+
+static void
+mute_changed_cb(const char *pref_name,
+                PurplePrefType pref_type,
+                gconstpointer val,
+                gpointer data)
+{
+	GtkToggleButton *button = data;
+	gboolean muted = GPOINTER_TO_INT(val);
+
+	g_return_if_fail(!strcmp (pref_name, PIDGIN_PREFS_ROOT "/sound/mute"));
+
+	/* Block the handler that re-sets the preference. */
+	g_signal_handlers_block_matched(button, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, (gpointer)pref_name);
+	gtk_toggle_button_set_active (button, muted);
+	g_signal_handlers_unblock_matched(button, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, (gpointer)pref_name);
+}
+
+
+static GtkWidget *
+sound_page(void)
+{
+	GtkWidget *ret;
+	GtkWidget *vbox, *vbox2, *sw, *button;
+	GtkSizeGroup *sg;
+	GtkTreeIter iter;
+	GtkWidget *event_view;
+	GtkListStore *event_store;
+	GtkCellRenderer *rend;
+	GtkTreeViewColumn *col;
+	GtkTreeSelection *sel;
+	GtkTreePath *path;
+	GtkWidget *hbox;
+	int j;
+	const char *file;
+	char *pref;
+#ifndef _WIN32
+	GtkWidget *dd;
+	GtkWidget *entry;
+	const char *cmd;
+#endif
+
+	ret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);
+	gtk_container_set_border_width (GTK_CONTAINER (ret), PIDGIN_HIG_BORDER);
+
+	sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+
+	vbox2 = pidgin_make_frame(ret, _("Sound Options"));
+
+	vbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_box_pack_start(GTK_BOX(vbox2), vbox, FALSE, FALSE, 0);
+
+#ifndef _WIN32
+	dd = pidgin_prefs_dropdown(vbox2, _("_Method:"), PURPLE_PREF_STRING,
+			PIDGIN_PREFS_ROOT "/sound/method",
+			_("Console beep"), "beep",
+#ifdef USE_GSTREAMER
+			_("Automatic"), "automatic",
+			"ESD", "esd",
+			"ALSA", "alsa",
+#endif
+			_("Command"), "custom",
+			_("No sounds"), "none",
+			NULL);
+	gtk_size_group_add_widget(sg, dd);
+	gtk_misc_set_alignment(GTK_MISC(dd), 0, 0.5);
+
+	entry = gtk_entry_new();
+	gtk_editable_set_editable(GTK_EDITABLE(entry), TRUE);
+	cmd = purple_prefs_get_path(PIDGIN_PREFS_ROOT "/sound/command");
+	if(cmd)
+		gtk_entry_set_text(GTK_ENTRY(entry), cmd);
+	g_signal_connect(G_OBJECT(entry), "changed",
+					 G_CALLBACK(sound_cmd_yeah), NULL);
+
+	hbox = pidgin_add_widget_to_vbox(GTK_BOX(vbox), _("Sound c_ommand:\n(%s for filename)"), sg, entry, TRUE, NULL);
+	purple_prefs_connect_callback(prefs, PIDGIN_PREFS_ROOT "/sound/method",
+								sound_changed1_cb, hbox);
+	gtk_widget_set_sensitive(hbox,
+			!strcmp(purple_prefs_get_string(PIDGIN_PREFS_ROOT "/sound/method"),
+					"custom"));
+#endif /* _WIN32 */
+
+	button = pidgin_prefs_checkbox(_("M_ute sounds"), PIDGIN_PREFS_ROOT "/sound/mute", vbox);
+	purple_prefs_connect_callback(prefs, PIDGIN_PREFS_ROOT "/sound/mute", mute_changed_cb, button);
+
+	pidgin_prefs_checkbox(_("Sounds when conversation has _focus"),
+				   PIDGIN_PREFS_ROOT "/sound/conv_focus", vbox);
+	pidgin_prefs_dropdown(vbox, _("_Enable sounds:"),
+				 PURPLE_PREF_INT, "/purple/sound/while_status",
+				_("Only when available"), 1,
+				_("Only when not available"), 2,
+				_("Always"), 3,
+				NULL);
+
+#ifdef USE_GSTREAMER
+	sw = gtk_hscale_new_with_range(0.0, 100.0, 5.0);
+	gtk_range_set_increments(GTK_RANGE(sw), 5.0, 25.0);
+	gtk_range_set_value(GTK_RANGE(sw), purple_prefs_get_int(PIDGIN_PREFS_ROOT "/sound/volume"));
+	g_signal_connect (G_OBJECT (sw), "format-value",
+			  G_CALLBACK (prefs_sound_volume_format),
+			  NULL);
+	g_signal_connect (G_OBJECT (sw), "value-changed",
+			  G_CALLBACK (prefs_sound_volume_changed),
+			  NULL);
+	hbox = pidgin_add_widget_to_vbox(GTK_BOX(vbox), _("V_olume:"), NULL, sw, TRUE, NULL);
+
+	purple_prefs_connect_callback(prefs, PIDGIN_PREFS_ROOT "/sound/method",
+								sound_changed3_cb, hbox);
+	sound_changed3_cb(PIDGIN_PREFS_ROOT "/sound/method", PURPLE_PREF_STRING,
+			  purple_prefs_get_string(PIDGIN_PREFS_ROOT "/sound/method"), hbox);
+#endif
+
+#ifndef _WIN32
+	gtk_widget_set_sensitive(vbox,
+			strcmp(purple_prefs_get_string(PIDGIN_PREFS_ROOT "/sound/method"), "none"));
+	purple_prefs_connect_callback(prefs, PIDGIN_PREFS_ROOT "/sound/method",
+								sound_changed2_cb, vbox);
+#endif
+	vbox = pidgin_make_frame(ret, _("Sound Events"));
+
+	/* The following is an ugly hack to make the frame expand so the
+	 * sound events list is big enough to be usable */
+	gtk_box_set_child_packing(GTK_BOX(vbox->parent), vbox, TRUE, TRUE, 0,
+			GTK_PACK_START);
+	gtk_box_set_child_packing(GTK_BOX(vbox->parent->parent), vbox->parent, TRUE,
+			TRUE, 0, GTK_PACK_START);
+	gtk_box_set_child_packing(GTK_BOX(vbox->parent->parent->parent),
+			vbox->parent->parent, TRUE, TRUE, 0, GTK_PACK_START);
+
+	/* SOUND SELECTION */
+	event_store = gtk_list_store_new (4, G_TYPE_BOOLEAN, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_UINT);
+
+	for (j=0; j < PURPLE_NUM_SOUNDS; j++) {
+		char *pref = g_strdup_printf(PIDGIN_PREFS_ROOT "/sound/enabled/%s",
+					     pidgin_sound_get_event_option(j));
+		const char *label = pidgin_sound_get_event_label(j);
+
+		if (label == NULL) {
+			g_free(pref);
+			continue;
+		}
+
+		gtk_list_store_append (event_store, &iter);
+		gtk_list_store_set(event_store, &iter,
+				   0, purple_prefs_get_bool(pref),
+				   1, _(label),
+				   2, pref,
+				   3, j,
+				   -1);
+		g_free(pref);
+	}
+
+	event_view = gtk_tree_view_new_with_model (GTK_TREE_MODEL(event_store));
+
+	rend = gtk_cell_renderer_toggle_new();
+	sel = gtk_tree_view_get_selection (GTK_TREE_VIEW (event_view));
+	g_signal_connect (G_OBJECT (sel), "changed",
+			  G_CALLBACK (prefs_sound_sel),
+			  NULL);
+	g_signal_connect (G_OBJECT(rend), "toggled",
+			  G_CALLBACK(event_toggled), event_store);
+	path = gtk_tree_path_new_first();
+	gtk_tree_selection_select_path(sel, path);
+	gtk_tree_path_free(path);
+
+	col = gtk_tree_view_column_new_with_attributes (_("Play"),
+							rend,
+							"active", 0,
+							NULL);
+	gtk_tree_view_append_column (GTK_TREE_VIEW(event_view), col);
+
+	rend = gtk_cell_renderer_text_new();
+	col = gtk_tree_view_column_new_with_attributes (_("Event"),
+							rend,
+							"text", 1,
+							NULL);
+	gtk_tree_view_append_column (GTK_TREE_VIEW(event_view), col);
+	g_object_unref(G_OBJECT(event_store));
+	gtk_box_pack_start(GTK_BOX(vbox),
+		pidgin_make_scrollable(event_view, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC, GTK_SHADOW_IN, -1, 100),
+		TRUE, TRUE, 0);
+
+	hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+	sound_entry = gtk_entry_new();
+	pref = g_strdup_printf(PIDGIN_PREFS_ROOT "/sound/file/%s",
+			       pidgin_sound_get_event_option(0));
+	file = purple_prefs_get_path(pref);
+	g_free(pref);
+	gtk_entry_set_text(GTK_ENTRY(sound_entry), (file && *file != '\0') ? file : _("(default)"));
+	gtk_editable_set_editable(GTK_EDITABLE(sound_entry), FALSE);
+	gtk_box_pack_start(GTK_BOX(hbox), sound_entry, FALSE, FALSE, PIDGIN_HIG_BOX_SPACE);
+
+	button = gtk_button_new_with_mnemonic(_("_Browse..."));
+	g_signal_connect(G_OBJECT(button), "clicked", G_CALLBACK(select_sound), NULL);
+	gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 1);
+
+	button = gtk_button_new_with_mnemonic(_("Pre_view"));
+	g_signal_connect(G_OBJECT(button), "clicked", G_CALLBACK(test_sound), NULL);
+	gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 1);
+
+	button = gtk_button_new_with_mnemonic(_("_Reset"));
+	g_signal_connect(G_OBJECT(button), "clicked", G_CALLBACK(reset_sound), NULL);
+	gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 1);
+
+	gtk_widget_show_all(ret);
+	g_object_unref(sg);
+
+	return ret;
+}
+
+
+static void
+set_idle_away(PurpleSavedStatus *status)
+{
+	purple_prefs_set_int("/purple/savedstatus/idleaway", purple_savedstatus_get_creation_time(status));
+}
+
+static void
+set_startupstatus(PurpleSavedStatus *status)
+{
+	purple_prefs_set_int("/purple/savedstatus/startup", purple_savedstatus_get_creation_time(status));
+}
+
+static GtkWidget *
+away_page(void)
+{
+	GtkWidget *ret;
+	GtkWidget *vbox;
+	GtkWidget *hbox;
+	GtkWidget *dd;
+	GtkWidget *label;
+	GtkWidget *button;
+	GtkWidget *menu;
+	GtkSizeGroup *sg;
+
+	ret = gtk_vbox_new(FALSE, PIDGIN_HIG_CAT_SPACE);
+	gtk_container_set_border_width (GTK_CONTAINER (ret), PIDGIN_HIG_BORDER);
+
+	sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+
+	/* Idle stuff */
+	vbox = pidgin_make_frame(ret, _("Idle"));
+
+	dd = pidgin_prefs_dropdown(vbox, _("_Report idle time:"),
+		PURPLE_PREF_STRING, "/purple/away/idle_reporting",
+		_("Never"), "none",
+		_("From last sent message"), "purple",
+#if defined(USE_SCREENSAVER) || defined(HAVE_IOKIT)
+		_("Based on keyboard or mouse use"), "system",
+#endif
+		NULL);
+	gtk_size_group_add_widget(sg, dd);
+	gtk_misc_set_alignment(GTK_MISC(dd), 0, 0.5);
+
+	pidgin_prefs_labeled_spin_button(vbox,
+			_("_Minutes before becoming idle:"), "/purple/away/mins_before_away",
+			1, 24 * 60, sg);
+
+	hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+
+	button = pidgin_prefs_checkbox(_("Change to this status when _idle:"),
+						   "/purple/away/away_when_idle", hbox);
+	gtk_size_group_add_widget(sg, button);
+
+	/* TODO: Show something useful if we don't have any saved statuses. */
+	menu = pidgin_status_menu(purple_savedstatus_get_idleaway(), G_CALLBACK(set_idle_away));
+	gtk_size_group_add_widget(sg, menu);
+	gtk_box_pack_start(GTK_BOX(hbox), menu, FALSE, FALSE, 0);
+
+	g_signal_connect(G_OBJECT(button), "clicked",
+			 G_CALLBACK(pidgin_toggle_sensitive), menu);
+
+	if(!purple_prefs_get_bool("/purple/away/away_when_idle"))
+		gtk_widget_set_sensitive(GTK_WIDGET(menu), FALSE);
+
+	/* Away stuff */
+	vbox = pidgin_make_frame(ret, _("Away"));
+
+	dd = pidgin_prefs_dropdown(vbox, _("_Auto-reply:"),
+		PURPLE_PREF_STRING, "/purple/away/auto_reply",
+		_("Never"), "never",
+		_("When away"), "away",
+		_("When both away and idle"), "awayidle",
+		NULL);
+	gtk_size_group_add_widget(sg, dd);
+	gtk_misc_set_alignment(GTK_MISC(dd), 0, 0.5);
+
+	/* Signon status stuff */
+	vbox = pidgin_make_frame(ret, _("Status at Startup"));
+
+	button = pidgin_prefs_checkbox(_("Use status from last _exit at startup"),
+		"/purple/savedstatus/startup_current_status", vbox);
+	gtk_size_group_add_widget(sg, button);
+
+	/* TODO: Show something useful if we don't have any saved statuses. */
+	menu = pidgin_status_menu(purple_savedstatus_get_startup(), G_CALLBACK(set_startupstatus));
+	gtk_size_group_add_widget(sg, menu);
+	g_signal_connect(G_OBJECT(button), "clicked",
+			 G_CALLBACK(pidgin_toggle_sensitive), menu);
+	pidgin_add_widget_to_vbox(GTK_BOX(vbox), _("Status to a_pply at startup:"), sg, menu, TRUE, &label);
+	g_signal_connect(G_OBJECT(button), "clicked",
+					 G_CALLBACK(pidgin_toggle_sensitive), label);
+
+	if(purple_prefs_get_bool("/purple/savedstatus/startup_current_status")) {
+		gtk_widget_set_sensitive(GTK_WIDGET(menu), FALSE);
+		gtk_widget_set_sensitive(GTK_WIDGET(label), FALSE);
+	}
+
+	gtk_widget_show_all(ret);
+	g_object_unref(sg);
+
+	return ret;
+}
+
+static int
+prefs_notebook_add_page(const char *text, GtkWidget *page, int ind)
+{
+	return gtk_notebook_append_page(GTK_NOTEBOOK(prefsnotebook), page, gtk_label_new(text));
+}
+
+static void
+prefs_notebook_init(void)
+{
+	prefs_notebook_add_page(_("Interface"), interface_page(), notebook_page++);
+
+#ifndef _WIN32
+	/* We use the registered default browser in windows */
+	/* if the user is running Mac OS X, hide the browsers tab */
+	if(purple_running_osx() == FALSE)
+		prefs_notebook_add_page(_("Browser"), browser_page(), notebook_page++);
+#endif
+
+	prefs_notebook_add_page(_("Conversations"), conv_page(), notebook_page++);
+	prefs_notebook_add_page(_("Logging"), logging_page(), notebook_page++);
+	prefs_notebook_add_page(_("Network"), network_page(), notebook_page++);
+	prefs_notebook_add_page(_("Proxy"), proxy_page(), notebook_page++);
+
+	prefs_notebook_add_page(_("Sounds"), sound_page(), notebook_page++);
+	prefs_notebook_add_page(_("Status / Idle"), away_page(), notebook_page++);
+	prefs_notebook_add_page(_("Themes"), theme_page(), notebook_page++);
+}
+
+void
+pidgin_prefs_show(void)
+{
+	GtkWidget *vbox;
+	GtkWidget *notebook;
+	GtkWidget *button;
+
+	if (prefs) {
+		gtk_window_present(GTK_WINDOW(prefs));
+		return;
+	}
+
+	/* copy the preferences to tmp values...
+	 * I liked "take affect immediately" Oh well :-( */
+	/* (that should have been "effect," right?) */
+
+	/* Back to instant-apply! I win!  BU-HAHAHA! */
+
+	/* Create the window */
+	prefs = pidgin_create_dialog(_("Preferences"), PIDGIN_HIG_BORDER, "preferences", FALSE);
+	g_signal_connect(G_OBJECT(prefs), "destroy",
+					 G_CALLBACK(delete_prefs), NULL);
+
+	vbox = pidgin_dialog_get_vbox_with_properties(GTK_DIALOG(prefs), FALSE, PIDGIN_HIG_BORDER);
+
+	/* The notebook */
+	prefsnotebook = notebook = gtk_notebook_new ();
+	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(notebook), GTK_POS_LEFT);
+	gtk_box_pack_start(GTK_BOX (vbox), notebook, FALSE, FALSE, 0);
+	gtk_widget_show(prefsnotebook);
+
+	button = pidgin_dialog_add_button(GTK_DIALOG(prefs), GTK_STOCK_CLOSE, NULL, NULL);
+	g_signal_connect_swapped(G_OBJECT(button), "clicked",
+							 G_CALLBACK(gtk_widget_destroy), prefs);
+
+	prefs_notebook_init();
+
+	/* Refresh the list of themes before showing the preferences window */
+	prefs_themes_refresh();
+
+	/* Show everything. */
+	gtk_widget_show(prefs);
+}
+
+static void
+set_bool_pref(GtkWidget *w, const char *key)
+{
+	purple_prefs_set_bool(key,
+		gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w)));
+}
+
+GtkWidget *
+pidgin_prefs_checkbox(const char *text, const char *key, GtkWidget *page)
+{
+	GtkWidget *button;
+
+	button = gtk_check_button_new_with_mnemonic(text);
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button),
+								 purple_prefs_get_bool(key));
+
+	gtk_box_pack_start(GTK_BOX(page), button, FALSE, FALSE, 0);
+
+	g_signal_connect(G_OBJECT(button), "clicked",
+					 G_CALLBACK(set_bool_pref), (char *)key);
+
+	gtk_widget_show(button);
+
+	return button;
+}
+
+static void
+smiley_theme_pref_cb(const char *name, PurplePrefType type,
+					 gconstpointer value, gpointer data)
+{
+	const char *themename = value;
+	GSList *themes;
+
+	for (themes = smiley_themes; themes; themes = themes->next) {
+		struct smiley_theme *smile = themes->data;
+		if (smile->name && strcmp(themename, smile->name) == 0) {
+			pidgin_themes_load_smiley_theme(smile->path, TRUE);
+			break;
+		}
+	}
+}
+
+void
+pidgin_prefs_init(void)
+{
+	purple_prefs_add_none(PIDGIN_PREFS_ROOT "");
+	purple_prefs_add_none("/plugins/gtk");
+
+#ifndef _WIN32
+	/* Browsers */
+	purple_prefs_add_none(PIDGIN_PREFS_ROOT "/browsers");
+	purple_prefs_add_int(PIDGIN_PREFS_ROOT "/browsers/place", PIDGIN_BROWSER_DEFAULT);
+	purple_prefs_add_string(PIDGIN_PREFS_ROOT "/browsers/manual_command", "");
+	purple_prefs_add_string(PIDGIN_PREFS_ROOT "/browsers/browser", "xdg-open");
+#endif
+
+	/* Plugins */
+	purple_prefs_add_none(PIDGIN_PREFS_ROOT "/plugins");
+	purple_prefs_add_path_list(PIDGIN_PREFS_ROOT "/plugins/loaded", NULL);
+
+	/* File locations */
+	purple_prefs_add_none(PIDGIN_PREFS_ROOT "/filelocations");
+	purple_prefs_add_path(PIDGIN_PREFS_ROOT "/filelocations/last_save_folder", "");
+	purple_prefs_add_path(PIDGIN_PREFS_ROOT "/filelocations/last_open_folder", "");
+	purple_prefs_add_path(PIDGIN_PREFS_ROOT "/filelocations/last_icon_folder", "");
+
+	/* Themes */
+	prefs_themes_init();
+
+	/* Smiley Themes */
+	purple_prefs_add_none(PIDGIN_PREFS_ROOT "/smileys");
+	purple_prefs_add_string(PIDGIN_PREFS_ROOT "/smileys/theme", "Default");
+
+	/* Smiley Callbacks */
+	purple_prefs_connect_callback(&prefs, PIDGIN_PREFS_ROOT "/smileys/theme",
+								smiley_theme_pref_cb, NULL);
+
+	pidgin_prefs_update_old();
+}
+
+void
+pidgin_prefs_update_old(void)
+{
+	const char *str = NULL;
+
+	purple_prefs_rename("/gaim/gtk", PIDGIN_PREFS_ROOT);
+
+	/* Rename some old prefs */
+	purple_prefs_rename(PIDGIN_PREFS_ROOT "/logging/log_ims", "/purple/logging/log_ims");
+	purple_prefs_rename(PIDGIN_PREFS_ROOT "/logging/log_chats", "/purple/logging/log_chats");
+	purple_prefs_rename("/purple/conversations/placement",
+					  PIDGIN_PREFS_ROOT "/conversations/placement");
+
+	purple_prefs_rename(PIDGIN_PREFS_ROOT "/debug/timestamps", "/purple/debug/timestamps");
+	purple_prefs_rename(PIDGIN_PREFS_ROOT "/conversations/im/raise_on_events", "/plugins/gtk/X11/notify/method_raise");
+
+	purple_prefs_rename_boolean_toggle(PIDGIN_PREFS_ROOT "/conversations/ignore_colors",
+									 PIDGIN_PREFS_ROOT "/conversations/show_incoming_formatting");
+
+	/*
+	 * this path pref changed to a string, so migrate.  I know this will break
+	 * things for and confuse users that use multiple versions with the same
+	 * config directory, but I'm not inclined to want to deal with that at the
+	 * moment. -- rekkanoryo
+	 */
+	if((str = purple_prefs_get_path(PIDGIN_PREFS_ROOT "/browsers/command")) != NULL) {
+		purple_prefs_set_string(PIDGIN_PREFS_ROOT "/browsers/manual_command", str);
+		purple_prefs_remove(PIDGIN_PREFS_ROOT "/browsers/command");
+	}
+
+	/* this string pref moved into the core, try to be friendly */
+	purple_prefs_rename(PIDGIN_PREFS_ROOT "/idle/reporting_method", "/purple/away/idle_reporting");
+	if ((str = purple_prefs_get_string("/purple/away/idle_reporting")) &&
+			strcmp(str, "gaim") == 0)
+		purple_prefs_set_string("/purple/away/idle_reporting", "purple");
+
+	/* Remove some no-longer-used prefs */
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/blist/auto_expand_contacts");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/blist/button_style");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/blist/grey_idle_buddies");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/blist/raise_on_events");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/blist/show_group_count");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/blist/show_warning_level");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/button_type");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/ctrl_enter_sends");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/enter_sends");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/escape_closes");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/html_shortcuts");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/icons_on_tabs");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/send_formatting");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/show_smileys");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/show_urls_as_links");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/smiley_shortcuts");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/use_custom_bgcolor");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/use_custom_fgcolor");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/use_custom_font");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/use_custom_size");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/chat/old_tab_complete");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/chat/tab_completion");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/im/hide_on_send");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/chat/color_nicks");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/chat/raise_on_events");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/ignore_fonts");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/ignore_font_sizes");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/passthrough_unknown_commands");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/idle");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/logging/individual_logs");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/sound/signon");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/sound/silent_signon");
+
+	/* Convert old queuing prefs to hide_new 3-way pref. */
+	if (purple_prefs_exists("/plugins/gtk/docklet/queue_messages") &&
+	    purple_prefs_get_bool("/plugins/gtk/docklet/queue_messages"))
+	{
+		purple_prefs_set_string(PIDGIN_PREFS_ROOT "/conversations/im/hide_new", "always");
+	}
+	else if (purple_prefs_exists(PIDGIN_PREFS_ROOT "/away/queue_messages") &&
+	         purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/away/queue_messages"))
+	{
+		purple_prefs_set_string(PIDGIN_PREFS_ROOT "/conversations/im/hide_new", "away");
+	}
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/away/queue_messages");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/away");
+	purple_prefs_remove("/plugins/gtk/docklet/queue_messages");
+
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/chat/default_width");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/chat/default_height");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/im/default_width");
+	purple_prefs_remove(PIDGIN_PREFS_ROOT "/conversations/im/default_height");
+	purple_prefs_rename(PIDGIN_PREFS_ROOT "/conversations/x",
+			PIDGIN_PREFS_ROOT "/conversations/im/x");
+	purple_prefs_rename(PIDGIN_PREFS_ROOT "/conversations/y",
+			PIDGIN_PREFS_ROOT "/conversations/im/y");
+}
diff -uNr pidgin-2.10.11.orig/pidgin/gtkutils.c pidgin-2.10.11/pidgin/gtkutils.c
--- pidgin-2.10.11.orig/pidgin/gtkutils.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkutils.c	2015-02-10 14:28:16.417353357 +0900
@@ -3705,3 +3705,61 @@
 	gtk_imhtml_class_register_protocol("gopher://", NULL, NULL);
 }
 
+gchar *
+pidgin_gtk_ellipsis_text(GtkWidget *widget, const char *text, gint min_width, gchar *ellipsis)
+{
+	PangoLayout *layout;
+	gint width, height;
+	gint ewidth;
+	glong len0, len1, len2;
+	gchar *buf, *buf_tmp;
+	gboolean with_ellipsis = FALSE;
+	const gchar default_ellipsis[] = "...";
+
+	if(!ellipsis)
+		ellipsis = default_ellipsis;
+
+	/* allocate buf */
+	buf = g_malloc0(strlen(text) * 2);
+
+	/* create layout */
+	layout = gtk_widget_create_pango_layout(widget, ellipsis);
+	pango_layout_get_pixel_size(layout, &width, &height);
+	ewidth = width; /* length of ellipsis text. */
+
+	len0 = 0;
+	len1 = g_utf8_strlen(text, -1);
+	len2 = len1;
+
+	while (1) {
+
+		if (len2 == len0)
+			break;
+
+		g_utf8_strncpy(buf, text, len2);
+		pango_layout_set_text(layout, buf, -1);
+		pango_layout_get_pixel_size(layout, &width, &height);
+
+		if(!with_ellipsis && width <= min_width)
+			break;
+		else
+			with_ellipsis = TRUE;
+
+		if (width + ewidth > min_width)
+			len1 = len2;
+		else
+			len0 = len2;
+
+		len2 = (len0 + len1) / 2;
+	}
+
+	g_object_unref(layout);
+
+	if (with_ellipsis) {
+		buf_tmp = buf;
+		buf = g_strdup_printf("%s%s", buf_tmp, ellipsis);
+		g_free(buf_tmp);
+	}
+
+	return buf;
+}
diff -uNr pidgin-2.10.11.orig/pidgin/gtkutils.c.orig pidgin-2.10.11/pidgin/gtkutils.c.orig
--- pidgin-2.10.11.orig/pidgin/gtkutils.c.orig	1970-01-01 09:00:00.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkutils.c.orig	2014-11-24 01:41:26.000000000 +0900
@@ -0,0 +1,3707 @@
+/**
+ * @file gtkutils.c GTK+ utility functions
+ * @ingroup pidgin
+ */
+
+/* pidgin
+ *
+ * Pidgin is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+#define _PIDGIN_GTKUTILS_C_
+
+#include "internal.h"
+#include "pidgin.h"
+
+#ifdef _WIN32
+# ifdef small
+#  undef small
+# endif
+#endif /*_WIN32*/
+
+#ifdef USE_GTKSPELL
+# include <gtkspell/gtkspell.h>
+# ifdef _WIN32
+#  include "wspell.h"
+# endif
+#endif
+
+#include <gdk/gdkkeysyms.h>
+
+#include "conversation.h"
+#include "debug.h"
+#include "desktopitem.h"
+#include "imgstore.h"
+#include "notify.h"
+#include "prefs.h"
+#include "prpl.h"
+#include "request.h"
+#include "signals.h"
+#include "sound.h"
+#include "util.h"
+
+#include "gtkaccount.h"
+#include "gtkprefs.h"
+
+#include "gtkconv.h"
+#include "gtkdialogs.h"
+#include "gtkimhtml.h"
+#include "gtkimhtmltoolbar.h"
+#include "pidginstock.h"
+#include "gtkthemes.h"
+#include "gtkutils.h"
+#include "pidgin/minidialog.h"
+
+typedef struct {
+	GtkWidget *menu;
+	gint default_item;
+} AopMenu;
+
+static guint accels_save_timer = 0;
+static GSList *registered_url_handlers = NULL;
+
+static gboolean
+url_clicked_idle_cb(gpointer data)
+{
+	purple_notify_uri(NULL, data);
+	g_free(data);
+	return FALSE;
+}
+
+static gboolean
+url_clicked_cb(GtkIMHtml *unused, GtkIMHtmlLink *link)
+{
+	const char *uri = gtk_imhtml_link_get_url(link);
+	g_idle_add(url_clicked_idle_cb, g_strdup(uri));
+	return TRUE;
+}
+
+static GtkIMHtmlFuncs gtkimhtml_cbs = {
+	(GtkIMHtmlGetImageFunc)purple_imgstore_find_by_id,
+	(GtkIMHtmlGetImageDataFunc)purple_imgstore_get_data,
+	(GtkIMHtmlGetImageSizeFunc)purple_imgstore_get_size,
+	(GtkIMHtmlGetImageFilenameFunc)purple_imgstore_get_filename,
+	purple_imgstore_ref_by_id,
+	purple_imgstore_unref_by_id,
+};
+
+void
+pidgin_setup_imhtml(GtkWidget *imhtml)
+{
+	g_return_if_fail(imhtml != NULL);
+	g_return_if_fail(GTK_IS_IMHTML(imhtml));
+
+	pidgin_themes_smiley_themeize(imhtml);
+
+	gtk_imhtml_set_funcs(GTK_IMHTML(imhtml), &gtkimhtml_cbs);
+
+#ifdef _WIN32
+	if (!purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/use_theme_font")) {
+		PangoFontDescription *desc;
+		const char *font = purple_prefs_get_string(PIDGIN_PREFS_ROOT "/conversations/custom_font");
+		desc = pango_font_description_from_string(font);
+		if (desc) {
+			gtk_widget_modify_font(imhtml, desc);
+			pango_font_description_free(desc);
+		}
+	}
+#endif
+
+}
+
+static
+void pidgin_window_init(GtkWindow *wnd, const char *title, guint border_width, const char *role, gboolean resizable)
+{
+	if (title)
+		gtk_window_set_title(wnd, title);
+#ifdef _WIN32
+	else
+		gtk_window_set_title(wnd, PIDGIN_ALERT_TITLE);
+#endif
+	gtk_container_set_border_width(GTK_CONTAINER(wnd), border_width);
+	if (role)
+		gtk_window_set_role(wnd, role);
+	gtk_window_set_resizable(wnd, resizable);
+}
+
+GtkWidget *
+pidgin_create_window(const char *title, guint border_width, const char *role, gboolean resizable)
+{
+	GtkWindow *wnd = NULL;
+
+	wnd = GTK_WINDOW(gtk_window_new(GTK_WINDOW_TOPLEVEL));
+	pidgin_window_init(wnd, title, border_width, role, resizable);
+
+	return GTK_WIDGET(wnd);
+}
+
+GtkWidget *
+pidgin_create_small_button(GtkWidget *image)
+{
+	GtkWidget *button;
+
+	button = gtk_button_new();
+	gtk_button_set_relief(GTK_BUTTON(button), GTK_RELIEF_NONE);
+
+	/* don't allow focus on the close button */
+	gtk_button_set_focus_on_click(GTK_BUTTON(button), FALSE);
+
+	/* set style to make it as small as possible */
+	gtk_widget_set_name(button, "pidgin-small-close-button");
+
+	gtk_widget_show(image);
+
+	gtk_container_add(GTK_CONTAINER(button), image);
+
+	return button;
+}
+
+GtkWidget *
+pidgin_create_dialog(const char *title, guint border_width, const char *role, gboolean resizable)
+{
+	GtkWindow *wnd = NULL;
+
+	wnd = GTK_WINDOW(gtk_dialog_new());
+	pidgin_window_init(wnd, title, border_width, role, resizable);
+	g_object_set(G_OBJECT(wnd), "has-separator", FALSE, NULL);
+
+	return GTK_WIDGET(wnd);
+}
+
+GtkWidget *
+pidgin_dialog_get_vbox_with_properties(GtkDialog *dialog, gboolean homogeneous, gint spacing)
+{
+	GtkBox *vbox = GTK_BOX(GTK_DIALOG(dialog)->vbox);
+	gtk_box_set_homogeneous(vbox, homogeneous);
+	gtk_box_set_spacing(vbox, spacing);
+	return GTK_WIDGET(vbox);
+}
+
+GtkWidget *pidgin_dialog_get_vbox(GtkDialog *dialog)
+{
+	return GTK_DIALOG(dialog)->vbox;
+}
+
+GtkWidget *pidgin_dialog_get_action_area(GtkDialog *dialog)
+{
+	return GTK_DIALOG(dialog)->action_area;
+}
+
+GtkWidget *pidgin_dialog_add_button(GtkDialog *dialog, const char *label,
+		GCallback callback, gpointer callbackdata)
+{
+	GtkWidget *button = gtk_button_new_from_stock(label);
+	GtkWidget *bbox = pidgin_dialog_get_action_area(dialog);
+	gtk_box_pack_start(GTK_BOX(bbox), button, FALSE, FALSE, 0);
+	if (callback)
+		g_signal_connect(G_OBJECT(button), "clicked", callback, callbackdata);
+	gtk_widget_show(button);
+	return button;
+}
+
+GtkWidget *
+pidgin_create_imhtml(gboolean editable, GtkWidget **imhtml_ret, GtkWidget **toolbar_ret, GtkWidget **sw_ret)
+{
+	GtkWidget *frame;
+	GtkWidget *imhtml;
+	GtkWidget *sep;
+	GtkWidget *sw;
+	GtkWidget *toolbar = NULL;
+	GtkWidget *vbox;
+
+	frame = gtk_frame_new(NULL);
+	gtk_frame_set_shadow_type(GTK_FRAME(frame), GTK_SHADOW_IN);
+
+	vbox = gtk_vbox_new(FALSE, 0);
+	gtk_container_add(GTK_CONTAINER(frame), vbox);
+	gtk_widget_show(vbox);
+
+	if (editable) {
+		toolbar = gtk_imhtmltoolbar_new();
+		gtk_box_pack_start(GTK_BOX(vbox), toolbar, FALSE, FALSE, 0);
+		gtk_widget_show(toolbar);
+
+		sep = gtk_hseparator_new();
+		gtk_box_pack_start(GTK_BOX(vbox), sep, FALSE, FALSE, 0);
+		g_signal_connect_swapped(G_OBJECT(toolbar), "show", G_CALLBACK(gtk_widget_show), sep);
+		g_signal_connect_swapped(G_OBJECT(toolbar), "hide", G_CALLBACK(gtk_widget_hide), sep);
+		gtk_widget_show(sep);
+	}
+
+	imhtml = gtk_imhtml_new(NULL, NULL);
+	gtk_imhtml_set_editable(GTK_IMHTML(imhtml), editable);
+	gtk_imhtml_set_format_functions(GTK_IMHTML(imhtml), GTK_IMHTML_ALL ^ GTK_IMHTML_IMAGE);
+	gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(imhtml), GTK_WRAP_WORD_CHAR);
+#ifdef USE_GTKSPELL
+	if (editable && purple_prefs_get_bool(PIDGIN_PREFS_ROOT "/conversations/spellcheck"))
+		pidgin_setup_gtkspell(GTK_TEXT_VIEW(imhtml));
+#endif
+	gtk_widget_show(imhtml);
+
+	if (editable) {
+		gtk_imhtmltoolbar_attach(GTK_IMHTMLTOOLBAR(toolbar), imhtml);
+		gtk_imhtmltoolbar_associate_smileys(GTK_IMHTMLTOOLBAR(toolbar), "default");
+	}
+	pidgin_setup_imhtml(imhtml);
+
+	sw = pidgin_make_scrollable(imhtml, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC, GTK_SHADOW_NONE, -1, -1);
+	gtk_box_pack_start(GTK_BOX(vbox), sw, TRUE, TRUE, 0);
+
+	if (imhtml_ret != NULL)
+		*imhtml_ret = imhtml;
+
+	if (editable && (toolbar_ret != NULL))
+		*toolbar_ret = toolbar;
+
+	if (sw_ret != NULL)
+		*sw_ret = sw;
+
+	return frame;
+}
+
+void
+pidgin_set_sensitive_if_input(GtkWidget *entry, GtkWidget *dialog)
+{
+	const char *text = gtk_entry_get_text(GTK_ENTRY(entry));
+	gtk_dialog_set_response_sensitive(GTK_DIALOG(dialog), GTK_RESPONSE_OK,
+									  (*text != '\0'));
+}
+
+void
+pidgin_toggle_sensitive(GtkWidget *widget, GtkWidget *to_toggle)
+{
+	gboolean sensitivity;
+
+	if (to_toggle == NULL)
+		return;
+
+	sensitivity = GTK_WIDGET_IS_SENSITIVE(to_toggle);
+
+	gtk_widget_set_sensitive(to_toggle, !sensitivity);
+}
+
+void
+pidgin_toggle_sensitive_array(GtkWidget *w, GPtrArray *data)
+{
+	gboolean sensitivity;
+	gpointer element;
+	guint i;
+
+	for (i=0; i < data->len; i++) {
+		element = g_ptr_array_index(data,i);
+		if (element == NULL)
+			continue;
+
+		sensitivity = GTK_WIDGET_IS_SENSITIVE(element);
+
+		gtk_widget_set_sensitive(element, !sensitivity);
+	}
+}
+
+void
+pidgin_toggle_showhide(GtkWidget *widget, GtkWidget *to_toggle)
+{
+	if (to_toggle == NULL)
+		return;
+
+	if (GTK_WIDGET_VISIBLE(to_toggle))
+		gtk_widget_hide(to_toggle);
+	else
+		gtk_widget_show(to_toggle);
+}
+
+GtkWidget *pidgin_separator(GtkWidget *menu)
+{
+	GtkWidget *menuitem;
+
+	menuitem = gtk_separator_menu_item_new();
+	gtk_widget_show(menuitem);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
+	return menuitem;
+}
+
+GtkWidget *pidgin_new_item(GtkWidget *menu, const char *str)
+{
+	GtkWidget *menuitem;
+	GtkWidget *label;
+
+	menuitem = gtk_menu_item_new();
+	if (menu)
+		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
+	gtk_widget_show(menuitem);
+
+	label = gtk_label_new(str);
+	gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
+	gtk_label_set_pattern(GTK_LABEL(label), "_");
+	gtk_container_add(GTK_CONTAINER(menuitem), label);
+	gtk_widget_show(label);
+/* FIXME: Go back and fix this
+	gtk_widget_add_accelerator(menuitem, "activate", accel, str[0],
+				   GDK_MOD1_MASK, GTK_ACCEL_LOCKED);
+*/
+	pidgin_set_accessible_label (menuitem, label);
+	return menuitem;
+}
+
+GtkWidget *pidgin_new_check_item(GtkWidget *menu, const char *str,
+		GCallback cb, gpointer data, gboolean checked)
+{
+	GtkWidget *menuitem;
+	menuitem = gtk_check_menu_item_new_with_mnemonic(str);
+
+	if (menu)
+		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
+
+	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuitem), checked);
+
+	if (cb)
+		g_signal_connect(G_OBJECT(menuitem), "activate", cb, data);
+
+	gtk_widget_show_all(menuitem);
+
+	return menuitem;
+}
+
+GtkWidget *
+pidgin_pixbuf_toolbar_button_from_stock(const char *icon)
+{
+	GtkWidget *button, *image, *bbox;
+
+	button = gtk_toggle_button_new();
+	gtk_button_set_relief(GTK_BUTTON(button), GTK_RELIEF_NONE);
+
+	bbox = gtk_vbox_new(FALSE, 0);
+
+	gtk_container_add (GTK_CONTAINER(button), bbox);
+
+	image = gtk_image_new_from_stock(icon, gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_EXTRA_SMALL));
+	gtk_box_pack_start(GTK_BOX(bbox), image, FALSE, FALSE, 0);
+
+	gtk_widget_show_all(bbox);
+
+	return button;
+}
+
+GtkWidget *
+pidgin_pixbuf_button_from_stock(const char *text, const char *icon,
+							  PidginButtonOrientation style)
+{
+	GtkWidget *button, *image, *label, *bbox, *ibox, *lbox = NULL;
+
+	button = gtk_button_new();
+
+	if (style == PIDGIN_BUTTON_HORIZONTAL) {
+		bbox = gtk_hbox_new(FALSE, 0);
+		ibox = gtk_hbox_new(FALSE, 0);
+		if (text)
+			lbox = gtk_hbox_new(FALSE, 0);
+	} else {
+		bbox = gtk_vbox_new(FALSE, 0);
+		ibox = gtk_vbox_new(FALSE, 0);
+		if (text)
+			lbox = gtk_vbox_new(FALSE, 0);
+	}
+
+	gtk_container_add(GTK_CONTAINER(button), bbox);
+
+	if (icon) {
+		gtk_box_pack_start(GTK_BOX(bbox), ibox, TRUE, TRUE, 0);
+		image = gtk_image_new_from_stock(icon, GTK_ICON_SIZE_BUTTON);
+		gtk_box_pack_end(GTK_BOX(ibox), image, FALSE, TRUE, 0);
+	}
+
+	if (text) {
+		gtk_box_pack_start(GTK_BOX(bbox), lbox, TRUE, TRUE, 0);
+		label = gtk_label_new(NULL);
+		gtk_label_set_text_with_mnemonic(GTK_LABEL(label), text);
+		gtk_label_set_mnemonic_widget(GTK_LABEL(label), button);
+		gtk_box_pack_start(GTK_BOX(lbox), label, FALSE, TRUE, 0);
+		pidgin_set_accessible_label (button, label);
+	}
+
+	gtk_widget_show_all(bbox);
+
+	return button;
+}
+
+
+GtkWidget *pidgin_new_item_from_stock(GtkWidget *menu, const char *str, const char *icon, GCallback cb, gpointer data, guint accel_key, guint accel_mods, char *mod)
+{
+	GtkWidget *menuitem;
+	/*
+	GtkWidget *hbox;
+	GtkWidget *label;
+	*/
+	GtkWidget *image;
+
+	if (icon == NULL)
+		menuitem = gtk_menu_item_new_with_mnemonic(str);
+	else
+		menuitem = gtk_image_menu_item_new_with_mnemonic(str);
+
+	if (menu)
+		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
+
+	if (cb)
+		g_signal_connect(G_OBJECT(menuitem), "activate", cb, data);
+
+	if (icon != NULL) {
+		image = gtk_image_new_from_stock(icon, gtk_icon_size_from_name(PIDGIN_ICON_SIZE_TANGO_EXTRA_SMALL));
+		gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menuitem), image);
+	}
+/* FIXME: this isn't right
+	if (mod) {
+		label = gtk_label_new(mod);
+		gtk_box_pack_end(GTK_BOX(hbox), label, FALSE, FALSE, 2);
+		gtk_widget_show(label);
+	}
+*/
+/*
+	if (accel_key) {
+		gtk_widget_add_accelerator(menuitem, "activate", accel, accel_key,
+					   accel_mods, GTK_ACCEL_LOCKED);
+	}
+*/
+
+	gtk_widget_show_all(menuitem);
+
+	return menuitem;
+}
+
+GtkWidget *
+pidgin_make_frame(GtkWidget *parent, const char *title)
+{
+	GtkWidget *vbox, *label, *hbox;
+	char *labeltitle;
+
+	vbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_box_pack_start(GTK_BOX(parent), vbox, FALSE, FALSE, 0);
+	gtk_widget_show(vbox);
+
+	label = gtk_label_new(NULL);
+
+	labeltitle = g_strdup_printf("<span weight=\"bold\">%s</span>", title);
+	gtk_label_set_markup(GTK_LABEL(label), labeltitle);
+	g_free(labeltitle);
+
+	gtk_misc_set_alignment(GTK_MISC(label), 0, 0);
+	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);
+	gtk_widget_show(label);
+	pidgin_set_accessible_label (vbox, label);
+
+	hbox = gtk_hbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);
+	gtk_widget_show(hbox);
+
+	label = gtk_label_new("    ");
+	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
+	gtk_widget_show(label);
+
+	vbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_box_pack_start(GTK_BOX(hbox), vbox, FALSE, FALSE, 0);
+	gtk_widget_show(vbox);
+
+	return vbox;
+}
+
+static gpointer
+aop_option_menu_get_selected(GtkWidget *optmenu, GtkWidget **p_item)
+{
+	GtkWidget *menu = gtk_option_menu_get_menu(GTK_OPTION_MENU(optmenu));
+	GtkWidget *item = gtk_menu_get_active(GTK_MENU(menu));
+	if (p_item)
+		(*p_item) = item;
+	return item ? g_object_get_data(G_OBJECT(item), "aop_per_item_data") : NULL;
+}
+
+static void
+aop_menu_cb(GtkWidget *optmenu, GCallback cb)
+{
+	GtkWidget *item;
+	gpointer per_item_data;
+
+	per_item_data = aop_option_menu_get_selected(optmenu, &item);
+
+	if (cb != NULL) {
+		((void (*)(GtkWidget *, gpointer, gpointer))cb)(item, per_item_data, g_object_get_data(G_OBJECT(optmenu), "user_data"));
+	}
+}
+
+static GtkWidget *
+aop_menu_item_new(GtkSizeGroup *sg, GdkPixbuf *pixbuf, const char *lbl, gpointer per_item_data, const char *data)
+{
+	GtkWidget *item;
+	GtkWidget *hbox;
+	GtkWidget *image;
+	GtkWidget *label;
+
+	item = gtk_menu_item_new();
+	gtk_widget_show(item);
+
+	hbox = gtk_hbox_new(FALSE, 4);
+	gtk_widget_show(hbox);
+
+	/* Create the image */
+	if (pixbuf == NULL)
+		image = gtk_image_new();
+	else
+		image = gtk_image_new_from_pixbuf(pixbuf);
+	gtk_widget_show(image);
+
+	if (sg)
+		gtk_size_group_add_widget(sg, image);
+
+	/* Create the label */
+	label = gtk_label_new (lbl);
+	gtk_widget_show (label);
+	gtk_label_set_justify(GTK_LABEL(label), GTK_JUSTIFY_LEFT);
+	gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
+
+	gtk_container_add(GTK_CONTAINER(item), hbox);
+	gtk_box_pack_start(GTK_BOX(hbox), image, FALSE, FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(hbox), label, TRUE, TRUE, 0);
+
+	g_object_set_data(G_OBJECT (item), data, per_item_data);
+	g_object_set_data(G_OBJECT (item), "aop_per_item_data", per_item_data);
+
+	pidgin_set_accessible_label(item, label);
+
+	return item;
+}
+
+static GdkPixbuf *
+pidgin_create_prpl_icon_from_prpl(PurplePlugin *prpl, PidginPrplIconSize size, PurpleAccount *account)
+{
+	PurplePluginProtocolInfo *prpl_info;
+	const char *protoname = NULL;
+	char *tmp;
+	char *filename = NULL;
+	GdkPixbuf *pixbuf;
+
+	prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+	if (prpl_info->list_icon == NULL)
+		return NULL;
+
+	protoname = prpl_info->list_icon(account, NULL);
+	if (protoname == NULL)
+		return NULL;
+
+	/*
+	 * Status icons will be themeable too, and then it will look up
+	 * protoname from the theme
+	 */
+	tmp = g_strconcat(protoname, ".png", NULL);
+
+	filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols",
+				    size == PIDGIN_PRPL_ICON_SMALL ? "16" :
+				    size == PIDGIN_PRPL_ICON_MEDIUM ? "22" : "48",
+				    tmp, NULL);
+	g_free(tmp);
+
+	pixbuf = pidgin_pixbuf_new_from_file(filename);
+	g_free(filename);
+
+	return pixbuf;
+}
+
+static GtkWidget *
+aop_option_menu_new(AopMenu *aop_menu, GCallback cb, gpointer user_data)
+{
+	GtkWidget *optmenu;
+
+	optmenu = gtk_option_menu_new();
+	gtk_widget_show(optmenu);
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(optmenu), aop_menu->menu);
+
+	if (aop_menu->default_item != -1)
+		gtk_option_menu_set_history(GTK_OPTION_MENU(optmenu), aop_menu->default_item);
+
+	g_object_set_data_full(G_OBJECT(optmenu), "aop_menu", aop_menu, (GDestroyNotify)g_free);
+	g_object_set_data(G_OBJECT(optmenu), "user_data", user_data);
+
+	g_signal_connect(G_OBJECT(optmenu), "changed", G_CALLBACK(aop_menu_cb), cb);
+
+	return optmenu;
+}
+
+static void
+aop_option_menu_replace_menu(GtkWidget *optmenu, AopMenu *new_aop_menu)
+{
+	if (gtk_option_menu_get_menu(GTK_OPTION_MENU(optmenu)))
+		gtk_option_menu_remove_menu(GTK_OPTION_MENU(optmenu));
+
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(optmenu), new_aop_menu->menu);
+
+	if (new_aop_menu->default_item != -1)
+		gtk_option_menu_set_history(GTK_OPTION_MENU(optmenu), new_aop_menu->default_item);
+
+	g_object_set_data_full(G_OBJECT(optmenu), "aop_menu", new_aop_menu, (GDestroyNotify)g_free);
+}
+
+static void
+aop_option_menu_select_by_data(GtkWidget *optmenu, gpointer data)
+{
+	guint idx;
+	GList *llItr = NULL;
+
+	for (idx = 0, llItr = GTK_MENU_SHELL(gtk_option_menu_get_menu(GTK_OPTION_MENU(optmenu)))->children;
+	     llItr != NULL;
+	     llItr = llItr->next, idx++) {
+		if (data == g_object_get_data(G_OBJECT(llItr->data), "aop_per_item_data")) {
+			gtk_option_menu_set_history(GTK_OPTION_MENU(optmenu), idx);
+			break;
+		}
+	}
+}
+
+static AopMenu *
+create_protocols_menu(const char *default_proto_id)
+{
+	AopMenu *aop_menu = NULL;
+	PurplePlugin *plugin;
+	GdkPixbuf *pixbuf = NULL;
+	GtkSizeGroup *sg;
+	GList *p;
+	const char *gtalk_name = NULL, *facebook_name = NULL;
+	int i;
+
+	aop_menu = g_malloc0(sizeof(AopMenu));
+	aop_menu->default_item = -1;
+	aop_menu->menu = gtk_menu_new();
+	gtk_widget_show(aop_menu->menu);
+	sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+
+	if (purple_find_prpl("prpl-jabber")) {
+		gtalk_name = _("Google Talk");
+		facebook_name = _("Facebook (XMPP)");
+	}
+
+	for (p = purple_plugins_get_protocols(), i = 0;
+		 p != NULL;
+		 p = p->next, i++) {
+
+		plugin = (PurplePlugin *)p->data;
+
+		if (gtalk_name && strcmp(gtalk_name, plugin->info->name) < 0) {
+			char *filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols",
+			                                  "16", "google-talk.png", NULL);
+			GtkWidget *item;
+
+			pixbuf = pidgin_pixbuf_new_from_file(filename);
+			g_free(filename);
+
+			gtk_menu_shell_append(GTK_MENU_SHELL(aop_menu->menu),
+				item = aop_menu_item_new(sg, pixbuf, gtalk_name, "prpl-jabber", "protocol"));
+			g_object_set_data(G_OBJECT(item), "fakegoogle", GINT_TO_POINTER(1));
+
+			if (pixbuf)
+				g_object_unref(pixbuf);
+
+			/* libpurple3 compatibility */
+			if (g_strcmp0(default_proto_id, "prpl-gtalk") == 0)
+				aop_menu->default_item = i;
+
+			gtalk_name = NULL;
+			i++;
+		}
+
+		if (facebook_name && strcmp(facebook_name, plugin->info->name) < 0) {
+			char *filename = g_build_filename(DATADIR, "pixmaps", "pidgin", "protocols",
+			                                  "16", "facebook.png", NULL);
+			GtkWidget *item;
+
+			pixbuf = pidgin_pixbuf_new_from_file(filename);
+			g_free(filename);
+
+			gtk_menu_shell_append(GTK_MENU_SHELL(aop_menu->menu),
+				item = aop_menu_item_new(sg, pixbuf, facebook_name, "prpl-jabber", "protocol"));
+			g_object_set_data(G_OBJECT(item), "fakefacebook", GINT_TO_POINTER(1));
+
+			if (pixbuf)
+				g_object_unref(pixbuf);
+
+			/* libpurple3 compatibility */
+			if (g_strcmp0(default_proto_id, "prpl-facebook-xmpp") == 0)
+				aop_menu->default_item = i;
+
+			facebook_name = NULL;
+			i++;
+		}
+
+		pixbuf = pidgin_create_prpl_icon_from_prpl(plugin, PIDGIN_PRPL_ICON_SMALL, NULL);
+
+		gtk_menu_shell_append(GTK_MENU_SHELL(aop_menu->menu),
+			aop_menu_item_new(sg, pixbuf, plugin->info->name, plugin->info->id, "protocol"));
+
+		if (pixbuf)
+			g_object_unref(pixbuf);
+
+		if (default_proto_id != NULL && !strcmp(plugin->info->id, default_proto_id))
+			aop_menu->default_item = i;
+	}
+
+	g_object_unref(sg);
+
+	return aop_menu;
+}
+
+GtkWidget *
+pidgin_protocol_option_menu_new(const char *id, GCallback cb,
+								  gpointer user_data)
+{
+	return aop_option_menu_new(create_protocols_menu(id), cb, user_data);
+}
+
+const char *
+pidgin_protocol_option_menu_get_selected(GtkWidget *optmenu)
+{
+	return (const char *)aop_option_menu_get_selected(optmenu, NULL);
+}
+
+PurpleAccount *
+pidgin_account_option_menu_get_selected(GtkWidget *optmenu)
+{
+	return (PurpleAccount *)aop_option_menu_get_selected(optmenu, NULL);
+}
+
+static AopMenu *
+create_account_menu(PurpleAccount *default_account,
+					PurpleFilterAccountFunc filter_func, gboolean show_all)
+{
+	AopMenu *aop_menu = NULL;
+	PurpleAccount *account;
+	GdkPixbuf *pixbuf = NULL;
+	GList *list;
+	GList *p;
+	GtkSizeGroup *sg;
+	int i;
+	char buf[256];
+
+	if (show_all)
+		list = purple_accounts_get_all();
+	else
+		list = purple_connections_get_all();
+
+	aop_menu = g_malloc0(sizeof(AopMenu));
+	aop_menu->default_item = -1;
+	aop_menu->menu = gtk_menu_new();
+	gtk_widget_show(aop_menu->menu);
+	sg = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);
+
+	for (p = list, i = 0; p != NULL; p = p->next, i++) {
+		if (show_all)
+			account = (PurpleAccount *)p->data;
+		else {
+			PurpleConnection *gc = (PurpleConnection *)p->data;
+
+			account = purple_connection_get_account(gc);
+		}
+
+		if (filter_func && !filter_func(account)) {
+			i--;
+			continue;
+		}
+
+		pixbuf = pidgin_create_prpl_icon(account, PIDGIN_PRPL_ICON_SMALL);
+
+		if (pixbuf) {
+			if (purple_account_is_disconnected(account) && show_all &&
+					purple_connections_get_all())
+				gdk_pixbuf_saturate_and_pixelate(pixbuf, pixbuf, 0.0, FALSE);
+		}
+
+		if (purple_account_get_alias(account)) {
+			g_snprintf(buf, sizeof(buf), "%s (%s) (%s)",
+					   purple_account_get_username(account),
+					   purple_account_get_alias(account),
+					   purple_account_get_protocol_name(account));
+		} else {
+			g_snprintf(buf, sizeof(buf), "%s (%s)",
+					   purple_account_get_username(account),
+					   purple_account_get_protocol_name(account));
+		}
+
+		gtk_menu_shell_append(GTK_MENU_SHELL(aop_menu->menu),
+			aop_menu_item_new(sg, pixbuf, buf, account, "account"));
+
+		if (pixbuf)
+			g_object_unref(pixbuf);
+
+		if (default_account && account == default_account)
+			aop_menu->default_item = i;
+	}
+
+	g_object_unref(sg);
+
+	return aop_menu;
+}
+
+static void
+regenerate_account_menu(GtkWidget *optmenu)
+{
+	gboolean show_all;
+	PurpleAccount *account;
+	PurpleFilterAccountFunc filter_func;
+
+	account = (PurpleAccount *)aop_option_menu_get_selected(optmenu, NULL);
+	show_all = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(optmenu), "show_all"));
+	filter_func = g_object_get_data(G_OBJECT(optmenu), "filter_func");
+
+	aop_option_menu_replace_menu(optmenu, create_account_menu(account, filter_func, show_all));
+}
+
+static void
+account_menu_sign_on_off_cb(PurpleConnection *gc, GtkWidget *optmenu)
+{
+	regenerate_account_menu(optmenu);
+}
+
+static void
+account_menu_added_removed_cb(PurpleAccount *account, GtkWidget *optmenu)
+{
+	regenerate_account_menu(optmenu);
+}
+
+static gboolean
+account_menu_destroyed_cb(GtkWidget *optmenu, GdkEvent *event,
+						  void *user_data)
+{
+	purple_signals_disconnect_by_handle(optmenu);
+
+	return FALSE;
+}
+
+void
+pidgin_account_option_menu_set_selected(GtkWidget *optmenu, PurpleAccount *account)
+{
+	aop_option_menu_select_by_data(optmenu, account);
+}
+
+GtkWidget *
+pidgin_account_option_menu_new(PurpleAccount *default_account,
+								 gboolean show_all, GCallback cb,
+								 PurpleFilterAccountFunc filter_func,
+								 gpointer user_data)
+{
+	GtkWidget *optmenu;
+
+	/* Create the option menu */
+	optmenu = aop_option_menu_new(create_account_menu(default_account, filter_func, show_all), cb, user_data);
+
+	g_signal_connect(G_OBJECT(optmenu), "destroy",
+					 G_CALLBACK(account_menu_destroyed_cb), NULL);
+
+	/* Register the purple sign on/off event callbacks. */
+	purple_signal_connect(purple_connections_get_handle(), "signed-on",
+						optmenu, PURPLE_CALLBACK(account_menu_sign_on_off_cb),
+						optmenu);
+	purple_signal_connect(purple_connections_get_handle(), "signed-off",
+						optmenu, PURPLE_CALLBACK(account_menu_sign_on_off_cb),
+						optmenu);
+	purple_signal_connect(purple_accounts_get_handle(), "account-added",
+						optmenu, PURPLE_CALLBACK(account_menu_added_removed_cb),
+						optmenu);
+	purple_signal_connect(purple_accounts_get_handle(), "account-removed",
+						optmenu, PURPLE_CALLBACK(account_menu_added_removed_cb),
+						optmenu);
+
+	/* Set some data. */
+	g_object_set_data(G_OBJECT(optmenu), "user_data", user_data);
+	g_object_set_data(G_OBJECT(optmenu), "show_all", GINT_TO_POINTER(show_all));
+	g_object_set_data(G_OBJECT(optmenu), "filter_func", filter_func);
+
+	return optmenu;
+}
+
+gboolean
+pidgin_check_if_dir(const char *path, GtkFileSelection *filesel)
+{
+	char *dirname = NULL;
+
+	if (g_file_test(path, G_FILE_TEST_IS_DIR)) {
+		/* append a / if needed */
+		if (path[strlen(path) - 1] != G_DIR_SEPARATOR) {
+			dirname = g_strconcat(path, G_DIR_SEPARATOR_S, NULL);
+		}
+		gtk_file_selection_set_filename(filesel, (dirname != NULL) ? dirname : path);
+		g_free(dirname);
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+void
+pidgin_setup_gtkspell(GtkTextView *textview)
+{
+#ifdef USE_GTKSPELL
+	GError *error = NULL;
+	char *locale = NULL;
+
+	g_return_if_fail(textview != NULL);
+	g_return_if_fail(GTK_IS_TEXT_VIEW(textview));
+
+	if (gtkspell_new_attach(textview, locale, &error) == NULL && error)
+	{
+		purple_debug_warning("gtkspell", "Failed to setup GtkSpell: %s\n",
+						   error->message);
+		g_error_free(error);
+	}
+#endif /* USE_GTKSPELL */
+}
+
+void
+pidgin_save_accels_cb(GtkAccelGroup *accel_group, guint arg1,
+                         GdkModifierType arg2, GClosure *arg3,
+                         gpointer data)
+{
+	purple_debug(PURPLE_DEBUG_MISC, "accels",
+	           "accel changed, scheduling save.\n");
+
+	if (!accels_save_timer)
+		accels_save_timer = purple_timeout_add_seconds(5, pidgin_save_accels,
+		                                  NULL);
+}
+
+gboolean
+pidgin_save_accels(gpointer data)
+{
+	char *filename = NULL;
+
+	filename = g_build_filename(purple_user_dir(), G_DIR_SEPARATOR_S,
+	                            "accels", NULL);
+	purple_debug(PURPLE_DEBUG_MISC, "accels", "saving accels to %s\n", filename);
+	gtk_accel_map_save(filename);
+	g_free(filename);
+
+	accels_save_timer = 0;
+	return FALSE;
+}
+
+void
+pidgin_load_accels()
+{
+	char *filename = NULL;
+
+	filename = g_build_filename(purple_user_dir(), G_DIR_SEPARATOR_S,
+	                            "accels", NULL);
+	gtk_accel_map_load(filename);
+	g_free(filename);
+}
+
+static void
+show_retrieveing_info(PurpleConnection *conn, const char *name)
+{
+	PurpleNotifyUserInfo *info = purple_notify_user_info_new();
+	purple_notify_user_info_add_pair(info, _("Information"), _("Retrieving..."));
+	purple_notify_userinfo(conn, name, info, NULL, NULL);
+	purple_notify_user_info_destroy(info);
+}
+
+void pidgin_retrieve_user_info(PurpleConnection *conn, const char *name)
+{
+	show_retrieveing_info(conn, name);
+	serv_get_info(conn, name);
+}
+
+void pidgin_retrieve_user_info_in_chat(PurpleConnection *conn, const char *name, int chat)
+{
+	char *who = NULL;
+	PurplePluginProtocolInfo *prpl_info = NULL;
+
+	if (chat < 0) {
+		pidgin_retrieve_user_info(conn, name);
+		return;
+	}
+
+	prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(conn->prpl);
+	if (prpl_info != NULL && prpl_info->get_cb_real_name)
+		who = prpl_info->get_cb_real_name(conn, chat, name);
+	if (prpl_info == NULL || prpl_info->get_cb_info == NULL) {
+		pidgin_retrieve_user_info(conn, who ? who : name);
+		g_free(who);
+		return;
+	}
+
+	show_retrieveing_info(conn, who ? who : name);
+	prpl_info->get_cb_info(conn, chat, name);
+	g_free(who);
+}
+
+gboolean
+pidgin_parse_x_im_contact(const char *msg, gboolean all_accounts,
+							PurpleAccount **ret_account, char **ret_protocol,
+							char **ret_username, char **ret_alias)
+{
+	char *protocol = NULL;
+	char *username = NULL;
+	char *alias    = NULL;
+	char *str;
+	char *s;
+	gboolean valid;
+
+	g_return_val_if_fail(msg          != NULL, FALSE);
+	g_return_val_if_fail(ret_protocol != NULL, FALSE);
+	g_return_val_if_fail(ret_username != NULL, FALSE);
+
+	s = str = g_strdup(msg);
+
+	while (*s != '\r' && *s != '\n' && *s != '\0')
+	{
+		char *key, *value;
+
+		key = s;
+
+		/* Grab the key */
+		while (*s != '\r' && *s != '\n' && *s != '\0' && *s != ' ')
+			s++;
+
+		if (*s == '\r') s++;
+
+		if (*s == '\n')
+		{
+			s++;
+			continue;
+		}
+
+		if (*s != '\0') *s++ = '\0';
+
+		/* Clear past any whitespace */
+		while (*s != '\0' && *s == ' ')
+			s++;
+
+		/* Now let's grab until the end of the line. */
+		value = s;
+
+		while (*s != '\r' && *s != '\n' && *s != '\0')
+			s++;
+
+		if (*s == '\r') *s++ = '\0';
+		if (*s == '\n') *s++ = '\0';
+
+		if (strchr(key, ':') != NULL)
+		{
+			if (!g_ascii_strcasecmp(key, "X-IM-Username:"))
+				username = g_strdup(value);
+			else if (!g_ascii_strcasecmp(key, "X-IM-Protocol:"))
+				protocol = g_strdup(value);
+			else if (!g_ascii_strcasecmp(key, "X-IM-Alias:"))
+				alias = g_strdup(value);
+		}
+	}
+
+	if (username != NULL && protocol != NULL)
+	{
+		valid = TRUE;
+
+		*ret_username = username;
+		*ret_protocol = protocol;
+
+		if (ret_alias != NULL)
+			*ret_alias = alias;
+
+		/* Check for a compatible account. */
+		if (ret_account != NULL)
+		{
+			GList *list;
+			PurpleAccount *account = NULL;
+			GList *l;
+			const char *protoname;
+
+			if (all_accounts)
+				list = purple_accounts_get_all();
+			else
+				list = purple_connections_get_all();
+
+			for (l = list; l != NULL; l = l->next)
+			{
+				PurpleConnection *gc;
+				PurplePluginProtocolInfo *prpl_info = NULL;
+				PurplePlugin *plugin;
+
+				if (all_accounts)
+				{
+					account = (PurpleAccount *)l->data;
+
+					plugin = purple_plugins_find_with_id(
+						purple_account_get_protocol_id(account));
+
+					if (plugin == NULL)
+					{
+						account = NULL;
+
+						continue;
+					}
+
+					prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(plugin);
+				}
+				else
+				{
+					gc = (PurpleConnection *)l->data;
+					account = purple_connection_get_account(gc);
+
+					prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+				}
+
+				protoname = prpl_info->list_icon(account, NULL);
+
+				if (!strcmp(protoname, protocol))
+					break;
+
+				account = NULL;
+			}
+
+			/* Special case for AIM and ICQ */
+			if (account == NULL && (!strcmp(protocol, "aim") ||
+									!strcmp(protocol, "icq")))
+			{
+				for (l = list; l != NULL; l = l->next)
+				{
+					PurpleConnection *gc;
+					PurplePluginProtocolInfo *prpl_info = NULL;
+					PurplePlugin *plugin;
+
+					if (all_accounts)
+					{
+						account = (PurpleAccount *)l->data;
+
+						plugin = purple_plugins_find_with_id(
+							purple_account_get_protocol_id(account));
+
+						if (plugin == NULL)
+						{
+							account = NULL;
+
+							continue;
+						}
+
+						prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(plugin);
+					}
+					else
+					{
+						gc = (PurpleConnection *)l->data;
+						account = purple_connection_get_account(gc);
+
+						prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+					}
+
+					protoname = prpl_info->list_icon(account, NULL);
+
+					if (!strcmp(protoname, "aim") || !strcmp(protoname, "icq"))
+						break;
+
+					account = NULL;
+				}
+			}
+
+			*ret_account = account;
+		}
+	}
+	else
+	{
+		valid = FALSE;
+
+		g_free(username);
+		g_free(protocol);
+		g_free(alias);
+	}
+
+	g_free(str);
+
+	return valid;
+}
+
+void
+pidgin_set_accessible_label (GtkWidget *w, GtkWidget *l)
+{
+	AtkObject *acc;
+	const gchar *label_text;
+	const gchar *existing_name;
+
+	acc = gtk_widget_get_accessible (w);
+
+	/* If this object has no name, set it's name with the label text */
+	existing_name = atk_object_get_name (acc);
+	if (!existing_name) {
+		label_text = gtk_label_get_text (GTK_LABEL(l));
+		if (label_text)
+			atk_object_set_name (acc, label_text);
+	}
+
+	pidgin_set_accessible_relations(w, l);
+}
+
+void
+pidgin_set_accessible_relations (GtkWidget *w, GtkWidget *l)
+{
+	AtkObject *acc, *label;
+	AtkObject *rel_obj[1];
+	AtkRelationSet *set;
+	AtkRelation *relation;
+
+	acc = gtk_widget_get_accessible (w);
+	label = gtk_widget_get_accessible (l);
+
+	/* Make sure mnemonics work */
+	gtk_label_set_mnemonic_widget(GTK_LABEL(l), w);
+
+	/* Create the labeled-by relation */
+	set = atk_object_ref_relation_set (acc);
+	rel_obj[0] = label;
+	relation = atk_relation_new (rel_obj, 1, ATK_RELATION_LABELLED_BY);
+	atk_relation_set_add (set, relation);
+	g_object_unref (relation);
+	g_object_unref(set);
+
+	/* Create the label-for relation */
+	set = atk_object_ref_relation_set (label);
+	rel_obj[0] = acc;
+	relation = atk_relation_new (rel_obj, 1, ATK_RELATION_LABEL_FOR);
+	atk_relation_set_add (set, relation);
+	g_object_unref (relation);
+	g_object_unref(set);
+}
+
+void
+pidgin_menu_position_func_helper(GtkMenu *menu,
+							gint *x,
+							gint *y,
+							gboolean *push_in,
+							gpointer data)
+{
+	GtkWidget *widget;
+	GtkRequisition requisition;
+	GdkScreen *screen;
+	GdkRectangle monitor;
+	gint monitor_num;
+	gint space_left, space_right, space_above, space_below;
+	gint needed_width;
+	gint needed_height;
+	gint xthickness;
+	gint ythickness;
+	gboolean rtl;
+
+	g_return_if_fail(GTK_IS_MENU(menu));
+
+	widget     = GTK_WIDGET(menu);
+	screen     = gtk_widget_get_screen(widget);
+	xthickness = widget->style->xthickness;
+	ythickness = widget->style->ythickness;
+	rtl        = (gtk_widget_get_direction(widget) == GTK_TEXT_DIR_RTL);
+
+	/*
+	 * We need the requisition to figure out the right place to
+	 * popup the menu. In fact, we always need to ask here, since
+	 * if a size_request was queued while we weren't popped up,
+	 * the requisition won't have been recomputed yet.
+	 */
+	gtk_widget_size_request (widget, &requisition);
+
+	monitor_num = gdk_screen_get_monitor_at_point (screen, *x, *y);
+
+	*push_in = FALSE;
+
+	/*
+	 * The placement of popup menus horizontally works like this (with
+	 * RTL in parentheses)
+	 *
+	 * - If there is enough room to the right (left) of the mouse cursor,
+	 *   position the menu there.
+	 *
+	 * - Otherwise, if if there is enough room to the left (right) of the
+	 *   mouse cursor, position the menu there.
+	 *
+	 * - Otherwise if the menu is smaller than the monitor, position it
+	 *   on the side of the mouse cursor that has the most space available
+	 *
+	 * - Otherwise (if there is simply not enough room for the menu on the
+	 *   monitor), position it as far left (right) as possible.
+	 *
+	 * Positioning in the vertical direction is similar: first try below
+	 * mouse cursor, then above.
+	 */
+	gdk_screen_get_monitor_geometry (screen, monitor_num, &monitor);
+
+	space_left = *x - monitor.x;
+	space_right = monitor.x + monitor.width - *x - 1;
+	space_above = *y - monitor.y;
+	space_below = monitor.y + monitor.height - *y - 1;
+
+	/* position horizontally */
+
+	/* the amount of space we need to position the menu. Note the
+	 * menu is offset "xthickness" pixels
+	 */
+	needed_width = requisition.width - xthickness;
+
+	if (needed_width <= space_left ||
+	    needed_width <= space_right)
+	{
+		if ((rtl  && needed_width <= space_left) ||
+		    (!rtl && needed_width >  space_right))
+		{
+			/* position left */
+			*x = *x + xthickness - requisition.width + 1;
+		}
+		else
+		{
+			/* position right */
+			*x = *x - xthickness;
+		}
+
+		/* x is clamped on-screen further down */
+	}
+	else if (requisition.width <= monitor.width)
+	{
+		/* the menu is too big to fit on either side of the mouse
+		 * cursor, but smaller than the monitor. Position it on
+		 * the side that has the most space
+		 */
+		if (space_left > space_right)
+		{
+			/* left justify */
+			*x = monitor.x;
+		}
+		else
+		{
+			/* right justify */
+			*x = monitor.x + monitor.width - requisition.width;
+		}
+	}
+	else /* menu is simply too big for the monitor */
+	{
+		if (rtl)
+		{
+			/* right justify */
+			*x = monitor.x + monitor.width - requisition.width;
+		}
+		else
+		{
+			/* left justify */
+			*x = monitor.x;
+		}
+	}
+
+	/* Position vertically. The algorithm is the same as above, but
+	 * simpler because we don't have to take RTL into account.
+	 */
+	needed_height = requisition.height - ythickness;
+
+	if (needed_height <= space_above ||
+	    needed_height <= space_below)
+	{
+		if (needed_height <= space_below)
+			*y = *y - ythickness;
+		else
+			*y = *y + ythickness - requisition.height + 1;
+
+		*y = CLAMP (*y, monitor.y,
+			   monitor.y + monitor.height - requisition.height);
+	}
+	else if (needed_height > space_below && needed_height > space_above)
+	{
+		if (space_below >= space_above)
+			*y = monitor.y + monitor.height - requisition.height;
+		else
+			*y = monitor.y;
+	}
+	else
+	{
+		*y = monitor.y;
+	}
+}
+
+
+void
+pidgin_treeview_popup_menu_position_func(GtkMenu *menu,
+										   gint *x,
+										   gint *y,
+										   gboolean *push_in,
+										   gpointer data)
+{
+	GtkWidget *widget = GTK_WIDGET(data);
+	GtkTreeView *tv = GTK_TREE_VIEW(data);
+	GtkTreePath *path;
+	GtkTreeViewColumn *col;
+	GdkRectangle rect;
+	gint ythickness = GTK_WIDGET(menu)->style->ythickness;
+
+	gdk_window_get_origin (widget->window, x, y);
+	gtk_tree_view_get_cursor (tv, &path, &col);
+	gtk_tree_view_get_cell_area (tv, path, col, &rect);
+
+	*x += rect.x+rect.width;
+	*y += rect.y+rect.height+ythickness;
+	pidgin_menu_position_func_helper(menu, x, y, push_in, data);
+}
+
+enum {
+	DND_FILE_TRANSFER,
+	DND_IM_IMAGE,
+	DND_BUDDY_ICON
+};
+
+typedef struct {
+	char *filename;
+	PurpleAccount *account;
+	char *who;
+} _DndData;
+
+static void dnd_image_ok_callback(_DndData *data, int choice)
+{
+	const gchar *shortname;
+	gchar *filedata;
+	size_t size;
+	struct stat st;
+	GError *err = NULL;
+	PurpleConversation *conv;
+	PidginConversation *gtkconv;
+	GtkTextIter iter;
+	int id;
+	PurpleBuddy *buddy;
+	PurpleContact *contact;
+	switch (choice) {
+	case DND_BUDDY_ICON:
+		if (g_stat(data->filename, &st)) {
+			char *str;
+
+			str = g_strdup_printf(_("The following error has occurred loading %s: %s"),
+						data->filename, g_strerror(errno));
+			purple_notify_error(NULL, NULL,
+					  _("Failed to load image"),
+					  str);
+			g_free(str);
+
+			break;
+		}
+
+		buddy = purple_find_buddy(data->account, data->who);
+		if (!buddy) {
+			purple_debug_info("custom-icon", "You can only set custom icons for people on your buddylist.\n");
+			break;
+		}
+		contact = purple_buddy_get_contact(buddy);
+		purple_buddy_icons_node_set_custom_icon_from_file((PurpleBlistNode*)contact, data->filename);
+		break;
+	case DND_FILE_TRANSFER:
+		serv_send_file(purple_account_get_connection(data->account), data->who, data->filename);
+		break;
+	case DND_IM_IMAGE:
+		conv = purple_conversation_new(PURPLE_CONV_TYPE_IM, data->account, data->who);
+		gtkconv = PIDGIN_CONVERSATION(conv);
+
+		if (!g_file_get_contents(data->filename, &filedata, &size,
+					 &err)) {
+			char *str;
+
+			str = g_strdup_printf(_("The following error has occurred loading %s: %s"), data->filename, err->message);
+			purple_notify_error(NULL, NULL,
+					  _("Failed to load image"),
+					  str);
+
+			g_error_free(err);
+			g_free(str);
+
+			break;
+		}
+		shortname = strrchr(data->filename, G_DIR_SEPARATOR);
+		shortname = shortname ? shortname + 1 : data->filename;
+		id = purple_imgstore_add_with_id(filedata, size, shortname);
+
+		gtk_text_buffer_get_iter_at_mark(GTK_IMHTML(gtkconv->entry)->text_buffer, &iter,
+						 gtk_text_buffer_get_insert(GTK_IMHTML(gtkconv->entry)->text_buffer));
+		gtk_imhtml_insert_image_at_iter(GTK_IMHTML(gtkconv->entry), id, &iter);
+		purple_imgstore_unref_by_id(id);
+
+		break;
+	}
+	g_free(data->filename);
+	g_free(data->who);
+	g_free(data);
+}
+
+static void dnd_image_cancel_callback(_DndData *data, int choice)
+{
+	g_free(data->filename);
+	g_free(data->who);
+	g_free(data);
+}
+
+static void dnd_set_icon_ok_cb(_DndData *data)
+{
+	dnd_image_ok_callback(data, DND_BUDDY_ICON);
+}
+
+static void dnd_set_icon_cancel_cb(_DndData *data)
+{
+	g_free(data->filename);
+	g_free(data->who);
+	g_free(data);
+}
+
+void
+pidgin_dnd_file_manage(GtkSelectionData *sd, PurpleAccount *account, const char *who)
+{
+	GdkPixbuf *pb;
+	GList *files = purple_uri_list_extract_filenames((const gchar *)sd->data);
+	PurpleConnection *gc = purple_account_get_connection(account);
+	PurplePluginProtocolInfo *prpl_info = NULL;
+#ifndef _WIN32
+	PurpleDesktopItem *item;
+#endif
+	gchar *filename = NULL;
+	gchar *basename = NULL;
+
+	g_return_if_fail(account != NULL);
+	g_return_if_fail(who != NULL);
+
+	for ( ; files; files = g_list_delete_link(files, files)) {
+		g_free(filename);
+		g_free(basename);
+
+		filename = files->data;
+		basename = g_path_get_basename(filename);
+
+		/* XXX - Make ft API support creating a transfer with more than one file */
+		if (!g_file_test(filename, G_FILE_TEST_EXISTS)) {
+			continue;
+		}
+
+		/* XXX - make ft api suupport sending a directory */
+		/* Are we dealing with a directory? */
+		if (g_file_test(filename, G_FILE_TEST_IS_DIR)) {
+			char *str, *str2;
+
+			str = g_strdup_printf(_("Cannot send folder %s."), basename);
+			str2 = g_strdup_printf(_("%s cannot transfer a folder. You will need to send the files within individually."), PIDGIN_NAME);
+
+			purple_notify_error(NULL, NULL,
+					  str, str2);
+
+			g_free(str);
+			g_free(str2);
+			continue;
+		}
+
+		/* Are we dealing with an image? */
+		pb = pidgin_pixbuf_new_from_file(filename);
+		if (pb) {
+			_DndData *data = g_malloc(sizeof(_DndData));
+			gboolean ft = FALSE, im = FALSE;
+
+			data->who = g_strdup(who);
+			data->filename = g_strdup(filename);
+			data->account = account;
+
+			if (gc)
+				prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(gc->prpl);
+
+			if (prpl_info && prpl_info->options & OPT_PROTO_IM_IMAGE)
+				im = TRUE;
+
+			if (prpl_info && prpl_info->can_receive_file)
+				ft = prpl_info->can_receive_file(gc, who);
+			else if (prpl_info && prpl_info->send_file)
+				ft = TRUE;
+
+			if (im && ft)
+				purple_request_choice(NULL, NULL,
+						    _("You have dragged an image"),
+						    _("You can send this image as a file transfer, "
+						      "embed it into this message, or use it as the buddy icon for this user."),
+						    DND_FILE_TRANSFER, _("OK"), (GCallback)dnd_image_ok_callback,
+						    _("Cancel"), (GCallback)dnd_image_cancel_callback,
+							account, who, NULL,
+							data,
+							_("Set as buddy icon"), DND_BUDDY_ICON,
+						    _("Send image file"), DND_FILE_TRANSFER,
+						    _("Insert in message"), DND_IM_IMAGE,
+							NULL);
+			else if (!(im || ft))
+				purple_request_yes_no(NULL, NULL, _("You have dragged an image"),
+							_("Would you like to set it as the buddy icon for this user?"),
+							PURPLE_DEFAULT_ACTION_NONE,
+							account, who, NULL,
+							data, (GCallback)dnd_set_icon_ok_cb, (GCallback)dnd_set_icon_cancel_cb);
+			else
+				purple_request_choice(NULL, NULL,
+						    _("You have dragged an image"),
+						    (ft ? _("You can send this image as a file transfer, or use it as the buddy icon for this user.") :
+						    _("You can insert this image into this message, or use it as the buddy icon for this user")),
+						    (ft ? DND_FILE_TRANSFER : DND_IM_IMAGE),
+							_("OK"), (GCallback)dnd_image_ok_callback,
+						    _("Cancel"), (GCallback)dnd_image_cancel_callback,
+							account, who, NULL,
+							data,
+						    _("Set as buddy icon"), DND_BUDDY_ICON,
+						    (ft ? _("Send image file") : _("Insert in message")), (ft ? DND_FILE_TRANSFER : DND_IM_IMAGE),
+							NULL);
+			g_object_unref(G_OBJECT(pb));
+
+			g_free(basename);
+			while (files) {
+				g_free(files->data);
+				files = g_list_delete_link(files, files);
+			}
+			return;
+		}
+
+#ifndef _WIN32
+		/* Are we trying to send a .desktop file? */
+		else if (purple_str_has_suffix(basename, ".desktop") && (item = purple_desktop_item_new_from_file(filename))) {
+			PurpleDesktopItemType dtype;
+			char key[64];
+			const char *itemname = NULL;
+
+			const char * const *langs;
+			langs = g_get_language_names();
+			if (langs[0]) {
+				g_snprintf(key, sizeof(key), "Name[%s]", langs[0]);
+				itemname = purple_desktop_item_get_string(item, key);
+			}
+
+			if (!itemname)
+				itemname = purple_desktop_item_get_string(item, "Name");
+
+			dtype = purple_desktop_item_get_entry_type(item);
+			switch (dtype) {
+				PurpleConversation *conv;
+				PidginConversation *gtkconv;
+
+			case PURPLE_DESKTOP_ITEM_TYPE_LINK:
+				conv = purple_conversation_new(PURPLE_CONV_TYPE_IM, account, who);
+				gtkconv =  PIDGIN_CONVERSATION(conv);
+				gtk_imhtml_insert_link(GTK_IMHTML(gtkconv->entry),
+						       gtk_text_buffer_get_insert(GTK_IMHTML(gtkconv->entry)->text_buffer),
+						       purple_desktop_item_get_string(item, "URL"), itemname);
+				break;
+			default:
+				/* I don't know if we really want to do anything here.  Most of
+				 * the desktop item types are crap like "MIME Type" (I have no
+				 * clue how that would be a desktop item) and "Comment"...
+				 * nothing we can really send.  The only logical one is
+				 * "Application," but do we really want to send a binary and
+				 * nothing else? Probably not.  I'll just give an error and
+				 * return. */
+				/* The original patch sent the icon used by the launcher.  That's probably wrong */
+				purple_notify_error(NULL, NULL, _("Cannot send launcher"),
+				                    _("You dragged a desktop launcher. Most "
+				                      "likely you wanted to send the target "
+				                      "of this launcher instead of this "
+				                      "launcher itself."));
+				break;
+			}
+			purple_desktop_item_unref(item);
+			g_free(basename);
+			while (files) {
+				g_free(files->data);
+				files = g_list_delete_link(files, files);
+			}
+			return;
+		}
+#endif /* _WIN32 */
+
+		/* Everything is fine, let's send */
+		serv_send_file(gc, who, filename);
+	}
+
+	g_free(filename);
+	g_free(basename);
+}
+
+void pidgin_buddy_icon_get_scale_size(GdkPixbuf *buf, PurpleBuddyIconSpec *spec, PurpleIconScaleRules rules, int *width, int *height)
+{
+	*width = gdk_pixbuf_get_width(buf);
+	*height = gdk_pixbuf_get_height(buf);
+
+	if ((spec == NULL) || !(spec->scale_rules & rules))
+		return;
+
+	purple_buddy_icon_get_scale_size(spec, width, height);
+
+	/* and now for some arbitrary sanity checks */
+	if(*width > 100)
+		*width = 100;
+	if(*height > 100)
+		*height = 100;
+}
+
+GdkPixbuf * pidgin_create_status_icon(PurpleStatusPrimitive prim, GtkWidget *w, const char *size)
+{
+	GtkIconSize icon_size = gtk_icon_size_from_name(size);
+	GdkPixbuf *pixbuf = NULL;
+	const char *stock = pidgin_stock_id_from_status_primitive(prim);
+
+	pixbuf = gtk_widget_render_icon (w, stock ? stock : PIDGIN_STOCK_STATUS_AVAILABLE,
+			icon_size, "GtkWidget");
+	return pixbuf;
+}
+
+static const char *
+stock_id_from_status_primitive_idle(PurpleStatusPrimitive prim, gboolean idle)
+{
+	const char *stock = NULL;
+	switch (prim) {
+		case PURPLE_STATUS_UNSET:
+			stock = NULL;
+			break;
+		case PURPLE_STATUS_UNAVAILABLE:
+			stock = idle ? PIDGIN_STOCK_STATUS_BUSY_I : PIDGIN_STOCK_STATUS_BUSY;
+			break;
+		case PURPLE_STATUS_AWAY:
+			stock = idle ? PIDGIN_STOCK_STATUS_AWAY_I : PIDGIN_STOCK_STATUS_AWAY;
+			break;
+		case PURPLE_STATUS_EXTENDED_AWAY:
+			stock = idle ? PIDGIN_STOCK_STATUS_XA_I : PIDGIN_STOCK_STATUS_XA;
+			break;
+		case PURPLE_STATUS_INVISIBLE:
+			stock = PIDGIN_STOCK_STATUS_INVISIBLE;
+			break;
+		case PURPLE_STATUS_OFFLINE:
+			stock = idle ? PIDGIN_STOCK_STATUS_OFFLINE_I : PIDGIN_STOCK_STATUS_OFFLINE;
+			break;
+		default:
+			stock = idle ? PIDGIN_STOCK_STATUS_AVAILABLE_I : PIDGIN_STOCK_STATUS_AVAILABLE;
+			break;
+	}
+	return stock;
+}
+
+const char *
+pidgin_stock_id_from_status_primitive(PurpleStatusPrimitive prim)
+{
+	return stock_id_from_status_primitive_idle(prim, FALSE);
+}
+
+const char *
+pidgin_stock_id_from_presence(PurplePresence *presence)
+{
+	PurpleStatus *status;
+	PurpleStatusType *type;
+	PurpleStatusPrimitive prim;
+	gboolean idle;
+
+	g_return_val_if_fail(presence, NULL);
+
+	status = purple_presence_get_active_status(presence);
+	type = purple_status_get_type(status);
+	prim = purple_status_type_get_primitive(type);
+
+	idle = purple_presence_is_idle(presence);
+
+	return stock_id_from_status_primitive_idle(prim, idle);
+}
+
+GdkPixbuf *
+pidgin_create_prpl_icon(PurpleAccount *account, PidginPrplIconSize size)
+{
+	PurplePlugin *prpl;
+
+	g_return_val_if_fail(account != NULL, NULL);
+
+	prpl = purple_find_prpl(purple_account_get_protocol_id(account));
+	if (prpl == NULL)
+		return NULL;
+	return pidgin_create_prpl_icon_from_prpl(prpl, size, account);
+}
+
+static void
+menu_action_cb(GtkMenuItem *item, gpointer object)
+{
+	gpointer data;
+	void (*callback)(gpointer, gpointer);
+
+	callback = g_object_get_data(G_OBJECT(item), "purplecallback");
+	data = g_object_get_data(G_OBJECT(item), "purplecallbackdata");
+
+	if (callback)
+		callback(object, data);
+}
+
+GtkWidget *
+pidgin_append_menu_action(GtkWidget *menu, PurpleMenuAction *act,
+                            gpointer object)
+{
+	GtkWidget *menuitem;
+
+	if (act == NULL) {
+		return pidgin_separator(menu);
+	}
+
+	if (act->children == NULL) {
+		menuitem = gtk_menu_item_new_with_mnemonic(act->label);
+
+		if (act->callback != NULL) {
+			g_object_set_data(G_OBJECT(menuitem),
+							  "purplecallback",
+							  act->callback);
+			g_object_set_data(G_OBJECT(menuitem),
+							  "purplecallbackdata",
+							  act->data);
+			g_signal_connect(G_OBJECT(menuitem), "activate",
+							 G_CALLBACK(menu_action_cb),
+							 object);
+		} else {
+			gtk_widget_set_sensitive(menuitem, FALSE);
+		}
+
+		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
+	} else {
+		GList *l = NULL;
+		GtkWidget *submenu = NULL;
+		GtkAccelGroup *group;
+
+		menuitem = gtk_menu_item_new_with_mnemonic(act->label);
+		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
+
+		submenu = gtk_menu_new();
+		gtk_menu_item_set_submenu(GTK_MENU_ITEM(menuitem), submenu);
+
+		group = gtk_menu_get_accel_group(GTK_MENU(menu));
+		if (group) {
+			char *path = g_strdup_printf("%s/%s", GTK_MENU_ITEM(menuitem)->accel_path, act->label);
+			gtk_menu_set_accel_path(GTK_MENU(submenu), path);
+			g_free(path);
+			gtk_menu_set_accel_group(GTK_MENU(submenu), group);
+		}
+
+		for (l = act->children; l; l = l->next) {
+			PurpleMenuAction *act = (PurpleMenuAction *)l->data;
+
+			pidgin_append_menu_action(submenu, act, object);
+		}
+		g_list_free(act->children);
+		act->children = NULL;
+	}
+	purple_menu_action_free(act);
+	return menuitem;
+}
+
+typedef struct
+{
+	GtkWidget *entry;
+	GtkWidget *accountopt;
+
+	PidginFilterBuddyCompletionEntryFunc filter_func;
+	gpointer filter_func_user_data;
+
+	GtkListStore *store;
+} PidginCompletionData;
+
+static gboolean buddyname_completion_match_func(GtkEntryCompletion *completion,
+		const gchar *key, GtkTreeIter *iter, gpointer user_data)
+{
+	GtkTreeModel *model;
+	GValue val1;
+	GValue val2;
+	const char *tmp;
+
+	model = gtk_entry_completion_get_model (completion);
+
+	val1.g_type = 0;
+	gtk_tree_model_get_value(model, iter, 2, &val1);
+	tmp = g_value_get_string(&val1);
+	if (tmp != NULL && purple_str_has_prefix(tmp, key))
+	{
+		g_value_unset(&val1);
+		return TRUE;
+	}
+	g_value_unset(&val1);
+
+	val2.g_type = 0;
+	gtk_tree_model_get_value(model, iter, 3, &val2);
+	tmp = g_value_get_string(&val2);
+	if (tmp != NULL && purple_str_has_prefix(tmp, key))
+	{
+		g_value_unset(&val2);
+		return TRUE;
+	}
+	g_value_unset(&val2);
+
+	return FALSE;
+}
+
+static gboolean buddyname_completion_match_selected_cb(GtkEntryCompletion *completion,
+		GtkTreeModel *model, GtkTreeIter *iter, PidginCompletionData *data)
+{
+	GValue val;
+	GtkWidget *optmenu = data->accountopt;
+	PurpleAccount *account;
+
+	val.g_type = 0;
+	gtk_tree_model_get_value(model, iter, 1, &val);
+	gtk_entry_set_text(GTK_ENTRY(data->entry), g_value_get_string(&val));
+	g_value_unset(&val);
+
+	gtk_tree_model_get_value(model, iter, 4, &val);
+	account = g_value_get_pointer(&val);
+	g_value_unset(&val);
+
+	if (account == NULL)
+		return TRUE;
+
+	if (optmenu != NULL)
+		aop_option_menu_select_by_data(optmenu, account);
+
+	return TRUE;
+}
+
+static void
+add_buddyname_autocomplete_entry(GtkListStore *store, const char *buddy_alias, const char *contact_alias,
+								  const PurpleAccount *account, const char *buddyname)
+{
+	GtkTreeIter iter;
+	gboolean completion_added = FALSE;
+	gchar *normalized_buddyname;
+	gchar *tmp;
+
+	tmp = g_utf8_normalize(buddyname, -1, G_NORMALIZE_DEFAULT);
+	normalized_buddyname = g_utf8_casefold(tmp, -1);
+	g_free(tmp);
+
+	/* There's no sense listing things like: 'xxx "xxx"'
+	   when the name and buddy alias match. */
+	if (buddy_alias && strcmp(buddy_alias, buddyname)) {
+		char *completion_entry = g_strdup_printf("%s \"%s\"", buddyname, buddy_alias);
+		char *tmp2 = g_utf8_normalize(buddy_alias, -1, G_NORMALIZE_DEFAULT);
+
+		tmp = g_utf8_casefold(tmp2, -1);
+		g_free(tmp2);
+
+		gtk_list_store_append(store, &iter);
+		gtk_list_store_set(store, &iter,
+				0, completion_entry,
+				1, buddyname,
+				2, normalized_buddyname,
+				3, tmp,
+				4, account,
+				-1);
+		g_free(completion_entry);
+		g_free(tmp);
+		completion_added = TRUE;
+	}
+
+	/* There's no sense listing things like: 'xxx "xxx"'
+	   when the name and contact alias match. */
+	if (contact_alias && strcmp(contact_alias, buddyname)) {
+		/* We don't want duplicates when the contact and buddy alias match. */
+		if (!buddy_alias || strcmp(contact_alias, buddy_alias)) {
+			char *completion_entry = g_strdup_printf("%s \"%s\"",
+							buddyname, contact_alias);
+			char *tmp2 = g_utf8_normalize(contact_alias, -1, G_NORMALIZE_DEFAULT);
+
+			tmp = g_utf8_casefold(tmp2, -1);
+			g_free(tmp2);
+
+			gtk_list_store_append(store, &iter);
+			gtk_list_store_set(store, &iter,
+					0, completion_entry,
+					1, buddyname,
+					2, normalized_buddyname,
+					3, tmp,
+					4, account,
+					-1);
+			g_free(completion_entry);
+			g_free(tmp);
+			completion_added = TRUE;
+		}
+	}
+
+	if (completion_added == FALSE) {
+		/* Add the buddy's name. */
+		gtk_list_store_append(store, &iter);
+		gtk_list_store_set(store, &iter,
+				0, buddyname,
+				1, buddyname,
+				2, normalized_buddyname,
+				3, NULL,
+				4, account,
+				-1);
+	}
+
+	g_free(normalized_buddyname);
+}
+
+static void get_log_set_name(PurpleLogSet *set, gpointer value, PidginCompletionData *data)
+{
+	PidginFilterBuddyCompletionEntryFunc filter_func = data->filter_func;
+	gpointer user_data = data->filter_func_user_data;
+
+	/* 1. Don't show buddies because we will have gotten them already.
+	 * 2. The boxes that use this autocomplete code handle only IMs. */
+	if (!set->buddy && set->type == PURPLE_LOG_IM) {
+		PidginBuddyCompletionEntry entry;
+		entry.is_buddy = FALSE;
+		entry.entry.logged_buddy = set;
+
+		if (filter_func(&entry, user_data)) {
+			add_buddyname_autocomplete_entry(data->store,
+												NULL, NULL, set->account, set->name);
+		}
+	}
+}
+
+static void
+add_completion_list(PidginCompletionData *data)
+{
+	PurpleBlistNode *gnode, *cnode, *bnode;
+	PidginFilterBuddyCompletionEntryFunc filter_func = data->filter_func;
+	gpointer user_data = data->filter_func_user_data;
+	GHashTable *sets;
+
+	gtk_list_store_clear(data->store);
+
+	for (gnode = purple_get_blist()->root; gnode != NULL; gnode = gnode->next)
+	{
+		if (!PURPLE_BLIST_NODE_IS_GROUP(gnode))
+			continue;
+
+		for (cnode = gnode->child; cnode != NULL; cnode = cnode->next)
+		{
+			if (!PURPLE_BLIST_NODE_IS_CONTACT(cnode))
+				continue;
+
+			for (bnode = cnode->child; bnode != NULL; bnode = bnode->next)
+			{
+				PidginBuddyCompletionEntry entry;
+				entry.is_buddy = TRUE;
+				entry.entry.buddy = (PurpleBuddy *) bnode;
+
+				if (filter_func(&entry, user_data)) {
+					add_buddyname_autocomplete_entry(data->store,
+														((PurpleContact *)cnode)->alias,
+														purple_buddy_get_contact_alias(entry.entry.buddy),
+														entry.entry.buddy->account,
+														entry.entry.buddy->name
+													 );
+				}
+			}
+		}
+	}
+
+	sets = purple_log_get_log_sets();
+	g_hash_table_foreach(sets, (GHFunc)get_log_set_name, data);
+	g_hash_table_destroy(sets);
+
+}
+
+static void
+buddyname_autocomplete_destroyed_cb(GtkWidget *widget, gpointer data)
+{
+	g_free(data);
+	purple_signals_disconnect_by_handle(widget);
+}
+
+static void
+repopulate_autocomplete(gpointer something, gpointer data)
+{
+	add_completion_list(data);
+}
+
+void
+pidgin_setup_screenname_autocomplete_with_filter(GtkWidget *entry, GtkWidget *accountopt, PidginFilterBuddyCompletionEntryFunc filter_func, gpointer user_data)
+{
+	PidginCompletionData *data;
+
+	/*
+	 * Store the displayed completion value, the buddy name, the UTF-8
+	 * normalized & casefolded buddy name, the UTF-8 normalized &
+	 * casefolded value for comparison, and the account.
+	 */
+	GtkListStore *store;
+
+	GtkEntryCompletion *completion;
+
+	data = g_new0(PidginCompletionData, 1);
+	store = gtk_list_store_new(5, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_POINTER);
+
+	data->entry = entry;
+	data->accountopt = accountopt;
+	if (filter_func == NULL) {
+		data->filter_func = pidgin_screenname_autocomplete_default_filter;
+		data->filter_func_user_data = NULL;
+	} else {
+		data->filter_func = filter_func;
+		data->filter_func_user_data = user_data;
+	}
+	data->store = store;
+
+	add_completion_list(data);
+
+	/* Sort the completion list by buddy name */
+	gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(store),
+	                                     1, GTK_SORT_ASCENDING);
+
+	completion = gtk_entry_completion_new();
+	gtk_entry_completion_set_match_func(completion, buddyname_completion_match_func, NULL, NULL);
+
+	g_signal_connect(G_OBJECT(completion), "match-selected",
+		G_CALLBACK(buddyname_completion_match_selected_cb), data);
+
+	gtk_entry_set_completion(GTK_ENTRY(entry), completion);
+	g_object_unref(completion);
+
+	gtk_entry_completion_set_model(completion, GTK_TREE_MODEL(store));
+	g_object_unref(store);
+
+	gtk_entry_completion_set_text_column(completion, 0);
+
+	purple_signal_connect(purple_connections_get_handle(), "signed-on", entry,
+						PURPLE_CALLBACK(repopulate_autocomplete), data);
+	purple_signal_connect(purple_connections_get_handle(), "signed-off", entry,
+						PURPLE_CALLBACK(repopulate_autocomplete), data);
+
+	purple_signal_connect(purple_accounts_get_handle(), "account-added", entry,
+						PURPLE_CALLBACK(repopulate_autocomplete), data);
+	purple_signal_connect(purple_accounts_get_handle(), "account-removed", entry,
+						PURPLE_CALLBACK(repopulate_autocomplete), data);
+
+	g_signal_connect(G_OBJECT(entry), "destroy", G_CALLBACK(buddyname_autocomplete_destroyed_cb), data);
+}
+
+gboolean
+pidgin_screenname_autocomplete_default_filter(const PidginBuddyCompletionEntry *completion_entry, gpointer all_accounts) {
+	gboolean all = GPOINTER_TO_INT(all_accounts);
+
+	if (completion_entry->is_buddy) {
+		return all || purple_account_is_connected(completion_entry->entry.buddy->account);
+	} else {
+		return all || (completion_entry->entry.logged_buddy->account != NULL && purple_account_is_connected(completion_entry->entry.logged_buddy->account));
+	}
+}
+
+void
+pidgin_setup_screenname_autocomplete(GtkWidget *entry, GtkWidget *accountopt, gboolean all) {
+	pidgin_setup_screenname_autocomplete_with_filter(entry, accountopt, pidgin_screenname_autocomplete_default_filter, GINT_TO_POINTER(all));
+}
+
+
+
+void pidgin_set_cursor(GtkWidget *widget, GdkCursorType cursor_type)
+{
+	GdkCursor *cursor;
+
+	g_return_if_fail(widget != NULL);
+	if (widget->window == NULL)
+		return;
+
+	cursor = gdk_cursor_new(cursor_type);
+	gdk_window_set_cursor(widget->window, cursor);
+	gdk_cursor_unref(cursor);
+
+	gdk_display_flush(gdk_drawable_get_display(GDK_DRAWABLE(widget->window)));
+}
+
+void pidgin_clear_cursor(GtkWidget *widget)
+{
+	g_return_if_fail(widget != NULL);
+	if (widget->window == NULL)
+		return;
+
+	gdk_window_set_cursor(widget->window, NULL);
+}
+
+struct _icon_chooser {
+	GtkWidget *icon_filesel;
+	GtkWidget *icon_preview;
+	GtkWidget *icon_text;
+
+	void (*callback)(const char*,gpointer);
+	gpointer data;
+};
+
+static void
+icon_filesel_choose_cb(GtkWidget *widget, gint response, struct _icon_chooser *dialog)
+{
+	char *filename, *current_folder;
+
+	if (response != GTK_RESPONSE_ACCEPT) {
+		if (response == GTK_RESPONSE_CANCEL) {
+			gtk_widget_destroy(dialog->icon_filesel);
+		}
+		dialog->icon_filesel = NULL;
+		if (dialog->callback)
+			dialog->callback(NULL, dialog->data);
+		g_free(dialog);
+		return;
+	}
+
+	filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog->icon_filesel));
+	current_folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(dialog->icon_filesel));
+	if (current_folder != NULL) {
+		purple_prefs_set_path(PIDGIN_PREFS_ROOT "/filelocations/last_icon_folder", current_folder);
+		g_free(current_folder);
+	}
+
+
+	if (dialog->callback)
+		dialog->callback(filename, dialog->data);
+	gtk_widget_destroy(dialog->icon_filesel);
+	g_free(filename);
+	g_free(dialog);
+ }
+
+
+static void
+icon_preview_change_cb(GtkFileChooser *widget, struct _icon_chooser *dialog)
+{
+	GdkPixbuf *pixbuf;
+	int height, width;
+	char *basename, *markup, *size;
+	struct stat st;
+	char *filename;
+
+	filename = gtk_file_chooser_get_preview_filename(
+					GTK_FILE_CHOOSER(dialog->icon_filesel));
+
+	if (!filename || g_stat(filename, &st) || !(pixbuf = pidgin_pixbuf_new_from_file_at_size(filename, 128, 128)))
+	{
+		gtk_image_set_from_pixbuf(GTK_IMAGE(dialog->icon_preview), NULL);
+		gtk_label_set_markup(GTK_LABEL(dialog->icon_text), "");
+		g_free(filename);
+		return;
+	}
+
+	gdk_pixbuf_get_file_info(filename, &width, &height);
+	basename = g_path_get_basename(filename);
+	size = purple_str_size_to_units(st.st_size);
+	markup = g_strdup_printf(_("<b>File:</b> %s\n"
+							   "<b>File size:</b> %s\n"
+							   "<b>Image size:</b> %dx%d"),
+							 basename, size, width, height);
+
+	gtk_image_set_from_pixbuf(GTK_IMAGE(dialog->icon_preview), pixbuf);
+	gtk_label_set_markup(GTK_LABEL(dialog->icon_text), markup);
+
+	g_object_unref(G_OBJECT(pixbuf));
+	g_free(filename);
+	g_free(basename);
+	g_free(size);
+	g_free(markup);
+}
+
+
+GtkWidget *pidgin_buddy_icon_chooser_new(GtkWindow *parent, void(*callback)(const char *, gpointer), gpointer data) {
+	struct _icon_chooser *dialog = g_new0(struct _icon_chooser, 1);
+
+	GtkWidget *vbox;
+	const char *current_folder;
+
+	dialog->callback = callback;
+	dialog->data = data;
+
+	current_folder = purple_prefs_get_path(PIDGIN_PREFS_ROOT "/filelocations/last_icon_folder");
+
+	dialog->icon_filesel = gtk_file_chooser_dialog_new(_("Buddy Icon"),
+							   parent,
+							   GTK_FILE_CHOOSER_ACTION_OPEN,
+							   GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+							   GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+							   NULL);
+	gtk_dialog_set_default_response(GTK_DIALOG(dialog->icon_filesel), GTK_RESPONSE_ACCEPT);
+	if ((current_folder != NULL) && (*current_folder != '\0'))
+		gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog->icon_filesel),
+						    current_folder);
+
+	dialog->icon_preview = gtk_image_new();
+	dialog->icon_text = gtk_label_new(NULL);
+
+	vbox = gtk_vbox_new(FALSE, PIDGIN_HIG_BOX_SPACE);
+	gtk_widget_set_size_request(GTK_WIDGET(vbox), -1, 50);
+	gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(dialog->icon_preview), TRUE, FALSE, 0);
+	gtk_box_pack_end(GTK_BOX(vbox), GTK_WIDGET(dialog->icon_text), FALSE, FALSE, 0);
+	gtk_widget_show_all(vbox);
+
+	gtk_file_chooser_set_preview_widget(GTK_FILE_CHOOSER(dialog->icon_filesel), vbox);
+	gtk_file_chooser_set_preview_widget_active(GTK_FILE_CHOOSER(dialog->icon_filesel), TRUE);
+	gtk_file_chooser_set_use_preview_label(GTK_FILE_CHOOSER(dialog->icon_filesel), FALSE);
+
+	g_signal_connect(G_OBJECT(dialog->icon_filesel), "update-preview",
+					 G_CALLBACK(icon_preview_change_cb), dialog);
+	g_signal_connect(G_OBJECT(dialog->icon_filesel), "response",
+					 G_CALLBACK(icon_filesel_choose_cb), dialog);
+	icon_preview_change_cb(NULL, dialog);
+
+#ifdef _WIN32
+	g_signal_connect(G_OBJECT(dialog->icon_filesel), "show",
+		G_CALLBACK(winpidgin_ensure_onscreen), dialog->icon_filesel);
+#endif
+
+	return dialog->icon_filesel;
+}
+
+/**
+ * @return True if any string from array a exists in array b.
+ */
+static gboolean
+str_array_match(char **a, char **b)
+{
+	int i, j;
+
+	if (!a || !b)
+		return FALSE;
+	for (i = 0; a[i] != NULL; i++)
+		for (j = 0; b[j] != NULL; j++)
+			if (!g_ascii_strcasecmp(a[i], b[j]))
+				return TRUE;
+	return FALSE;
+}
+
+gpointer
+pidgin_convert_buddy_icon(PurplePlugin *plugin, const char *path, size_t *len)
+{
+	PurplePluginProtocolInfo *prpl_info;
+	PurpleBuddyIconSpec *spec;
+	int orig_width, orig_height, new_width, new_height;
+	GdkPixbufFormat *format;
+	char **pixbuf_formats;
+	char **prpl_formats;
+	GError *error = NULL;
+	gchar *contents;
+	gsize length;
+	GdkPixbuf *pixbuf, *original;
+	float scale_factor;
+	int i;
+	gchar *tmp;
+
+	prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(plugin);
+	spec = &prpl_info->icon_spec;
+	g_return_val_if_fail(spec->format != NULL, NULL);
+
+	format = gdk_pixbuf_get_file_info(path, &orig_width, &orig_height);
+	if (format == NULL) {
+		purple_debug_warning("buddyicon", "Could not get file info of %s\n", path);
+		return NULL;
+	}
+
+	pixbuf_formats = gdk_pixbuf_format_get_extensions(format);
+	prpl_formats = g_strsplit(spec->format, ",", 0);
+
+	if (str_array_match(pixbuf_formats, prpl_formats) && /* This is an acceptable format AND */
+		 (!(spec->scale_rules & PURPLE_ICON_SCALE_SEND) || /* The prpl doesn't scale before it sends OR */
+		  (spec->min_width <= orig_width && spec->max_width >= orig_width &&
+		   spec->min_height <= orig_height && spec->max_height >= orig_height))) /* The icon is the correct size */
+	{
+		g_strfreev(pixbuf_formats);
+
+		if (!g_file_get_contents(path, &contents, &length, &error)) {
+			purple_debug_warning("buddyicon", "Could not get file contents "
+					"of %s: %s\n", path, error->message);
+			g_strfreev(prpl_formats);
+			return NULL;
+		}
+
+		if (spec->max_filesize == 0 || length < spec->max_filesize) {
+			/* The supplied image fits the file size, dimensions and type
+			   constraints.  Great!  Return it without making any changes. */
+			if (len)
+				*len = length;
+			g_strfreev(prpl_formats);
+			return contents;
+		}
+
+		/* The image was too big.  Fall-through and try scaling it down. */
+		g_free(contents);
+	} else {
+		g_strfreev(pixbuf_formats);
+	}
+
+	/* The original image wasn't compatible.  Scale it or convert file type. */
+	pixbuf = gdk_pixbuf_new_from_file(path, &error);
+	if (error) {
+		purple_debug_warning("buddyicon", "Could not open icon '%s' for "
+				"conversion: %s\n", path, error->message);
+		g_error_free(error);
+		g_strfreev(prpl_formats);
+		return NULL;
+	}
+	original = g_object_ref(G_OBJECT(pixbuf));
+
+	new_width = orig_width;
+	new_height = orig_height;
+
+	/* Make sure the image is the correct dimensions */
+	if (spec->scale_rules & PURPLE_ICON_SCALE_SEND &&
+		(orig_width < spec->min_width || orig_width > spec->max_width ||
+		 orig_height < spec->min_height || orig_height > spec->max_height))
+	{
+		purple_buddy_icon_get_scale_size(spec, &new_width, &new_height);
+
+		g_object_unref(G_OBJECT(pixbuf));
+		pixbuf = gdk_pixbuf_scale_simple(original, new_width, new_height, GDK_INTERP_HYPER);
+	}
+
+	scale_factor = 1;
+	do {
+		for (i = 0; prpl_formats[i]; i++) {
+			int quality = 100;
+			do {
+				const char *key = NULL;
+				const char *value = NULL;
+				gchar tmp_buf[4];
+
+				purple_debug_info("buddyicon", "Converting buddy icon to %s\n", prpl_formats[i]);
+
+				if (g_str_equal(prpl_formats[i], "png")) {
+					key = "compression";
+					value = "9";
+				} else if (g_str_equal(prpl_formats[i], "jpeg")) {
+					sprintf(tmp_buf, "%u", quality);
+					key = "quality";
+					value = tmp_buf;
+				}
+
+				if (!gdk_pixbuf_save_to_buffer(pixbuf, &contents, &length,
+						prpl_formats[i], &error, key, value, NULL))
+				{
+					/* The NULL checking of error is necessary due to this bug:
+					 * http://bugzilla.gnome.org/show_bug.cgi?id=405539 */
+					purple_debug_warning("buddyicon",
+							"Could not convert to %s: %s\n", prpl_formats[i],
+							(error && error->message) ? error->message : "Unknown error");
+					g_error_free(error);
+					error = NULL;
+
+					/* We couldn't convert to this image type.  Try the next
+					   image type. */
+					break;
+				}
+
+				if (spec->max_filesize == 0 || length <= spec->max_filesize) {
+					/* We were able to save the image as this image type and
+					   have it be within the size constraints.  Great!  Return
+					   the image. */
+					purple_debug_info("buddyicon", "Converted image from "
+							"%dx%d to %dx%d, format=%s, quality=%u, "
+							"filesize=%zu\n", orig_width, orig_height,
+							new_width, new_height, prpl_formats[i], quality,
+							length);
+					if (len)
+						*len = length;
+					g_strfreev(prpl_formats);
+					g_object_unref(G_OBJECT(pixbuf));
+					g_object_unref(G_OBJECT(original));
+					return contents;
+				}
+
+				g_free(contents);
+
+				if (!g_str_equal(prpl_formats[i], "jpeg")) {
+					/* File size was too big and we can't lower the quality,
+					   so skip to the next image type. */
+					break;
+				}
+
+				/* File size was too big, but we're dealing with jpeg so try
+				   lowering the quality. */
+				quality -= 5;
+			} while (quality >= 70);
+		}
+
+		/* We couldn't save the image in any format that was below the max
+		   file size.  Maybe we can reduce the image dimensions? */
+		scale_factor *= 0.8;
+		new_width = orig_width * scale_factor;
+		new_height = orig_height * scale_factor;
+		g_object_unref(G_OBJECT(pixbuf));
+		pixbuf = gdk_pixbuf_scale_simple(original, new_width, new_height, GDK_INTERP_HYPER);
+	} while ((new_width > 10 || new_height > 10) && new_width > spec->min_width && new_height > spec->min_height);
+	g_strfreev(prpl_formats);
+	g_object_unref(G_OBJECT(pixbuf));
+	g_object_unref(G_OBJECT(original));
+
+	tmp = g_strdup_printf(_("The file '%s' is too large for %s.  Please try a smaller image.\n"),
+			path, plugin->info->name);
+	purple_notify_error(NULL, _("Icon Error"), _("Could not set icon"), tmp);
+	g_free(tmp);
+
+	return NULL;
+}
+
+void pidgin_set_custom_buddy_icon(PurpleAccount *account, const char *who, const char *filename)
+{
+	PurpleBuddy *buddy;
+	PurpleContact *contact;
+
+	buddy = purple_find_buddy(account, who);
+	if (!buddy) {
+		purple_debug_info("custom-icon", "You can only set custom icon for someone in your buddylist.\n");
+		return;
+	}
+
+	contact = purple_buddy_get_contact(buddy);
+	purple_buddy_icons_node_set_custom_icon_from_file((PurpleBlistNode*)contact, filename);
+}
+
+char *pidgin_make_pretty_arrows(const char *str)
+{
+	char *ret;
+	char **split = g_strsplit(str, "->", -1);
+	ret = g_strjoinv("\342\207\250", split);
+	g_strfreev(split);
+
+	split = g_strsplit(ret, "<-", -1);
+	g_free(ret);
+	ret = g_strjoinv("\342\207\246", split);
+	g_strfreev(split);
+
+	return ret;
+}
+
+void pidgin_set_urgent(GtkWindow *window, gboolean urgent)
+{
+#if defined _WIN32
+	winpidgin_window_flash(window, urgent);
+#else
+	gtk_window_set_urgency_hint(window, urgent);
+#endif
+}
+
+static GSList *minidialogs = NULL;
+
+static void *
+pidgin_utils_get_handle(void)
+{
+	static int handle;
+
+	return &handle;
+}
+
+static void connection_signed_off_cb(PurpleConnection *gc)
+{
+	GSList *list, *l_next;
+	for (list = minidialogs; list; list = l_next) {
+		l_next = list->next;
+		if (g_object_get_data(G_OBJECT(list->data), "gc") == gc) {
+				gtk_widget_destroy(GTK_WIDGET(list->data));
+		}
+	}
+}
+
+static void alert_killed_cb(GtkWidget *widget)
+{
+	minidialogs = g_slist_remove(minidialogs, widget);
+}
+
+struct _old_button_clicked_cb_data
+{
+	PidginUtilMiniDialogCallback cb;
+	gpointer data;
+};
+
+static void
+old_mini_dialog_button_clicked_cb(PidginMiniDialog *mini_dialog,
+                                  GtkButton *button,
+                                  gpointer user_data)
+{
+	struct _old_button_clicked_cb_data *data = user_data;
+	data->cb(data->data, button);
+}
+
+static void
+old_mini_dialog_destroy_cb(GtkWidget *dialog,
+                           GList *cb_datas)
+{
+	while (cb_datas != NULL)
+	{
+		g_free(cb_datas->data);
+		cb_datas = g_list_delete_link(cb_datas, cb_datas);
+	}
+}
+
+static void
+mini_dialog_init(PidginMiniDialog *mini_dialog, PurpleConnection *gc, void *user_data, va_list args)
+{
+	const char *button_text;
+	GList *cb_datas = NULL;
+	static gboolean first_call = TRUE;
+
+	if (first_call) {
+		first_call = FALSE;
+		purple_signal_connect(purple_connections_get_handle(), "signed-off",
+		                      pidgin_utils_get_handle(),
+		                      PURPLE_CALLBACK(connection_signed_off_cb), NULL);
+	}
+
+	g_object_set_data(G_OBJECT(mini_dialog), "gc" ,gc);
+	g_signal_connect(G_OBJECT(mini_dialog), "destroy",
+		G_CALLBACK(alert_killed_cb), NULL);
+
+	while ((button_text = va_arg(args, char*))) {
+		struct _old_button_clicked_cb_data *data = NULL;
+		PidginMiniDialogCallback wrapper_cb = NULL;
+		PidginUtilMiniDialogCallback callback =
+			va_arg(args, PidginUtilMiniDialogCallback);
+
+		if (callback != NULL) {
+			data = g_new0(struct _old_button_clicked_cb_data, 1);
+			data->cb = callback;
+			data->data = user_data;
+			wrapper_cb = old_mini_dialog_button_clicked_cb;
+		}
+		pidgin_mini_dialog_add_button(mini_dialog, button_text,
+			wrapper_cb, data);
+		cb_datas = g_list_append(cb_datas, data);
+	}
+
+	g_signal_connect(G_OBJECT(mini_dialog), "destroy",
+		G_CALLBACK(old_mini_dialog_destroy_cb), cb_datas);
+}
+
+#define INIT_AND_RETURN_MINI_DIALOG(mini_dialog) \
+	va_list args; \
+	va_start(args, user_data); \
+	mini_dialog_init(mini_dialog, gc, user_data, args); \
+	va_end(args); \
+	return GTK_WIDGET(mini_dialog);
+
+GtkWidget *
+pidgin_make_mini_dialog(PurpleConnection *gc,
+                        const char *icon_name,
+                        const char *primary,
+                        const char *secondary,
+                        void *user_data,
+                        ...)
+{
+	PidginMiniDialog *mini_dialog = pidgin_mini_dialog_new(primary, secondary, icon_name);
+	INIT_AND_RETURN_MINI_DIALOG(mini_dialog);
+}
+
+GtkWidget *
+pidgin_make_mini_dialog_with_custom_icon(PurpleConnection *gc,
+					GdkPixbuf *custom_icon,
+					const char *primary,
+					const char *secondary,
+					void *user_data,
+					...)
+{
+	PidginMiniDialog *mini_dialog = pidgin_mini_dialog_new_with_custom_icon(primary, secondary, custom_icon);
+	INIT_AND_RETURN_MINI_DIALOG(mini_dialog);
+}
+
+/*
+ * "This is so dead sexy."
+ * "Two thumbs up."
+ * "Best movie of the year."
+ *
+ * This is the function that handles CTRL+F searching in the buddy list.
+ * It finds the top-most buddy/group/chat/whatever containing the
+ * entered string.
+ *
+ * It's somewhat ineffecient, because we strip all the HTML from the
+ * "name" column of the buddy list (because the GtkTreeModel does not
+ * contain the screen name in a non-markedup format).  But the alternative
+ * is to add an extra column to the GtkTreeModel.  And this function is
+ * used rarely, so it shouldn't matter TOO much.
+ */
+gboolean pidgin_tree_view_search_equal_func(GtkTreeModel *model, gint column,
+			const gchar *key, GtkTreeIter *iter, gpointer data)
+{
+	gchar *enteredstring;
+	gchar *tmp;
+	gchar *withmarkup;
+	gchar *nomarkup;
+	gchar *normalized;
+	gboolean result;
+	size_t i;
+	size_t len;
+	PangoLogAttr *log_attrs;
+	gchar *word;
+
+	if (g_ascii_strcasecmp(key, "Global Thermonuclear War") == 0)
+	{
+		purple_notify_info(NULL, "WOPR",
+				"Wouldn't you prefer a nice game of chess?", NULL);
+		return FALSE;
+	}
+
+	gtk_tree_model_get(model, iter, column, &withmarkup, -1);
+	if (withmarkup == NULL)   /* This is probably a separator */
+		return TRUE;
+
+	tmp = g_utf8_normalize(key, -1, G_NORMALIZE_DEFAULT);
+	enteredstring = g_utf8_casefold(tmp, -1);
+	g_free(tmp);
+
+	nomarkup = purple_markup_strip_html(withmarkup);
+	tmp = g_utf8_normalize(nomarkup, -1, G_NORMALIZE_DEFAULT);
+	g_free(nomarkup);
+	normalized = g_utf8_casefold(tmp, -1);
+	g_free(tmp);
+
+	if (purple_str_has_prefix(normalized, enteredstring))
+	{
+		g_free(withmarkup);
+		g_free(enteredstring);
+		g_free(normalized);
+		return FALSE;
+	}
+
+
+	/* Use Pango to separate by words. */
+	len = g_utf8_strlen(normalized, -1);
+	log_attrs = g_new(PangoLogAttr, len + 1);
+
+	pango_get_log_attrs(normalized, strlen(normalized), -1, NULL, log_attrs, len + 1);
+
+	word = normalized;
+	result = TRUE;
+	for (i = 0; i < (len - 1) ; i++)
+	{
+		if (log_attrs[i].is_word_start &&
+		    purple_str_has_prefix(word, enteredstring))
+		{
+			result = FALSE;
+			break;
+		}
+		word = g_utf8_next_char(word);
+	}
+	g_free(log_attrs);
+
+/* The non-Pango version. */
+#if 0
+	word = normalized;
+	result = TRUE;
+	while (word[0] != '\0')
+	{
+		gunichar c = g_utf8_get_char(word);
+		if (!g_unichar_isalnum(c))
+		{
+			word = g_utf8_find_next_char(word, NULL);
+			if (purple_str_has_prefix(word, enteredstring))
+			{
+				result = FALSE;
+				break;
+			}
+		}
+		else
+			word = g_utf8_find_next_char(word, NULL);
+	}
+#endif
+
+	g_free(withmarkup);
+	g_free(enteredstring);
+	g_free(normalized);
+
+	return result;
+}
+
+
+gboolean pidgin_gdk_pixbuf_is_opaque(GdkPixbuf *pixbuf) {
+	int height, rowstride, i;
+	unsigned char *pixels;
+	unsigned char *row;
+
+	if (!gdk_pixbuf_get_has_alpha(pixbuf))
+		return TRUE;
+
+	height = gdk_pixbuf_get_height (pixbuf);
+	rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+	pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+	row = pixels;
+	for (i = 3; i < rowstride; i+=4) {
+		if (row[i] < 0xfe)
+			return FALSE;
+	}
+
+	for (i = 1; i < height - 1; i++) {
+		row = pixels + (i * rowstride);
+		if (row[3] < 0xfe || row[rowstride - 1] < 0xfe) {
+			return FALSE;
+	    }
+	}
+
+	row = pixels + ((height - 1) * rowstride);
+	for (i = 3; i < rowstride; i += 4) {
+		if (row[i] < 0xfe)
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+void pidgin_gdk_pixbuf_make_round(GdkPixbuf *pixbuf) {
+	int width, height, rowstride;
+	guchar *pixels;
+	if (!gdk_pixbuf_get_has_alpha(pixbuf))
+		return;
+	width = gdk_pixbuf_get_width(pixbuf);
+	height = gdk_pixbuf_get_height(pixbuf);
+	rowstride = gdk_pixbuf_get_rowstride(pixbuf);
+	pixels = gdk_pixbuf_get_pixels(pixbuf);
+
+	if (width < 6 || height < 6)
+		return;
+	/* Top left */
+	pixels[3] = 0;
+	pixels[7] = 0x80;
+	pixels[11] = 0xC0;
+	pixels[rowstride + 3] = 0x80;
+	pixels[rowstride * 2 + 3] = 0xC0;
+
+	/* Top right */
+	pixels[width * 4 - 1] = 0;
+	pixels[width * 4 - 5] = 0x80;
+	pixels[width * 4 - 9] = 0xC0;
+	pixels[rowstride + (width * 4) - 1] = 0x80;
+	pixels[(2 * rowstride) + (width * 4) - 1] = 0xC0;
+
+	/* Bottom left */
+	pixels[(height - 1) * rowstride + 3] = 0;
+	pixels[(height - 1) * rowstride + 7] = 0x80;
+	pixels[(height - 1) * rowstride + 11] = 0xC0;
+	pixels[(height - 2) * rowstride + 3] = 0x80;
+	pixels[(height - 3) * rowstride + 3] = 0xC0;
+
+	/* Bottom right */
+	pixels[height * rowstride - 1] = 0;
+	pixels[(height - 1) * rowstride - 1] = 0x80;
+	pixels[(height - 2) * rowstride - 1] = 0xC0;
+	pixels[height * rowstride - 5] = 0x80;
+	pixels[height * rowstride - 9] = 0xC0;
+}
+
+const char *pidgin_get_dim_grey_string(GtkWidget *widget) {
+	static char dim_grey_string[8] = "";
+	GtkStyle *style;
+
+	if (!widget)
+		return "dim grey";
+
+ 	style = gtk_widget_get_style(widget);
+	if (!style)
+		return "dim grey";
+
+	snprintf(dim_grey_string, sizeof(dim_grey_string), "#%02x%02x%02x",
+	style->text_aa[GTK_STATE_NORMAL].red >> 8,
+	style->text_aa[GTK_STATE_NORMAL].green >> 8,
+	style->text_aa[GTK_STATE_NORMAL].blue >> 8);
+	return dim_grey_string;
+}
+
+static void
+combo_box_changed_cb(GtkComboBox *combo_box, GtkEntry *entry)
+{
+	char *text = gtk_combo_box_get_active_text(combo_box);
+	gtk_entry_set_text(entry, text ? text : "");
+	g_free(text);
+}
+
+static gboolean
+entry_key_pressed_cb(GtkWidget *entry, GdkEventKey *key, GtkComboBox *combo)
+{
+	if (key->keyval == GDK_Down || key->keyval == GDK_Up) {
+		gtk_combo_box_popup(combo);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+GtkWidget *
+pidgin_text_combo_box_entry_new(const char *default_item, GList *items)
+{
+	GtkComboBox *ret = NULL;
+	GtkWidget *the_entry = NULL;
+
+	ret = GTK_COMBO_BOX(gtk_combo_box_entry_new_text());
+	the_entry = gtk_entry_new();
+	gtk_container_add(GTK_CONTAINER(ret), the_entry);
+
+	if (default_item)
+		gtk_entry_set_text(GTK_ENTRY(the_entry), default_item);
+
+	for (; items != NULL ; items = items->next) {
+		char *text = items->data;
+		if (text && *text)
+			gtk_combo_box_append_text(ret, text);
+	}
+
+	g_signal_connect(G_OBJECT(ret), "changed", (GCallback)combo_box_changed_cb, the_entry);
+	g_signal_connect_after(G_OBJECT(the_entry), "key-press-event", G_CALLBACK(entry_key_pressed_cb), ret);
+
+	return GTK_WIDGET(ret);
+}
+
+const char *pidgin_text_combo_box_entry_get_text(GtkWidget *widget)
+{
+	return gtk_entry_get_text(GTK_ENTRY(GTK_BIN((widget))->child));
+}
+
+void pidgin_text_combo_box_entry_set_text(GtkWidget *widget, const char *text)
+{
+	gtk_entry_set_text(GTK_ENTRY(GTK_BIN((widget))->child), (text));
+}
+
+GtkWidget *
+pidgin_add_widget_to_vbox(GtkBox *vbox, const char *widget_label, GtkSizeGroup *sg, GtkWidget *widget, gboolean expand, GtkWidget **p_label)
+{
+	GtkWidget *hbox;
+	GtkWidget *label = NULL;
+
+	if (widget_label) {
+		hbox = gtk_hbox_new(FALSE, 5);
+		gtk_widget_show(hbox);
+		gtk_box_pack_start(vbox, hbox, FALSE, FALSE, 0);
+
+		label = gtk_label_new_with_mnemonic(widget_label);
+		gtk_widget_show(label);
+		if (sg) {
+			gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
+			gtk_size_group_add_widget(sg, label);
+		}
+		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
+	} else {
+		hbox = GTK_WIDGET(vbox);
+	}
+
+	gtk_widget_show(widget);
+	gtk_box_pack_start(GTK_BOX(hbox), widget, expand, TRUE, 0);
+	if (label) {
+		gtk_label_set_mnemonic_widget(GTK_LABEL(label), widget);
+		pidgin_set_accessible_label (widget, label);
+	}
+
+	if (p_label)
+		(*p_label) = label;
+	return hbox;
+}
+
+gboolean pidgin_auto_parent_window(GtkWidget *widget)
+{
+#if 0
+	/* This looks at the most recent window that received focus, and makes
+	 * that the parent window. */
+#ifndef _WIN32
+	static GdkAtom _WindowTime = GDK_NONE;
+	static GdkAtom _Cardinal = GDK_NONE;
+	GList *windows = NULL;
+	GtkWidget *parent = NULL;
+	time_t window_time = 0;
+
+	windows = gtk_window_list_toplevels();
+
+	if (_WindowTime == GDK_NONE) {
+		_WindowTime = gdk_x11_xatom_to_atom(gdk_x11_get_xatom_by_name("_NET_WM_USER_TIME"));
+	}
+	if (_Cardinal == GDK_NONE) {
+		_Cardinal = gdk_atom_intern("CARDINAL", FALSE);
+	}
+
+	while (windows) {
+		GtkWidget *window = windows->data;
+		guchar *data = NULL;
+		int al = 0;
+		time_t value;
+
+		windows = g_list_delete_link(windows, windows);
+
+		if (window == widget ||
+				!GTK_WIDGET_VISIBLE(window))
+			continue;
+
+		if (!gdk_property_get(window->window, _WindowTime, _Cardinal, 0, sizeof(time_t), FALSE,
+				NULL, NULL, &al, &data))
+			continue;
+		value = *(time_t *)data;
+		if (window_time < value) {
+			window_time = value;
+			parent = window;
+		}
+		g_free(data);
+	}
+	if (windows)
+		g_list_free(windows);
+	if (parent) {
+		if (!gtk_get_current_event() && gtk_window_has_toplevel_focus(GTK_WINDOW(parent))) {
+			/* The window is in focus, and the new window was not triggered by a keypress/click
+			 * event. So do not set it transient, to avoid focus stealing and all that.
+			 */
+			return FALSE;
+		}
+		gtk_window_set_transient_for(GTK_WINDOW(widget), GTK_WINDOW(parent));
+		return TRUE;
+	}
+	return FALSE;
+#endif
+#else
+	/* This finds the currently active window and makes that the parent window. */
+	GList *windows = NULL;
+	GtkWidget *parent = NULL;
+	GdkEvent *event = gtk_get_current_event();
+	GdkWindow *menu = NULL;
+
+	if (event == NULL)
+		/* The window was not triggered by a user action. */
+		return FALSE;
+
+	/* We need to special case events from a popup menu. */
+	if (event->type == GDK_BUTTON_RELEASE) {
+		/* XXX: Neither of the following works:
+			menu = event->button.window;
+			menu = gdk_window_get_parent(event->button.window);
+			menu = gdk_window_get_toplevel(event->button.window);
+		*/
+	} else if (event->type == GDK_KEY_PRESS)
+		menu = event->key.window;
+
+	windows = gtk_window_list_toplevels();
+	while (windows) {
+		GtkWidget *window = windows->data;
+		windows = g_list_delete_link(windows, windows);
+
+		if (window == widget ||
+				!GTK_WIDGET_VISIBLE(window)) {
+			continue;
+		}
+
+		if (gtk_window_has_toplevel_focus(GTK_WINDOW(window)) ||
+				(menu && menu == window->window)) {
+			parent = window;
+			break;
+		}
+	}
+	if (windows)
+		g_list_free(windows);
+	if (parent) {
+		gtk_window_set_transient_for(GTK_WINDOW(widget), GTK_WINDOW(parent));
+		return TRUE;
+	}
+	return FALSE;
+#endif
+}
+
+static GObject *pidgin_pixbuf_from_data_helper(const guchar *buf, gsize count, gboolean animated)
+{
+	GObject *pixbuf;
+	GdkPixbufLoader *loader;
+	GError *error = NULL;
+
+	loader = gdk_pixbuf_loader_new();
+
+	if (!gdk_pixbuf_loader_write(loader, buf, count, &error) || error) {
+		purple_debug_warning("gtkutils", "gdk_pixbuf_loader_write() "
+				"failed with size=%zu: %s\n", count,
+				error ? error->message : "(no error message)");
+		if (error)
+			g_error_free(error);
+		g_object_unref(G_OBJECT(loader));
+		return NULL;
+	}
+
+	if (!gdk_pixbuf_loader_close(loader, &error) || error) {
+		purple_debug_warning("gtkutils", "gdk_pixbuf_loader_close() "
+				"failed for image of size %zu: %s\n", count,
+				error ? error->message : "(no error message)");
+		if (error)
+			g_error_free(error);
+		g_object_unref(G_OBJECT(loader));
+		return NULL;
+	}
+
+	if (animated)
+		pixbuf = G_OBJECT(gdk_pixbuf_loader_get_animation(loader));
+	else
+		pixbuf = G_OBJECT(gdk_pixbuf_loader_get_pixbuf(loader));
+	if (!pixbuf) {
+		purple_debug_warning("gtkutils", "%s() returned NULL for image "
+				"of size %zu\n",
+				animated ? "gdk_pixbuf_loader_get_animation"
+					: "gdk_pixbuf_loader_get_pixbuf", count);
+		g_object_unref(G_OBJECT(loader));
+		return NULL;
+	}
+
+	g_object_ref(pixbuf);
+	g_object_unref(G_OBJECT(loader));
+
+	return pixbuf;
+}
+
+GdkPixbuf *pidgin_pixbuf_from_data(const guchar *buf, gsize count)
+{
+	return GDK_PIXBUF(pidgin_pixbuf_from_data_helper(buf, count, FALSE));
+}
+
+GdkPixbufAnimation *pidgin_pixbuf_anim_from_data(const guchar *buf, gsize count)
+{
+	return GDK_PIXBUF_ANIMATION(pidgin_pixbuf_from_data_helper(buf, count, TRUE));
+}
+
+GdkPixbuf *pidgin_pixbuf_from_imgstore(PurpleStoredImage *image)
+{
+	return pidgin_pixbuf_from_data(purple_imgstore_get_data(image),
+			purple_imgstore_get_size(image));
+}
+
+GdkPixbuf *pidgin_pixbuf_new_from_file(const gchar *filename)
+{
+	GdkPixbuf *pixbuf;
+	GError *error = NULL;
+
+	pixbuf = gdk_pixbuf_new_from_file(filename, &error);
+	if (!pixbuf || error) {
+		purple_debug_warning("gtkutils", "gdk_pixbuf_new_from_file() "
+				"returned %s for file %s: %s\n",
+				pixbuf ? "something" : "nothing",
+				filename,
+				error ? error->message : "(no error message)");
+		if (error)
+			g_error_free(error);
+		if (pixbuf)
+			g_object_unref(G_OBJECT(pixbuf));
+		return NULL;
+	}
+
+	return pixbuf;
+}
+
+GdkPixbuf *pidgin_pixbuf_new_from_file_at_size(const char *filename, int width, int height)
+{
+	GdkPixbuf *pixbuf;
+	GError *error = NULL;
+
+	pixbuf = gdk_pixbuf_new_from_file_at_size(filename,
+			width, height, &error);
+	if (!pixbuf || error) {
+		purple_debug_warning("gtkutils", "gdk_pixbuf_new_from_file_at_size() "
+				"returned %s for file %s: %s\n",
+				pixbuf ? "something" : "nothing",
+				filename,
+				error ? error->message : "(no error message)");
+		if (error)
+			g_error_free(error);
+		if (pixbuf)
+			g_object_unref(G_OBJECT(pixbuf));
+		return NULL;
+	}
+
+	return pixbuf;
+}
+
+GdkPixbuf *pidgin_pixbuf_new_from_file_at_scale(const char *filename, int width, int height, gboolean preserve_aspect_ratio)
+{
+	GdkPixbuf *pixbuf;
+	GError *error = NULL;
+
+	pixbuf = gdk_pixbuf_new_from_file_at_scale(filename,
+			width, height, preserve_aspect_ratio, &error);
+	if (!pixbuf || error) {
+		purple_debug_warning("gtkutils", "gdk_pixbuf_new_from_file_at_scale() "
+				"returned %s for file %s: %s\n",
+				pixbuf ? "something" : "nothing",
+				filename,
+				error ? error->message : "(no error message)");
+		if (error)
+			g_error_free(error);
+		if (pixbuf)
+			g_object_unref(G_OBJECT(pixbuf));
+		return NULL;
+	}
+
+	return pixbuf;
+}
+
+static void url_copy(GtkWidget *w, gchar *url)
+{
+	GtkClipboard *clipboard;
+
+	clipboard = gtk_widget_get_clipboard(w, GDK_SELECTION_PRIMARY);
+	gtk_clipboard_set_text(clipboard, url, -1);
+
+	clipboard = gtk_widget_get_clipboard(w, GDK_SELECTION_CLIPBOARD);
+	gtk_clipboard_set_text(clipboard, url, -1);
+}
+
+static gboolean
+link_context_menu(GtkIMHtml *imhtml, GtkIMHtmlLink *link, GtkWidget *menu)
+{
+	GtkWidget *img, *item;
+	const char *url;
+
+	url = gtk_imhtml_link_get_url(link);
+
+	/* Open Link */
+	img = gtk_image_new_from_stock(GTK_STOCK_JUMP_TO, GTK_ICON_SIZE_MENU);
+	item = gtk_image_menu_item_new_with_mnemonic(_("_Open Link"));
+	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), img);
+	g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(gtk_imhtml_link_activate), link);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+
+	/* Copy Link Location */
+	img = gtk_image_new_from_stock(GTK_STOCK_COPY, GTK_ICON_SIZE_MENU);
+	item = gtk_image_menu_item_new_with_mnemonic(_("_Copy Link Location"));
+	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), img);
+	g_signal_connect(G_OBJECT(item), "activate", G_CALLBACK(url_copy), (gpointer)url);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+
+	return TRUE;
+}
+
+static gboolean
+copy_email_address(GtkIMHtml *imhtml, GtkIMHtmlLink *link, GtkWidget *menu)
+{
+	GtkWidget *img, *item;
+	const char *text;
+	char *address;
+#define MAILTOSIZE  (sizeof("mailto:") - 1)
+
+	text = gtk_imhtml_link_get_url(link);
+	g_return_val_if_fail(text && strlen(text) > MAILTOSIZE, FALSE);
+	address = (char*)text + MAILTOSIZE;
+
+	/* Copy Email Address */
+	img = gtk_image_new_from_stock(GTK_STOCK_COPY, GTK_ICON_SIZE_MENU);
+	item = gtk_image_menu_item_new_with_mnemonic(_("_Copy Email Address"));
+	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), img);
+	g_signal_connect(G_OBJECT(item), "activate", G_CALLBACK(url_copy), address);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+
+	return TRUE;
+}
+
+/**
+ * @param filename The path to a file. Specifically this is the link target
+ *        from a link in an IM window with the leading "file://" removed.
+ */
+static void
+open_file(GtkIMHtml *imhtml, const char *filename)
+{
+	/* Copied from gtkft.c:open_button_cb */
+#ifdef _WIN32
+	/* If using Win32... */
+	int code;
+	/* Escape URI by replacing double-quote with 2 double-quotes. */
+	gchar *escaped = purple_strreplace(filename, "\"", "\"\"");
+	gchar *param = g_strconcat("/select,\"", escaped, "\"", NULL);
+	wchar_t *wc_param = g_utf8_to_utf16(param, -1, NULL, NULL, NULL);
+
+	/* TODO: Better to use SHOpenFolderAndSelectItems()? */
+	code = (int)ShellExecuteW(NULL, L"OPEN", L"explorer.exe", wc_param, NULL, SW_NORMAL);
+
+	g_free(wc_param);
+	g_free(param);
+	g_free(escaped);
+
+	if (code == SE_ERR_ASSOCINCOMPLETE || code == SE_ERR_NOASSOC)
+	{
+		purple_notify_error(imhtml, NULL,
+				_("There is no application configured to open this type of file."), NULL);
+	}
+	else if (code < 32)
+	{
+		purple_notify_error(imhtml, NULL,
+				_("An error occurred while opening the file."), NULL);
+		purple_debug_warning("gtkutils", "filename: %s; code: %d\n",
+				filename, code);
+	}
+#else
+	char *command = NULL;
+	char *tmp = NULL;
+	GError *error = NULL;
+
+	if (purple_running_gnome())
+	{
+		char *escaped = g_shell_quote(filename);
+		command = g_strdup_printf("gnome-open %s", escaped);
+		g_free(escaped);
+	}
+	else if (purple_running_kde())
+	{
+		char *escaped = g_shell_quote(filename);
+
+		if (purple_str_has_suffix(filename, ".desktop"))
+			command = g_strdup_printf("kfmclient openURL %s 'text/plain'", escaped);
+		else
+			command = g_strdup_printf("kfmclient openURL %s", escaped);
+		g_free(escaped);
+	}
+	else
+	{
+		purple_notify_uri(NULL, filename);
+		return;
+	}
+
+	if (purple_program_is_valid(command))
+	{
+		gint exit_status;
+		if (!g_spawn_command_line_sync(command, NULL, NULL, &exit_status, &error))
+		{
+			tmp = g_strdup_printf(_("Error launching %s: %s"),
+							filename, error->message);
+			purple_notify_error(imhtml, NULL, _("Unable to open file."), tmp);
+			g_free(tmp);
+			g_error_free(error);
+		}
+		if (exit_status != 0)
+		{
+			char *primary = g_strdup_printf(_("Error running %s"), command);
+			char *secondary = g_strdup_printf(_("Process returned error code %d"),
+									exit_status);
+			purple_notify_error(imhtml, NULL, primary, secondary);
+			g_free(tmp);
+		}
+	}
+#endif
+}
+
+#define FILELINKSIZE  (sizeof("file://") - 1)
+static gboolean
+file_clicked_cb(GtkIMHtml *imhtml, GtkIMHtmlLink *link)
+{
+	/* Strip "file://" from the URI. */
+	const char *filename = gtk_imhtml_link_get_url(link) + FILELINKSIZE;
+	open_file(imhtml, filename);
+	return TRUE;
+}
+
+static gboolean
+open_containing_cb(GtkIMHtml *imhtml, const char *url)
+{
+	char *dir = g_path_get_dirname(url + FILELINKSIZE);
+	open_file(imhtml, dir);
+	g_free(dir);
+	return TRUE;
+}
+
+static gboolean
+file_context_menu(GtkIMHtml *imhtml, GtkIMHtmlLink *link, GtkWidget *menu)
+{
+	GtkWidget *img, *item;
+	const char *url;
+
+	url = gtk_imhtml_link_get_url(link);
+
+	/* Open File */
+	img = gtk_image_new_from_stock(GTK_STOCK_JUMP_TO, GTK_ICON_SIZE_MENU);
+	item = gtk_image_menu_item_new_with_mnemonic(_("_Open File"));
+	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), img);
+	g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(gtk_imhtml_link_activate), link);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+
+	/* Open Containing Directory */
+	img = gtk_image_new_from_stock(GTK_STOCK_DIRECTORY, GTK_ICON_SIZE_MENU);
+	item = gtk_image_menu_item_new_with_mnemonic(_("Open _Containing Directory"));
+	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), img);
+
+	g_signal_connect(G_OBJECT(item), "activate", G_CALLBACK(open_containing_cb), (gpointer)url);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+
+	return TRUE;
+}
+
+#define AUDIOLINKSIZE  (sizeof("audio://") - 1)
+static gboolean
+audio_clicked_cb(GtkIMHtml *imhtml, GtkIMHtmlLink *link)
+{
+	const char *uri;
+	PidginConversation *conv = g_object_get_data(G_OBJECT(imhtml), "gtkconv");
+	if (!conv) /* no playback in debug window */
+		return TRUE;
+	uri = gtk_imhtml_link_get_url(link) + AUDIOLINKSIZE;
+	purple_sound_play_file(uri, NULL);
+	return TRUE;
+}
+
+static void
+savefile_write_cb(gpointer user_data, char *file)
+{
+	char *temp_file = user_data;
+	gchar *contents;
+	gsize length;
+	GError *error = NULL;
+
+	if (!g_file_get_contents(temp_file, &contents, &length, &error)) {
+		purple_debug_error("gtkutils", "Unable to read contents of %s: %s\n",
+		                   temp_file, error->message);
+		g_error_free(error);
+		return;
+	}
+
+	if (!purple_util_write_data_to_file_absolute(file, contents, length)) {
+		purple_debug_error("gtkutils", "Unable to write contents to %s\n",
+		                   file);
+	}
+}
+
+static gboolean
+save_file_cb(GtkWidget *item, const char *url)
+{
+	PidginConversation *conv = g_object_get_data(G_OBJECT(item), "gtkconv");
+	if (!conv)
+		return TRUE;
+	purple_request_file(conv->active_conv, _("Save File"), NULL, TRUE,
+	                    G_CALLBACK(savefile_write_cb), NULL,
+	                    conv->active_conv->account, NULL, conv->active_conv,
+	                    (void *)url);
+	return TRUE;
+}
+
+static gboolean
+audio_context_menu(GtkIMHtml *imhtml, GtkIMHtmlLink *link, GtkWidget *menu)
+{
+	GtkWidget *img, *item;
+	const char *url;
+	PidginConversation *conv = g_object_get_data(G_OBJECT(imhtml), "gtkconv");
+	if (!conv) /* No menu in debug window */
+		return TRUE;
+
+	url = gtk_imhtml_link_get_url(link);
+
+	/* Play Sound */
+	img = gtk_image_new_from_stock(GTK_STOCK_MEDIA_PLAY, GTK_ICON_SIZE_MENU);
+	item = gtk_image_menu_item_new_with_mnemonic(_("_Play Sound"));
+	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), img);
+
+	g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(gtk_imhtml_link_activate), link);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+
+	/* Save File */
+	img = gtk_image_new_from_stock(GTK_STOCK_SAVE, GTK_ICON_SIZE_MENU);
+	item = gtk_image_menu_item_new_with_mnemonic(_("_Save File"));
+	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), img);
+	g_signal_connect(G_OBJECT(item), "activate", G_CALLBACK(save_file_cb), (gpointer)(url+AUDIOLINKSIZE));
+	g_object_set_data(G_OBJECT(item), "gtkconv", conv);
+	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
+
+	return TRUE;
+}
+
+/* XXX: The following two functions are for demonstration purposes only! */
+static gboolean
+open_dialog(GtkIMHtml *imhtml, GtkIMHtmlLink *link)
+{
+	const char *url;
+	const char *str;
+
+	url = gtk_imhtml_link_get_url(link);
+	if (!url || strlen(url) < sizeof("open://"))
+		return FALSE;
+
+	str = url + sizeof("open://") - 1;
+
+	if (strcmp(str, "accounts") == 0)
+		pidgin_accounts_window_show();
+	else if (strcmp(str, "prefs") == 0)
+		pidgin_prefs_show();
+	else
+		return FALSE;
+	return TRUE;
+}
+
+static gboolean
+dummy(GtkIMHtml *imhtml, GtkIMHtmlLink *link, GtkWidget *menu)
+{
+	return TRUE;
+}
+
+static gboolean
+register_gnome_url_handlers(void)
+{
+	char *tmp;
+	char *err;
+	char *c;
+	char *start;
+
+	tmp = g_find_program_in_path("gconftool-2");
+	if (tmp == NULL)
+		return FALSE;
+
+	g_free(tmp);
+	tmp = NULL;
+
+	if (!g_spawn_command_line_sync("gconftool-2 --all-dirs /desktop/gnome/url-handlers",
+	                               &tmp, &err, NULL, NULL))
+	{
+		g_free(tmp);
+		g_free(err);
+		g_return_val_if_reached(FALSE);
+	}
+	g_free(err);
+	err = NULL;
+
+	for (c = start = tmp ; *c ; c++)
+	{
+		/* Skip leading spaces. */
+		if (c == start && *c == ' ')
+			start = c + 1;
+		else if (*c == '\n')
+		{
+			*c = '\0';
+			if (g_str_has_prefix(start, "/desktop/gnome/url-handlers/"))
+			{
+				char *cmd;
+				char *tmp2 = NULL;
+				char *protocol;
+
+				/* If there is an enabled boolean, honor it. */
+				cmd = g_strdup_printf("gconftool-2 -g %s/enabled", start);
+				if (g_spawn_command_line_sync(cmd, &tmp2, &err, NULL, NULL))
+				{
+					g_free(err);
+					err = NULL;
+					if (!strcmp(tmp2, "false\n"))
+					{
+						g_free(tmp2);
+						g_free(cmd);
+						start = c + 1;
+						continue;
+					}
+				}
+				g_free(cmd);
+				g_free(tmp2);
+
+				start += sizeof("/desktop/gnome/url-handlers/") - 1;
+
+				protocol = g_strdup_printf("%s:", start);
+				registered_url_handlers = g_slist_prepend(registered_url_handlers, protocol);
+				gtk_imhtml_class_register_protocol(protocol, url_clicked_cb, link_context_menu);
+			}
+			start = c + 1;
+		}
+	}
+	g_free(tmp);
+
+	return (registered_url_handlers != NULL);
+}
+
+#ifdef _WIN32
+static void
+winpidgin_register_win32_url_handlers(void)
+{
+	int idx = 0;
+	LONG ret = ERROR_SUCCESS;
+
+	do {
+		DWORD nameSize = 256;
+		wchar_t start[256];
+		ret = RegEnumKeyExW(HKEY_CLASSES_ROOT, idx++, start, &nameSize,
+							NULL, NULL, NULL, NULL);
+		if (ret == ERROR_SUCCESS) {
+			HKEY reg_key = NULL;
+			ret = RegOpenKeyExW(HKEY_CLASSES_ROOT, start, 0, KEY_READ, &reg_key);
+			if (ret == ERROR_SUCCESS) {
+				ret = RegQueryValueExW(reg_key, L"URL Protocol", NULL, NULL, NULL, NULL);
+				if (ret == ERROR_SUCCESS) {
+					gchar *utf8 = g_utf16_to_utf8(start, -1, NULL, NULL, NULL);
+					gchar *protocol = g_strdup_printf("%s:", utf8);
+					g_free(utf8);
+					registered_url_handlers = g_slist_prepend(registered_url_handlers, protocol);
+					/* We still pass everything to the "http" "open" handler for security reasons */
+					gtk_imhtml_class_register_protocol(protocol, url_clicked_cb, link_context_menu);
+				}
+				RegCloseKey(reg_key);
+			}
+			ret = ERROR_SUCCESS;
+		}
+	} while (ret == ERROR_SUCCESS);
+
+	if (ret != ERROR_NO_MORE_ITEMS)
+		purple_debug_error("winpidgin", "Error iterating HKEY_CLASSES_ROOT subkeys: %ld\n",
+						   ret);
+}
+#endif
+
+GtkWidget *
+pidgin_make_scrollable(GtkWidget *child, GtkPolicyType hscrollbar_policy, GtkPolicyType vscrollbar_policy, GtkShadowType shadow_type, int width, int height)
+{
+	GtkWidget *sw = gtk_scrolled_window_new(NULL, NULL);
+
+	if (G_LIKELY(sw)) {
+		gtk_widget_show(sw);
+		gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), hscrollbar_policy, vscrollbar_policy);
+		gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(sw), shadow_type);
+		if (width != -1 || height != -1)
+			gtk_widget_set_size_request(sw, width, height);
+		if (child) {
+			if (GTK_WIDGET_GET_CLASS(child)->set_scroll_adjustments_signal)
+				gtk_container_add(GTK_CONTAINER(sw), child);
+			else
+				gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(sw), child);
+		}
+		return sw;
+	}
+
+	return child;
+}
+
+void pidgin_utils_init(void)
+{
+	gtk_imhtml_class_register_protocol("http://", url_clicked_cb, link_context_menu);
+	gtk_imhtml_class_register_protocol("https://", url_clicked_cb, link_context_menu);
+	gtk_imhtml_class_register_protocol("ftp://", url_clicked_cb, link_context_menu);
+	gtk_imhtml_class_register_protocol("gopher://", url_clicked_cb, link_context_menu);
+	gtk_imhtml_class_register_protocol("mailto:", url_clicked_cb, copy_email_address);
+
+	gtk_imhtml_class_register_protocol("file://", file_clicked_cb, file_context_menu);
+	gtk_imhtml_class_register_protocol("audio://", audio_clicked_cb, audio_context_menu);
+
+	/* Example custom URL handler. */
+	gtk_imhtml_class_register_protocol("open://", open_dialog, dummy);
+
+	/* If we're under GNOME, try registering the system URL handlers. */
+	if (purple_running_gnome())
+		register_gnome_url_handlers();
+
+	/* Used to make small buttons */
+	gtk_rc_parse_string("style \"pidgin-small-close-button\"\n"
+	                    "{\n"
+	                    "GtkWidget::focus-padding = 0\n"
+	                    "GtkWidget::focus-line-width = 0\n"
+	                    "xthickness = 0\n"
+	                    "ythickness = 0\n"
+	                    "GtkContainer::border-width = 0\n"
+	                    "GtkButton::inner-border = {0, 0, 0, 0}\n"
+	                    "GtkButton::default-border = {0, 0, 0, 0}\n"
+	                    "}\n"
+	                    "widget \"*.pidgin-small-close-button\" style \"pidgin-small-close-button\"");
+
+#ifdef _WIN32
+	winpidgin_register_win32_url_handlers();
+#endif
+
+}
+
+void pidgin_utils_uninit(void)
+{
+	gtk_imhtml_class_register_protocol("open://", NULL, NULL);
+
+	/* If we have GNOME handlers registered, unregister them. */
+	if (registered_url_handlers)
+	{
+		GSList *l;
+		for (l = registered_url_handlers; l; l = l->next)
+		{
+			gtk_imhtml_class_register_protocol((char *)l->data, NULL, NULL);
+			g_free(l->data);
+		}
+		g_slist_free(registered_url_handlers);
+		registered_url_handlers = NULL;
+		return;
+	}
+
+	gtk_imhtml_class_register_protocol("audio://", NULL, NULL);
+	gtk_imhtml_class_register_protocol("file://", NULL, NULL);
+
+	gtk_imhtml_class_register_protocol("http://", NULL, NULL);
+	gtk_imhtml_class_register_protocol("https://", NULL, NULL);
+	gtk_imhtml_class_register_protocol("ftp://", NULL, NULL);
+	gtk_imhtml_class_register_protocol("mailto:", NULL, NULL);
+	gtk_imhtml_class_register_protocol("gopher://", NULL, NULL);
+}
+
diff -uNr pidgin-2.10.11.orig/pidgin/gtkutils.h pidgin-2.10.11/pidgin/gtkutils.h
--- pidgin-2.10.11.orig/pidgin/gtkutils.h	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/pidgin/gtkutils.h	2015-02-10 14:28:16.420686854 +0900
@@ -977,5 +977,7 @@
  */
 void pidgin_utils_uninit(void);
 
+gchar *pidgin_gtk_ellipsis_text(GtkWidget *widget, const char *text, gint min_width, gchar *ellipsis);
+
 #endif /* _PIDGINUTILS_H_ */
 
diff -uNr pidgin-2.10.11.orig/pidgin/pidginstock.c pidgin-2.10.11/pidgin/pidginstock.c
--- pidgin-2.10.11.orig/pidgin/pidginstock.c	2014-11-24 01:41:26.000000000 +0900
+++ pidgin-2.10.11/pidgin/pidginstock.c	2015-02-10 14:28:16.420686854 +0900
@@ -331,7 +331,8 @@
 
 static void
 add_sized_icon(GtkIconSet *iconset, GtkIconSize sizeid, PidginIconTheme *theme,
-		const char *size, SizedStockIcon sized_icon, gboolean translucent)
+		const char *size, SizedStockIcon sized_icon, gboolean translucent,
+		gboolean size_wildcarded)
 {
 	char *filename;
 	GtkIconSource *source;
@@ -348,7 +349,7 @@
 	gtk_icon_source_set_direction(source, GTK_TEXT_DIR_LTR);
 	gtk_icon_source_set_direction_wildcarded(source, !sized_icon.rtl);
 	gtk_icon_source_set_size(source, sizeid);
-	gtk_icon_source_set_size_wildcarded(source, FALSE);
+	gtk_icon_source_set_size_wildcarded(source, size_wildcarded);
 	gtk_icon_source_set_state_wildcarded(source, TRUE);
 	gtk_icon_set_add_source(iconset, source);
 	gtk_icon_source_free(source);
@@ -358,7 +359,7 @@
 		gtk_icon_source_set_pixbuf(source, pixbuf);
 		gtk_icon_source_set_direction_wildcarded(source, TRUE);
 		gtk_icon_source_set_size(source, GTK_ICON_SIZE_MENU);
-		gtk_icon_source_set_size_wildcarded(source, FALSE);
+		gtk_icon_source_set_size_wildcarded(source, size_wildcarded);
 		gtk_icon_source_set_state_wildcarded(source, TRUE);
 		gtk_icon_set_add_source(iconset, source);
 		gtk_icon_source_free(source);
@@ -378,7 +379,7 @@
 		gtk_icon_source_set_filename(source, filename);
 		gtk_icon_source_set_direction(source, GTK_TEXT_DIR_RTL);
 		gtk_icon_source_set_size(source, sizeid);
-		gtk_icon_source_set_size_wildcarded(source, FALSE);
+		gtk_icon_source_set_size_wildcarded(source, size_wildcarded);
 		gtk_icon_source_set_state_wildcarded(source, TRUE);
 		gtk_icon_set_add_source(iconset, source);
 		g_free(filename);
@@ -434,9 +435,9 @@
 
 #define ADD_SIZED_ICON(name, size) \
 		if (sized_status_icons[i].name) { \
-			add_sized_icon(normal, name, PIDGIN_ICON_THEME(theme), size, sized_status_icons[i], FALSE); \
+			add_sized_icon(normal, name, PIDGIN_ICON_THEME(theme), size, sized_status_icons[i], FALSE, FALSE); \
 			if (sized_status_icons[i].translucent_name) \
-				add_sized_icon(translucent, name, PIDGIN_ICON_THEME(theme), size, sized_status_icons[i], TRUE); \
+				add_sized_icon(translucent, name, PIDGIN_ICON_THEME(theme), size, sized_status_icons[i], TRUE, FALSE); \
 		}
 		ADD_SIZED_ICON(microscopic, "11");
 		ADD_SIZED_ICON(extra_small, "16");
@@ -463,9 +464,9 @@
 
 #define ADD_SIZED_ICON(name, size) \
 		if (sized_tray_icons[i].name) { \
-			add_sized_icon(normal, name, PIDGIN_ICON_THEME(theme), size, sized_tray_icons[i], FALSE); \
+			add_sized_icon(normal, name, PIDGIN_ICON_THEME(theme), size, sized_tray_icons[i], FALSE, TRUE); \
 			if (sized_tray_icons[i].translucent_name) \
-				add_sized_icon(translucent, name, PIDGIN_ICON_THEME(theme), size, sized_tray_icons[i], TRUE); \
+				add_sized_icon(translucent, name, PIDGIN_ICON_THEME(theme), size, sized_tray_icons[i], TRUE, TRUE); \
 		}
 		ADD_SIZED_ICON(extra_small, "16x16");
 		ADD_SIZED_ICON(small, "22x22");
@@ -553,7 +554,7 @@
 
 #define ADD_SIZED_ICON(name, size) \
 		if (sized_stock_icons[i].name) \
-			add_sized_icon(iconset, name, PIDGIN_ICON_THEME(theme), size, sized_stock_icons[i], FALSE);
+			add_sized_icon(iconset, name, PIDGIN_ICON_THEME(theme), size, sized_stock_icons[i], FALSE, FALSE);
 		ADD_SIZED_ICON(microscopic, "11");
 		ADD_SIZED_ICON(extra_small, "16");
 		ADD_SIZED_ICON(small, "22");
