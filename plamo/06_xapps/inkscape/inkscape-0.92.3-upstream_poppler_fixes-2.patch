diff -uNr inkscape-0.92.3.orig/src/extension/internal/pdfinput/pdf-input.cpp inkscape-0.92.3/src/extension/internal/pdfinput/pdf-input.cpp
--- inkscape-0.92.3.orig/src/extension/internal/pdfinput/pdf-input.cpp	2018-12-18 17:57:06.852715741 +0900
+++ inkscape-0.92.3/src/extension/internal/pdfinput/pdf-input.cpp	2018-12-18 17:58:16.369913456 +0900
@@ -319,7 +319,7 @@
     _render_thumb = true;
 
     // Create PopplerDocument
-    Glib::ustring filename = _pdf_doc->getFileName()->getCString();
+    Glib::ustring filename = _pdf_doc->getFileName()->c_str();
     if (!Glib::path_is_absolute(filename)) {
         filename = Glib::build_filename(Glib::get_current_dir(),filename);
     }
diff -uNr inkscape-0.92.3.orig/src/extension/internal/pdfinput/pdf-parser.cpp inkscape-0.92.3/src/extension/internal/pdfinput/pdf-parser.cpp
--- inkscape-0.92.3.orig/src/extension/internal/pdfinput/pdf-parser.cpp	2018-12-18 17:57:06.852715741 +0900
+++ inkscape-0.92.3/src/extension/internal/pdfinput/pdf-parser.cpp	2018-12-18 17:58:16.379913053 +0900
@@ -271,7 +271,7 @@
     // Manipulate clip path stack
     ClipHistoryEntry *save();
     ClipHistoryEntry *restore();
-    GBool hasSaves() { return saved != NULL; }
+    bool hasSaves() { return saved != NULL; }
     void setClip(GfxPath *newClipPath, GfxClipType newClipType = clipNormal);
     GfxPath *getClipPath() { return clipPath; }
     GfxClipType getClipType() { return clipType; }
@@ -299,11 +299,11 @@
                      _POPPLER_CONST PDFRectangle *cropBox) :
     xref(xrefA),
     builder(builderA),
-    subPage(gFalse),
+    subPage(false),
     printCommands(false),
     res(new GfxResources(xref, resDict, NULL)), // start the resource stack
-    state(new GfxState(72.0, 72.0, box, rotate, gTrue)),
-    fontChanged(gFalse),
+    state(new GfxState(72.0, 72.0, box, rotate, true)),
+    fontChanged(false),
     clip(clipNone),
     ignoreUndef(0),
     baseMatrix(),
@@ -356,11 +356,11 @@
 		     _POPPLER_CONST PDFRectangle *box) :
     xref(xrefA),
     builder(builderA),
-    subPage(gTrue),
+    subPage(true),
     printCommands(false),
     res(new GfxResources(xref, resDict, NULL)), // start the resource stack
-    state(new GfxState(72, 72, box, 0, gFalse)),
-    fontChanged(gFalse),
+    state(new GfxState(72, 72, box, 0, false)),
+    fontChanged(false),
     clip(clipNone),
     ignoreUndef(0),
     baseMatrix(),
@@ -409,7 +409,7 @@
   }
 }
 
-void PdfParser::parse(Object *obj, GBool topLevel) {
+void PdfParser::parse(Object *obj, bool topLevel) {
   Object obj2;
 
   if (obj->isArray()) {
@@ -434,13 +434,13 @@
 	error(errInternal, -1, "Weird page contents");
     	return;
   }
-  parser = new Parser(xref, new Lexer(xref, obj), gFalse);
+  parser = new Parser(xref, new Lexer(xref, obj), false);
   go(topLevel);
   delete parser;
   parser = NULL;
 }
 
-void PdfParser::go(GBool /*topLevel*/)
+void PdfParser::go(bool /*topLevel*/)
 {
   Object obj;
   Object args[maxArgs];
@@ -640,7 +640,7 @@
   return &opTab[a];
 }
 
-GBool PdfParser::checkArg(Object *arg, TchkType type) {
+bool PdfParser::checkArg(Object *arg, TchkType type) {
   switch (type) {
   case tchkBool:   return arg->isBool();
   case tchkInt:    return arg->isInt();
@@ -650,9 +650,9 @@
   case tchkArray:  return arg->isArray();
   case tchkProps:  return arg->isDict() || arg->isName();
   case tchkSCN:    return arg->isNum() || arg->isName();
-  case tchkNone:   return gFalse;
+  case tchkNone:   return false;
   }
-  return gFalse;
+  return false;
 }
 
 int PdfParser::getPos() {
@@ -707,7 +707,7 @@
       builder->pushGroup();
       builder->setTransform(a0, a1, a2, a3, a4, a5);
   }
-  fontChanged = gTrue;
+  fontChanged = true;
 }
 
 // TODO not good that numArgs is ignored but args[] is used:
@@ -773,8 +773,8 @@
   Object obj1, obj2, obj3, obj4, obj5;
   Function *funcs[4] = {0, 0, 0, 0};
   GfxColor backdropColor;
-  GBool haveBackdropColor = gFalse;
-  GBool alpha = gFalse;
+  bool haveBackdropColor = false;
+  bool alpha = false;
 
 #if defined(POPPLER_NEW_OBJECT_API)
   if ((obj1 = res->lookupGState(args[0].getName())).isNull()) {
@@ -830,7 +830,7 @@
 #endif
 
   // fill/stroke overprint
-  GBool haveFillOP = gFalse;
+  bool haveFillOP = false;
 #if defined(POPPLER_NEW_OBJECT_API)
   if ((haveFillOP = (obj2 = obj1.dictLookup(const_cast<char*>("op"))).isBool())) {
 #else
@@ -925,9 +925,9 @@
 #else
       if (obj2.dictLookup(const_cast<char*>("S"), &obj3)->isName(const_cast<char*>("Alpha"))) {
 #endif
-	alpha = gTrue;
+	alpha = true;
       } else { // "Luminosity"
-	alpha = gFalse;
+	alpha = false;
       }
 #if !defined(POPPLER_NEW_OBJECT_API)
       obj3.free();
@@ -978,8 +978,8 @@
 	if (obj3.streamGetDict()->lookup(const_cast<char*>("Group"), &obj4)->isDict()) {
 #endif
 	  GfxColorSpace *blendingColorSpace = 0;
-	  GBool isolated = gFalse;
-	  GBool knockout = gFalse;
+	  bool isolated = false;
+	  bool knockout = false;
 #if defined(POPPLER_NEW_OBJECT_API)
 	  if (!((obj5 = obj4.dictLookup(const_cast<char*>("CS"))).isNull())) {
 #else
@@ -1050,9 +1050,9 @@
 #endif
 }
 
-void PdfParser::doSoftMask(Object *str, GBool alpha,
+void PdfParser::doSoftMask(Object *str, bool alpha,
 		     GfxColorSpace *blendingColorSpace,
-		     GBool isolated, GBool knockout,
+		     bool isolated, bool knockout,
 		     Function *transferFunc, GfxColor *backdropColor) {
   Dict *dict, *resDict;
   double m[6], bbox[4];
@@ -1145,7 +1145,7 @@
 
   // draw it
   ++formDepth;
-  doForm1(str, resDict, m, bbox, gTrue, gTrue,
+  doForm1(str, resDict, m, bbox, true, true,
 	  blendingColorSpace, isolated, knockout,
 	  alpha, transferFunc, backdropColor);
   --formDepth;
@@ -1615,7 +1615,7 @@
   if (state->isPath()) {
     if (state->getFillColorSpace()->getMode() == csPattern &&
         !builder->isPatternTypeSupported(state->getFillPattern())) {
-      doPatternFillFallback(gFalse);
+      doPatternFillFallback(false);
     } else {
       builder->addPath(state, true, false);
     }
@@ -1632,7 +1632,7 @@
   if (state->isPath()) {
     if (state->getFillColorSpace()->getMode() == csPattern &&
         !builder->isPatternTypeSupported(state->getFillPattern())) {
-      doPatternFillFallback(gTrue);
+      doPatternFillFallback(true);
     } else {
       builder->addPath(state, true, false, true);
     }
@@ -1647,7 +1647,7 @@
     return;
   }
   if (state->isPath()) {
-    doFillAndStroke(gFalse);
+    doFillAndStroke(false);
   } else {
     builder->addPath(state, true, true);
   }
@@ -1662,7 +1662,7 @@
   }
   if (state->isPath()) {
     state->closePath();
-    doFillAndStroke(gFalse);
+    doFillAndStroke(false);
   }
   doEndPath();
 }
@@ -1674,7 +1674,7 @@
     return;
   }
   if (state->isPath()) {
-    doFillAndStroke(gTrue);
+    doFillAndStroke(true);
   }
   doEndPath();
 }
@@ -1687,20 +1687,20 @@
   }
   if (state->isPath()) {
     state->closePath();
-    doFillAndStroke(gTrue);
+    doFillAndStroke(true);
   }
   doEndPath();
 }
 
-void PdfParser::doFillAndStroke(GBool eoFill) {
-    GBool fillOk = gTrue, strokeOk = gTrue;
+void PdfParser::doFillAndStroke(bool eoFill) {
+    bool fillOk = true, strokeOk = true;
     if (state->getFillColorSpace()->getMode() == csPattern &&
         !builder->isPatternTypeSupported(state->getFillPattern())) {
-        fillOk = gFalse;
+        fillOk = false;
     }
     if (state->getStrokeColorSpace()->getMode() == csPattern &&
         !builder->isPatternTypeSupported(state->getStrokePattern())) {
-        strokeOk = gFalse;
+        strokeOk = false;
     }
     if (fillOk && strokeOk) {
         builder->addPath(state, true, true, eoFill);
@@ -1710,7 +1710,7 @@
     }
 }
 
-void PdfParser::doPatternFillFallback(GBool eoFill) {
+void PdfParser::doPatternFillFallback(bool eoFill) {
   GfxPattern *pattern;
 
   if (!(pattern = state->getFillPattern())) {
@@ -1720,7 +1720,7 @@
   case 1:
     break;
   case 2:
-    doShadingPatternFillFallback(static_cast<GfxShadingPattern *>(pattern), gFalse, eoFill);
+    doShadingPatternFillFallback(static_cast<GfxShadingPattern *>(pattern), false, eoFill);
     break;
   default:
     error(errUnimplemented, getPos(), "Unimplemented pattern type (%d) in fill",
@@ -1739,7 +1739,7 @@
   case 1:
     break;
   case 2:
-    doShadingPatternFillFallback(static_cast<GfxShadingPattern *>(pattern), gTrue, gFalse);
+    doShadingPatternFillFallback(static_cast<GfxShadingPattern *>(pattern), true, false);
     break;
   default:
     error(errUnimplemented, getPos(), "Unimplemented pattern type ({0:d}) in stroke",
@@ -1749,7 +1749,7 @@
 }
 
 void PdfParser::doShadingPatternFillFallback(GfxShadingPattern *sPat,
-                                             GBool stroke, GBool eoFill) {
+                                             bool stroke, bool eoFill) {
   GfxShading *shading;
   GfxPath *savedPath;
   const double *ctm, *btm, *ptm;
@@ -1863,7 +1863,7 @@
   double xTemp, yTemp;
   double gradientTransform[6];
   double *matrix = NULL;
-  GBool savedState = gFalse;
+  bool savedState = false;
 
 #if defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
   if (!(shading = res->lookupShading(args[0].getName(), NULL, NULL))) {
@@ -1879,13 +1879,13 @@
   if (shading->getType() != 2 && shading->getType() != 3) {
     savedPath = state->getPath()->copy();
     saveState();
-    savedState = gTrue;
+    savedState = true;
   } else {  // get gradient transform if possible
       // check proper operator sequence
       // first there should be one W(*) and then one 'cm' somewhere before 'sh'
-      GBool seenClip, seenConcat;
+      bool seenClip, seenConcat;
       seenClip = (clipHistory->getClipPath() != NULL);
-      seenConcat = gFalse;
+      seenConcat = false;
       int i = 1;
       while (i <= maxOperatorHistoryDepth) {
         const char *opName = getPreviousOperator(i);
@@ -1893,7 +1893,7 @@
           if (seenConcat) {   // more than one 'cm'
             break;
           } else {
-            seenConcat = gTrue;
+            seenConcat = true;
           }
         }
         i++;
@@ -2348,7 +2348,7 @@
   state->setTextMat(1, 0, 0, 1, 0, 0);
   state->textMoveTo(0, 0);
   builder->updateTextPosition(0.0, 0.0);
-  fontChanged = gTrue;
+  fontChanged = true;
   builder->beginTextObject(state);
 }
 
@@ -2376,20 +2376,20 @@
     // unsetting the font (drawing no text) is better than using the
     // previous one and drawing random glyphs from it
     state->setFont(NULL, args[1].getNum());
-    fontChanged = gTrue;
+    fontChanged = true;
     return;
   }
   if (printCommands) {
     printf("  font: tag=%s name='%s' %g\n",
-	   font->getTag()->getCString(),
-	   font->getName() ? font->getName()->getCString() : "???",
+	   font->getTag()->c_str(),
+	   font->getName() ? font->getName()->c_str() : "???",
 	   args[1].getNum());
     fflush(stdout);
   }
 
   font->incRefCnt();
   state->setFont(font, args[1].getNum());
-  fontChanged = gTrue;
+  fontChanged = true;
 }
 
 // TODO not good that numArgs is ignored but args[] is used:
@@ -2422,7 +2422,7 @@
 {
   state->setHorizScaling(args[0].getNum());
   builder->updateTextMatrix(state);
-  fontChanged = gTrue;
+  fontChanged = true;
 }
 
 //------------------------------------------------------------------------
@@ -2462,7 +2462,7 @@
   state->textMoveTo(0, 0);
   builder->updateTextMatrix(state);
   builder->updateTextPosition(0.0, 0.0);
-  fontChanged = gTrue;
+  fontChanged = true;
 }
 
 void PdfParser::opTextNextLine(Object /*args*/[], int /*numArgs*/)
@@ -2488,7 +2488,7 @@
   }
   if (fontChanged) {
     builder->updateFont(state);
-    fontChanged = gFalse;
+    fontChanged = false;
   }
   doShowText(args[0].getString());
 }
@@ -2505,7 +2505,7 @@
   }
   if (fontChanged) {
     builder->updateFont(state);
-    fontChanged = gFalse;
+    fontChanged = false;
   }
   tx = state->getLineX();
   ty = state->getLineY() - state->getLeading();
@@ -2526,7 +2526,7 @@
   }
   if (fontChanged) {
     builder->updateFont(state);
-    fontChanged = gFalse;
+    fontChanged = false;
   }
   state->setWordSpace(args[0].getNum());
   state->setCharSpace(args[1].getNum());
@@ -2550,7 +2550,7 @@
   }
   if (fontChanged) {
     builder->updateFont(state);
-    fontChanged = gFalse;
+    fontChanged = false;
   }
   wMode = state->getFont()->getWMode();
   a = args[0].getArray();
@@ -2639,7 +2639,7 @@
     double lineX = state->getLineX();
     double lineY = state->getLineY();
     oldParser = parser;
-    p = s->getCString();
+    p = s->c_str();
     len = s->getLength();
     while (len > 0) {
       n = font->getNextChar(p, len, &code,
@@ -2668,7 +2668,7 @@
 	  pushResources(resDict);
 	}
 	if (charProc.isStream()) {
-	  //parse(&charProc, gFalse); // TODO: parse into SVG font
+	  //parse(&charProc, false); // TODO: parse into SVG font
 	} else {
 	  error(errSyntaxError, getPos(), "Missing or bad Type3 CharProc entry");
 	}
@@ -2694,7 +2694,7 @@
 
   } else {
     state->textTransformDelta(0, state->getRise(), &riseX, &riseY);
-    p = s->getCString();
+    p = s->c_str();
     len = s->getLength();
     while (len > 0) {
       n = font->getNextChar(p, len, &code,
@@ -2770,7 +2770,7 @@
 #else
     res->lookupXObjectNF(name, &refObj);
 #endif
-    doImage(&refObj, obj1.getStream(), gFalse);
+    doImage(&refObj, obj1.getStream(), false);
 #if !defined(POPPLER_NEW_OBJECT_API)
     refObj.free();
 #endif
@@ -2795,19 +2795,19 @@
 #endif
 }
 
-void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
+void PdfParser::doImage(Object * /*ref*/, Stream *str, bool inlineImg)
 {
     Dict *dict;
     int width, height;
     int bits;
-    GBool interpolate;
+    bool interpolate;
     StreamColorSpaceMode csMode;
-    GBool mask;
-    GBool invert;
+    bool mask;
+    bool invert;
     Object maskObj, smaskObj;
-    GBool haveColorKeyMask, haveExplicitMask, haveSoftMask;
-    GBool maskInvert;
-    GBool maskInterpolate;
+    bool haveColorKeyMask, haveExplicitMask, haveSoftMask;
+    bool maskInvert;
+    bool maskInterpolate;
     Object obj1, obj2;
     
     // get info from the stream
@@ -2885,11 +2885,11 @@
     if (obj1.isBool())
       interpolate = obj1.getBool();
     else
-      interpolate = gFalse;
+      interpolate = false;
 #if !defined(POPPLER_NEW_OBJECT_API)
     obj1.free();
 #endif
-    maskInterpolate = gFalse;
+    maskInterpolate = false;
 
     // image or mask?
 #if defined(POPPLER_NEW_OBJECT_API)
@@ -2905,7 +2905,7 @@
         dict->lookup(const_cast<char*>("IM"), &obj1);
 #endif
     }
-    mask = gFalse;
+    mask = false;
     if (obj1.isBool()) {
         mask = obj1.getBool();
     }
@@ -2949,7 +2949,7 @@
         if (bits != 1) {
             goto err1;
         }
-        invert = gFalse;
+        invert = false;
 #if defined(POPPLER_NEW_OBJECT_API)
         obj1 = dict->lookup(const_cast<char*>("Decode"));
 #else
@@ -2970,7 +2970,7 @@
             obj1.arrayGet(0, &obj2);
 #endif
             if (obj2.isInt() && obj2.getInt() == 1) {
-                invert = gTrue;
+                invert = true;
             }
 #if !defined(POPPLER_NEW_OBJECT_API)
             obj2.free();
@@ -3067,11 +3067,11 @@
         
         // get the mask
         int maskColors[2*gfxColorMaxComps];
-        haveColorKeyMask = haveExplicitMask = haveSoftMask = gFalse;
+        haveColorKeyMask = haveExplicitMask = haveSoftMask = false;
         Stream *maskStr = NULL;
         int maskWidth = 0;
         int maskHeight = 0;
-        maskInvert = gFalse;
+        maskInvert = false;
         GfxImageColorMap *maskColorMap = NULL;
 #if defined(POPPLER_NEW_OBJECT_API)
         maskObj = dict->lookup(const_cast<char*>("Mask"));
@@ -3158,7 +3158,7 @@
 	    if (obj1.isBool())
 	      maskInterpolate = obj1.getBool();
 	    else
-	      maskInterpolate = gFalse;
+	      maskInterpolate = false;
 #if defined(POPPLER_NEW_OBJECT_API)
             obj1 = maskDict->lookup(const_cast<char*>("ColorSpace"));
 #else
@@ -3227,7 +3227,7 @@
                 goto err1;
             }
             //~ handle the Matte entry
-            haveSoftMask = gTrue;
+            haveSoftMask = true;
         } else if (maskObj.isArray()) {
             // color key mask
             int i;
@@ -3242,7 +3242,7 @@
                 obj1.free();
 #endif
             }
-              haveColorKeyMask = gTrue;
+              haveColorKeyMask = true;
         } else if (maskObj.isStream()) {
             // explicit mask
             if (inlineImg) {
@@ -3319,11 +3319,11 @@
 	    if (obj1.isBool())
 	      maskInterpolate = obj1.getBool();
 	    else
-	      maskInterpolate = gFalse;
+	      maskInterpolate = false;
 #if !defined(POPPLER_NEW_OBJECT_API)
 	    obj1.free();
 #endif
-            maskInvert = gFalse;
+            maskInvert = false;
 #if defined(POPPLER_NEW_OBJECT_API)
             obj1 = maskDict->lookup(const_cast<char*>("Decode"));
 #else
@@ -3344,7 +3344,7 @@
                 obj1.arrayGet(0, &obj2);
 #endif
                 if (obj2.isInt() && obj2.getInt() == 1) {
-                    maskInvert = gTrue;
+                    maskInvert = true;
                 }
 #if !defined(POPPLER_NEW_OBJECT_API)
                 obj2.free();
@@ -3355,7 +3355,7 @@
 #if !defined(POPPLER_NEW_OBJECT_API)
             obj1.free();
 #endif
-            haveExplicitMask = gTrue;
+            haveExplicitMask = true;
         }
         
         // draw it
@@ -3390,7 +3390,7 @@
 
 void PdfParser::doForm(Object *str) {
   Dict *dict;
-  GBool transpGroup, isolated, knockout;
+  bool transpGroup, isolated, knockout;
   GfxColorSpace *blendingColorSpace;
   Object matrixObj, bboxObj;
   double m[6], bbox[4];
@@ -3484,7 +3484,7 @@
   resDict = resObj.isDict() ? resObj.getDict() : (Dict *)NULL;
 
   // check for a transparency group
-  transpGroup = isolated = knockout = gFalse;
+  transpGroup = isolated = knockout = false;
   blendingColorSpace = NULL;
 #if defined(POPPLER_NEW_OBJECT_API)
   if ((obj1 = dict->lookup(const_cast<char*>("Group"))).isDict()) {
@@ -3493,7 +3493,7 @@
   if (dict->lookup(const_cast<char*>("Group"), &obj1)->isDict()) {
     if (obj1.dictLookup(const_cast<char*>("S"), &obj2)->isName(const_cast<char*>("Transparency"))) {
 #endif
-      transpGroup = gTrue;
+      transpGroup = true;
 #if defined(POPPLER_NEW_OBJECT_API)
       if (!((obj3 = obj1.dictLookup(const_cast<char*>("CS"))).isNull())) {
 #else
@@ -3537,7 +3537,7 @@
   // draw it
   ++formDepth;
   doForm1(str, resDict, m, bbox,
-	  transpGroup, gFalse, blendingColorSpace, isolated, knockout);
+	  transpGroup, false, blendingColorSpace, isolated, knockout);
   --formDepth;
 
   if (blendingColorSpace) {
@@ -3549,10 +3549,10 @@
 }
 
 void PdfParser::doForm1(Object *str, Dict *resDict, double *matrix, double *bbox,
-		  GBool transpGroup, GBool softMask,
+		  bool transpGroup, bool softMask,
 		  GfxColorSpace *blendingColorSpace,
-		  GBool isolated, GBool knockout,
-		  GBool alpha, Function *transferFunc,
+		  bool isolated, bool knockout,
+		  bool alpha, Function *transferFunc,
 		  GfxColor *backdropColor) {
   Parser *oldParser;
   double oldBaseMatrix[6];
@@ -3613,7 +3613,7 @@
   }
 
   // draw the form
-  parse(str, gFalse);
+  parse(str, false);
 
   // restore base matrix
   for (i = 0; i < 6; ++i) {
@@ -3653,7 +3653,7 @@
 
   // display the image
   if (str) {
-    doImage(NULL, str, gTrue);
+    doImage(NULL, str, true);
   
     // skip 'EI' tag
     int c1 = str->getUndecodedStream()->getChar();
@@ -3712,10 +3712,10 @@
 
   // make stream
 #if defined(POPPLER_NEW_OBJECT_API)
-  str = new EmbedStream(parser->getStream(), dict.copy(), gFalse, 0);
+  str = new EmbedStream(parser->getStream(), dict.copy(), false, 0);
   str = str->addFilters(dict.getDict());
 #else
-  str = new EmbedStream(parser->getStream(), &dict, gFalse, 0);
+  str = new EmbedStream(parser->getStream(), &dict, false, 0);
   str = str->addFilters(&dict);
 #endif
 
diff -uNr inkscape-0.92.3.orig/src/extension/internal/pdfinput/pdf-parser.h inkscape-0.92.3/src/extension/internal/pdfinput/pdf-parser.h
--- inkscape-0.92.3.orig/src/extension/internal/pdfinput/pdf-parser.h	2018-12-18 17:57:06.852715741 +0900
+++ inkscape-0.92.3/src/extension/internal/pdfinput/pdf-parser.h	2018-12-18 17:58:16.379913053 +0900
@@ -98,7 +98,7 @@
 struct OpHistoryEntry {
     const char *name;       // operator's name
     GfxState *state;        // saved state, NULL if none
-    GBool executed;         // whether the operator has been executed
+    bool executed;         // whether the operator has been executed
 
     OpHistoryEntry *next;   // next entry on stack
     unsigned depth;         // total number of entries descending from this
@@ -141,7 +141,7 @@
   virtual ~PdfParser();
 
   // Interpret a stream or array of streams.
-  void parse(Object *obj, GBool topLevel = gTrue);
+  void parse(Object *obj, bool topLevel = true);
 
   // Save graphics state.
   void saveState();
@@ -159,12 +159,12 @@
 
   XRef *xref;			// the xref table for this PDF file
   SvgBuilder *builder;          // SVG generator
-  GBool subPage;		// is this a sub-page object?
-  GBool printCommands;		// print the drawing commands (for debugging)
+  bool subPage;		// is this a sub-page object?
+  bool printCommands;		// print the drawing commands (for debugging)
   GfxResources *res;		// resource stack
 
   GfxState *state;		// current graphics state
-  GBool fontChanged;		// set if font or text matrix has changed
+  bool fontChanged;		// set if font or text matrix has changed
   GfxClipType clip;		// do a clip?
   int ignoreUndef;		// current BX/EX nesting level
   double baseMatrix[6];		// default matrix for most recent
@@ -188,10 +188,10 @@
   OpHistoryEntry *popOperator();
   const char *getPreviousOperator(unsigned int look_back=1);    // returns the nth previous operator's name
 
-  void go(GBool topLevel);
+  void go(bool topLevel);
   void execOp(Object *cmd, Object args[], int numArgs);
   PdfOperator *findOp(const char *name);
-  GBool checkArg(Object *arg, TchkType type);
+  bool checkArg(Object *arg, TchkType type);
   int getPos();
 
   // graphics state operators
@@ -205,9 +205,9 @@
   void opSetMiterLimit(Object args[], int numArgs);
   void opSetLineWidth(Object args[], int numArgs);
   void opSetExtGState(Object args[], int numArgs);
-  void doSoftMask(Object *str, GBool alpha,
+  void doSoftMask(Object *str, bool alpha,
 		  GfxColorSpace *blendingColorSpace,
-		  GBool isolated, GBool knockout,
+		  bool isolated, bool knockout,
 		  Function *transferFunc, GfxColor *backdropColor);
   void opSetRenderingIntent(Object args[], int numArgs);
 
@@ -244,11 +244,11 @@
   void opCloseFillStroke(Object args[], int numArgs);
   void opEOFillStroke(Object args[], int numArgs);
   void opCloseEOFillStroke(Object args[], int numArgs);
-  void doFillAndStroke(GBool eoFill);
-  void doPatternFillFallback(GBool eoFill);
+  void doFillAndStroke(bool eoFill);
+  void doPatternFillFallback(bool eoFill);
   void doPatternStrokeFallback();
   void doShadingPatternFillFallback(GfxShadingPattern *sPat,
-                                    GBool stroke, GBool eoFill);
+                                    bool stroke, bool eoFill);
   void opShFill(Object args[], int numArgs);
   void doFunctionShFill(GfxFunctionShading *shading);
   void doFunctionShFill1(GfxFunctionShading *shading,
@@ -301,13 +301,13 @@
 
   // XObject operators
   void opXObject(Object args[], int numArgs);
-  void doImage(Object *ref, Stream *str, GBool inlineImg);
+  void doImage(Object *ref, Stream *str, bool inlineImg);
   void doForm(Object *str);
   void doForm1(Object *str, Dict *resDict, double *matrix, double *bbox,
-	       GBool transpGroup = gFalse, GBool softMask = gFalse,
+	       bool transpGroup = false, bool softMask = false,
 	       GfxColorSpace *blendingColorSpace = NULL,
-	       GBool isolated = gFalse, GBool knockout = gFalse,
-	       GBool alpha = gFalse, Function *transferFunc = NULL,
+	       bool isolated = false, bool knockout = false,
+	       bool alpha = false, Function *transferFunc = NULL,
 	       GfxColor *backdropColor = NULL);
 
   // in-line image operators
diff -uNr inkscape-0.92.3.orig/src/extension/internal/pdfinput/svg-builder.cpp inkscape-0.92.3/src/extension/internal/pdfinput/svg-builder.cpp
--- inkscape-0.92.3.orig/src/extension/internal/pdfinput/svg-builder.cpp	2018-12-18 17:57:06.852715741 +0900
+++ inkscape-0.92.3/src/extension/internal/pdfinput/svg-builder.cpp	2018-12-18 17:58:16.383246253 +0900
@@ -1020,7 +1020,7 @@
     GfxFont *font = state->getFont();
     // Store original name
     if (font->getName()) {
-        _font_specification = font->getName()->getCString();
+        _font_specification = font->getName()->c_str();
     } else {
         _font_specification = "Arial";
     }
@@ -1047,7 +1047,7 @@
 
     // Font family
     if (font->getFamily()) { // if font family is explicitly given use it.
-        sp_repr_css_set_property(_font_style, "font-family", font->getFamily()->getCString());
+        sp_repr_css_set_property(_font_style, "font-family", font->getFamily()->c_str());
     } else { 
         int attr_value = 1;
         sp_repr_get_int(_preferences, "localFonts", &attr_value);
diff -uNr inkscape-0.92.3.orig/src/ui/tools/flood-tool.cpp inkscape-0.92.3/src/ui/tools/flood-tool.cpp
--- inkscape-0.92.3.orig/src/ui/tools/flood-tool.cpp	2018-03-12 05:38:09.000000000 +0900
+++ inkscape-0.92.3/src/ui/tools/flood-tool.cpp	2018-12-18 17:58:05.603680793 +0900
@@ -1147,8 +1147,8 @@
     case GDK_MOTION_NOTIFY:
         if ( dragging && ( event->motion.state & GDK_BUTTON1_MASK ) && !this->space_panning) {
             if ( this->within_tolerance
-                 && ( abs( (gint) event->motion.x - this->xp ) < this->tolerance )
-                 && ( abs( (gint) event->motion.y - this->yp ) < this->tolerance ) ) {
+                 && ( std::fabs( (gint) event->motion.x - this->xp ) < this->tolerance )
+                 && ( std::fabs( (gint) event->motion.y - this->yp ) < this->tolerance ) ) {
                 break; // do not drag if we're within tolerance from origin
             }
             
