autofs-5.0.6 - fix paged query more results check

From: Ian Kent <raven@themaw.net>

When getting paged results from an LDAP server the server returns an
opaque cookie (of type berval) that is used to retrieve the next page.
The criteria for deciding if there are more pages is that the berval
value is non-null and has a non-zero length.

To determine if the berval value has non-zero length autofs checks the
strlen() of the value but on ppc64 and s390x this can return 0 even if
the value has non-zero length causing a premature termination of the
query.

Fix this by also checking the berval length field.
Also make sure we free the opaque cookie when the query is finished.
---

 CHANGELOG             |    1 +
 modules/lookup_ldap.c |   13 ++++++++++++-
 2 files changed, 13 insertions(+), 1 deletions(-)


diff --git a/CHANGELOG b/CHANGELOG
index a178b74..884a9ae 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -2,6 +2,7 @@
 =======================
 - fix ipv6 name for lookup fix.
 - improve mount location error reporting.
+- fix paged query more results check.
 
 28/06/2011 autofs-5.0.6
 -----------------------
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index 719fed1..a25050a 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -2041,7 +2041,8 @@ do_paged:
 	rv = ldap_parse_page_control(sp->ldap,
 				     returnedControls, &sp->totalCount,
 				     &sp->cookie);
-	if (sp->cookie && sp->cookie->bv_val && strlen(sp->cookie->bv_val))
+	if (sp->cookie && sp->cookie->bv_val &&
+	    (strlen(sp->cookie->bv_val) || sp->cookie->bv_len))
 		sp->morePages = TRUE;
 	else
 		sp->morePages = FALSE;
@@ -2382,6 +2383,10 @@ static int read_one_map(struct autofs_point *ap,
 		    rv == LDAP_SIZELIMIT_EXCEEDED) {
 			if (sp.result)
 				ldap_msgfree(sp.result);
+			if (sp.cookie) {
+				ber_bvfree(sp.cookie);
+				sp.cookie = NULL;
+			}
 			sp.pageSize = sp.pageSize / 2;
 			if (sp.pageSize < 5) {
 				debug(ap->logopt, MODPREFIX
@@ -2397,6 +2402,8 @@ static int read_one_map(struct autofs_point *ap,
 		if (rv != LDAP_SUCCESS || !sp.result) {
 			unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
 			*result_ldap = rv;
+			if (sp.cookie)
+				ber_bvfree(sp.cookie);
 			free(sp.query);
 			return NSS_STATUS_UNAVAIL;
 		}
@@ -2406,6 +2413,8 @@ static int read_one_map(struct autofs_point *ap,
 			ldap_msgfree(sp.result);
 			unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
 			*result_ldap = rv;
+			if (sp.cookie)
+				ber_bvfree(sp.cookie);
 			free(sp.query);
 			return NSS_STATUS_NOTFOUND;
 		}
@@ -2417,6 +2426,8 @@ static int read_one_map(struct autofs_point *ap,
 	unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
 
 	source->age = age;
+	if (sp.cookie)
+		ber_bvfree(sp.cookie);
 	free(sp.query);
 
 	return NSS_STATUS_SUCCESS;
